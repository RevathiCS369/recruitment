// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"recruit/ent/migrate"

	"recruit/ent/ageeligibility"
	"recruit/ent/application"
	"recruit/ent/center"
	"recruit/ent/circlemaster"
	"recruit/ent/disability"
	"recruit/ent/divisionmaster"
	"recruit/ent/employeecadre"
	"recruit/ent/employeecategory"
	"recruit/ent/employeedesignation"
	"recruit/ent/employeeposts"
	"recruit/ent/employees"
	"recruit/ent/exam"
	"recruit/ent/examcalendar"
	"recruit/ent/exameligibility"
	"recruit/ent/exampapers"
	"recruit/ent/facility"
	"recruit/ent/nodalofficer"
	"recruit/ent/notification"
	"recruit/ent/papertypes"
	"recruit/ent/regionmaster"
	"recruit/ent/user"
	"recruit/ent/vacancyyear"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AgeEligibility is the client for interacting with the AgeEligibility builders.
	AgeEligibility *AgeEligibilityClient
	// Application is the client for interacting with the Application builders.
	Application *ApplicationClient
	// Center is the client for interacting with the Center builders.
	Center *CenterClient
	// CircleMaster is the client for interacting with the CircleMaster builders.
	CircleMaster *CircleMasterClient
	// Disability is the client for interacting with the Disability builders.
	Disability *DisabilityClient
	// DivisionMaster is the client for interacting with the DivisionMaster builders.
	DivisionMaster *DivisionMasterClient
	// EmployeeCadre is the client for interacting with the EmployeeCadre builders.
	EmployeeCadre *EmployeeCadreClient
	// EmployeeCategory is the client for interacting with the EmployeeCategory builders.
	EmployeeCategory *EmployeeCategoryClient
	// EmployeeDesignation is the client for interacting with the EmployeeDesignation builders.
	EmployeeDesignation *EmployeeDesignationClient
	// EmployeePosts is the client for interacting with the EmployeePosts builders.
	EmployeePosts *EmployeePostsClient
	// Employees is the client for interacting with the Employees builders.
	Employees *EmployeesClient
	// Exam is the client for interacting with the Exam builders.
	Exam *ExamClient
	// ExamCalendar is the client for interacting with the ExamCalendar builders.
	ExamCalendar *ExamCalendarClient
	// ExamEligibility is the client for interacting with the ExamEligibility builders.
	ExamEligibility *ExamEligibilityClient
	// ExamPapers is the client for interacting with the ExamPapers builders.
	ExamPapers *ExamPapersClient
	// Facility is the client for interacting with the Facility builders.
	Facility *FacilityClient
	// NodalOfficer is the client for interacting with the NodalOfficer builders.
	NodalOfficer *NodalOfficerClient
	// Notification is the client for interacting with the Notification builders.
	Notification *NotificationClient
	// PaperTypes is the client for interacting with the PaperTypes builders.
	PaperTypes *PaperTypesClient
	// RegionMaster is the client for interacting with the RegionMaster builders.
	RegionMaster *RegionMasterClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// VacancyYear is the client for interacting with the VacancyYear builders.
	VacancyYear *VacancyYearClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AgeEligibility = NewAgeEligibilityClient(c.config)
	c.Application = NewApplicationClient(c.config)
	c.Center = NewCenterClient(c.config)
	c.CircleMaster = NewCircleMasterClient(c.config)
	c.Disability = NewDisabilityClient(c.config)
	c.DivisionMaster = NewDivisionMasterClient(c.config)
	c.EmployeeCadre = NewEmployeeCadreClient(c.config)
	c.EmployeeCategory = NewEmployeeCategoryClient(c.config)
	c.EmployeeDesignation = NewEmployeeDesignationClient(c.config)
	c.EmployeePosts = NewEmployeePostsClient(c.config)
	c.Employees = NewEmployeesClient(c.config)
	c.Exam = NewExamClient(c.config)
	c.ExamCalendar = NewExamCalendarClient(c.config)
	c.ExamEligibility = NewExamEligibilityClient(c.config)
	c.ExamPapers = NewExamPapersClient(c.config)
	c.Facility = NewFacilityClient(c.config)
	c.NodalOfficer = NewNodalOfficerClient(c.config)
	c.Notification = NewNotificationClient(c.config)
	c.PaperTypes = NewPaperTypesClient(c.config)
	c.RegionMaster = NewRegionMasterClient(c.config)
	c.User = NewUserClient(c.config)
	c.VacancyYear = NewVacancyYearClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		AgeEligibility:      NewAgeEligibilityClient(cfg),
		Application:         NewApplicationClient(cfg),
		Center:              NewCenterClient(cfg),
		CircleMaster:        NewCircleMasterClient(cfg),
		Disability:          NewDisabilityClient(cfg),
		DivisionMaster:      NewDivisionMasterClient(cfg),
		EmployeeCadre:       NewEmployeeCadreClient(cfg),
		EmployeeCategory:    NewEmployeeCategoryClient(cfg),
		EmployeeDesignation: NewEmployeeDesignationClient(cfg),
		EmployeePosts:       NewEmployeePostsClient(cfg),
		Employees:           NewEmployeesClient(cfg),
		Exam:                NewExamClient(cfg),
		ExamCalendar:        NewExamCalendarClient(cfg),
		ExamEligibility:     NewExamEligibilityClient(cfg),
		ExamPapers:          NewExamPapersClient(cfg),
		Facility:            NewFacilityClient(cfg),
		NodalOfficer:        NewNodalOfficerClient(cfg),
		Notification:        NewNotificationClient(cfg),
		PaperTypes:          NewPaperTypesClient(cfg),
		RegionMaster:        NewRegionMasterClient(cfg),
		User:                NewUserClient(cfg),
		VacancyYear:         NewVacancyYearClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		AgeEligibility:      NewAgeEligibilityClient(cfg),
		Application:         NewApplicationClient(cfg),
		Center:              NewCenterClient(cfg),
		CircleMaster:        NewCircleMasterClient(cfg),
		Disability:          NewDisabilityClient(cfg),
		DivisionMaster:      NewDivisionMasterClient(cfg),
		EmployeeCadre:       NewEmployeeCadreClient(cfg),
		EmployeeCategory:    NewEmployeeCategoryClient(cfg),
		EmployeeDesignation: NewEmployeeDesignationClient(cfg),
		EmployeePosts:       NewEmployeePostsClient(cfg),
		Employees:           NewEmployeesClient(cfg),
		Exam:                NewExamClient(cfg),
		ExamCalendar:        NewExamCalendarClient(cfg),
		ExamEligibility:     NewExamEligibilityClient(cfg),
		ExamPapers:          NewExamPapersClient(cfg),
		Facility:            NewFacilityClient(cfg),
		NodalOfficer:        NewNodalOfficerClient(cfg),
		Notification:        NewNotificationClient(cfg),
		PaperTypes:          NewPaperTypesClient(cfg),
		RegionMaster:        NewRegionMasterClient(cfg),
		User:                NewUserClient(cfg),
		VacancyYear:         NewVacancyYearClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AgeEligibility.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AgeEligibility, c.Application, c.Center, c.CircleMaster, c.Disability,
		c.DivisionMaster, c.EmployeeCadre, c.EmployeeCategory, c.EmployeeDesignation,
		c.EmployeePosts, c.Employees, c.Exam, c.ExamCalendar, c.ExamEligibility,
		c.ExamPapers, c.Facility, c.NodalOfficer, c.Notification, c.PaperTypes,
		c.RegionMaster, c.User, c.VacancyYear,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AgeEligibility, c.Application, c.Center, c.CircleMaster, c.Disability,
		c.DivisionMaster, c.EmployeeCadre, c.EmployeeCategory, c.EmployeeDesignation,
		c.EmployeePosts, c.Employees, c.Exam, c.ExamCalendar, c.ExamEligibility,
		c.ExamPapers, c.Facility, c.NodalOfficer, c.Notification, c.PaperTypes,
		c.RegionMaster, c.User, c.VacancyYear,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AgeEligibilityMutation:
		return c.AgeEligibility.mutate(ctx, m)
	case *ApplicationMutation:
		return c.Application.mutate(ctx, m)
	case *CenterMutation:
		return c.Center.mutate(ctx, m)
	case *CircleMasterMutation:
		return c.CircleMaster.mutate(ctx, m)
	case *DisabilityMutation:
		return c.Disability.mutate(ctx, m)
	case *DivisionMasterMutation:
		return c.DivisionMaster.mutate(ctx, m)
	case *EmployeeCadreMutation:
		return c.EmployeeCadre.mutate(ctx, m)
	case *EmployeeCategoryMutation:
		return c.EmployeeCategory.mutate(ctx, m)
	case *EmployeeDesignationMutation:
		return c.EmployeeDesignation.mutate(ctx, m)
	case *EmployeePostsMutation:
		return c.EmployeePosts.mutate(ctx, m)
	case *EmployeesMutation:
		return c.Employees.mutate(ctx, m)
	case *ExamMutation:
		return c.Exam.mutate(ctx, m)
	case *ExamCalendarMutation:
		return c.ExamCalendar.mutate(ctx, m)
	case *ExamEligibilityMutation:
		return c.ExamEligibility.mutate(ctx, m)
	case *ExamPapersMutation:
		return c.ExamPapers.mutate(ctx, m)
	case *FacilityMutation:
		return c.Facility.mutate(ctx, m)
	case *NodalOfficerMutation:
		return c.NodalOfficer.mutate(ctx, m)
	case *NotificationMutation:
		return c.Notification.mutate(ctx, m)
	case *PaperTypesMutation:
		return c.PaperTypes.mutate(ctx, m)
	case *RegionMasterMutation:
		return c.RegionMaster.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *VacancyYearMutation:
		return c.VacancyYear.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AgeEligibilityClient is a client for the AgeEligibility schema.
type AgeEligibilityClient struct {
	config
}

// NewAgeEligibilityClient returns a client for the AgeEligibility from the given config.
func NewAgeEligibilityClient(c config) *AgeEligibilityClient {
	return &AgeEligibilityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ageeligibility.Hooks(f(g(h())))`.
func (c *AgeEligibilityClient) Use(hooks ...Hook) {
	c.hooks.AgeEligibility = append(c.hooks.AgeEligibility, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ageeligibility.Intercept(f(g(h())))`.
func (c *AgeEligibilityClient) Intercept(interceptors ...Interceptor) {
	c.inters.AgeEligibility = append(c.inters.AgeEligibility, interceptors...)
}

// Create returns a builder for creating a AgeEligibility entity.
func (c *AgeEligibilityClient) Create() *AgeEligibilityCreate {
	mutation := newAgeEligibilityMutation(c.config, OpCreate)
	return &AgeEligibilityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AgeEligibility entities.
func (c *AgeEligibilityClient) CreateBulk(builders ...*AgeEligibilityCreate) *AgeEligibilityCreateBulk {
	return &AgeEligibilityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AgeEligibility.
func (c *AgeEligibilityClient) Update() *AgeEligibilityUpdate {
	mutation := newAgeEligibilityMutation(c.config, OpUpdate)
	return &AgeEligibilityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgeEligibilityClient) UpdateOne(ae *AgeEligibility) *AgeEligibilityUpdateOne {
	mutation := newAgeEligibilityMutation(c.config, OpUpdateOne, withAgeEligibility(ae))
	return &AgeEligibilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgeEligibilityClient) UpdateOneID(id int32) *AgeEligibilityUpdateOne {
	mutation := newAgeEligibilityMutation(c.config, OpUpdateOne, withAgeEligibilityID(id))
	return &AgeEligibilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AgeEligibility.
func (c *AgeEligibilityClient) Delete() *AgeEligibilityDelete {
	mutation := newAgeEligibilityMutation(c.config, OpDelete)
	return &AgeEligibilityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgeEligibilityClient) DeleteOne(ae *AgeEligibility) *AgeEligibilityDeleteOne {
	return c.DeleteOneID(ae.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgeEligibilityClient) DeleteOneID(id int32) *AgeEligibilityDeleteOne {
	builder := c.Delete().Where(ageeligibility.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgeEligibilityDeleteOne{builder}
}

// Query returns a query builder for AgeEligibility.
func (c *AgeEligibilityClient) Query() *AgeEligibilityQuery {
	return &AgeEligibilityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgeEligibility},
		inters: c.Interceptors(),
	}
}

// Get returns a AgeEligibility entity by its id.
func (c *AgeEligibilityClient) Get(ctx context.Context, id int32) (*AgeEligibility, error) {
	return c.Query().Where(ageeligibility.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgeEligibilityClient) GetX(ctx context.Context, id int32) *AgeEligibility {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExamEligibility queries the exam_eligibility edge of a AgeEligibility.
func (c *AgeEligibilityClient) QueryExamEligibility(ae *AgeEligibility) *ExamEligibilityQuery {
	query := (&ExamEligibilityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ae.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ageeligibility.Table, ageeligibility.FieldID, id),
			sqlgraph.To(exameligibility.Table, exameligibility.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ageeligibility.ExamEligibilityTable, ageeligibility.ExamEligibilityColumn),
		)
		fromV = sqlgraph.Neighbors(ae.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgeEligibilityClient) Hooks() []Hook {
	return c.hooks.AgeEligibility
}

// Interceptors returns the client interceptors.
func (c *AgeEligibilityClient) Interceptors() []Interceptor {
	return c.inters.AgeEligibility
}

func (c *AgeEligibilityClient) mutate(ctx context.Context, m *AgeEligibilityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgeEligibilityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgeEligibilityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgeEligibilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgeEligibilityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AgeEligibility mutation op: %q", m.Op())
	}
}

// ApplicationClient is a client for the Application schema.
type ApplicationClient struct {
	config
}

// NewApplicationClient returns a client for the Application from the given config.
func NewApplicationClient(c config) *ApplicationClient {
	return &ApplicationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `application.Hooks(f(g(h())))`.
func (c *ApplicationClient) Use(hooks ...Hook) {
	c.hooks.Application = append(c.hooks.Application, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `application.Intercept(f(g(h())))`.
func (c *ApplicationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Application = append(c.inters.Application, interceptors...)
}

// Create returns a builder for creating a Application entity.
func (c *ApplicationClient) Create() *ApplicationCreate {
	mutation := newApplicationMutation(c.config, OpCreate)
	return &ApplicationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Application entities.
func (c *ApplicationClient) CreateBulk(builders ...*ApplicationCreate) *ApplicationCreateBulk {
	return &ApplicationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Application.
func (c *ApplicationClient) Update() *ApplicationUpdate {
	mutation := newApplicationMutation(c.config, OpUpdate)
	return &ApplicationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ApplicationClient) UpdateOne(a *Application) *ApplicationUpdateOne {
	mutation := newApplicationMutation(c.config, OpUpdateOne, withApplication(a))
	return &ApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ApplicationClient) UpdateOneID(id int32) *ApplicationUpdateOne {
	mutation := newApplicationMutation(c.config, OpUpdateOne, withApplicationID(id))
	return &ApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Application.
func (c *ApplicationClient) Delete() *ApplicationDelete {
	mutation := newApplicationMutation(c.config, OpDelete)
	return &ApplicationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ApplicationClient) DeleteOne(a *Application) *ApplicationDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ApplicationClient) DeleteOneID(id int32) *ApplicationDeleteOne {
	builder := c.Delete().Where(application.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ApplicationDeleteOne{builder}
}

// Query returns a query builder for Application.
func (c *ApplicationClient) Query() *ApplicationQuery {
	return &ApplicationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApplication},
		inters: c.Interceptors(),
	}
}

// Get returns a Application entity by its id.
func (c *ApplicationClient) Get(ctx context.Context, id int32) (*Application, error) {
	return c.Query().Where(application.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ApplicationClient) GetX(ctx context.Context, id int32) *Application {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCenter queries the center edge of a Application.
func (c *ApplicationClient) QueryCenter(a *Application) *CenterQuery {
	query := (&CenterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(application.Table, application.FieldID, id),
			sqlgraph.To(center.Table, center.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, application.CenterTable, application.CenterColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotification queries the notification edge of a Application.
func (c *ApplicationClient) QueryNotification(a *Application) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(application.Table, application.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, application.NotificationTable, application.NotificationColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ApplicationClient) Hooks() []Hook {
	return c.hooks.Application
}

// Interceptors returns the client interceptors.
func (c *ApplicationClient) Interceptors() []Interceptor {
	return c.inters.Application
}

func (c *ApplicationClient) mutate(ctx context.Context, m *ApplicationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ApplicationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ApplicationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ApplicationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Application mutation op: %q", m.Op())
	}
}

// CenterClient is a client for the Center schema.
type CenterClient struct {
	config
}

// NewCenterClient returns a client for the Center from the given config.
func NewCenterClient(c config) *CenterClient {
	return &CenterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `center.Hooks(f(g(h())))`.
func (c *CenterClient) Use(hooks ...Hook) {
	c.hooks.Center = append(c.hooks.Center, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `center.Intercept(f(g(h())))`.
func (c *CenterClient) Intercept(interceptors ...Interceptor) {
	c.inters.Center = append(c.inters.Center, interceptors...)
}

// Create returns a builder for creating a Center entity.
func (c *CenterClient) Create() *CenterCreate {
	mutation := newCenterMutation(c.config, OpCreate)
	return &CenterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Center entities.
func (c *CenterClient) CreateBulk(builders ...*CenterCreate) *CenterCreateBulk {
	return &CenterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Center.
func (c *CenterClient) Update() *CenterUpdate {
	mutation := newCenterMutation(c.config, OpUpdate)
	return &CenterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CenterClient) UpdateOne(ce *Center) *CenterUpdateOne {
	mutation := newCenterMutation(c.config, OpUpdateOne, withCenter(ce))
	return &CenterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CenterClient) UpdateOneID(id int32) *CenterUpdateOne {
	mutation := newCenterMutation(c.config, OpUpdateOne, withCenterID(id))
	return &CenterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Center.
func (c *CenterClient) Delete() *CenterDelete {
	mutation := newCenterMutation(c.config, OpDelete)
	return &CenterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CenterClient) DeleteOne(ce *Center) *CenterDeleteOne {
	return c.DeleteOneID(ce.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CenterClient) DeleteOneID(id int32) *CenterDeleteOne {
	builder := c.Delete().Where(center.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CenterDeleteOne{builder}
}

// Query returns a query builder for Center.
func (c *CenterClient) Query() *CenterQuery {
	return &CenterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCenter},
		inters: c.Interceptors(),
	}
}

// Get returns a Center entity by its id.
func (c *CenterClient) Get(ctx context.Context, id int32) (*Center, error) {
	return c.Query().Where(center.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CenterClient) GetX(ctx context.Context, id int32) *Center {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApplications queries the applications edge of a Center.
func (c *CenterClient) QueryApplications(ce *Center) *ApplicationQuery {
	query := (&ApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(center.Table, center.FieldID, id),
			sqlgraph.To(application.Table, application.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, center.ApplicationsTable, center.ApplicationsColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodalOfficer queries the nodal_officer edge of a Center.
func (c *CenterClient) QueryNodalOfficer(ce *Center) *NodalOfficerQuery {
	query := (&NodalOfficerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(center.Table, center.FieldID, id),
			sqlgraph.To(nodalofficer.Table, nodalofficer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, center.NodalOfficerTable, center.NodalOfficerColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotification queries the notification edge of a Center.
func (c *CenterClient) QueryNotification(ce *Center) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(center.Table, center.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, center.NotificationTable, center.NotificationColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CenterClient) Hooks() []Hook {
	return c.hooks.Center
}

// Interceptors returns the client interceptors.
func (c *CenterClient) Interceptors() []Interceptor {
	return c.inters.Center
}

func (c *CenterClient) mutate(ctx context.Context, m *CenterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CenterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CenterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CenterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CenterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Center mutation op: %q", m.Op())
	}
}

// CircleMasterClient is a client for the CircleMaster schema.
type CircleMasterClient struct {
	config
}

// NewCircleMasterClient returns a client for the CircleMaster from the given config.
func NewCircleMasterClient(c config) *CircleMasterClient {
	return &CircleMasterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `circlemaster.Hooks(f(g(h())))`.
func (c *CircleMasterClient) Use(hooks ...Hook) {
	c.hooks.CircleMaster = append(c.hooks.CircleMaster, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `circlemaster.Intercept(f(g(h())))`.
func (c *CircleMasterClient) Intercept(interceptors ...Interceptor) {
	c.inters.CircleMaster = append(c.inters.CircleMaster, interceptors...)
}

// Create returns a builder for creating a CircleMaster entity.
func (c *CircleMasterClient) Create() *CircleMasterCreate {
	mutation := newCircleMasterMutation(c.config, OpCreate)
	return &CircleMasterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CircleMaster entities.
func (c *CircleMasterClient) CreateBulk(builders ...*CircleMasterCreate) *CircleMasterCreateBulk {
	return &CircleMasterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CircleMaster.
func (c *CircleMasterClient) Update() *CircleMasterUpdate {
	mutation := newCircleMasterMutation(c.config, OpUpdate)
	return &CircleMasterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CircleMasterClient) UpdateOne(cm *CircleMaster) *CircleMasterUpdateOne {
	mutation := newCircleMasterMutation(c.config, OpUpdateOne, withCircleMaster(cm))
	return &CircleMasterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CircleMasterClient) UpdateOneID(id int32) *CircleMasterUpdateOne {
	mutation := newCircleMasterMutation(c.config, OpUpdateOne, withCircleMasterID(id))
	return &CircleMasterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CircleMaster.
func (c *CircleMasterClient) Delete() *CircleMasterDelete {
	mutation := newCircleMasterMutation(c.config, OpDelete)
	return &CircleMasterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CircleMasterClient) DeleteOne(cm *CircleMaster) *CircleMasterDeleteOne {
	return c.DeleteOneID(cm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CircleMasterClient) DeleteOneID(id int32) *CircleMasterDeleteOne {
	builder := c.Delete().Where(circlemaster.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CircleMasterDeleteOne{builder}
}

// Query returns a query builder for CircleMaster.
func (c *CircleMasterClient) Query() *CircleMasterQuery {
	return &CircleMasterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCircleMaster},
		inters: c.Interceptors(),
	}
}

// Get returns a CircleMaster entity by its id.
func (c *CircleMasterClient) Get(ctx context.Context, id int32) (*CircleMaster, error) {
	return c.Query().Where(circlemaster.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CircleMasterClient) GetX(ctx context.Context, id int32) *CircleMaster {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRegionRef queries the region_ref edge of a CircleMaster.
func (c *CircleMasterClient) QueryRegionRef(cm *CircleMaster) *RegionMasterQuery {
	query := (&RegionMasterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(circlemaster.Table, circlemaster.FieldID, id),
			sqlgraph.To(regionmaster.Table, regionmaster.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, circlemaster.RegionRefTable, circlemaster.RegionRefColumn),
		)
		fromV = sqlgraph.Neighbors(cm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCircleRef queries the circle_ref edge of a CircleMaster.
func (c *CircleMasterClient) QueryCircleRef(cm *CircleMaster) *FacilityQuery {
	query := (&FacilityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(circlemaster.Table, circlemaster.FieldID, id),
			sqlgraph.To(facility.Table, facility.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, circlemaster.CircleRefTable, circlemaster.CircleRefColumn),
		)
		fromV = sqlgraph.Neighbors(cm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CircleMasterClient) Hooks() []Hook {
	return c.hooks.CircleMaster
}

// Interceptors returns the client interceptors.
func (c *CircleMasterClient) Interceptors() []Interceptor {
	return c.inters.CircleMaster
}

func (c *CircleMasterClient) mutate(ctx context.Context, m *CircleMasterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CircleMasterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CircleMasterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CircleMasterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CircleMasterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CircleMaster mutation op: %q", m.Op())
	}
}

// DisabilityClient is a client for the Disability schema.
type DisabilityClient struct {
	config
}

// NewDisabilityClient returns a client for the Disability from the given config.
func NewDisabilityClient(c config) *DisabilityClient {
	return &DisabilityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `disability.Hooks(f(g(h())))`.
func (c *DisabilityClient) Use(hooks ...Hook) {
	c.hooks.Disability = append(c.hooks.Disability, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `disability.Intercept(f(g(h())))`.
func (c *DisabilityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Disability = append(c.inters.Disability, interceptors...)
}

// Create returns a builder for creating a Disability entity.
func (c *DisabilityClient) Create() *DisabilityCreate {
	mutation := newDisabilityMutation(c.config, OpCreate)
	return &DisabilityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Disability entities.
func (c *DisabilityClient) CreateBulk(builders ...*DisabilityCreate) *DisabilityCreateBulk {
	return &DisabilityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Disability.
func (c *DisabilityClient) Update() *DisabilityUpdate {
	mutation := newDisabilityMutation(c.config, OpUpdate)
	return &DisabilityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DisabilityClient) UpdateOne(d *Disability) *DisabilityUpdateOne {
	mutation := newDisabilityMutation(c.config, OpUpdateOne, withDisability(d))
	return &DisabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DisabilityClient) UpdateOneID(id int32) *DisabilityUpdateOne {
	mutation := newDisabilityMutation(c.config, OpUpdateOne, withDisabilityID(id))
	return &DisabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Disability.
func (c *DisabilityClient) Delete() *DisabilityDelete {
	mutation := newDisabilityMutation(c.config, OpDelete)
	return &DisabilityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DisabilityClient) DeleteOne(d *Disability) *DisabilityDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DisabilityClient) DeleteOneID(id int32) *DisabilityDeleteOne {
	builder := c.Delete().Where(disability.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DisabilityDeleteOne{builder}
}

// Query returns a query builder for Disability.
func (c *DisabilityClient) Query() *DisabilityQuery {
	return &DisabilityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDisability},
		inters: c.Interceptors(),
	}
}

// Get returns a Disability entity by its id.
func (c *DisabilityClient) Get(ctx context.Context, id int32) (*Disability, error) {
	return c.Query().Where(disability.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DisabilityClient) GetX(ctx context.Context, id int32) *Disability {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DisabilityClient) Hooks() []Hook {
	return c.hooks.Disability
}

// Interceptors returns the client interceptors.
func (c *DisabilityClient) Interceptors() []Interceptor {
	return c.inters.Disability
}

func (c *DisabilityClient) mutate(ctx context.Context, m *DisabilityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DisabilityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DisabilityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DisabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DisabilityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Disability mutation op: %q", m.Op())
	}
}

// DivisionMasterClient is a client for the DivisionMaster schema.
type DivisionMasterClient struct {
	config
}

// NewDivisionMasterClient returns a client for the DivisionMaster from the given config.
func NewDivisionMasterClient(c config) *DivisionMasterClient {
	return &DivisionMasterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `divisionmaster.Hooks(f(g(h())))`.
func (c *DivisionMasterClient) Use(hooks ...Hook) {
	c.hooks.DivisionMaster = append(c.hooks.DivisionMaster, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `divisionmaster.Intercept(f(g(h())))`.
func (c *DivisionMasterClient) Intercept(interceptors ...Interceptor) {
	c.inters.DivisionMaster = append(c.inters.DivisionMaster, interceptors...)
}

// Create returns a builder for creating a DivisionMaster entity.
func (c *DivisionMasterClient) Create() *DivisionMasterCreate {
	mutation := newDivisionMasterMutation(c.config, OpCreate)
	return &DivisionMasterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DivisionMaster entities.
func (c *DivisionMasterClient) CreateBulk(builders ...*DivisionMasterCreate) *DivisionMasterCreateBulk {
	return &DivisionMasterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DivisionMaster.
func (c *DivisionMasterClient) Update() *DivisionMasterUpdate {
	mutation := newDivisionMasterMutation(c.config, OpUpdate)
	return &DivisionMasterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DivisionMasterClient) UpdateOne(dm *DivisionMaster) *DivisionMasterUpdateOne {
	mutation := newDivisionMasterMutation(c.config, OpUpdateOne, withDivisionMaster(dm))
	return &DivisionMasterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DivisionMasterClient) UpdateOneID(id int32) *DivisionMasterUpdateOne {
	mutation := newDivisionMasterMutation(c.config, OpUpdateOne, withDivisionMasterID(id))
	return &DivisionMasterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DivisionMaster.
func (c *DivisionMasterClient) Delete() *DivisionMasterDelete {
	mutation := newDivisionMasterMutation(c.config, OpDelete)
	return &DivisionMasterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DivisionMasterClient) DeleteOne(dm *DivisionMaster) *DivisionMasterDeleteOne {
	return c.DeleteOneID(dm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DivisionMasterClient) DeleteOneID(id int32) *DivisionMasterDeleteOne {
	builder := c.Delete().Where(divisionmaster.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DivisionMasterDeleteOne{builder}
}

// Query returns a query builder for DivisionMaster.
func (c *DivisionMasterClient) Query() *DivisionMasterQuery {
	return &DivisionMasterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDivisionMaster},
		inters: c.Interceptors(),
	}
}

// Get returns a DivisionMaster entity by its id.
func (c *DivisionMasterClient) Get(ctx context.Context, id int32) (*DivisionMaster, error) {
	return c.Query().Where(divisionmaster.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DivisionMasterClient) GetX(ctx context.Context, id int32) *DivisionMaster {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRegions queries the regions edge of a DivisionMaster.
func (c *DivisionMasterClient) QueryRegions(dm *DivisionMaster) *RegionMasterQuery {
	query := (&RegionMasterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(divisionmaster.Table, divisionmaster.FieldID, id),
			sqlgraph.To(regionmaster.Table, regionmaster.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, divisionmaster.RegionsTable, divisionmaster.RegionsColumn),
		)
		fromV = sqlgraph.Neighbors(dm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DivisionMasterClient) Hooks() []Hook {
	return c.hooks.DivisionMaster
}

// Interceptors returns the client interceptors.
func (c *DivisionMasterClient) Interceptors() []Interceptor {
	return c.inters.DivisionMaster
}

func (c *DivisionMasterClient) mutate(ctx context.Context, m *DivisionMasterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DivisionMasterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DivisionMasterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DivisionMasterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DivisionMasterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DivisionMaster mutation op: %q", m.Op())
	}
}

// EmployeeCadreClient is a client for the EmployeeCadre schema.
type EmployeeCadreClient struct {
	config
}

// NewEmployeeCadreClient returns a client for the EmployeeCadre from the given config.
func NewEmployeeCadreClient(c config) *EmployeeCadreClient {
	return &EmployeeCadreClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `employeecadre.Hooks(f(g(h())))`.
func (c *EmployeeCadreClient) Use(hooks ...Hook) {
	c.hooks.EmployeeCadre = append(c.hooks.EmployeeCadre, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `employeecadre.Intercept(f(g(h())))`.
func (c *EmployeeCadreClient) Intercept(interceptors ...Interceptor) {
	c.inters.EmployeeCadre = append(c.inters.EmployeeCadre, interceptors...)
}

// Create returns a builder for creating a EmployeeCadre entity.
func (c *EmployeeCadreClient) Create() *EmployeeCadreCreate {
	mutation := newEmployeeCadreMutation(c.config, OpCreate)
	return &EmployeeCadreCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmployeeCadre entities.
func (c *EmployeeCadreClient) CreateBulk(builders ...*EmployeeCadreCreate) *EmployeeCadreCreateBulk {
	return &EmployeeCadreCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmployeeCadre.
func (c *EmployeeCadreClient) Update() *EmployeeCadreUpdate {
	mutation := newEmployeeCadreMutation(c.config, OpUpdate)
	return &EmployeeCadreUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmployeeCadreClient) UpdateOne(ec *EmployeeCadre) *EmployeeCadreUpdateOne {
	mutation := newEmployeeCadreMutation(c.config, OpUpdateOne, withEmployeeCadre(ec))
	return &EmployeeCadreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmployeeCadreClient) UpdateOneID(id int32) *EmployeeCadreUpdateOne {
	mutation := newEmployeeCadreMutation(c.config, OpUpdateOne, withEmployeeCadreID(id))
	return &EmployeeCadreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmployeeCadre.
func (c *EmployeeCadreClient) Delete() *EmployeeCadreDelete {
	mutation := newEmployeeCadreMutation(c.config, OpDelete)
	return &EmployeeCadreDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmployeeCadreClient) DeleteOne(ec *EmployeeCadre) *EmployeeCadreDeleteOne {
	return c.DeleteOneID(ec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmployeeCadreClient) DeleteOneID(id int32) *EmployeeCadreDeleteOne {
	builder := c.Delete().Where(employeecadre.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmployeeCadreDeleteOne{builder}
}

// Query returns a query builder for EmployeeCadre.
func (c *EmployeeCadreClient) Query() *EmployeeCadreQuery {
	return &EmployeeCadreQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmployeeCadre},
		inters: c.Interceptors(),
	}
}

// Get returns a EmployeeCadre entity by its id.
func (c *EmployeeCadreClient) Get(ctx context.Context, id int32) (*EmployeeCadre, error) {
	return c.Query().Where(employeecadre.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmployeeCadreClient) GetX(ctx context.Context, id int32) *EmployeeCadre {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EmployeeCadreClient) Hooks() []Hook {
	return c.hooks.EmployeeCadre
}

// Interceptors returns the client interceptors.
func (c *EmployeeCadreClient) Interceptors() []Interceptor {
	return c.inters.EmployeeCadre
}

func (c *EmployeeCadreClient) mutate(ctx context.Context, m *EmployeeCadreMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmployeeCadreCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmployeeCadreUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmployeeCadreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmployeeCadreDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EmployeeCadre mutation op: %q", m.Op())
	}
}

// EmployeeCategoryClient is a client for the EmployeeCategory schema.
type EmployeeCategoryClient struct {
	config
}

// NewEmployeeCategoryClient returns a client for the EmployeeCategory from the given config.
func NewEmployeeCategoryClient(c config) *EmployeeCategoryClient {
	return &EmployeeCategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `employeecategory.Hooks(f(g(h())))`.
func (c *EmployeeCategoryClient) Use(hooks ...Hook) {
	c.hooks.EmployeeCategory = append(c.hooks.EmployeeCategory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `employeecategory.Intercept(f(g(h())))`.
func (c *EmployeeCategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.EmployeeCategory = append(c.inters.EmployeeCategory, interceptors...)
}

// Create returns a builder for creating a EmployeeCategory entity.
func (c *EmployeeCategoryClient) Create() *EmployeeCategoryCreate {
	mutation := newEmployeeCategoryMutation(c.config, OpCreate)
	return &EmployeeCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmployeeCategory entities.
func (c *EmployeeCategoryClient) CreateBulk(builders ...*EmployeeCategoryCreate) *EmployeeCategoryCreateBulk {
	return &EmployeeCategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmployeeCategory.
func (c *EmployeeCategoryClient) Update() *EmployeeCategoryUpdate {
	mutation := newEmployeeCategoryMutation(c.config, OpUpdate)
	return &EmployeeCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmployeeCategoryClient) UpdateOne(ec *EmployeeCategory) *EmployeeCategoryUpdateOne {
	mutation := newEmployeeCategoryMutation(c.config, OpUpdateOne, withEmployeeCategory(ec))
	return &EmployeeCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmployeeCategoryClient) UpdateOneID(id int32) *EmployeeCategoryUpdateOne {
	mutation := newEmployeeCategoryMutation(c.config, OpUpdateOne, withEmployeeCategoryID(id))
	return &EmployeeCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmployeeCategory.
func (c *EmployeeCategoryClient) Delete() *EmployeeCategoryDelete {
	mutation := newEmployeeCategoryMutation(c.config, OpDelete)
	return &EmployeeCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmployeeCategoryClient) DeleteOne(ec *EmployeeCategory) *EmployeeCategoryDeleteOne {
	return c.DeleteOneID(ec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmployeeCategoryClient) DeleteOneID(id int32) *EmployeeCategoryDeleteOne {
	builder := c.Delete().Where(employeecategory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmployeeCategoryDeleteOne{builder}
}

// Query returns a query builder for EmployeeCategory.
func (c *EmployeeCategoryClient) Query() *EmployeeCategoryQuery {
	return &EmployeeCategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmployeeCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a EmployeeCategory entity by its id.
func (c *EmployeeCategoryClient) Get(ctx context.Context, id int32) (*EmployeeCategory, error) {
	return c.Query().Where(employeecategory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmployeeCategoryClient) GetX(ctx context.Context, id int32) *EmployeeCategory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EmployeeCategoryClient) Hooks() []Hook {
	return c.hooks.EmployeeCategory
}

// Interceptors returns the client interceptors.
func (c *EmployeeCategoryClient) Interceptors() []Interceptor {
	return c.inters.EmployeeCategory
}

func (c *EmployeeCategoryClient) mutate(ctx context.Context, m *EmployeeCategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmployeeCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmployeeCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmployeeCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmployeeCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EmployeeCategory mutation op: %q", m.Op())
	}
}

// EmployeeDesignationClient is a client for the EmployeeDesignation schema.
type EmployeeDesignationClient struct {
	config
}

// NewEmployeeDesignationClient returns a client for the EmployeeDesignation from the given config.
func NewEmployeeDesignationClient(c config) *EmployeeDesignationClient {
	return &EmployeeDesignationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `employeedesignation.Hooks(f(g(h())))`.
func (c *EmployeeDesignationClient) Use(hooks ...Hook) {
	c.hooks.EmployeeDesignation = append(c.hooks.EmployeeDesignation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `employeedesignation.Intercept(f(g(h())))`.
func (c *EmployeeDesignationClient) Intercept(interceptors ...Interceptor) {
	c.inters.EmployeeDesignation = append(c.inters.EmployeeDesignation, interceptors...)
}

// Create returns a builder for creating a EmployeeDesignation entity.
func (c *EmployeeDesignationClient) Create() *EmployeeDesignationCreate {
	mutation := newEmployeeDesignationMutation(c.config, OpCreate)
	return &EmployeeDesignationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmployeeDesignation entities.
func (c *EmployeeDesignationClient) CreateBulk(builders ...*EmployeeDesignationCreate) *EmployeeDesignationCreateBulk {
	return &EmployeeDesignationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmployeeDesignation.
func (c *EmployeeDesignationClient) Update() *EmployeeDesignationUpdate {
	mutation := newEmployeeDesignationMutation(c.config, OpUpdate)
	return &EmployeeDesignationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmployeeDesignationClient) UpdateOne(ed *EmployeeDesignation) *EmployeeDesignationUpdateOne {
	mutation := newEmployeeDesignationMutation(c.config, OpUpdateOne, withEmployeeDesignation(ed))
	return &EmployeeDesignationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmployeeDesignationClient) UpdateOneID(id int32) *EmployeeDesignationUpdateOne {
	mutation := newEmployeeDesignationMutation(c.config, OpUpdateOne, withEmployeeDesignationID(id))
	return &EmployeeDesignationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmployeeDesignation.
func (c *EmployeeDesignationClient) Delete() *EmployeeDesignationDelete {
	mutation := newEmployeeDesignationMutation(c.config, OpDelete)
	return &EmployeeDesignationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmployeeDesignationClient) DeleteOne(ed *EmployeeDesignation) *EmployeeDesignationDeleteOne {
	return c.DeleteOneID(ed.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmployeeDesignationClient) DeleteOneID(id int32) *EmployeeDesignationDeleteOne {
	builder := c.Delete().Where(employeedesignation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmployeeDesignationDeleteOne{builder}
}

// Query returns a query builder for EmployeeDesignation.
func (c *EmployeeDesignationClient) Query() *EmployeeDesignationQuery {
	return &EmployeeDesignationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmployeeDesignation},
		inters: c.Interceptors(),
	}
}

// Get returns a EmployeeDesignation entity by its id.
func (c *EmployeeDesignationClient) Get(ctx context.Context, id int32) (*EmployeeDesignation, error) {
	return c.Query().Where(employeedesignation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmployeeDesignationClient) GetX(ctx context.Context, id int32) *EmployeeDesignation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EmployeeDesignationClient) Hooks() []Hook {
	return c.hooks.EmployeeDesignation
}

// Interceptors returns the client interceptors.
func (c *EmployeeDesignationClient) Interceptors() []Interceptor {
	return c.inters.EmployeeDesignation
}

func (c *EmployeeDesignationClient) mutate(ctx context.Context, m *EmployeeDesignationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmployeeDesignationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmployeeDesignationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmployeeDesignationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmployeeDesignationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EmployeeDesignation mutation op: %q", m.Op())
	}
}

// EmployeePostsClient is a client for the EmployeePosts schema.
type EmployeePostsClient struct {
	config
}

// NewEmployeePostsClient returns a client for the EmployeePosts from the given config.
func NewEmployeePostsClient(c config) *EmployeePostsClient {
	return &EmployeePostsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `employeeposts.Hooks(f(g(h())))`.
func (c *EmployeePostsClient) Use(hooks ...Hook) {
	c.hooks.EmployeePosts = append(c.hooks.EmployeePosts, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `employeeposts.Intercept(f(g(h())))`.
func (c *EmployeePostsClient) Intercept(interceptors ...Interceptor) {
	c.inters.EmployeePosts = append(c.inters.EmployeePosts, interceptors...)
}

// Create returns a builder for creating a EmployeePosts entity.
func (c *EmployeePostsClient) Create() *EmployeePostsCreate {
	mutation := newEmployeePostsMutation(c.config, OpCreate)
	return &EmployeePostsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmployeePosts entities.
func (c *EmployeePostsClient) CreateBulk(builders ...*EmployeePostsCreate) *EmployeePostsCreateBulk {
	return &EmployeePostsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmployeePosts.
func (c *EmployeePostsClient) Update() *EmployeePostsUpdate {
	mutation := newEmployeePostsMutation(c.config, OpUpdate)
	return &EmployeePostsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmployeePostsClient) UpdateOne(ep *EmployeePosts) *EmployeePostsUpdateOne {
	mutation := newEmployeePostsMutation(c.config, OpUpdateOne, withEmployeePosts(ep))
	return &EmployeePostsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmployeePostsClient) UpdateOneID(id int32) *EmployeePostsUpdateOne {
	mutation := newEmployeePostsMutation(c.config, OpUpdateOne, withEmployeePostsID(id))
	return &EmployeePostsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmployeePosts.
func (c *EmployeePostsClient) Delete() *EmployeePostsDelete {
	mutation := newEmployeePostsMutation(c.config, OpDelete)
	return &EmployeePostsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmployeePostsClient) DeleteOne(ep *EmployeePosts) *EmployeePostsDeleteOne {
	return c.DeleteOneID(ep.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmployeePostsClient) DeleteOneID(id int32) *EmployeePostsDeleteOne {
	builder := c.Delete().Where(employeeposts.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmployeePostsDeleteOne{builder}
}

// Query returns a query builder for EmployeePosts.
func (c *EmployeePostsClient) Query() *EmployeePostsQuery {
	return &EmployeePostsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmployeePosts},
		inters: c.Interceptors(),
	}
}

// Get returns a EmployeePosts entity by its id.
func (c *EmployeePostsClient) Get(ctx context.Context, id int32) (*EmployeePosts, error) {
	return c.Query().Where(employeeposts.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmployeePostsClient) GetX(ctx context.Context, id int32) *EmployeePosts {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EmployeePostsClient) Hooks() []Hook {
	return c.hooks.EmployeePosts
}

// Interceptors returns the client interceptors.
func (c *EmployeePostsClient) Interceptors() []Interceptor {
	return c.inters.EmployeePosts
}

func (c *EmployeePostsClient) mutate(ctx context.Context, m *EmployeePostsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmployeePostsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmployeePostsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmployeePostsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmployeePostsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EmployeePosts mutation op: %q", m.Op())
	}
}

// EmployeesClient is a client for the Employees schema.
type EmployeesClient struct {
	config
}

// NewEmployeesClient returns a client for the Employees from the given config.
func NewEmployeesClient(c config) *EmployeesClient {
	return &EmployeesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `employees.Hooks(f(g(h())))`.
func (c *EmployeesClient) Use(hooks ...Hook) {
	c.hooks.Employees = append(c.hooks.Employees, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `employees.Intercept(f(g(h())))`.
func (c *EmployeesClient) Intercept(interceptors ...Interceptor) {
	c.inters.Employees = append(c.inters.Employees, interceptors...)
}

// Create returns a builder for creating a Employees entity.
func (c *EmployeesClient) Create() *EmployeesCreate {
	mutation := newEmployeesMutation(c.config, OpCreate)
	return &EmployeesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Employees entities.
func (c *EmployeesClient) CreateBulk(builders ...*EmployeesCreate) *EmployeesCreateBulk {
	return &EmployeesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Employees.
func (c *EmployeesClient) Update() *EmployeesUpdate {
	mutation := newEmployeesMutation(c.config, OpUpdate)
	return &EmployeesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmployeesClient) UpdateOne(e *Employees) *EmployeesUpdateOne {
	mutation := newEmployeesMutation(c.config, OpUpdateOne, withEmployees(e))
	return &EmployeesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmployeesClient) UpdateOneID(id int32) *EmployeesUpdateOne {
	mutation := newEmployeesMutation(c.config, OpUpdateOne, withEmployeesID(id))
	return &EmployeesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Employees.
func (c *EmployeesClient) Delete() *EmployeesDelete {
	mutation := newEmployeesMutation(c.config, OpDelete)
	return &EmployeesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmployeesClient) DeleteOne(e *Employees) *EmployeesDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmployeesClient) DeleteOneID(id int32) *EmployeesDeleteOne {
	builder := c.Delete().Where(employees.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmployeesDeleteOne{builder}
}

// Query returns a query builder for Employees.
func (c *EmployeesClient) Query() *EmployeesQuery {
	return &EmployeesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmployees},
		inters: c.Interceptors(),
	}
}

// Get returns a Employees entity by its id.
func (c *EmployeesClient) Get(ctx context.Context, id int32) (*Employees, error) {
	return c.Query().Where(employees.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmployeesClient) GetX(ctx context.Context, id int32) *Employees {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EmployeesClient) Hooks() []Hook {
	return c.hooks.Employees
}

// Interceptors returns the client interceptors.
func (c *EmployeesClient) Interceptors() []Interceptor {
	return c.inters.Employees
}

func (c *EmployeesClient) mutate(ctx context.Context, m *EmployeesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmployeesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmployeesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmployeesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmployeesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Employees mutation op: %q", m.Op())
	}
}

// ExamClient is a client for the Exam schema.
type ExamClient struct {
	config
}

// NewExamClient returns a client for the Exam from the given config.
func NewExamClient(c config) *ExamClient {
	return &ExamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `exam.Hooks(f(g(h())))`.
func (c *ExamClient) Use(hooks ...Hook) {
	c.hooks.Exam = append(c.hooks.Exam, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `exam.Intercept(f(g(h())))`.
func (c *ExamClient) Intercept(interceptors ...Interceptor) {
	c.inters.Exam = append(c.inters.Exam, interceptors...)
}

// Create returns a builder for creating a Exam entity.
func (c *ExamClient) Create() *ExamCreate {
	mutation := newExamMutation(c.config, OpCreate)
	return &ExamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Exam entities.
func (c *ExamClient) CreateBulk(builders ...*ExamCreate) *ExamCreateBulk {
	return &ExamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Exam.
func (c *ExamClient) Update() *ExamUpdate {
	mutation := newExamMutation(c.config, OpUpdate)
	return &ExamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExamClient) UpdateOne(e *Exam) *ExamUpdateOne {
	mutation := newExamMutation(c.config, OpUpdateOne, withExam(e))
	return &ExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExamClient) UpdateOneID(id int32) *ExamUpdateOne {
	mutation := newExamMutation(c.config, OpUpdateOne, withExamID(id))
	return &ExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Exam.
func (c *ExamClient) Delete() *ExamDelete {
	mutation := newExamMutation(c.config, OpDelete)
	return &ExamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExamClient) DeleteOne(e *Exam) *ExamDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExamClient) DeleteOneID(id int32) *ExamDeleteOne {
	builder := c.Delete().Where(exam.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExamDeleteOne{builder}
}

// Query returns a query builder for Exam.
func (c *ExamClient) Query() *ExamQuery {
	return &ExamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExam},
		inters: c.Interceptors(),
	}
}

// Get returns a Exam entity by its id.
func (c *ExamClient) Get(ctx context.Context, id int32) (*Exam, error) {
	return c.Query().Where(exam.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExamClient) GetX(ctx context.Context, id int32) *Exam {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNodalOfficers queries the nodal_officers edge of a Exam.
func (c *ExamClient) QueryNodalOfficers(e *Exam) *NodalOfficerQuery {
	query := (&NodalOfficerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exam.Table, exam.FieldID, id),
			sqlgraph.To(nodalofficer.Table, nodalofficer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exam.NodalOfficersTable, exam.NodalOfficersColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a Exam.
func (c *ExamClient) QueryNotifications(e *Exam) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exam.Table, exam.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exam.NotificationsTable, exam.NotificationsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExamsRef queries the exams_ref edge of a Exam.
func (c *ExamClient) QueryExamsRef(e *Exam) *ExamCalendarQuery {
	query := (&ExamCalendarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exam.Table, exam.FieldID, id),
			sqlgraph.To(examcalendar.Table, examcalendar.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exam.ExamsRefTable, exam.ExamsRefColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPapers queries the papers edge of a Exam.
func (c *ExamClient) QueryPapers(e *Exam) *ExamPapersQuery {
	query := (&ExamPapersClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exam.Table, exam.FieldID, id),
			sqlgraph.To(exampapers.Table, exampapers.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exam.PapersTable, exam.PapersColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExamClient) Hooks() []Hook {
	return c.hooks.Exam
}

// Interceptors returns the client interceptors.
func (c *ExamClient) Interceptors() []Interceptor {
	return c.inters.Exam
}

func (c *ExamClient) mutate(ctx context.Context, m *ExamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Exam mutation op: %q", m.Op())
	}
}

// ExamCalendarClient is a client for the ExamCalendar schema.
type ExamCalendarClient struct {
	config
}

// NewExamCalendarClient returns a client for the ExamCalendar from the given config.
func NewExamCalendarClient(c config) *ExamCalendarClient {
	return &ExamCalendarClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `examcalendar.Hooks(f(g(h())))`.
func (c *ExamCalendarClient) Use(hooks ...Hook) {
	c.hooks.ExamCalendar = append(c.hooks.ExamCalendar, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `examcalendar.Intercept(f(g(h())))`.
func (c *ExamCalendarClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExamCalendar = append(c.inters.ExamCalendar, interceptors...)
}

// Create returns a builder for creating a ExamCalendar entity.
func (c *ExamCalendarClient) Create() *ExamCalendarCreate {
	mutation := newExamCalendarMutation(c.config, OpCreate)
	return &ExamCalendarCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExamCalendar entities.
func (c *ExamCalendarClient) CreateBulk(builders ...*ExamCalendarCreate) *ExamCalendarCreateBulk {
	return &ExamCalendarCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExamCalendar.
func (c *ExamCalendarClient) Update() *ExamCalendarUpdate {
	mutation := newExamCalendarMutation(c.config, OpUpdate)
	return &ExamCalendarUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExamCalendarClient) UpdateOne(ec *ExamCalendar) *ExamCalendarUpdateOne {
	mutation := newExamCalendarMutation(c.config, OpUpdateOne, withExamCalendar(ec))
	return &ExamCalendarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExamCalendarClient) UpdateOneID(id int32) *ExamCalendarUpdateOne {
	mutation := newExamCalendarMutation(c.config, OpUpdateOne, withExamCalendarID(id))
	return &ExamCalendarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExamCalendar.
func (c *ExamCalendarClient) Delete() *ExamCalendarDelete {
	mutation := newExamCalendarMutation(c.config, OpDelete)
	return &ExamCalendarDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExamCalendarClient) DeleteOne(ec *ExamCalendar) *ExamCalendarDeleteOne {
	return c.DeleteOneID(ec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExamCalendarClient) DeleteOneID(id int32) *ExamCalendarDeleteOne {
	builder := c.Delete().Where(examcalendar.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExamCalendarDeleteOne{builder}
}

// Query returns a query builder for ExamCalendar.
func (c *ExamCalendarClient) Query() *ExamCalendarQuery {
	return &ExamCalendarQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExamCalendar},
		inters: c.Interceptors(),
	}
}

// Get returns a ExamCalendar entity by its id.
func (c *ExamCalendarClient) Get(ctx context.Context, id int32) (*ExamCalendar, error) {
	return c.Query().Where(examcalendar.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExamCalendarClient) GetX(ctx context.Context, id int32) *ExamCalendar {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVcyYears queries the vcy_years edge of a ExamCalendar.
func (c *ExamCalendarClient) QueryVcyYears(ec *ExamCalendar) *VacancyYearQuery {
	query := (&VacancyYearClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(examcalendar.Table, examcalendar.FieldID, id),
			sqlgraph.To(vacancyyear.Table, vacancyyear.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, examcalendar.VcyYearsTable, examcalendar.VcyYearsColumn),
		)
		fromV = sqlgraph.Neighbors(ec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExams queries the exams edge of a ExamCalendar.
func (c *ExamCalendarClient) QueryExams(ec *ExamCalendar) *ExamQuery {
	query := (&ExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(examcalendar.Table, examcalendar.FieldID, id),
			sqlgraph.To(exam.Table, exam.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, examcalendar.ExamsTable, examcalendar.ExamsColumn),
		)
		fromV = sqlgraph.Neighbors(ec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPapers queries the papers edge of a ExamCalendar.
func (c *ExamCalendarClient) QueryPapers(ec *ExamCalendar) *ExamPapersQuery {
	query := (&ExamPapersClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(examcalendar.Table, examcalendar.FieldID, id),
			sqlgraph.To(exampapers.Table, exampapers.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, examcalendar.PapersTable, examcalendar.PapersColumn),
		)
		fromV = sqlgraph.Neighbors(ec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifyRef queries the Notify_ref edge of a ExamCalendar.
func (c *ExamCalendarClient) QueryNotifyRef(ec *ExamCalendar) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(examcalendar.Table, examcalendar.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, examcalendar.NotifyRefTable, examcalendar.NotifyRefColumn),
		)
		fromV = sqlgraph.Neighbors(ec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExamCalendarClient) Hooks() []Hook {
	return c.hooks.ExamCalendar
}

// Interceptors returns the client interceptors.
func (c *ExamCalendarClient) Interceptors() []Interceptor {
	return c.inters.ExamCalendar
}

func (c *ExamCalendarClient) mutate(ctx context.Context, m *ExamCalendarMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExamCalendarCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExamCalendarUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExamCalendarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExamCalendarDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExamCalendar mutation op: %q", m.Op())
	}
}

// ExamEligibilityClient is a client for the ExamEligibility schema.
type ExamEligibilityClient struct {
	config
}

// NewExamEligibilityClient returns a client for the ExamEligibility from the given config.
func NewExamEligibilityClient(c config) *ExamEligibilityClient {
	return &ExamEligibilityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `exameligibility.Hooks(f(g(h())))`.
func (c *ExamEligibilityClient) Use(hooks ...Hook) {
	c.hooks.ExamEligibility = append(c.hooks.ExamEligibility, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `exameligibility.Intercept(f(g(h())))`.
func (c *ExamEligibilityClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExamEligibility = append(c.inters.ExamEligibility, interceptors...)
}

// Create returns a builder for creating a ExamEligibility entity.
func (c *ExamEligibilityClient) Create() *ExamEligibilityCreate {
	mutation := newExamEligibilityMutation(c.config, OpCreate)
	return &ExamEligibilityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExamEligibility entities.
func (c *ExamEligibilityClient) CreateBulk(builders ...*ExamEligibilityCreate) *ExamEligibilityCreateBulk {
	return &ExamEligibilityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExamEligibility.
func (c *ExamEligibilityClient) Update() *ExamEligibilityUpdate {
	mutation := newExamEligibilityMutation(c.config, OpUpdate)
	return &ExamEligibilityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExamEligibilityClient) UpdateOne(ee *ExamEligibility) *ExamEligibilityUpdateOne {
	mutation := newExamEligibilityMutation(c.config, OpUpdateOne, withExamEligibility(ee))
	return &ExamEligibilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExamEligibilityClient) UpdateOneID(id int32) *ExamEligibilityUpdateOne {
	mutation := newExamEligibilityMutation(c.config, OpUpdateOne, withExamEligibilityID(id))
	return &ExamEligibilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExamEligibility.
func (c *ExamEligibilityClient) Delete() *ExamEligibilityDelete {
	mutation := newExamEligibilityMutation(c.config, OpDelete)
	return &ExamEligibilityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExamEligibilityClient) DeleteOne(ee *ExamEligibility) *ExamEligibilityDeleteOne {
	return c.DeleteOneID(ee.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExamEligibilityClient) DeleteOneID(id int32) *ExamEligibilityDeleteOne {
	builder := c.Delete().Where(exameligibility.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExamEligibilityDeleteOne{builder}
}

// Query returns a query builder for ExamEligibility.
func (c *ExamEligibilityClient) Query() *ExamEligibilityQuery {
	return &ExamEligibilityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExamEligibility},
		inters: c.Interceptors(),
	}
}

// Get returns a ExamEligibility entity by its id.
func (c *ExamEligibilityClient) Get(ctx context.Context, id int32) (*ExamEligibility, error) {
	return c.Query().Where(exameligibility.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExamEligibilityClient) GetX(ctx context.Context, id int32) *ExamEligibility {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAgeEligibilities queries the age_eligibilities edge of a ExamEligibility.
func (c *ExamEligibilityClient) QueryAgeEligibilities(ee *ExamEligibility) *AgeEligibilityQuery {
	query := (&AgeEligibilityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ee.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exameligibility.Table, exameligibility.FieldID, id),
			sqlgraph.To(ageeligibility.Table, ageeligibility.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exameligibility.AgeEligibilitiesTable, exameligibility.AgeEligibilitiesColumn),
		)
		fromV = sqlgraph.Neighbors(ee.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExamEligibilityClient) Hooks() []Hook {
	return c.hooks.ExamEligibility
}

// Interceptors returns the client interceptors.
func (c *ExamEligibilityClient) Interceptors() []Interceptor {
	return c.inters.ExamEligibility
}

func (c *ExamEligibilityClient) mutate(ctx context.Context, m *ExamEligibilityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExamEligibilityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExamEligibilityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExamEligibilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExamEligibilityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExamEligibility mutation op: %q", m.Op())
	}
}

// ExamPapersClient is a client for the ExamPapers schema.
type ExamPapersClient struct {
	config
}

// NewExamPapersClient returns a client for the ExamPapers from the given config.
func NewExamPapersClient(c config) *ExamPapersClient {
	return &ExamPapersClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `exampapers.Hooks(f(g(h())))`.
func (c *ExamPapersClient) Use(hooks ...Hook) {
	c.hooks.ExamPapers = append(c.hooks.ExamPapers, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `exampapers.Intercept(f(g(h())))`.
func (c *ExamPapersClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExamPapers = append(c.inters.ExamPapers, interceptors...)
}

// Create returns a builder for creating a ExamPapers entity.
func (c *ExamPapersClient) Create() *ExamPapersCreate {
	mutation := newExamPapersMutation(c.config, OpCreate)
	return &ExamPapersCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExamPapers entities.
func (c *ExamPapersClient) CreateBulk(builders ...*ExamPapersCreate) *ExamPapersCreateBulk {
	return &ExamPapersCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExamPapers.
func (c *ExamPapersClient) Update() *ExamPapersUpdate {
	mutation := newExamPapersMutation(c.config, OpUpdate)
	return &ExamPapersUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExamPapersClient) UpdateOne(ep *ExamPapers) *ExamPapersUpdateOne {
	mutation := newExamPapersMutation(c.config, OpUpdateOne, withExamPapers(ep))
	return &ExamPapersUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExamPapersClient) UpdateOneID(id int32) *ExamPapersUpdateOne {
	mutation := newExamPapersMutation(c.config, OpUpdateOne, withExamPapersID(id))
	return &ExamPapersUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExamPapers.
func (c *ExamPapersClient) Delete() *ExamPapersDelete {
	mutation := newExamPapersMutation(c.config, OpDelete)
	return &ExamPapersDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExamPapersClient) DeleteOne(ep *ExamPapers) *ExamPapersDeleteOne {
	return c.DeleteOneID(ep.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExamPapersClient) DeleteOneID(id int32) *ExamPapersDeleteOne {
	builder := c.Delete().Where(exampapers.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExamPapersDeleteOne{builder}
}

// Query returns a query builder for ExamPapers.
func (c *ExamPapersClient) Query() *ExamPapersQuery {
	return &ExamPapersQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExamPapers},
		inters: c.Interceptors(),
	}
}

// Get returns a ExamPapers entity by its id.
func (c *ExamPapersClient) Get(ctx context.Context, id int32) (*ExamPapers, error) {
	return c.Query().Where(exampapers.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExamPapersClient) GetX(ctx context.Context, id int32) *ExamPapers {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCenters queries the centers edge of a ExamPapers.
func (c *ExamPapersClient) QueryCenters(ep *ExamPapers) *CenterQuery {
	query := (&CenterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ep.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exampapers.Table, exampapers.FieldID, id),
			sqlgraph.To(center.Table, center.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exampapers.CentersTable, exampapers.CentersColumn),
		)
		fromV = sqlgraph.Neighbors(ep.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExam queries the exam edge of a ExamPapers.
func (c *ExamPapersClient) QueryExam(ep *ExamPapers) *ExamQuery {
	query := (&ExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ep.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exampapers.Table, exampapers.FieldID, id),
			sqlgraph.To(exam.Table, exam.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, exampapers.ExamTable, exampapers.ExamColumn),
		)
		fromV = sqlgraph.Neighbors(ep.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExampapersTypes queries the exampapers_types edge of a ExamPapers.
func (c *ExamPapersClient) QueryExampapersTypes(ep *ExamPapers) *PaperTypesQuery {
	query := (&PaperTypesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ep.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exampapers.Table, exampapers.FieldID, id),
			sqlgraph.To(papertypes.Table, papertypes.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exampapers.ExampapersTypesTable, exampapers.ExampapersTypesColumn),
		)
		fromV = sqlgraph.Neighbors(ep.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPapersRef queries the papers_ref edge of a ExamPapers.
func (c *ExamPapersClient) QueryPapersRef(ep *ExamPapers) *ExamCalendarQuery {
	query := (&ExamCalendarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ep.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exampapers.Table, exampapers.FieldID, id),
			sqlgraph.To(examcalendar.Table, examcalendar.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exampapers.PapersRefTable, exampapers.PapersRefColumn),
		)
		fromV = sqlgraph.Neighbors(ep.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExamPapersClient) Hooks() []Hook {
	return c.hooks.ExamPapers
}

// Interceptors returns the client interceptors.
func (c *ExamPapersClient) Interceptors() []Interceptor {
	return c.inters.ExamPapers
}

func (c *ExamPapersClient) mutate(ctx context.Context, m *ExamPapersMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExamPapersCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExamPapersUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExamPapersUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExamPapersDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExamPapers mutation op: %q", m.Op())
	}
}

// FacilityClient is a client for the Facility schema.
type FacilityClient struct {
	config
}

// NewFacilityClient returns a client for the Facility from the given config.
func NewFacilityClient(c config) *FacilityClient {
	return &FacilityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `facility.Hooks(f(g(h())))`.
func (c *FacilityClient) Use(hooks ...Hook) {
	c.hooks.Facility = append(c.hooks.Facility, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `facility.Intercept(f(g(h())))`.
func (c *FacilityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Facility = append(c.inters.Facility, interceptors...)
}

// Create returns a builder for creating a Facility entity.
func (c *FacilityClient) Create() *FacilityCreate {
	mutation := newFacilityMutation(c.config, OpCreate)
	return &FacilityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Facility entities.
func (c *FacilityClient) CreateBulk(builders ...*FacilityCreate) *FacilityCreateBulk {
	return &FacilityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Facility.
func (c *FacilityClient) Update() *FacilityUpdate {
	mutation := newFacilityMutation(c.config, OpUpdate)
	return &FacilityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FacilityClient) UpdateOne(f *Facility) *FacilityUpdateOne {
	mutation := newFacilityMutation(c.config, OpUpdateOne, withFacility(f))
	return &FacilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FacilityClient) UpdateOneID(id int32) *FacilityUpdateOne {
	mutation := newFacilityMutation(c.config, OpUpdateOne, withFacilityID(id))
	return &FacilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Facility.
func (c *FacilityClient) Delete() *FacilityDelete {
	mutation := newFacilityMutation(c.config, OpDelete)
	return &FacilityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FacilityClient) DeleteOne(f *Facility) *FacilityDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FacilityClient) DeleteOneID(id int32) *FacilityDeleteOne {
	builder := c.Delete().Where(facility.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FacilityDeleteOne{builder}
}

// Query returns a query builder for Facility.
func (c *FacilityClient) Query() *FacilityQuery {
	return &FacilityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFacility},
		inters: c.Interceptors(),
	}
}

// Get returns a Facility entity by its id.
func (c *FacilityClient) Get(ctx context.Context, id int32) (*Facility, error) {
	return c.Query().Where(facility.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FacilityClient) GetX(ctx context.Context, id int32) *Facility {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRegionRef queries the region_ref edge of a Facility.
func (c *FacilityClient) QueryRegionRef(f *Facility) *RegionMasterQuery {
	query := (&RegionMasterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(facility.Table, facility.FieldID, id),
			sqlgraph.To(regionmaster.Table, regionmaster.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, facility.RegionRefTable, facility.RegionRefColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCircleRef queries the circle_ref edge of a Facility.
func (c *FacilityClient) QueryCircleRef(f *Facility) *CircleMasterQuery {
	query := (&CircleMasterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(facility.Table, facility.FieldID, id),
			sqlgraph.To(circlemaster.Table, circlemaster.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, facility.CircleRefTable, facility.CircleRefColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FacilityClient) Hooks() []Hook {
	return c.hooks.Facility
}

// Interceptors returns the client interceptors.
func (c *FacilityClient) Interceptors() []Interceptor {
	return c.inters.Facility
}

func (c *FacilityClient) mutate(ctx context.Context, m *FacilityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FacilityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FacilityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FacilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FacilityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Facility mutation op: %q", m.Op())
	}
}

// NodalOfficerClient is a client for the NodalOfficer schema.
type NodalOfficerClient struct {
	config
}

// NewNodalOfficerClient returns a client for the NodalOfficer from the given config.
func NewNodalOfficerClient(c config) *NodalOfficerClient {
	return &NodalOfficerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `nodalofficer.Hooks(f(g(h())))`.
func (c *NodalOfficerClient) Use(hooks ...Hook) {
	c.hooks.NodalOfficer = append(c.hooks.NodalOfficer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `nodalofficer.Intercept(f(g(h())))`.
func (c *NodalOfficerClient) Intercept(interceptors ...Interceptor) {
	c.inters.NodalOfficer = append(c.inters.NodalOfficer, interceptors...)
}

// Create returns a builder for creating a NodalOfficer entity.
func (c *NodalOfficerClient) Create() *NodalOfficerCreate {
	mutation := newNodalOfficerMutation(c.config, OpCreate)
	return &NodalOfficerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NodalOfficer entities.
func (c *NodalOfficerClient) CreateBulk(builders ...*NodalOfficerCreate) *NodalOfficerCreateBulk {
	return &NodalOfficerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NodalOfficer.
func (c *NodalOfficerClient) Update() *NodalOfficerUpdate {
	mutation := newNodalOfficerMutation(c.config, OpUpdate)
	return &NodalOfficerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NodalOfficerClient) UpdateOne(no *NodalOfficer) *NodalOfficerUpdateOne {
	mutation := newNodalOfficerMutation(c.config, OpUpdateOne, withNodalOfficer(no))
	return &NodalOfficerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NodalOfficerClient) UpdateOneID(id int32) *NodalOfficerUpdateOne {
	mutation := newNodalOfficerMutation(c.config, OpUpdateOne, withNodalOfficerID(id))
	return &NodalOfficerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NodalOfficer.
func (c *NodalOfficerClient) Delete() *NodalOfficerDelete {
	mutation := newNodalOfficerMutation(c.config, OpDelete)
	return &NodalOfficerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NodalOfficerClient) DeleteOne(no *NodalOfficer) *NodalOfficerDeleteOne {
	return c.DeleteOneID(no.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NodalOfficerClient) DeleteOneID(id int32) *NodalOfficerDeleteOne {
	builder := c.Delete().Where(nodalofficer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NodalOfficerDeleteOne{builder}
}

// Query returns a query builder for NodalOfficer.
func (c *NodalOfficerClient) Query() *NodalOfficerQuery {
	return &NodalOfficerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNodalOfficer},
		inters: c.Interceptors(),
	}
}

// Get returns a NodalOfficer entity by its id.
func (c *NodalOfficerClient) Get(ctx context.Context, id int32) (*NodalOfficer, error) {
	return c.Query().Where(nodalofficer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NodalOfficerClient) GetX(ctx context.Context, id int32) *NodalOfficer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCenters queries the centers edge of a NodalOfficer.
func (c *NodalOfficerClient) QueryCenters(no *NodalOfficer) *CenterQuery {
	query := (&CenterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := no.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nodalofficer.Table, nodalofficer.FieldID, id),
			sqlgraph.To(center.Table, center.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, nodalofficer.CentersTable, nodalofficer.CentersColumn),
		)
		fromV = sqlgraph.Neighbors(no.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExam queries the exam edge of a NodalOfficer.
func (c *NodalOfficerClient) QueryExam(no *NodalOfficer) *ExamQuery {
	query := (&ExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := no.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nodalofficer.Table, nodalofficer.FieldID, id),
			sqlgraph.To(exam.Table, exam.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, nodalofficer.ExamTable, nodalofficer.ExamColumn),
		)
		fromV = sqlgraph.Neighbors(no.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotification queries the notification edge of a NodalOfficer.
func (c *NodalOfficerClient) QueryNotification(no *NodalOfficer) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := no.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nodalofficer.Table, nodalofficer.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, nodalofficer.NotificationTable, nodalofficer.NotificationColumn),
		)
		fromV = sqlgraph.Neighbors(no.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NodalOfficerClient) Hooks() []Hook {
	return c.hooks.NodalOfficer
}

// Interceptors returns the client interceptors.
func (c *NodalOfficerClient) Interceptors() []Interceptor {
	return c.inters.NodalOfficer
}

func (c *NodalOfficerClient) mutate(ctx context.Context, m *NodalOfficerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NodalOfficerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NodalOfficerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NodalOfficerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NodalOfficerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NodalOfficer mutation op: %q", m.Op())
	}
}

// NotificationClient is a client for the Notification schema.
type NotificationClient struct {
	config
}

// NewNotificationClient returns a client for the Notification from the given config.
func NewNotificationClient(c config) *NotificationClient {
	return &NotificationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notification.Hooks(f(g(h())))`.
func (c *NotificationClient) Use(hooks ...Hook) {
	c.hooks.Notification = append(c.hooks.Notification, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notification.Intercept(f(g(h())))`.
func (c *NotificationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Notification = append(c.inters.Notification, interceptors...)
}

// Create returns a builder for creating a Notification entity.
func (c *NotificationClient) Create() *NotificationCreate {
	mutation := newNotificationMutation(c.config, OpCreate)
	return &NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Notification entities.
func (c *NotificationClient) CreateBulk(builders ...*NotificationCreate) *NotificationCreateBulk {
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Notification.
func (c *NotificationClient) Update() *NotificationUpdate {
	mutation := newNotificationMutation(c.config, OpUpdate)
	return &NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationClient) UpdateOne(n *Notification) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotification(n))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationClient) UpdateOneID(id int32) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotificationID(id))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Notification.
func (c *NotificationClient) Delete() *NotificationDelete {
	mutation := newNotificationMutation(c.config, OpDelete)
	return &NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationClient) DeleteOne(n *Notification) *NotificationDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationClient) DeleteOneID(id int32) *NotificationDeleteOne {
	builder := c.Delete().Where(notification.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationDeleteOne{builder}
}

// Query returns a query builder for Notification.
func (c *NotificationClient) Query() *NotificationQuery {
	return &NotificationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotification},
		inters: c.Interceptors(),
	}
}

// Get returns a Notification entity by its id.
func (c *NotificationClient) Get(ctx context.Context, id int32) (*Notification, error) {
	return c.Query().Where(notification.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationClient) GetX(ctx context.Context, id int32) *Notification {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApplications queries the applications edge of a Notification.
func (c *NotificationClient) QueryApplications(n *Notification) *ApplicationQuery {
	query := (&ApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(application.Table, application.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, notification.ApplicationsTable, notification.ApplicationsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCenters queries the centers edge of a Notification.
func (c *NotificationClient) QueryCenters(n *Notification) *CenterQuery {
	query := (&CenterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(center.Table, center.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, notification.CentersTable, notification.CentersColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodalOfficers queries the nodal_officers edge of a Notification.
func (c *NotificationClient) QueryNodalOfficers(n *Notification) *NodalOfficerQuery {
	query := (&NodalOfficerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(nodalofficer.Table, nodalofficer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, notification.NodalOfficersTable, notification.NodalOfficersColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExam queries the exam edge of a Notification.
func (c *NotificationClient) QueryExam(n *Notification) *ExamQuery {
	query := (&ExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(exam.Table, exam.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, notification.ExamTable, notification.ExamColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVacancyYears queries the vacancy_years edge of a Notification.
func (c *NotificationClient) QueryVacancyYears(n *Notification) *VacancyYearQuery {
	query := (&VacancyYearClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(vacancyyear.Table, vacancyyear.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, notification.VacancyYearsTable, notification.VacancyYearsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifyRef queries the notify_ref edge of a Notification.
func (c *NotificationClient) QueryNotifyRef(n *Notification) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, notification.NotifyRefTable, notification.NotifyRefPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NotificationClient) Hooks() []Hook {
	return c.hooks.Notification
}

// Interceptors returns the client interceptors.
func (c *NotificationClient) Interceptors() []Interceptor {
	return c.inters.Notification
}

func (c *NotificationClient) mutate(ctx context.Context, m *NotificationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Notification mutation op: %q", m.Op())
	}
}

// PaperTypesClient is a client for the PaperTypes schema.
type PaperTypesClient struct {
	config
}

// NewPaperTypesClient returns a client for the PaperTypes from the given config.
func NewPaperTypesClient(c config) *PaperTypesClient {
	return &PaperTypesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `papertypes.Hooks(f(g(h())))`.
func (c *PaperTypesClient) Use(hooks ...Hook) {
	c.hooks.PaperTypes = append(c.hooks.PaperTypes, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `papertypes.Intercept(f(g(h())))`.
func (c *PaperTypesClient) Intercept(interceptors ...Interceptor) {
	c.inters.PaperTypes = append(c.inters.PaperTypes, interceptors...)
}

// Create returns a builder for creating a PaperTypes entity.
func (c *PaperTypesClient) Create() *PaperTypesCreate {
	mutation := newPaperTypesMutation(c.config, OpCreate)
	return &PaperTypesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PaperTypes entities.
func (c *PaperTypesClient) CreateBulk(builders ...*PaperTypesCreate) *PaperTypesCreateBulk {
	return &PaperTypesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PaperTypes.
func (c *PaperTypesClient) Update() *PaperTypesUpdate {
	mutation := newPaperTypesMutation(c.config, OpUpdate)
	return &PaperTypesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PaperTypesClient) UpdateOne(pt *PaperTypes) *PaperTypesUpdateOne {
	mutation := newPaperTypesMutation(c.config, OpUpdateOne, withPaperTypes(pt))
	return &PaperTypesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PaperTypesClient) UpdateOneID(id int32) *PaperTypesUpdateOne {
	mutation := newPaperTypesMutation(c.config, OpUpdateOne, withPaperTypesID(id))
	return &PaperTypesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PaperTypes.
func (c *PaperTypesClient) Delete() *PaperTypesDelete {
	mutation := newPaperTypesMutation(c.config, OpDelete)
	return &PaperTypesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PaperTypesClient) DeleteOne(pt *PaperTypes) *PaperTypesDeleteOne {
	return c.DeleteOneID(pt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PaperTypesClient) DeleteOneID(id int32) *PaperTypesDeleteOne {
	builder := c.Delete().Where(papertypes.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PaperTypesDeleteOne{builder}
}

// Query returns a query builder for PaperTypes.
func (c *PaperTypesClient) Query() *PaperTypesQuery {
	return &PaperTypesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePaperTypes},
		inters: c.Interceptors(),
	}
}

// Get returns a PaperTypes entity by its id.
func (c *PaperTypesClient) Get(ctx context.Context, id int32) (*PaperTypes, error) {
	return c.Query().Where(papertypes.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PaperTypesClient) GetX(ctx context.Context, id int32) *PaperTypes {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPapercode queries the papercode edge of a PaperTypes.
func (c *PaperTypesClient) QueryPapercode(pt *PaperTypes) *ExamPapersQuery {
	query := (&ExamPapersClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(papertypes.Table, papertypes.FieldID, id),
			sqlgraph.To(exampapers.Table, exampapers.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, papertypes.PapercodeTable, papertypes.PapercodeColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PaperTypesClient) Hooks() []Hook {
	return c.hooks.PaperTypes
}

// Interceptors returns the client interceptors.
func (c *PaperTypesClient) Interceptors() []Interceptor {
	return c.inters.PaperTypes
}

func (c *PaperTypesClient) mutate(ctx context.Context, m *PaperTypesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PaperTypesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PaperTypesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PaperTypesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PaperTypesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PaperTypes mutation op: %q", m.Op())
	}
}

// RegionMasterClient is a client for the RegionMaster schema.
type RegionMasterClient struct {
	config
}

// NewRegionMasterClient returns a client for the RegionMaster from the given config.
func NewRegionMasterClient(c config) *RegionMasterClient {
	return &RegionMasterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `regionmaster.Hooks(f(g(h())))`.
func (c *RegionMasterClient) Use(hooks ...Hook) {
	c.hooks.RegionMaster = append(c.hooks.RegionMaster, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `regionmaster.Intercept(f(g(h())))`.
func (c *RegionMasterClient) Intercept(interceptors ...Interceptor) {
	c.inters.RegionMaster = append(c.inters.RegionMaster, interceptors...)
}

// Create returns a builder for creating a RegionMaster entity.
func (c *RegionMasterClient) Create() *RegionMasterCreate {
	mutation := newRegionMasterMutation(c.config, OpCreate)
	return &RegionMasterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RegionMaster entities.
func (c *RegionMasterClient) CreateBulk(builders ...*RegionMasterCreate) *RegionMasterCreateBulk {
	return &RegionMasterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RegionMaster.
func (c *RegionMasterClient) Update() *RegionMasterUpdate {
	mutation := newRegionMasterMutation(c.config, OpUpdate)
	return &RegionMasterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RegionMasterClient) UpdateOne(rm *RegionMaster) *RegionMasterUpdateOne {
	mutation := newRegionMasterMutation(c.config, OpUpdateOne, withRegionMaster(rm))
	return &RegionMasterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RegionMasterClient) UpdateOneID(id int32) *RegionMasterUpdateOne {
	mutation := newRegionMasterMutation(c.config, OpUpdateOne, withRegionMasterID(id))
	return &RegionMasterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RegionMaster.
func (c *RegionMasterClient) Delete() *RegionMasterDelete {
	mutation := newRegionMasterMutation(c.config, OpDelete)
	return &RegionMasterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RegionMasterClient) DeleteOne(rm *RegionMaster) *RegionMasterDeleteOne {
	return c.DeleteOneID(rm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RegionMasterClient) DeleteOneID(id int32) *RegionMasterDeleteOne {
	builder := c.Delete().Where(regionmaster.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RegionMasterDeleteOne{builder}
}

// Query returns a query builder for RegionMaster.
func (c *RegionMasterClient) Query() *RegionMasterQuery {
	return &RegionMasterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRegionMaster},
		inters: c.Interceptors(),
	}
}

// Get returns a RegionMaster entity by its id.
func (c *RegionMasterClient) Get(ctx context.Context, id int32) (*RegionMaster, error) {
	return c.Query().Where(regionmaster.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RegionMasterClient) GetX(ctx context.Context, id int32) *RegionMaster {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCircleRef queries the circle_ref edge of a RegionMaster.
func (c *RegionMasterClient) QueryCircleRef(rm *RegionMaster) *CircleMasterQuery {
	query := (&CircleMasterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(regionmaster.Table, regionmaster.FieldID, id),
			sqlgraph.To(circlemaster.Table, circlemaster.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, regionmaster.CircleRefTable, regionmaster.CircleRefColumn),
		)
		fromV = sqlgraph.Neighbors(rm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRegions queries the regions edge of a RegionMaster.
func (c *RegionMasterClient) QueryRegions(rm *RegionMaster) *DivisionMasterQuery {
	query := (&DivisionMasterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(regionmaster.Table, regionmaster.FieldID, id),
			sqlgraph.To(divisionmaster.Table, divisionmaster.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, regionmaster.RegionsTable, regionmaster.RegionsColumn),
		)
		fromV = sqlgraph.Neighbors(rm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRegionRefRef queries the region_ref_ref edge of a RegionMaster.
func (c *RegionMasterClient) QueryRegionRefRef(rm *RegionMaster) *FacilityQuery {
	query := (&FacilityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(regionmaster.Table, regionmaster.FieldID, id),
			sqlgraph.To(facility.Table, facility.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, regionmaster.RegionRefRefTable, regionmaster.RegionRefRefColumn),
		)
		fromV = sqlgraph.Neighbors(rm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RegionMasterClient) Hooks() []Hook {
	return c.hooks.RegionMaster
}

// Interceptors returns the client interceptors.
func (c *RegionMasterClient) Interceptors() []Interceptor {
	return c.inters.RegionMaster
}

func (c *RegionMasterClient) mutate(ctx context.Context, m *RegionMasterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RegionMasterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RegionMasterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RegionMasterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RegionMasterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RegionMaster mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// VacancyYearClient is a client for the VacancyYear schema.
type VacancyYearClient struct {
	config
}

// NewVacancyYearClient returns a client for the VacancyYear from the given config.
func NewVacancyYearClient(c config) *VacancyYearClient {
	return &VacancyYearClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vacancyyear.Hooks(f(g(h())))`.
func (c *VacancyYearClient) Use(hooks ...Hook) {
	c.hooks.VacancyYear = append(c.hooks.VacancyYear, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vacancyyear.Intercept(f(g(h())))`.
func (c *VacancyYearClient) Intercept(interceptors ...Interceptor) {
	c.inters.VacancyYear = append(c.inters.VacancyYear, interceptors...)
}

// Create returns a builder for creating a VacancyYear entity.
func (c *VacancyYearClient) Create() *VacancyYearCreate {
	mutation := newVacancyYearMutation(c.config, OpCreate)
	return &VacancyYearCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VacancyYear entities.
func (c *VacancyYearClient) CreateBulk(builders ...*VacancyYearCreate) *VacancyYearCreateBulk {
	return &VacancyYearCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VacancyYear.
func (c *VacancyYearClient) Update() *VacancyYearUpdate {
	mutation := newVacancyYearMutation(c.config, OpUpdate)
	return &VacancyYearUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VacancyYearClient) UpdateOne(vy *VacancyYear) *VacancyYearUpdateOne {
	mutation := newVacancyYearMutation(c.config, OpUpdateOne, withVacancyYear(vy))
	return &VacancyYearUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VacancyYearClient) UpdateOneID(id int32) *VacancyYearUpdateOne {
	mutation := newVacancyYearMutation(c.config, OpUpdateOne, withVacancyYearID(id))
	return &VacancyYearUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VacancyYear.
func (c *VacancyYearClient) Delete() *VacancyYearDelete {
	mutation := newVacancyYearMutation(c.config, OpDelete)
	return &VacancyYearDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VacancyYearClient) DeleteOne(vy *VacancyYear) *VacancyYearDeleteOne {
	return c.DeleteOneID(vy.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VacancyYearClient) DeleteOneID(id int32) *VacancyYearDeleteOne {
	builder := c.Delete().Where(vacancyyear.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VacancyYearDeleteOne{builder}
}

// Query returns a query builder for VacancyYear.
func (c *VacancyYearClient) Query() *VacancyYearQuery {
	return &VacancyYearQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVacancyYear},
		inters: c.Interceptors(),
	}
}

// Get returns a VacancyYear entity by its id.
func (c *VacancyYearClient) Get(ctx context.Context, id int32) (*VacancyYear, error) {
	return c.Query().Where(vacancyyear.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VacancyYearClient) GetX(ctx context.Context, id int32) *VacancyYear {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVacancyRef queries the vacancy_ref edge of a VacancyYear.
func (c *VacancyYearClient) QueryVacancyRef(vy *VacancyYear) *ExamCalendarQuery {
	query := (&ExamCalendarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vy.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vacancyyear.Table, vacancyyear.FieldID, id),
			sqlgraph.To(examcalendar.Table, examcalendar.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vacancyyear.VacancyRefTable, vacancyyear.VacancyRefColumn),
		)
		fromV = sqlgraph.Neighbors(vy.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExams queries the exams edge of a VacancyYear.
func (c *VacancyYearClient) QueryExams(vy *VacancyYear) *ExamQuery {
	query := (&ExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vy.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vacancyyear.Table, vacancyyear.FieldID, id),
			sqlgraph.To(exam.Table, exam.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vacancyyear.ExamsTable, vacancyyear.ExamsColumn),
		)
		fromV = sqlgraph.Neighbors(vy.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VacancyYearClient) Hooks() []Hook {
	return c.hooks.VacancyYear
}

// Interceptors returns the client interceptors.
func (c *VacancyYearClient) Interceptors() []Interceptor {
	return c.inters.VacancyYear
}

func (c *VacancyYearClient) mutate(ctx context.Context, m *VacancyYearMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VacancyYearCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VacancyYearUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VacancyYearUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VacancyYearDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VacancyYear mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AgeEligibility, Application, Center, CircleMaster, Disability, DivisionMaster,
		EmployeeCadre, EmployeeCategory, EmployeeDesignation, EmployeePosts, Employees,
		Exam, ExamCalendar, ExamEligibility, ExamPapers, Facility, NodalOfficer,
		Notification, PaperTypes, RegionMaster, User, VacancyYear []ent.Hook
	}
	inters struct {
		AgeEligibility, Application, Center, CircleMaster, Disability, DivisionMaster,
		EmployeeCadre, EmployeeCategory, EmployeeDesignation, EmployeePosts, Employees,
		Exam, ExamCalendar, ExamEligibility, ExamPapers, Facility, NodalOfficer,
		Notification, PaperTypes, RegionMaster, User, VacancyYear []ent.Interceptor
	}
)
