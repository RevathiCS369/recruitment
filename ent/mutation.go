// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"recruit/ent/ageeligibility"
	"recruit/ent/application"
	"recruit/ent/center"
	"recruit/ent/circlemaster"
	"recruit/ent/disability"
	"recruit/ent/divisionmaster"
	"recruit/ent/employeecadre"
	"recruit/ent/employeecategory"
	"recruit/ent/employeedesignation"
	"recruit/ent/employeeposts"
	"recruit/ent/employees"
	"recruit/ent/exam"
	"recruit/ent/examcalendar"
	"recruit/ent/exameligibility"
	"recruit/ent/exampapers"
	"recruit/ent/facility"
	"recruit/ent/nodalofficer"
	"recruit/ent/notification"
	"recruit/ent/papertypes"
	"recruit/ent/predicate"
	"recruit/ent/regionmaster"
	"recruit/ent/user"
	"recruit/ent/vacancyyear"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAgeEligibility      = "AgeEligibility"
	TypeApplication         = "Application"
	TypeCenter              = "Center"
	TypeCircleMaster        = "CircleMaster"
	TypeDisability          = "Disability"
	TypeDivisionMaster      = "DivisionMaster"
	TypeEmployeeCadre       = "EmployeeCadre"
	TypeEmployeeCategory    = "EmployeeCategory"
	TypeEmployeeDesignation = "EmployeeDesignation"
	TypeEmployeePosts       = "EmployeePosts"
	TypeEmployees           = "Employees"
	TypeExam                = "Exam"
	TypeExamCalendar        = "ExamCalendar"
	TypeExamEligibility     = "ExamEligibility"
	TypeExamPapers          = "ExamPapers"
	TypeFacility            = "Facility"
	TypeNodalOfficer        = "NodalOfficer"
	TypeNotification        = "Notification"
	TypePaperTypes          = "PaperTypes"
	TypeRegionMaster        = "RegionMaster"
	TypeUser                = "User"
	TypeVacancyYear         = "VacancyYear"
)

// AgeEligibilityMutation represents an operation that mutates the AgeEligibility nodes in the graph.
type AgeEligibilityMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int32
	_Age                    *int32
	add_Age                 *int32
	_CategoryID             *int32
	add_CategoryID          *int32
	clearedFields           map[string]struct{}
	exam_eligibility        *int32
	clearedexam_eligibility bool
	done                    bool
	oldValue                func(context.Context) (*AgeEligibility, error)
	predicates              []predicate.AgeEligibility
}

var _ ent.Mutation = (*AgeEligibilityMutation)(nil)

// ageeligibilityOption allows management of the mutation configuration using functional options.
type ageeligibilityOption func(*AgeEligibilityMutation)

// newAgeEligibilityMutation creates new mutation for the AgeEligibility entity.
func newAgeEligibilityMutation(c config, op Op, opts ...ageeligibilityOption) *AgeEligibilityMutation {
	m := &AgeEligibilityMutation{
		config:        c,
		op:            op,
		typ:           TypeAgeEligibility,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgeEligibilityID sets the ID field of the mutation.
func withAgeEligibilityID(id int32) ageeligibilityOption {
	return func(m *AgeEligibilityMutation) {
		var (
			err   error
			once  sync.Once
			value *AgeEligibility
		)
		m.oldValue = func(ctx context.Context) (*AgeEligibility, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgeEligibility.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgeEligibility sets the old AgeEligibility of the mutation.
func withAgeEligibility(node *AgeEligibility) ageeligibilityOption {
	return func(m *AgeEligibilityMutation) {
		m.oldValue = func(context.Context) (*AgeEligibility, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgeEligibilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgeEligibilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AgeEligibility entities.
func (m *AgeEligibilityMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgeEligibilityMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgeEligibilityMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AgeEligibility.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEligibilityCode sets the "EligibilityCode" field.
func (m *AgeEligibilityMutation) SetEligibilityCode(i int32) {
	m.exam_eligibility = &i
}

// EligibilityCode returns the value of the "EligibilityCode" field in the mutation.
func (m *AgeEligibilityMutation) EligibilityCode() (r int32, exists bool) {
	v := m.exam_eligibility
	if v == nil {
		return
	}
	return *v, true
}

// OldEligibilityCode returns the old "EligibilityCode" field's value of the AgeEligibility entity.
// If the AgeEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgeEligibilityMutation) OldEligibilityCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligibilityCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligibilityCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligibilityCode: %w", err)
	}
	return oldValue.EligibilityCode, nil
}

// ClearEligibilityCode clears the value of the "EligibilityCode" field.
func (m *AgeEligibilityMutation) ClearEligibilityCode() {
	m.exam_eligibility = nil
	m.clearedFields[ageeligibility.FieldEligibilityCode] = struct{}{}
}

// EligibilityCodeCleared returns if the "EligibilityCode" field was cleared in this mutation.
func (m *AgeEligibilityMutation) EligibilityCodeCleared() bool {
	_, ok := m.clearedFields[ageeligibility.FieldEligibilityCode]
	return ok
}

// ResetEligibilityCode resets all changes to the "EligibilityCode" field.
func (m *AgeEligibilityMutation) ResetEligibilityCode() {
	m.exam_eligibility = nil
	delete(m.clearedFields, ageeligibility.FieldEligibilityCode)
}

// SetAge sets the "Age" field.
func (m *AgeEligibilityMutation) SetAge(i int32) {
	m._Age = &i
	m.add_Age = nil
}

// Age returns the value of the "Age" field in the mutation.
func (m *AgeEligibilityMutation) Age() (r int32, exists bool) {
	v := m._Age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "Age" field's value of the AgeEligibility entity.
// If the AgeEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgeEligibilityMutation) OldAge(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "Age" field.
func (m *AgeEligibilityMutation) AddAge(i int32) {
	if m.add_Age != nil {
		*m.add_Age += i
	} else {
		m.add_Age = &i
	}
}

// AddedAge returns the value that was added to the "Age" field in this mutation.
func (m *AgeEligibilityMutation) AddedAge() (r int32, exists bool) {
	v := m.add_Age
	if v == nil {
		return
	}
	return *v, true
}

// ClearAge clears the value of the "Age" field.
func (m *AgeEligibilityMutation) ClearAge() {
	m._Age = nil
	m.add_Age = nil
	m.clearedFields[ageeligibility.FieldAge] = struct{}{}
}

// AgeCleared returns if the "Age" field was cleared in this mutation.
func (m *AgeEligibilityMutation) AgeCleared() bool {
	_, ok := m.clearedFields[ageeligibility.FieldAge]
	return ok
}

// ResetAge resets all changes to the "Age" field.
func (m *AgeEligibilityMutation) ResetAge() {
	m._Age = nil
	m.add_Age = nil
	delete(m.clearedFields, ageeligibility.FieldAge)
}

// SetCategoryID sets the "CategoryID" field.
func (m *AgeEligibilityMutation) SetCategoryID(i int32) {
	m._CategoryID = &i
	m.add_CategoryID = nil
}

// CategoryID returns the value of the "CategoryID" field in the mutation.
func (m *AgeEligibilityMutation) CategoryID() (r int32, exists bool) {
	v := m._CategoryID
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "CategoryID" field's value of the AgeEligibility entity.
// If the AgeEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgeEligibilityMutation) OldCategoryID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "CategoryID" field.
func (m *AgeEligibilityMutation) AddCategoryID(i int32) {
	if m.add_CategoryID != nil {
		*m.add_CategoryID += i
	} else {
		m.add_CategoryID = &i
	}
}

// AddedCategoryID returns the value that was added to the "CategoryID" field in this mutation.
func (m *AgeEligibilityMutation) AddedCategoryID() (r int32, exists bool) {
	v := m.add_CategoryID
	if v == nil {
		return
	}
	return *v, true
}

// ClearCategoryID clears the value of the "CategoryID" field.
func (m *AgeEligibilityMutation) ClearCategoryID() {
	m._CategoryID = nil
	m.add_CategoryID = nil
	m.clearedFields[ageeligibility.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "CategoryID" field was cleared in this mutation.
func (m *AgeEligibilityMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[ageeligibility.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "CategoryID" field.
func (m *AgeEligibilityMutation) ResetCategoryID() {
	m._CategoryID = nil
	m.add_CategoryID = nil
	delete(m.clearedFields, ageeligibility.FieldCategoryID)
}

// SetExamEligibilityID sets the "exam_eligibility" edge to the ExamEligibility entity by id.
func (m *AgeEligibilityMutation) SetExamEligibilityID(id int32) {
	m.exam_eligibility = &id
}

// ClearExamEligibility clears the "exam_eligibility" edge to the ExamEligibility entity.
func (m *AgeEligibilityMutation) ClearExamEligibility() {
	m.clearedexam_eligibility = true
}

// ExamEligibilityCleared reports if the "exam_eligibility" edge to the ExamEligibility entity was cleared.
func (m *AgeEligibilityMutation) ExamEligibilityCleared() bool {
	return m.EligibilityCodeCleared() || m.clearedexam_eligibility
}

// ExamEligibilityID returns the "exam_eligibility" edge ID in the mutation.
func (m *AgeEligibilityMutation) ExamEligibilityID() (id int32, exists bool) {
	if m.exam_eligibility != nil {
		return *m.exam_eligibility, true
	}
	return
}

// ExamEligibilityIDs returns the "exam_eligibility" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamEligibilityID instead. It exists only for internal usage by the builders.
func (m *AgeEligibilityMutation) ExamEligibilityIDs() (ids []int32) {
	if id := m.exam_eligibility; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExamEligibility resets all changes to the "exam_eligibility" edge.
func (m *AgeEligibilityMutation) ResetExamEligibility() {
	m.exam_eligibility = nil
	m.clearedexam_eligibility = false
}

// Where appends a list predicates to the AgeEligibilityMutation builder.
func (m *AgeEligibilityMutation) Where(ps ...predicate.AgeEligibility) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgeEligibilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgeEligibilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AgeEligibility, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgeEligibilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgeEligibilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AgeEligibility).
func (m *AgeEligibilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgeEligibilityMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.exam_eligibility != nil {
		fields = append(fields, ageeligibility.FieldEligibilityCode)
	}
	if m._Age != nil {
		fields = append(fields, ageeligibility.FieldAge)
	}
	if m._CategoryID != nil {
		fields = append(fields, ageeligibility.FieldCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgeEligibilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ageeligibility.FieldEligibilityCode:
		return m.EligibilityCode()
	case ageeligibility.FieldAge:
		return m.Age()
	case ageeligibility.FieldCategoryID:
		return m.CategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgeEligibilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ageeligibility.FieldEligibilityCode:
		return m.OldEligibilityCode(ctx)
	case ageeligibility.FieldAge:
		return m.OldAge(ctx)
	case ageeligibility.FieldCategoryID:
		return m.OldCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown AgeEligibility field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgeEligibilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ageeligibility.FieldEligibilityCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligibilityCode(v)
		return nil
	case ageeligibility.FieldAge:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case ageeligibility.FieldCategoryID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown AgeEligibility field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgeEligibilityMutation) AddedFields() []string {
	var fields []string
	if m.add_Age != nil {
		fields = append(fields, ageeligibility.FieldAge)
	}
	if m.add_CategoryID != nil {
		fields = append(fields, ageeligibility.FieldCategoryID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgeEligibilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ageeligibility.FieldAge:
		return m.AddedAge()
	case ageeligibility.FieldCategoryID:
		return m.AddedCategoryID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgeEligibilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ageeligibility.FieldAge:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case ageeligibility.FieldCategoryID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown AgeEligibility numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgeEligibilityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ageeligibility.FieldEligibilityCode) {
		fields = append(fields, ageeligibility.FieldEligibilityCode)
	}
	if m.FieldCleared(ageeligibility.FieldAge) {
		fields = append(fields, ageeligibility.FieldAge)
	}
	if m.FieldCleared(ageeligibility.FieldCategoryID) {
		fields = append(fields, ageeligibility.FieldCategoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgeEligibilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgeEligibilityMutation) ClearField(name string) error {
	switch name {
	case ageeligibility.FieldEligibilityCode:
		m.ClearEligibilityCode()
		return nil
	case ageeligibility.FieldAge:
		m.ClearAge()
		return nil
	case ageeligibility.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	}
	return fmt.Errorf("unknown AgeEligibility nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgeEligibilityMutation) ResetField(name string) error {
	switch name {
	case ageeligibility.FieldEligibilityCode:
		m.ResetEligibilityCode()
		return nil
	case ageeligibility.FieldAge:
		m.ResetAge()
		return nil
	case ageeligibility.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	}
	return fmt.Errorf("unknown AgeEligibility field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgeEligibilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.exam_eligibility != nil {
		edges = append(edges, ageeligibility.EdgeExamEligibility)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgeEligibilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ageeligibility.EdgeExamEligibility:
		if id := m.exam_eligibility; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgeEligibilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgeEligibilityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgeEligibilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedexam_eligibility {
		edges = append(edges, ageeligibility.EdgeExamEligibility)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgeEligibilityMutation) EdgeCleared(name string) bool {
	switch name {
	case ageeligibility.EdgeExamEligibility:
		return m.clearedexam_eligibility
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgeEligibilityMutation) ClearEdge(name string) error {
	switch name {
	case ageeligibility.EdgeExamEligibility:
		m.ClearExamEligibility()
		return nil
	}
	return fmt.Errorf("unknown AgeEligibility unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgeEligibilityMutation) ResetEdge(name string) error {
	switch name {
	case ageeligibility.EdgeExamEligibility:
		m.ResetExamEligibility()
		return nil
	}
	return fmt.Errorf("unknown AgeEligibility edge %s", name)
}

// ApplicationMutation represents an operation that mutates the Application nodes in the graph.
type ApplicationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int32
	_EmployeeID         *int32
	add_EmployeeID      *int32
	_HallTicketNumber   *string
	_AppliedStamp       *time.Time
	clearedFields       map[string]struct{}
	center              *int32
	clearedcenter       bool
	notification        *int32
	clearednotification bool
	done                bool
	oldValue            func(context.Context) (*Application, error)
	predicates          []predicate.Application
}

var _ ent.Mutation = (*ApplicationMutation)(nil)

// applicationOption allows management of the mutation configuration using functional options.
type applicationOption func(*ApplicationMutation)

// newApplicationMutation creates new mutation for the Application entity.
func newApplicationMutation(c config, op Op, opts ...applicationOption) *ApplicationMutation {
	m := &ApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationID sets the ID field of the mutation.
func withApplicationID(id int32) applicationOption {
	return func(m *ApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Application
		)
		m.oldValue = func(ctx context.Context) (*Application, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Application.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplication sets the old Application of the mutation.
func withApplication(node *Application) applicationOption {
	return func(m *ApplicationMutation) {
		m.oldValue = func(context.Context) (*Application, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Application entities.
func (m *ApplicationMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicationMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicationMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Application.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *ApplicationMutation) SetEmployeeID(i int32) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *ApplicationMutation) EmployeeID() (r int32, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldEmployeeID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *ApplicationMutation) AddEmployeeID(i int32) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *ApplicationMutation) AddedEmployeeID() (r int32, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *ApplicationMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
}

// SetNotifyCode sets the "NotifyCode" field.
func (m *ApplicationMutation) SetNotifyCode(i int32) {
	m.notification = &i
}

// NotifyCode returns the value of the "NotifyCode" field in the mutation.
func (m *ApplicationMutation) NotifyCode() (r int32, exists bool) {
	v := m.notification
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyCode returns the old "NotifyCode" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldNotifyCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyCode: %w", err)
	}
	return oldValue.NotifyCode, nil
}

// ClearNotifyCode clears the value of the "NotifyCode" field.
func (m *ApplicationMutation) ClearNotifyCode() {
	m.notification = nil
	m.clearedFields[application.FieldNotifyCode] = struct{}{}
}

// NotifyCodeCleared returns if the "NotifyCode" field was cleared in this mutation.
func (m *ApplicationMutation) NotifyCodeCleared() bool {
	_, ok := m.clearedFields[application.FieldNotifyCode]
	return ok
}

// ResetNotifyCode resets all changes to the "NotifyCode" field.
func (m *ApplicationMutation) ResetNotifyCode() {
	m.notification = nil
	delete(m.clearedFields, application.FieldNotifyCode)
}

// SetHallTicketNumber sets the "HallTicketNumber" field.
func (m *ApplicationMutation) SetHallTicketNumber(s string) {
	m._HallTicketNumber = &s
}

// HallTicketNumber returns the value of the "HallTicketNumber" field in the mutation.
func (m *ApplicationMutation) HallTicketNumber() (r string, exists bool) {
	v := m._HallTicketNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldHallTicketNumber returns the old "HallTicketNumber" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldHallTicketNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHallTicketNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHallTicketNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHallTicketNumber: %w", err)
	}
	return oldValue.HallTicketNumber, nil
}

// ClearHallTicketNumber clears the value of the "HallTicketNumber" field.
func (m *ApplicationMutation) ClearHallTicketNumber() {
	m._HallTicketNumber = nil
	m.clearedFields[application.FieldHallTicketNumber] = struct{}{}
}

// HallTicketNumberCleared returns if the "HallTicketNumber" field was cleared in this mutation.
func (m *ApplicationMutation) HallTicketNumberCleared() bool {
	_, ok := m.clearedFields[application.FieldHallTicketNumber]
	return ok
}

// ResetHallTicketNumber resets all changes to the "HallTicketNumber" field.
func (m *ApplicationMutation) ResetHallTicketNumber() {
	m._HallTicketNumber = nil
	delete(m.clearedFields, application.FieldHallTicketNumber)
}

// SetCenterCode sets the "CenterCode" field.
func (m *ApplicationMutation) SetCenterCode(i int32) {
	m.center = &i
}

// CenterCode returns the value of the "CenterCode" field in the mutation.
func (m *ApplicationMutation) CenterCode() (r int32, exists bool) {
	v := m.center
	if v == nil {
		return
	}
	return *v, true
}

// OldCenterCode returns the old "CenterCode" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldCenterCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCenterCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCenterCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCenterCode: %w", err)
	}
	return oldValue.CenterCode, nil
}

// ClearCenterCode clears the value of the "CenterCode" field.
func (m *ApplicationMutation) ClearCenterCode() {
	m.center = nil
	m.clearedFields[application.FieldCenterCode] = struct{}{}
}

// CenterCodeCleared returns if the "CenterCode" field was cleared in this mutation.
func (m *ApplicationMutation) CenterCodeCleared() bool {
	_, ok := m.clearedFields[application.FieldCenterCode]
	return ok
}

// ResetCenterCode resets all changes to the "CenterCode" field.
func (m *ApplicationMutation) ResetCenterCode() {
	m.center = nil
	delete(m.clearedFields, application.FieldCenterCode)
}

// SetAppliedStamp sets the "AppliedStamp" field.
func (m *ApplicationMutation) SetAppliedStamp(t time.Time) {
	m._AppliedStamp = &t
}

// AppliedStamp returns the value of the "AppliedStamp" field in the mutation.
func (m *ApplicationMutation) AppliedStamp() (r time.Time, exists bool) {
	v := m._AppliedStamp
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliedStamp returns the old "AppliedStamp" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldAppliedStamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliedStamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliedStamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliedStamp: %w", err)
	}
	return oldValue.AppliedStamp, nil
}

// ResetAppliedStamp resets all changes to the "AppliedStamp" field.
func (m *ApplicationMutation) ResetAppliedStamp() {
	m._AppliedStamp = nil
}

// SetCenterID sets the "center" edge to the Center entity by id.
func (m *ApplicationMutation) SetCenterID(id int32) {
	m.center = &id
}

// ClearCenter clears the "center" edge to the Center entity.
func (m *ApplicationMutation) ClearCenter() {
	m.clearedcenter = true
}

// CenterCleared reports if the "center" edge to the Center entity was cleared.
func (m *ApplicationMutation) CenterCleared() bool {
	return m.CenterCodeCleared() || m.clearedcenter
}

// CenterID returns the "center" edge ID in the mutation.
func (m *ApplicationMutation) CenterID() (id int32, exists bool) {
	if m.center != nil {
		return *m.center, true
	}
	return
}

// CenterIDs returns the "center" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CenterID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) CenterIDs() (ids []int32) {
	if id := m.center; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCenter resets all changes to the "center" edge.
func (m *ApplicationMutation) ResetCenter() {
	m.center = nil
	m.clearedcenter = false
}

// SetNotificationID sets the "notification" edge to the Notification entity by id.
func (m *ApplicationMutation) SetNotificationID(id int32) {
	m.notification = &id
}

// ClearNotification clears the "notification" edge to the Notification entity.
func (m *ApplicationMutation) ClearNotification() {
	m.clearednotification = true
}

// NotificationCleared reports if the "notification" edge to the Notification entity was cleared.
func (m *ApplicationMutation) NotificationCleared() bool {
	return m.NotifyCodeCleared() || m.clearednotification
}

// NotificationID returns the "notification" edge ID in the mutation.
func (m *ApplicationMutation) NotificationID() (id int32, exists bool) {
	if m.notification != nil {
		return *m.notification, true
	}
	return
}

// NotificationIDs returns the "notification" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotificationID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) NotificationIDs() (ids []int32) {
	if id := m.notification; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotification resets all changes to the "notification" edge.
func (m *ApplicationMutation) ResetNotification() {
	m.notification = nil
	m.clearednotification = false
}

// Where appends a list predicates to the ApplicationMutation builder.
func (m *ApplicationMutation) Where(ps ...predicate.Application) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Application, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Application).
func (m *ApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._EmployeeID != nil {
		fields = append(fields, application.FieldEmployeeID)
	}
	if m.notification != nil {
		fields = append(fields, application.FieldNotifyCode)
	}
	if m._HallTicketNumber != nil {
		fields = append(fields, application.FieldHallTicketNumber)
	}
	if m.center != nil {
		fields = append(fields, application.FieldCenterCode)
	}
	if m._AppliedStamp != nil {
		fields = append(fields, application.FieldAppliedStamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case application.FieldEmployeeID:
		return m.EmployeeID()
	case application.FieldNotifyCode:
		return m.NotifyCode()
	case application.FieldHallTicketNumber:
		return m.HallTicketNumber()
	case application.FieldCenterCode:
		return m.CenterCode()
	case application.FieldAppliedStamp:
		return m.AppliedStamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case application.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case application.FieldNotifyCode:
		return m.OldNotifyCode(ctx)
	case application.FieldHallTicketNumber:
		return m.OldHallTicketNumber(ctx)
	case application.FieldCenterCode:
		return m.OldCenterCode(ctx)
	case application.FieldAppliedStamp:
		return m.OldAppliedStamp(ctx)
	}
	return nil, fmt.Errorf("unknown Application field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case application.FieldEmployeeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case application.FieldNotifyCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyCode(v)
		return nil
	case application.FieldHallTicketNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHallTicketNumber(v)
		return nil
	case application.FieldCenterCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCenterCode(v)
		return nil
	case application.FieldAppliedStamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliedStamp(v)
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicationMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeeID != nil {
		fields = append(fields, application.FieldEmployeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case application.FieldEmployeeID:
		return m.AddedEmployeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case application.FieldEmployeeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown Application numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(application.FieldNotifyCode) {
		fields = append(fields, application.FieldNotifyCode)
	}
	if m.FieldCleared(application.FieldHallTicketNumber) {
		fields = append(fields, application.FieldHallTicketNumber)
	}
	if m.FieldCleared(application.FieldCenterCode) {
		fields = append(fields, application.FieldCenterCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationMutation) ClearField(name string) error {
	switch name {
	case application.FieldNotifyCode:
		m.ClearNotifyCode()
		return nil
	case application.FieldHallTicketNumber:
		m.ClearHallTicketNumber()
		return nil
	case application.FieldCenterCode:
		m.ClearCenterCode()
		return nil
	}
	return fmt.Errorf("unknown Application nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicationMutation) ResetField(name string) error {
	switch name {
	case application.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case application.FieldNotifyCode:
		m.ResetNotifyCode()
		return nil
	case application.FieldHallTicketNumber:
		m.ResetHallTicketNumber()
		return nil
	case application.FieldCenterCode:
		m.ResetCenterCode()
		return nil
	case application.FieldAppliedStamp:
		m.ResetAppliedStamp()
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.center != nil {
		edges = append(edges, application.EdgeCenter)
	}
	if m.notification != nil {
		edges = append(edges, application.EdgeNotification)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeCenter:
		if id := m.center; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeNotification:
		if id := m.notification; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcenter {
		edges = append(edges, application.EdgeCenter)
	}
	if m.clearednotification {
		edges = append(edges, application.EdgeNotification)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case application.EdgeCenter:
		return m.clearedcenter
	case application.EdgeNotification:
		return m.clearednotification
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicationMutation) ClearEdge(name string) error {
	switch name {
	case application.EdgeCenter:
		m.ClearCenter()
		return nil
	case application.EdgeNotification:
		m.ClearNotification()
		return nil
	}
	return fmt.Errorf("unknown Application unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicationMutation) ResetEdge(name string) error {
	switch name {
	case application.EdgeCenter:
		m.ResetCenter()
		return nil
	case application.EdgeNotification:
		m.ResetNotification()
		return nil
	}
	return fmt.Errorf("unknown Application edge %s", name)
}

// CenterMutation represents an operation that mutates the Center nodes in the graph.
type CenterMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int32
	_CenterName          *string
	clearedFields        map[string]struct{}
	applications         map[int32]struct{}
	removedapplications  map[int32]struct{}
	clearedapplications  bool
	nodal_officer        *int32
	clearednodal_officer bool
	notification         *int32
	clearednotification  bool
	done                 bool
	oldValue             func(context.Context) (*Center, error)
	predicates           []predicate.Center
}

var _ ent.Mutation = (*CenterMutation)(nil)

// centerOption allows management of the mutation configuration using functional options.
type centerOption func(*CenterMutation)

// newCenterMutation creates new mutation for the Center entity.
func newCenterMutation(c config, op Op, opts ...centerOption) *CenterMutation {
	m := &CenterMutation{
		config:        c,
		op:            op,
		typ:           TypeCenter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCenterID sets the ID field of the mutation.
func withCenterID(id int32) centerOption {
	return func(m *CenterMutation) {
		var (
			err   error
			once  sync.Once
			value *Center
		)
		m.oldValue = func(ctx context.Context) (*Center, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Center.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCenter sets the old Center of the mutation.
func withCenter(node *Center) centerOption {
	return func(m *CenterMutation) {
		m.oldValue = func(context.Context) (*Center, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CenterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CenterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Center entities.
func (m *CenterMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CenterMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CenterMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Center.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNotifyCode sets the "NotifyCode" field.
func (m *CenterMutation) SetNotifyCode(i int32) {
	m.notification = &i
}

// NotifyCode returns the value of the "NotifyCode" field in the mutation.
func (m *CenterMutation) NotifyCode() (r int32, exists bool) {
	v := m.notification
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyCode returns the old "NotifyCode" field's value of the Center entity.
// If the Center object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CenterMutation) OldNotifyCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyCode: %w", err)
	}
	return oldValue.NotifyCode, nil
}

// ClearNotifyCode clears the value of the "NotifyCode" field.
func (m *CenterMutation) ClearNotifyCode() {
	m.notification = nil
	m.clearedFields[center.FieldNotifyCode] = struct{}{}
}

// NotifyCodeCleared returns if the "NotifyCode" field was cleared in this mutation.
func (m *CenterMutation) NotifyCodeCleared() bool {
	_, ok := m.clearedFields[center.FieldNotifyCode]
	return ok
}

// ResetNotifyCode resets all changes to the "NotifyCode" field.
func (m *CenterMutation) ResetNotifyCode() {
	m.notification = nil
	delete(m.clearedFields, center.FieldNotifyCode)
}

// SetNodalOfficerCode sets the "NodalOfficerCode" field.
func (m *CenterMutation) SetNodalOfficerCode(i int32) {
	m.nodal_officer = &i
}

// NodalOfficerCode returns the value of the "NodalOfficerCode" field in the mutation.
func (m *CenterMutation) NodalOfficerCode() (r int32, exists bool) {
	v := m.nodal_officer
	if v == nil {
		return
	}
	return *v, true
}

// OldNodalOfficerCode returns the old "NodalOfficerCode" field's value of the Center entity.
// If the Center object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CenterMutation) OldNodalOfficerCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodalOfficerCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodalOfficerCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodalOfficerCode: %w", err)
	}
	return oldValue.NodalOfficerCode, nil
}

// ClearNodalOfficerCode clears the value of the "NodalOfficerCode" field.
func (m *CenterMutation) ClearNodalOfficerCode() {
	m.nodal_officer = nil
	m.clearedFields[center.FieldNodalOfficerCode] = struct{}{}
}

// NodalOfficerCodeCleared returns if the "NodalOfficerCode" field was cleared in this mutation.
func (m *CenterMutation) NodalOfficerCodeCleared() bool {
	_, ok := m.clearedFields[center.FieldNodalOfficerCode]
	return ok
}

// ResetNodalOfficerCode resets all changes to the "NodalOfficerCode" field.
func (m *CenterMutation) ResetNodalOfficerCode() {
	m.nodal_officer = nil
	delete(m.clearedFields, center.FieldNodalOfficerCode)
}

// SetCenterName sets the "CenterName" field.
func (m *CenterMutation) SetCenterName(s string) {
	m._CenterName = &s
}

// CenterName returns the value of the "CenterName" field in the mutation.
func (m *CenterMutation) CenterName() (r string, exists bool) {
	v := m._CenterName
	if v == nil {
		return
	}
	return *v, true
}

// OldCenterName returns the old "CenterName" field's value of the Center entity.
// If the Center object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CenterMutation) OldCenterName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCenterName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCenterName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCenterName: %w", err)
	}
	return oldValue.CenterName, nil
}

// ResetCenterName resets all changes to the "CenterName" field.
func (m *CenterMutation) ResetCenterName() {
	m._CenterName = nil
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *CenterMutation) AddApplicationIDs(ids ...int32) {
	if m.applications == nil {
		m.applications = make(map[int32]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *CenterMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *CenterMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *CenterMutation) RemoveApplicationIDs(ids ...int32) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *CenterMutation) RemovedApplicationsIDs() (ids []int32) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *CenterMutation) ApplicationsIDs() (ids []int32) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *CenterMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// SetNodalOfficerID sets the "nodal_officer" edge to the NodalOfficer entity by id.
func (m *CenterMutation) SetNodalOfficerID(id int32) {
	m.nodal_officer = &id
}

// ClearNodalOfficer clears the "nodal_officer" edge to the NodalOfficer entity.
func (m *CenterMutation) ClearNodalOfficer() {
	m.clearednodal_officer = true
}

// NodalOfficerCleared reports if the "nodal_officer" edge to the NodalOfficer entity was cleared.
func (m *CenterMutation) NodalOfficerCleared() bool {
	return m.NodalOfficerCodeCleared() || m.clearednodal_officer
}

// NodalOfficerID returns the "nodal_officer" edge ID in the mutation.
func (m *CenterMutation) NodalOfficerID() (id int32, exists bool) {
	if m.nodal_officer != nil {
		return *m.nodal_officer, true
	}
	return
}

// NodalOfficerIDs returns the "nodal_officer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodalOfficerID instead. It exists only for internal usage by the builders.
func (m *CenterMutation) NodalOfficerIDs() (ids []int32) {
	if id := m.nodal_officer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNodalOfficer resets all changes to the "nodal_officer" edge.
func (m *CenterMutation) ResetNodalOfficer() {
	m.nodal_officer = nil
	m.clearednodal_officer = false
}

// SetNotificationID sets the "notification" edge to the Notification entity by id.
func (m *CenterMutation) SetNotificationID(id int32) {
	m.notification = &id
}

// ClearNotification clears the "notification" edge to the Notification entity.
func (m *CenterMutation) ClearNotification() {
	m.clearednotification = true
}

// NotificationCleared reports if the "notification" edge to the Notification entity was cleared.
func (m *CenterMutation) NotificationCleared() bool {
	return m.NotifyCodeCleared() || m.clearednotification
}

// NotificationID returns the "notification" edge ID in the mutation.
func (m *CenterMutation) NotificationID() (id int32, exists bool) {
	if m.notification != nil {
		return *m.notification, true
	}
	return
}

// NotificationIDs returns the "notification" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotificationID instead. It exists only for internal usage by the builders.
func (m *CenterMutation) NotificationIDs() (ids []int32) {
	if id := m.notification; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotification resets all changes to the "notification" edge.
func (m *CenterMutation) ResetNotification() {
	m.notification = nil
	m.clearednotification = false
}

// Where appends a list predicates to the CenterMutation builder.
func (m *CenterMutation) Where(ps ...predicate.Center) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CenterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CenterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Center, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CenterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CenterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Center).
func (m *CenterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CenterMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.notification != nil {
		fields = append(fields, center.FieldNotifyCode)
	}
	if m.nodal_officer != nil {
		fields = append(fields, center.FieldNodalOfficerCode)
	}
	if m._CenterName != nil {
		fields = append(fields, center.FieldCenterName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CenterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case center.FieldNotifyCode:
		return m.NotifyCode()
	case center.FieldNodalOfficerCode:
		return m.NodalOfficerCode()
	case center.FieldCenterName:
		return m.CenterName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CenterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case center.FieldNotifyCode:
		return m.OldNotifyCode(ctx)
	case center.FieldNodalOfficerCode:
		return m.OldNodalOfficerCode(ctx)
	case center.FieldCenterName:
		return m.OldCenterName(ctx)
	}
	return nil, fmt.Errorf("unknown Center field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CenterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case center.FieldNotifyCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyCode(v)
		return nil
	case center.FieldNodalOfficerCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodalOfficerCode(v)
		return nil
	case center.FieldCenterName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCenterName(v)
		return nil
	}
	return fmt.Errorf("unknown Center field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CenterMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CenterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CenterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Center numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CenterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(center.FieldNotifyCode) {
		fields = append(fields, center.FieldNotifyCode)
	}
	if m.FieldCleared(center.FieldNodalOfficerCode) {
		fields = append(fields, center.FieldNodalOfficerCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CenterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CenterMutation) ClearField(name string) error {
	switch name {
	case center.FieldNotifyCode:
		m.ClearNotifyCode()
		return nil
	case center.FieldNodalOfficerCode:
		m.ClearNodalOfficerCode()
		return nil
	}
	return fmt.Errorf("unknown Center nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CenterMutation) ResetField(name string) error {
	switch name {
	case center.FieldNotifyCode:
		m.ResetNotifyCode()
		return nil
	case center.FieldNodalOfficerCode:
		m.ResetNodalOfficerCode()
		return nil
	case center.FieldCenterName:
		m.ResetCenterName()
		return nil
	}
	return fmt.Errorf("unknown Center field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CenterMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.applications != nil {
		edges = append(edges, center.EdgeApplications)
	}
	if m.nodal_officer != nil {
		edges = append(edges, center.EdgeNodalOfficer)
	}
	if m.notification != nil {
		edges = append(edges, center.EdgeNotification)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CenterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case center.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	case center.EdgeNodalOfficer:
		if id := m.nodal_officer; id != nil {
			return []ent.Value{*id}
		}
	case center.EdgeNotification:
		if id := m.notification; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CenterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedapplications != nil {
		edges = append(edges, center.EdgeApplications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CenterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case center.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CenterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapplications {
		edges = append(edges, center.EdgeApplications)
	}
	if m.clearednodal_officer {
		edges = append(edges, center.EdgeNodalOfficer)
	}
	if m.clearednotification {
		edges = append(edges, center.EdgeNotification)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CenterMutation) EdgeCleared(name string) bool {
	switch name {
	case center.EdgeApplications:
		return m.clearedapplications
	case center.EdgeNodalOfficer:
		return m.clearednodal_officer
	case center.EdgeNotification:
		return m.clearednotification
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CenterMutation) ClearEdge(name string) error {
	switch name {
	case center.EdgeNodalOfficer:
		m.ClearNodalOfficer()
		return nil
	case center.EdgeNotification:
		m.ClearNotification()
		return nil
	}
	return fmt.Errorf("unknown Center unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CenterMutation) ResetEdge(name string) error {
	switch name {
	case center.EdgeApplications:
		m.ResetApplications()
		return nil
	case center.EdgeNodalOfficer:
		m.ResetNodalOfficer()
		return nil
	case center.EdgeNotification:
		m.ResetNotification()
		return nil
	}
	return fmt.Errorf("unknown Center edge %s", name)
}

// CircleMasterMutation represents an operation that mutates the CircleMaster nodes in the graph.
type CircleMasterMutation struct {
	config
	op                Op
	typ               string
	id                *int32
	_CircleCode       *int32
	add_CircleCode    *int32
	_CircleOfficeId   *string
	_CircleOfficeName *string
	_OfficeType       *string
	_EmailID          *string
	_MobileNumber     *int32
	add_MobileNumber  *int32
	clearedFields     map[string]struct{}
	region_ref        map[int32]struct{}
	removedregion_ref map[int32]struct{}
	clearedregion_ref bool
	circle_ref        map[int32]struct{}
	removedcircle_ref map[int32]struct{}
	clearedcircle_ref bool
	done              bool
	oldValue          func(context.Context) (*CircleMaster, error)
	predicates        []predicate.CircleMaster
}

var _ ent.Mutation = (*CircleMasterMutation)(nil)

// circlemasterOption allows management of the mutation configuration using functional options.
type circlemasterOption func(*CircleMasterMutation)

// newCircleMasterMutation creates new mutation for the CircleMaster entity.
func newCircleMasterMutation(c config, op Op, opts ...circlemasterOption) *CircleMasterMutation {
	m := &CircleMasterMutation{
		config:        c,
		op:            op,
		typ:           TypeCircleMaster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCircleMasterID sets the ID field of the mutation.
func withCircleMasterID(id int32) circlemasterOption {
	return func(m *CircleMasterMutation) {
		var (
			err   error
			once  sync.Once
			value *CircleMaster
		)
		m.oldValue = func(ctx context.Context) (*CircleMaster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CircleMaster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCircleMaster sets the old CircleMaster of the mutation.
func withCircleMaster(node *CircleMaster) circlemasterOption {
	return func(m *CircleMasterMutation) {
		m.oldValue = func(context.Context) (*CircleMaster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CircleMasterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CircleMasterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CircleMaster entities.
func (m *CircleMasterMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CircleMasterMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CircleMasterMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CircleMaster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCircleCode sets the "CircleCode" field.
func (m *CircleMasterMutation) SetCircleCode(i int32) {
	m._CircleCode = &i
	m.add_CircleCode = nil
}

// CircleCode returns the value of the "CircleCode" field in the mutation.
func (m *CircleMasterMutation) CircleCode() (r int32, exists bool) {
	v := m._CircleCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleCode returns the old "CircleCode" field's value of the CircleMaster entity.
// If the CircleMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CircleMasterMutation) OldCircleCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleCode: %w", err)
	}
	return oldValue.CircleCode, nil
}

// AddCircleCode adds i to the "CircleCode" field.
func (m *CircleMasterMutation) AddCircleCode(i int32) {
	if m.add_CircleCode != nil {
		*m.add_CircleCode += i
	} else {
		m.add_CircleCode = &i
	}
}

// AddedCircleCode returns the value that was added to the "CircleCode" field in this mutation.
func (m *CircleMasterMutation) AddedCircleCode() (r int32, exists bool) {
	v := m.add_CircleCode
	if v == nil {
		return
	}
	return *v, true
}

// ResetCircleCode resets all changes to the "CircleCode" field.
func (m *CircleMasterMutation) ResetCircleCode() {
	m._CircleCode = nil
	m.add_CircleCode = nil
}

// SetCircleOfficeId sets the "CircleOfficeId" field.
func (m *CircleMasterMutation) SetCircleOfficeId(s string) {
	m._CircleOfficeId = &s
}

// CircleOfficeId returns the value of the "CircleOfficeId" field in the mutation.
func (m *CircleMasterMutation) CircleOfficeId() (r string, exists bool) {
	v := m._CircleOfficeId
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleOfficeId returns the old "CircleOfficeId" field's value of the CircleMaster entity.
// If the CircleMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CircleMasterMutation) OldCircleOfficeId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleOfficeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleOfficeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleOfficeId: %w", err)
	}
	return oldValue.CircleOfficeId, nil
}

// ResetCircleOfficeId resets all changes to the "CircleOfficeId" field.
func (m *CircleMasterMutation) ResetCircleOfficeId() {
	m._CircleOfficeId = nil
}

// SetCircleOfficeName sets the "CircleOfficeName" field.
func (m *CircleMasterMutation) SetCircleOfficeName(s string) {
	m._CircleOfficeName = &s
}

// CircleOfficeName returns the value of the "CircleOfficeName" field in the mutation.
func (m *CircleMasterMutation) CircleOfficeName() (r string, exists bool) {
	v := m._CircleOfficeName
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleOfficeName returns the old "CircleOfficeName" field's value of the CircleMaster entity.
// If the CircleMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CircleMasterMutation) OldCircleOfficeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleOfficeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleOfficeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleOfficeName: %w", err)
	}
	return oldValue.CircleOfficeName, nil
}

// ResetCircleOfficeName resets all changes to the "CircleOfficeName" field.
func (m *CircleMasterMutation) ResetCircleOfficeName() {
	m._CircleOfficeName = nil
}

// SetOfficeType sets the "OfficeType" field.
func (m *CircleMasterMutation) SetOfficeType(s string) {
	m._OfficeType = &s
}

// OfficeType returns the value of the "OfficeType" field in the mutation.
func (m *CircleMasterMutation) OfficeType() (r string, exists bool) {
	v := m._OfficeType
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeType returns the old "OfficeType" field's value of the CircleMaster entity.
// If the CircleMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CircleMasterMutation) OldOfficeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeType: %w", err)
	}
	return oldValue.OfficeType, nil
}

// ResetOfficeType resets all changes to the "OfficeType" field.
func (m *CircleMasterMutation) ResetOfficeType() {
	m._OfficeType = nil
}

// SetEmailID sets the "EmailID" field.
func (m *CircleMasterMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *CircleMasterMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the CircleMaster entity.
// If the CircleMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CircleMasterMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ClearEmailID clears the value of the "EmailID" field.
func (m *CircleMasterMutation) ClearEmailID() {
	m._EmailID = nil
	m.clearedFields[circlemaster.FieldEmailID] = struct{}{}
}

// EmailIDCleared returns if the "EmailID" field was cleared in this mutation.
func (m *CircleMasterMutation) EmailIDCleared() bool {
	_, ok := m.clearedFields[circlemaster.FieldEmailID]
	return ok
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *CircleMasterMutation) ResetEmailID() {
	m._EmailID = nil
	delete(m.clearedFields, circlemaster.FieldEmailID)
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *CircleMasterMutation) SetMobileNumber(i int32) {
	m._MobileNumber = &i
	m.add_MobileNumber = nil
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *CircleMasterMutation) MobileNumber() (r int32, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the CircleMaster entity.
// If the CircleMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CircleMasterMutation) OldMobileNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// AddMobileNumber adds i to the "MobileNumber" field.
func (m *CircleMasterMutation) AddMobileNumber(i int32) {
	if m.add_MobileNumber != nil {
		*m.add_MobileNumber += i
	} else {
		m.add_MobileNumber = &i
	}
}

// AddedMobileNumber returns the value that was added to the "MobileNumber" field in this mutation.
func (m *CircleMasterMutation) AddedMobileNumber() (r int32, exists bool) {
	v := m.add_MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearMobileNumber clears the value of the "MobileNumber" field.
func (m *CircleMasterMutation) ClearMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	m.clearedFields[circlemaster.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "MobileNumber" field was cleared in this mutation.
func (m *CircleMasterMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[circlemaster.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *CircleMasterMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	delete(m.clearedFields, circlemaster.FieldMobileNumber)
}

// AddRegionRefIDs adds the "region_ref" edge to the RegionMaster entity by ids.
func (m *CircleMasterMutation) AddRegionRefIDs(ids ...int32) {
	if m.region_ref == nil {
		m.region_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.region_ref[ids[i]] = struct{}{}
	}
}

// ClearRegionRef clears the "region_ref" edge to the RegionMaster entity.
func (m *CircleMasterMutation) ClearRegionRef() {
	m.clearedregion_ref = true
}

// RegionRefCleared reports if the "region_ref" edge to the RegionMaster entity was cleared.
func (m *CircleMasterMutation) RegionRefCleared() bool {
	return m.clearedregion_ref
}

// RemoveRegionRefIDs removes the "region_ref" edge to the RegionMaster entity by IDs.
func (m *CircleMasterMutation) RemoveRegionRefIDs(ids ...int32) {
	if m.removedregion_ref == nil {
		m.removedregion_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.region_ref, ids[i])
		m.removedregion_ref[ids[i]] = struct{}{}
	}
}

// RemovedRegionRef returns the removed IDs of the "region_ref" edge to the RegionMaster entity.
func (m *CircleMasterMutation) RemovedRegionRefIDs() (ids []int32) {
	for id := range m.removedregion_ref {
		ids = append(ids, id)
	}
	return
}

// RegionRefIDs returns the "region_ref" edge IDs in the mutation.
func (m *CircleMasterMutation) RegionRefIDs() (ids []int32) {
	for id := range m.region_ref {
		ids = append(ids, id)
	}
	return
}

// ResetRegionRef resets all changes to the "region_ref" edge.
func (m *CircleMasterMutation) ResetRegionRef() {
	m.region_ref = nil
	m.clearedregion_ref = false
	m.removedregion_ref = nil
}

// AddCircleRefIDs adds the "circle_ref" edge to the Facility entity by ids.
func (m *CircleMasterMutation) AddCircleRefIDs(ids ...int32) {
	if m.circle_ref == nil {
		m.circle_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.circle_ref[ids[i]] = struct{}{}
	}
}

// ClearCircleRef clears the "circle_ref" edge to the Facility entity.
func (m *CircleMasterMutation) ClearCircleRef() {
	m.clearedcircle_ref = true
}

// CircleRefCleared reports if the "circle_ref" edge to the Facility entity was cleared.
func (m *CircleMasterMutation) CircleRefCleared() bool {
	return m.clearedcircle_ref
}

// RemoveCircleRefIDs removes the "circle_ref" edge to the Facility entity by IDs.
func (m *CircleMasterMutation) RemoveCircleRefIDs(ids ...int32) {
	if m.removedcircle_ref == nil {
		m.removedcircle_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.circle_ref, ids[i])
		m.removedcircle_ref[ids[i]] = struct{}{}
	}
}

// RemovedCircleRef returns the removed IDs of the "circle_ref" edge to the Facility entity.
func (m *CircleMasterMutation) RemovedCircleRefIDs() (ids []int32) {
	for id := range m.removedcircle_ref {
		ids = append(ids, id)
	}
	return
}

// CircleRefIDs returns the "circle_ref" edge IDs in the mutation.
func (m *CircleMasterMutation) CircleRefIDs() (ids []int32) {
	for id := range m.circle_ref {
		ids = append(ids, id)
	}
	return
}

// ResetCircleRef resets all changes to the "circle_ref" edge.
func (m *CircleMasterMutation) ResetCircleRef() {
	m.circle_ref = nil
	m.clearedcircle_ref = false
	m.removedcircle_ref = nil
}

// Where appends a list predicates to the CircleMasterMutation builder.
func (m *CircleMasterMutation) Where(ps ...predicate.CircleMaster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CircleMasterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CircleMasterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CircleMaster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CircleMasterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CircleMasterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CircleMaster).
func (m *CircleMasterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CircleMasterMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._CircleCode != nil {
		fields = append(fields, circlemaster.FieldCircleCode)
	}
	if m._CircleOfficeId != nil {
		fields = append(fields, circlemaster.FieldCircleOfficeId)
	}
	if m._CircleOfficeName != nil {
		fields = append(fields, circlemaster.FieldCircleOfficeName)
	}
	if m._OfficeType != nil {
		fields = append(fields, circlemaster.FieldOfficeType)
	}
	if m._EmailID != nil {
		fields = append(fields, circlemaster.FieldEmailID)
	}
	if m._MobileNumber != nil {
		fields = append(fields, circlemaster.FieldMobileNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CircleMasterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case circlemaster.FieldCircleCode:
		return m.CircleCode()
	case circlemaster.FieldCircleOfficeId:
		return m.CircleOfficeId()
	case circlemaster.FieldCircleOfficeName:
		return m.CircleOfficeName()
	case circlemaster.FieldOfficeType:
		return m.OfficeType()
	case circlemaster.FieldEmailID:
		return m.EmailID()
	case circlemaster.FieldMobileNumber:
		return m.MobileNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CircleMasterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case circlemaster.FieldCircleCode:
		return m.OldCircleCode(ctx)
	case circlemaster.FieldCircleOfficeId:
		return m.OldCircleOfficeId(ctx)
	case circlemaster.FieldCircleOfficeName:
		return m.OldCircleOfficeName(ctx)
	case circlemaster.FieldOfficeType:
		return m.OldOfficeType(ctx)
	case circlemaster.FieldEmailID:
		return m.OldEmailID(ctx)
	case circlemaster.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	}
	return nil, fmt.Errorf("unknown CircleMaster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CircleMasterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case circlemaster.FieldCircleCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleCode(v)
		return nil
	case circlemaster.FieldCircleOfficeId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleOfficeId(v)
		return nil
	case circlemaster.FieldCircleOfficeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleOfficeName(v)
		return nil
	case circlemaster.FieldOfficeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeType(v)
		return nil
	case circlemaster.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case circlemaster.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	}
	return fmt.Errorf("unknown CircleMaster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CircleMasterMutation) AddedFields() []string {
	var fields []string
	if m.add_CircleCode != nil {
		fields = append(fields, circlemaster.FieldCircleCode)
	}
	if m.add_MobileNumber != nil {
		fields = append(fields, circlemaster.FieldMobileNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CircleMasterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case circlemaster.FieldCircleCode:
		return m.AddedCircleCode()
	case circlemaster.FieldMobileNumber:
		return m.AddedMobileNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CircleMasterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case circlemaster.FieldCircleCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCircleCode(v)
		return nil
	case circlemaster.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMobileNumber(v)
		return nil
	}
	return fmt.Errorf("unknown CircleMaster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CircleMasterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(circlemaster.FieldEmailID) {
		fields = append(fields, circlemaster.FieldEmailID)
	}
	if m.FieldCleared(circlemaster.FieldMobileNumber) {
		fields = append(fields, circlemaster.FieldMobileNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CircleMasterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CircleMasterMutation) ClearField(name string) error {
	switch name {
	case circlemaster.FieldEmailID:
		m.ClearEmailID()
		return nil
	case circlemaster.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	}
	return fmt.Errorf("unknown CircleMaster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CircleMasterMutation) ResetField(name string) error {
	switch name {
	case circlemaster.FieldCircleCode:
		m.ResetCircleCode()
		return nil
	case circlemaster.FieldCircleOfficeId:
		m.ResetCircleOfficeId()
		return nil
	case circlemaster.FieldCircleOfficeName:
		m.ResetCircleOfficeName()
		return nil
	case circlemaster.FieldOfficeType:
		m.ResetOfficeType()
		return nil
	case circlemaster.FieldEmailID:
		m.ResetEmailID()
		return nil
	case circlemaster.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	}
	return fmt.Errorf("unknown CircleMaster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CircleMasterMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.region_ref != nil {
		edges = append(edges, circlemaster.EdgeRegionRef)
	}
	if m.circle_ref != nil {
		edges = append(edges, circlemaster.EdgeCircleRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CircleMasterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case circlemaster.EdgeRegionRef:
		ids := make([]ent.Value, 0, len(m.region_ref))
		for id := range m.region_ref {
			ids = append(ids, id)
		}
		return ids
	case circlemaster.EdgeCircleRef:
		ids := make([]ent.Value, 0, len(m.circle_ref))
		for id := range m.circle_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CircleMasterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedregion_ref != nil {
		edges = append(edges, circlemaster.EdgeRegionRef)
	}
	if m.removedcircle_ref != nil {
		edges = append(edges, circlemaster.EdgeCircleRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CircleMasterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case circlemaster.EdgeRegionRef:
		ids := make([]ent.Value, 0, len(m.removedregion_ref))
		for id := range m.removedregion_ref {
			ids = append(ids, id)
		}
		return ids
	case circlemaster.EdgeCircleRef:
		ids := make([]ent.Value, 0, len(m.removedcircle_ref))
		for id := range m.removedcircle_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CircleMasterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedregion_ref {
		edges = append(edges, circlemaster.EdgeRegionRef)
	}
	if m.clearedcircle_ref {
		edges = append(edges, circlemaster.EdgeCircleRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CircleMasterMutation) EdgeCleared(name string) bool {
	switch name {
	case circlemaster.EdgeRegionRef:
		return m.clearedregion_ref
	case circlemaster.EdgeCircleRef:
		return m.clearedcircle_ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CircleMasterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CircleMaster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CircleMasterMutation) ResetEdge(name string) error {
	switch name {
	case circlemaster.EdgeRegionRef:
		m.ResetRegionRef()
		return nil
	case circlemaster.EdgeCircleRef:
		m.ResetCircleRef()
		return nil
	}
	return fmt.Errorf("unknown CircleMaster edge %s", name)
}

// DisabilityMutation represents an operation that mutates the Disability nodes in the graph.
type DisabilityMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int32
	_DisabilityTypeCode        *string
	_DisabilityTypeDescription *string
	_DisabilityPercentage      *int32
	add_DisabilityPercentage   *int32
	_DisabilityFlag            *disability.DisabilityFlag
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*Disability, error)
	predicates                 []predicate.Disability
}

var _ ent.Mutation = (*DisabilityMutation)(nil)

// disabilityOption allows management of the mutation configuration using functional options.
type disabilityOption func(*DisabilityMutation)

// newDisabilityMutation creates new mutation for the Disability entity.
func newDisabilityMutation(c config, op Op, opts ...disabilityOption) *DisabilityMutation {
	m := &DisabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeDisability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDisabilityID sets the ID field of the mutation.
func withDisabilityID(id int32) disabilityOption {
	return func(m *DisabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *Disability
		)
		m.oldValue = func(ctx context.Context) (*Disability, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Disability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDisability sets the old Disability of the mutation.
func withDisability(node *Disability) disabilityOption {
	return func(m *DisabilityMutation) {
		m.oldValue = func(context.Context) (*Disability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DisabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DisabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Disability entities.
func (m *DisabilityMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DisabilityMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DisabilityMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Disability.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDisabilityTypeCode sets the "DisabilityTypeCode" field.
func (m *DisabilityMutation) SetDisabilityTypeCode(s string) {
	m._DisabilityTypeCode = &s
}

// DisabilityTypeCode returns the value of the "DisabilityTypeCode" field in the mutation.
func (m *DisabilityMutation) DisabilityTypeCode() (r string, exists bool) {
	v := m._DisabilityTypeCode
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityTypeCode returns the old "DisabilityTypeCode" field's value of the Disability entity.
// If the Disability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DisabilityMutation) OldDisabilityTypeCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityTypeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityTypeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityTypeCode: %w", err)
	}
	return oldValue.DisabilityTypeCode, nil
}

// ResetDisabilityTypeCode resets all changes to the "DisabilityTypeCode" field.
func (m *DisabilityMutation) ResetDisabilityTypeCode() {
	m._DisabilityTypeCode = nil
}

// SetDisabilityTypeDescription sets the "DisabilityTypeDescription" field.
func (m *DisabilityMutation) SetDisabilityTypeDescription(s string) {
	m._DisabilityTypeDescription = &s
}

// DisabilityTypeDescription returns the value of the "DisabilityTypeDescription" field in the mutation.
func (m *DisabilityMutation) DisabilityTypeDescription() (r string, exists bool) {
	v := m._DisabilityTypeDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityTypeDescription returns the old "DisabilityTypeDescription" field's value of the Disability entity.
// If the Disability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DisabilityMutation) OldDisabilityTypeDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityTypeDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityTypeDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityTypeDescription: %w", err)
	}
	return oldValue.DisabilityTypeDescription, nil
}

// ResetDisabilityTypeDescription resets all changes to the "DisabilityTypeDescription" field.
func (m *DisabilityMutation) ResetDisabilityTypeDescription() {
	m._DisabilityTypeDescription = nil
}

// SetDisabilityPercentage sets the "DisabilityPercentage" field.
func (m *DisabilityMutation) SetDisabilityPercentage(i int32) {
	m._DisabilityPercentage = &i
	m.add_DisabilityPercentage = nil
}

// DisabilityPercentage returns the value of the "DisabilityPercentage" field in the mutation.
func (m *DisabilityMutation) DisabilityPercentage() (r int32, exists bool) {
	v := m._DisabilityPercentage
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityPercentage returns the old "DisabilityPercentage" field's value of the Disability entity.
// If the Disability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DisabilityMutation) OldDisabilityPercentage(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityPercentage: %w", err)
	}
	return oldValue.DisabilityPercentage, nil
}

// AddDisabilityPercentage adds i to the "DisabilityPercentage" field.
func (m *DisabilityMutation) AddDisabilityPercentage(i int32) {
	if m.add_DisabilityPercentage != nil {
		*m.add_DisabilityPercentage += i
	} else {
		m.add_DisabilityPercentage = &i
	}
}

// AddedDisabilityPercentage returns the value that was added to the "DisabilityPercentage" field in this mutation.
func (m *DisabilityMutation) AddedDisabilityPercentage() (r int32, exists bool) {
	v := m.add_DisabilityPercentage
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisabilityPercentage resets all changes to the "DisabilityPercentage" field.
func (m *DisabilityMutation) ResetDisabilityPercentage() {
	m._DisabilityPercentage = nil
	m.add_DisabilityPercentage = nil
}

// SetDisabilityFlag sets the "DisabilityFlag" field.
func (m *DisabilityMutation) SetDisabilityFlag(df disability.DisabilityFlag) {
	m._DisabilityFlag = &df
}

// DisabilityFlag returns the value of the "DisabilityFlag" field in the mutation.
func (m *DisabilityMutation) DisabilityFlag() (r disability.DisabilityFlag, exists bool) {
	v := m._DisabilityFlag
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityFlag returns the old "DisabilityFlag" field's value of the Disability entity.
// If the Disability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DisabilityMutation) OldDisabilityFlag(ctx context.Context) (v disability.DisabilityFlag, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityFlag: %w", err)
	}
	return oldValue.DisabilityFlag, nil
}

// ResetDisabilityFlag resets all changes to the "DisabilityFlag" field.
func (m *DisabilityMutation) ResetDisabilityFlag() {
	m._DisabilityFlag = nil
}

// Where appends a list predicates to the DisabilityMutation builder.
func (m *DisabilityMutation) Where(ps ...predicate.Disability) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DisabilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DisabilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Disability, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DisabilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DisabilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Disability).
func (m *DisabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DisabilityMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._DisabilityTypeCode != nil {
		fields = append(fields, disability.FieldDisabilityTypeCode)
	}
	if m._DisabilityTypeDescription != nil {
		fields = append(fields, disability.FieldDisabilityTypeDescription)
	}
	if m._DisabilityPercentage != nil {
		fields = append(fields, disability.FieldDisabilityPercentage)
	}
	if m._DisabilityFlag != nil {
		fields = append(fields, disability.FieldDisabilityFlag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DisabilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case disability.FieldDisabilityTypeCode:
		return m.DisabilityTypeCode()
	case disability.FieldDisabilityTypeDescription:
		return m.DisabilityTypeDescription()
	case disability.FieldDisabilityPercentage:
		return m.DisabilityPercentage()
	case disability.FieldDisabilityFlag:
		return m.DisabilityFlag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DisabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case disability.FieldDisabilityTypeCode:
		return m.OldDisabilityTypeCode(ctx)
	case disability.FieldDisabilityTypeDescription:
		return m.OldDisabilityTypeDescription(ctx)
	case disability.FieldDisabilityPercentage:
		return m.OldDisabilityPercentage(ctx)
	case disability.FieldDisabilityFlag:
		return m.OldDisabilityFlag(ctx)
	}
	return nil, fmt.Errorf("unknown Disability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DisabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case disability.FieldDisabilityTypeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityTypeCode(v)
		return nil
	case disability.FieldDisabilityTypeDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityTypeDescription(v)
		return nil
	case disability.FieldDisabilityPercentage:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityPercentage(v)
		return nil
	case disability.FieldDisabilityFlag:
		v, ok := value.(disability.DisabilityFlag)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityFlag(v)
		return nil
	}
	return fmt.Errorf("unknown Disability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DisabilityMutation) AddedFields() []string {
	var fields []string
	if m.add_DisabilityPercentage != nil {
		fields = append(fields, disability.FieldDisabilityPercentage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DisabilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case disability.FieldDisabilityPercentage:
		return m.AddedDisabilityPercentage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DisabilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case disability.FieldDisabilityPercentage:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisabilityPercentage(v)
		return nil
	}
	return fmt.Errorf("unknown Disability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DisabilityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DisabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DisabilityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Disability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DisabilityMutation) ResetField(name string) error {
	switch name {
	case disability.FieldDisabilityTypeCode:
		m.ResetDisabilityTypeCode()
		return nil
	case disability.FieldDisabilityTypeDescription:
		m.ResetDisabilityTypeDescription()
		return nil
	case disability.FieldDisabilityPercentage:
		m.ResetDisabilityPercentage()
		return nil
	case disability.FieldDisabilityFlag:
		m.ResetDisabilityFlag()
		return nil
	}
	return fmt.Errorf("unknown Disability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DisabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DisabilityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DisabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DisabilityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DisabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DisabilityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DisabilityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Disability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DisabilityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Disability edge %s", name)
}

// DivisionMasterMutation represents an operation that mutates the DivisionMaster nodes in the graph.
type DivisionMasterMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int32
	_DivisionCode        *int32
	add_DivisionCode     *int32
	_OfficeType          *string
	_DivisionOfficeID    *string
	_DivisionOfficeName  *string
	_ReportingOfficeType *string
	_ReportingOfficeCode *string
	_EmailID             *string
	_MobileNumber        *int32
	add_MobileNumber     *int32
	_RegionCode          *int32
	add_RegionCode       *int32
	clearedFields        map[string]struct{}
	regions              map[int32]struct{}
	removedregions       map[int32]struct{}
	clearedregions       bool
	done                 bool
	oldValue             func(context.Context) (*DivisionMaster, error)
	predicates           []predicate.DivisionMaster
}

var _ ent.Mutation = (*DivisionMasterMutation)(nil)

// divisionmasterOption allows management of the mutation configuration using functional options.
type divisionmasterOption func(*DivisionMasterMutation)

// newDivisionMasterMutation creates new mutation for the DivisionMaster entity.
func newDivisionMasterMutation(c config, op Op, opts ...divisionmasterOption) *DivisionMasterMutation {
	m := &DivisionMasterMutation{
		config:        c,
		op:            op,
		typ:           TypeDivisionMaster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDivisionMasterID sets the ID field of the mutation.
func withDivisionMasterID(id int32) divisionmasterOption {
	return func(m *DivisionMasterMutation) {
		var (
			err   error
			once  sync.Once
			value *DivisionMaster
		)
		m.oldValue = func(ctx context.Context) (*DivisionMaster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DivisionMaster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDivisionMaster sets the old DivisionMaster of the mutation.
func withDivisionMaster(node *DivisionMaster) divisionmasterOption {
	return func(m *DivisionMasterMutation) {
		m.oldValue = func(context.Context) (*DivisionMaster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DivisionMasterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DivisionMasterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DivisionMaster entities.
func (m *DivisionMasterMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DivisionMasterMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DivisionMasterMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DivisionMaster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDivisionCode sets the "DivisionCode" field.
func (m *DivisionMasterMutation) SetDivisionCode(i int32) {
	m._DivisionCode = &i
	m.add_DivisionCode = nil
}

// DivisionCode returns the value of the "DivisionCode" field in the mutation.
func (m *DivisionMasterMutation) DivisionCode() (r int32, exists bool) {
	v := m._DivisionCode
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionCode returns the old "DivisionCode" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldDivisionCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionCode: %w", err)
	}
	return oldValue.DivisionCode, nil
}

// AddDivisionCode adds i to the "DivisionCode" field.
func (m *DivisionMasterMutation) AddDivisionCode(i int32) {
	if m.add_DivisionCode != nil {
		*m.add_DivisionCode += i
	} else {
		m.add_DivisionCode = &i
	}
}

// AddedDivisionCode returns the value that was added to the "DivisionCode" field in this mutation.
func (m *DivisionMasterMutation) AddedDivisionCode() (r int32, exists bool) {
	v := m.add_DivisionCode
	if v == nil {
		return
	}
	return *v, true
}

// ResetDivisionCode resets all changes to the "DivisionCode" field.
func (m *DivisionMasterMutation) ResetDivisionCode() {
	m._DivisionCode = nil
	m.add_DivisionCode = nil
}

// SetOfficeType sets the "OfficeType" field.
func (m *DivisionMasterMutation) SetOfficeType(s string) {
	m._OfficeType = &s
}

// OfficeType returns the value of the "OfficeType" field in the mutation.
func (m *DivisionMasterMutation) OfficeType() (r string, exists bool) {
	v := m._OfficeType
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeType returns the old "OfficeType" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldOfficeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeType: %w", err)
	}
	return oldValue.OfficeType, nil
}

// ResetOfficeType resets all changes to the "OfficeType" field.
func (m *DivisionMasterMutation) ResetOfficeType() {
	m._OfficeType = nil
}

// SetDivisionOfficeID sets the "DivisionOfficeID" field.
func (m *DivisionMasterMutation) SetDivisionOfficeID(s string) {
	m._DivisionOfficeID = &s
}

// DivisionOfficeID returns the value of the "DivisionOfficeID" field in the mutation.
func (m *DivisionMasterMutation) DivisionOfficeID() (r string, exists bool) {
	v := m._DivisionOfficeID
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionOfficeID returns the old "DivisionOfficeID" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldDivisionOfficeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionOfficeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionOfficeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionOfficeID: %w", err)
	}
	return oldValue.DivisionOfficeID, nil
}

// ResetDivisionOfficeID resets all changes to the "DivisionOfficeID" field.
func (m *DivisionMasterMutation) ResetDivisionOfficeID() {
	m._DivisionOfficeID = nil
}

// SetDivisionOfficeName sets the "DivisionOfficeName" field.
func (m *DivisionMasterMutation) SetDivisionOfficeName(s string) {
	m._DivisionOfficeName = &s
}

// DivisionOfficeName returns the value of the "DivisionOfficeName" field in the mutation.
func (m *DivisionMasterMutation) DivisionOfficeName() (r string, exists bool) {
	v := m._DivisionOfficeName
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionOfficeName returns the old "DivisionOfficeName" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldDivisionOfficeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionOfficeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionOfficeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionOfficeName: %w", err)
	}
	return oldValue.DivisionOfficeName, nil
}

// ResetDivisionOfficeName resets all changes to the "DivisionOfficeName" field.
func (m *DivisionMasterMutation) ResetDivisionOfficeName() {
	m._DivisionOfficeName = nil
}

// SetReportingOfficeType sets the "ReportingOfficeType" field.
func (m *DivisionMasterMutation) SetReportingOfficeType(s string) {
	m._ReportingOfficeType = &s
}

// ReportingOfficeType returns the value of the "ReportingOfficeType" field in the mutation.
func (m *DivisionMasterMutation) ReportingOfficeType() (r string, exists bool) {
	v := m._ReportingOfficeType
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingOfficeType returns the old "ReportingOfficeType" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldReportingOfficeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingOfficeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingOfficeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingOfficeType: %w", err)
	}
	return oldValue.ReportingOfficeType, nil
}

// ClearReportingOfficeType clears the value of the "ReportingOfficeType" field.
func (m *DivisionMasterMutation) ClearReportingOfficeType() {
	m._ReportingOfficeType = nil
	m.clearedFields[divisionmaster.FieldReportingOfficeType] = struct{}{}
}

// ReportingOfficeTypeCleared returns if the "ReportingOfficeType" field was cleared in this mutation.
func (m *DivisionMasterMutation) ReportingOfficeTypeCleared() bool {
	_, ok := m.clearedFields[divisionmaster.FieldReportingOfficeType]
	return ok
}

// ResetReportingOfficeType resets all changes to the "ReportingOfficeType" field.
func (m *DivisionMasterMutation) ResetReportingOfficeType() {
	m._ReportingOfficeType = nil
	delete(m.clearedFields, divisionmaster.FieldReportingOfficeType)
}

// SetReportingOfficeCode sets the "ReportingOfficeCode" field.
func (m *DivisionMasterMutation) SetReportingOfficeCode(s string) {
	m._ReportingOfficeCode = &s
}

// ReportingOfficeCode returns the value of the "ReportingOfficeCode" field in the mutation.
func (m *DivisionMasterMutation) ReportingOfficeCode() (r string, exists bool) {
	v := m._ReportingOfficeCode
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingOfficeCode returns the old "ReportingOfficeCode" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldReportingOfficeCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingOfficeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingOfficeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingOfficeCode: %w", err)
	}
	return oldValue.ReportingOfficeCode, nil
}

// ClearReportingOfficeCode clears the value of the "ReportingOfficeCode" field.
func (m *DivisionMasterMutation) ClearReportingOfficeCode() {
	m._ReportingOfficeCode = nil
	m.clearedFields[divisionmaster.FieldReportingOfficeCode] = struct{}{}
}

// ReportingOfficeCodeCleared returns if the "ReportingOfficeCode" field was cleared in this mutation.
func (m *DivisionMasterMutation) ReportingOfficeCodeCleared() bool {
	_, ok := m.clearedFields[divisionmaster.FieldReportingOfficeCode]
	return ok
}

// ResetReportingOfficeCode resets all changes to the "ReportingOfficeCode" field.
func (m *DivisionMasterMutation) ResetReportingOfficeCode() {
	m._ReportingOfficeCode = nil
	delete(m.clearedFields, divisionmaster.FieldReportingOfficeCode)
}

// SetEmailID sets the "EmailID" field.
func (m *DivisionMasterMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *DivisionMasterMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ClearEmailID clears the value of the "EmailID" field.
func (m *DivisionMasterMutation) ClearEmailID() {
	m._EmailID = nil
	m.clearedFields[divisionmaster.FieldEmailID] = struct{}{}
}

// EmailIDCleared returns if the "EmailID" field was cleared in this mutation.
func (m *DivisionMasterMutation) EmailIDCleared() bool {
	_, ok := m.clearedFields[divisionmaster.FieldEmailID]
	return ok
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *DivisionMasterMutation) ResetEmailID() {
	m._EmailID = nil
	delete(m.clearedFields, divisionmaster.FieldEmailID)
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *DivisionMasterMutation) SetMobileNumber(i int32) {
	m._MobileNumber = &i
	m.add_MobileNumber = nil
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *DivisionMasterMutation) MobileNumber() (r int32, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldMobileNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// AddMobileNumber adds i to the "MobileNumber" field.
func (m *DivisionMasterMutation) AddMobileNumber(i int32) {
	if m.add_MobileNumber != nil {
		*m.add_MobileNumber += i
	} else {
		m.add_MobileNumber = &i
	}
}

// AddedMobileNumber returns the value that was added to the "MobileNumber" field in this mutation.
func (m *DivisionMasterMutation) AddedMobileNumber() (r int32, exists bool) {
	v := m.add_MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearMobileNumber clears the value of the "MobileNumber" field.
func (m *DivisionMasterMutation) ClearMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	m.clearedFields[divisionmaster.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "MobileNumber" field was cleared in this mutation.
func (m *DivisionMasterMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[divisionmaster.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *DivisionMasterMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	delete(m.clearedFields, divisionmaster.FieldMobileNumber)
}

// SetRegionCode sets the "RegionCode" field.
func (m *DivisionMasterMutation) SetRegionCode(i int32) {
	m._RegionCode = &i
	m.add_RegionCode = nil
}

// RegionCode returns the value of the "RegionCode" field in the mutation.
func (m *DivisionMasterMutation) RegionCode() (r int32, exists bool) {
	v := m._RegionCode
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionCode returns the old "RegionCode" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldRegionCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionCode: %w", err)
	}
	return oldValue.RegionCode, nil
}

// AddRegionCode adds i to the "RegionCode" field.
func (m *DivisionMasterMutation) AddRegionCode(i int32) {
	if m.add_RegionCode != nil {
		*m.add_RegionCode += i
	} else {
		m.add_RegionCode = &i
	}
}

// AddedRegionCode returns the value that was added to the "RegionCode" field in this mutation.
func (m *DivisionMasterMutation) AddedRegionCode() (r int32, exists bool) {
	v := m.add_RegionCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearRegionCode clears the value of the "RegionCode" field.
func (m *DivisionMasterMutation) ClearRegionCode() {
	m._RegionCode = nil
	m.add_RegionCode = nil
	m.clearedFields[divisionmaster.FieldRegionCode] = struct{}{}
}

// RegionCodeCleared returns if the "RegionCode" field was cleared in this mutation.
func (m *DivisionMasterMutation) RegionCodeCleared() bool {
	_, ok := m.clearedFields[divisionmaster.FieldRegionCode]
	return ok
}

// ResetRegionCode resets all changes to the "RegionCode" field.
func (m *DivisionMasterMutation) ResetRegionCode() {
	m._RegionCode = nil
	m.add_RegionCode = nil
	delete(m.clearedFields, divisionmaster.FieldRegionCode)
}

// AddRegionIDs adds the "regions" edge to the RegionMaster entity by ids.
func (m *DivisionMasterMutation) AddRegionIDs(ids ...int32) {
	if m.regions == nil {
		m.regions = make(map[int32]struct{})
	}
	for i := range ids {
		m.regions[ids[i]] = struct{}{}
	}
}

// ClearRegions clears the "regions" edge to the RegionMaster entity.
func (m *DivisionMasterMutation) ClearRegions() {
	m.clearedregions = true
}

// RegionsCleared reports if the "regions" edge to the RegionMaster entity was cleared.
func (m *DivisionMasterMutation) RegionsCleared() bool {
	return m.clearedregions
}

// RemoveRegionIDs removes the "regions" edge to the RegionMaster entity by IDs.
func (m *DivisionMasterMutation) RemoveRegionIDs(ids ...int32) {
	if m.removedregions == nil {
		m.removedregions = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.regions, ids[i])
		m.removedregions[ids[i]] = struct{}{}
	}
}

// RemovedRegions returns the removed IDs of the "regions" edge to the RegionMaster entity.
func (m *DivisionMasterMutation) RemovedRegionsIDs() (ids []int32) {
	for id := range m.removedregions {
		ids = append(ids, id)
	}
	return
}

// RegionsIDs returns the "regions" edge IDs in the mutation.
func (m *DivisionMasterMutation) RegionsIDs() (ids []int32) {
	for id := range m.regions {
		ids = append(ids, id)
	}
	return
}

// ResetRegions resets all changes to the "regions" edge.
func (m *DivisionMasterMutation) ResetRegions() {
	m.regions = nil
	m.clearedregions = false
	m.removedregions = nil
}

// Where appends a list predicates to the DivisionMasterMutation builder.
func (m *DivisionMasterMutation) Where(ps ...predicate.DivisionMaster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DivisionMasterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DivisionMasterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DivisionMaster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DivisionMasterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DivisionMasterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DivisionMaster).
func (m *DivisionMasterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DivisionMasterMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._DivisionCode != nil {
		fields = append(fields, divisionmaster.FieldDivisionCode)
	}
	if m._OfficeType != nil {
		fields = append(fields, divisionmaster.FieldOfficeType)
	}
	if m._DivisionOfficeID != nil {
		fields = append(fields, divisionmaster.FieldDivisionOfficeID)
	}
	if m._DivisionOfficeName != nil {
		fields = append(fields, divisionmaster.FieldDivisionOfficeName)
	}
	if m._ReportingOfficeType != nil {
		fields = append(fields, divisionmaster.FieldReportingOfficeType)
	}
	if m._ReportingOfficeCode != nil {
		fields = append(fields, divisionmaster.FieldReportingOfficeCode)
	}
	if m._EmailID != nil {
		fields = append(fields, divisionmaster.FieldEmailID)
	}
	if m._MobileNumber != nil {
		fields = append(fields, divisionmaster.FieldMobileNumber)
	}
	if m._RegionCode != nil {
		fields = append(fields, divisionmaster.FieldRegionCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DivisionMasterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case divisionmaster.FieldDivisionCode:
		return m.DivisionCode()
	case divisionmaster.FieldOfficeType:
		return m.OfficeType()
	case divisionmaster.FieldDivisionOfficeID:
		return m.DivisionOfficeID()
	case divisionmaster.FieldDivisionOfficeName:
		return m.DivisionOfficeName()
	case divisionmaster.FieldReportingOfficeType:
		return m.ReportingOfficeType()
	case divisionmaster.FieldReportingOfficeCode:
		return m.ReportingOfficeCode()
	case divisionmaster.FieldEmailID:
		return m.EmailID()
	case divisionmaster.FieldMobileNumber:
		return m.MobileNumber()
	case divisionmaster.FieldRegionCode:
		return m.RegionCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DivisionMasterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case divisionmaster.FieldDivisionCode:
		return m.OldDivisionCode(ctx)
	case divisionmaster.FieldOfficeType:
		return m.OldOfficeType(ctx)
	case divisionmaster.FieldDivisionOfficeID:
		return m.OldDivisionOfficeID(ctx)
	case divisionmaster.FieldDivisionOfficeName:
		return m.OldDivisionOfficeName(ctx)
	case divisionmaster.FieldReportingOfficeType:
		return m.OldReportingOfficeType(ctx)
	case divisionmaster.FieldReportingOfficeCode:
		return m.OldReportingOfficeCode(ctx)
	case divisionmaster.FieldEmailID:
		return m.OldEmailID(ctx)
	case divisionmaster.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case divisionmaster.FieldRegionCode:
		return m.OldRegionCode(ctx)
	}
	return nil, fmt.Errorf("unknown DivisionMaster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivisionMasterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case divisionmaster.FieldDivisionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionCode(v)
		return nil
	case divisionmaster.FieldOfficeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeType(v)
		return nil
	case divisionmaster.FieldDivisionOfficeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionOfficeID(v)
		return nil
	case divisionmaster.FieldDivisionOfficeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionOfficeName(v)
		return nil
	case divisionmaster.FieldReportingOfficeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingOfficeType(v)
		return nil
	case divisionmaster.FieldReportingOfficeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingOfficeCode(v)
		return nil
	case divisionmaster.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case divisionmaster.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case divisionmaster.FieldRegionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionCode(v)
		return nil
	}
	return fmt.Errorf("unknown DivisionMaster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DivisionMasterMutation) AddedFields() []string {
	var fields []string
	if m.add_DivisionCode != nil {
		fields = append(fields, divisionmaster.FieldDivisionCode)
	}
	if m.add_MobileNumber != nil {
		fields = append(fields, divisionmaster.FieldMobileNumber)
	}
	if m.add_RegionCode != nil {
		fields = append(fields, divisionmaster.FieldRegionCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DivisionMasterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case divisionmaster.FieldDivisionCode:
		return m.AddedDivisionCode()
	case divisionmaster.FieldMobileNumber:
		return m.AddedMobileNumber()
	case divisionmaster.FieldRegionCode:
		return m.AddedRegionCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivisionMasterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case divisionmaster.FieldDivisionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDivisionCode(v)
		return nil
	case divisionmaster.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMobileNumber(v)
		return nil
	case divisionmaster.FieldRegionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegionCode(v)
		return nil
	}
	return fmt.Errorf("unknown DivisionMaster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DivisionMasterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(divisionmaster.FieldReportingOfficeType) {
		fields = append(fields, divisionmaster.FieldReportingOfficeType)
	}
	if m.FieldCleared(divisionmaster.FieldReportingOfficeCode) {
		fields = append(fields, divisionmaster.FieldReportingOfficeCode)
	}
	if m.FieldCleared(divisionmaster.FieldEmailID) {
		fields = append(fields, divisionmaster.FieldEmailID)
	}
	if m.FieldCleared(divisionmaster.FieldMobileNumber) {
		fields = append(fields, divisionmaster.FieldMobileNumber)
	}
	if m.FieldCleared(divisionmaster.FieldRegionCode) {
		fields = append(fields, divisionmaster.FieldRegionCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DivisionMasterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DivisionMasterMutation) ClearField(name string) error {
	switch name {
	case divisionmaster.FieldReportingOfficeType:
		m.ClearReportingOfficeType()
		return nil
	case divisionmaster.FieldReportingOfficeCode:
		m.ClearReportingOfficeCode()
		return nil
	case divisionmaster.FieldEmailID:
		m.ClearEmailID()
		return nil
	case divisionmaster.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	case divisionmaster.FieldRegionCode:
		m.ClearRegionCode()
		return nil
	}
	return fmt.Errorf("unknown DivisionMaster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DivisionMasterMutation) ResetField(name string) error {
	switch name {
	case divisionmaster.FieldDivisionCode:
		m.ResetDivisionCode()
		return nil
	case divisionmaster.FieldOfficeType:
		m.ResetOfficeType()
		return nil
	case divisionmaster.FieldDivisionOfficeID:
		m.ResetDivisionOfficeID()
		return nil
	case divisionmaster.FieldDivisionOfficeName:
		m.ResetDivisionOfficeName()
		return nil
	case divisionmaster.FieldReportingOfficeType:
		m.ResetReportingOfficeType()
		return nil
	case divisionmaster.FieldReportingOfficeCode:
		m.ResetReportingOfficeCode()
		return nil
	case divisionmaster.FieldEmailID:
		m.ResetEmailID()
		return nil
	case divisionmaster.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case divisionmaster.FieldRegionCode:
		m.ResetRegionCode()
		return nil
	}
	return fmt.Errorf("unknown DivisionMaster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DivisionMasterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.regions != nil {
		edges = append(edges, divisionmaster.EdgeRegions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DivisionMasterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case divisionmaster.EdgeRegions:
		ids := make([]ent.Value, 0, len(m.regions))
		for id := range m.regions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DivisionMasterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedregions != nil {
		edges = append(edges, divisionmaster.EdgeRegions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DivisionMasterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case divisionmaster.EdgeRegions:
		ids := make([]ent.Value, 0, len(m.removedregions))
		for id := range m.removedregions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DivisionMasterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedregions {
		edges = append(edges, divisionmaster.EdgeRegions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DivisionMasterMutation) EdgeCleared(name string) bool {
	switch name {
	case divisionmaster.EdgeRegions:
		return m.clearedregions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DivisionMasterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DivisionMaster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DivisionMasterMutation) ResetEdge(name string) error {
	switch name {
	case divisionmaster.EdgeRegions:
		m.ResetRegions()
		return nil
	}
	return fmt.Errorf("unknown DivisionMaster edge %s", name)
}

// EmployeeCadreMutation represents an operation that mutates the EmployeeCadre nodes in the graph.
type EmployeeCadreMutation struct {
	config
	op               Op
	typ              string
	id               *int32
	cadrecode        *string
	cadredescription *string
	_PayLevel        *string
	_Scale           *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*EmployeeCadre, error)
	predicates       []predicate.EmployeeCadre
}

var _ ent.Mutation = (*EmployeeCadreMutation)(nil)

// employeecadreOption allows management of the mutation configuration using functional options.
type employeecadreOption func(*EmployeeCadreMutation)

// newEmployeeCadreMutation creates new mutation for the EmployeeCadre entity.
func newEmployeeCadreMutation(c config, op Op, opts ...employeecadreOption) *EmployeeCadreMutation {
	m := &EmployeeCadreMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployeeCadre,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeCadreID sets the ID field of the mutation.
func withEmployeeCadreID(id int32) employeecadreOption {
	return func(m *EmployeeCadreMutation) {
		var (
			err   error
			once  sync.Once
			value *EmployeeCadre
		)
		m.oldValue = func(ctx context.Context) (*EmployeeCadre, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmployeeCadre.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployeeCadre sets the old EmployeeCadre of the mutation.
func withEmployeeCadre(node *EmployeeCadre) employeecadreOption {
	return func(m *EmployeeCadreMutation) {
		m.oldValue = func(context.Context) (*EmployeeCadre, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeCadreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeCadreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmployeeCadre entities.
func (m *EmployeeCadreMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeCadreMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeCadreMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmployeeCadre.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCadrecode sets the "cadrecode" field.
func (m *EmployeeCadreMutation) SetCadrecode(s string) {
	m.cadrecode = &s
}

// Cadrecode returns the value of the "cadrecode" field in the mutation.
func (m *EmployeeCadreMutation) Cadrecode() (r string, exists bool) {
	v := m.cadrecode
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrecode returns the old "cadrecode" field's value of the EmployeeCadre entity.
// If the EmployeeCadre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeCadreMutation) OldCadrecode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrecode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrecode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrecode: %w", err)
	}
	return oldValue.Cadrecode, nil
}

// ResetCadrecode resets all changes to the "cadrecode" field.
func (m *EmployeeCadreMutation) ResetCadrecode() {
	m.cadrecode = nil
}

// SetCadredescription sets the "cadredescription" field.
func (m *EmployeeCadreMutation) SetCadredescription(s string) {
	m.cadredescription = &s
}

// Cadredescription returns the value of the "cadredescription" field in the mutation.
func (m *EmployeeCadreMutation) Cadredescription() (r string, exists bool) {
	v := m.cadredescription
	if v == nil {
		return
	}
	return *v, true
}

// OldCadredescription returns the old "cadredescription" field's value of the EmployeeCadre entity.
// If the EmployeeCadre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeCadreMutation) OldCadredescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadredescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadredescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadredescription: %w", err)
	}
	return oldValue.Cadredescription, nil
}

// ResetCadredescription resets all changes to the "cadredescription" field.
func (m *EmployeeCadreMutation) ResetCadredescription() {
	m.cadredescription = nil
}

// SetPayLevel sets the "PayLevel" field.
func (m *EmployeeCadreMutation) SetPayLevel(s string) {
	m._PayLevel = &s
}

// PayLevel returns the value of the "PayLevel" field in the mutation.
func (m *EmployeeCadreMutation) PayLevel() (r string, exists bool) {
	v := m._PayLevel
	if v == nil {
		return
	}
	return *v, true
}

// OldPayLevel returns the old "PayLevel" field's value of the EmployeeCadre entity.
// If the EmployeeCadre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeCadreMutation) OldPayLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayLevel: %w", err)
	}
	return oldValue.PayLevel, nil
}

// ResetPayLevel resets all changes to the "PayLevel" field.
func (m *EmployeeCadreMutation) ResetPayLevel() {
	m._PayLevel = nil
}

// SetScale sets the "Scale" field.
func (m *EmployeeCadreMutation) SetScale(s string) {
	m._Scale = &s
}

// Scale returns the value of the "Scale" field in the mutation.
func (m *EmployeeCadreMutation) Scale() (r string, exists bool) {
	v := m._Scale
	if v == nil {
		return
	}
	return *v, true
}

// OldScale returns the old "Scale" field's value of the EmployeeCadre entity.
// If the EmployeeCadre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeCadreMutation) OldScale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScale: %w", err)
	}
	return oldValue.Scale, nil
}

// ResetScale resets all changes to the "Scale" field.
func (m *EmployeeCadreMutation) ResetScale() {
	m._Scale = nil
}

// Where appends a list predicates to the EmployeeCadreMutation builder.
func (m *EmployeeCadreMutation) Where(ps ...predicate.EmployeeCadre) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeCadreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeCadreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmployeeCadre, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeCadreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeCadreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmployeeCadre).
func (m *EmployeeCadreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeCadreMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.cadrecode != nil {
		fields = append(fields, employeecadre.FieldCadrecode)
	}
	if m.cadredescription != nil {
		fields = append(fields, employeecadre.FieldCadredescription)
	}
	if m._PayLevel != nil {
		fields = append(fields, employeecadre.FieldPayLevel)
	}
	if m._Scale != nil {
		fields = append(fields, employeecadre.FieldScale)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeCadreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employeecadre.FieldCadrecode:
		return m.Cadrecode()
	case employeecadre.FieldCadredescription:
		return m.Cadredescription()
	case employeecadre.FieldPayLevel:
		return m.PayLevel()
	case employeecadre.FieldScale:
		return m.Scale()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeCadreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employeecadre.FieldCadrecode:
		return m.OldCadrecode(ctx)
	case employeecadre.FieldCadredescription:
		return m.OldCadredescription(ctx)
	case employeecadre.FieldPayLevel:
		return m.OldPayLevel(ctx)
	case employeecadre.FieldScale:
		return m.OldScale(ctx)
	}
	return nil, fmt.Errorf("unknown EmployeeCadre field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeCadreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employeecadre.FieldCadrecode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrecode(v)
		return nil
	case employeecadre.FieldCadredescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadredescription(v)
		return nil
	case employeecadre.FieldPayLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayLevel(v)
		return nil
	case employeecadre.FieldScale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScale(v)
		return nil
	}
	return fmt.Errorf("unknown EmployeeCadre field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeCadreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeCadreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeCadreMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmployeeCadre numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeCadreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeCadreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeCadreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EmployeeCadre nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeCadreMutation) ResetField(name string) error {
	switch name {
	case employeecadre.FieldCadrecode:
		m.ResetCadrecode()
		return nil
	case employeecadre.FieldCadredescription:
		m.ResetCadredescription()
		return nil
	case employeecadre.FieldPayLevel:
		m.ResetPayLevel()
		return nil
	case employeecadre.FieldScale:
		m.ResetScale()
		return nil
	}
	return fmt.Errorf("unknown EmployeeCadre field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeCadreMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeCadreMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeCadreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeCadreMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeCadreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeCadreMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeCadreMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EmployeeCadre unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeCadreMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EmployeeCadre edge %s", name)
}

// EmployeeCategoryMutation represents an operation that mutates the EmployeeCategory nodes in the graph.
type EmployeeCategoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int32
	_Categrycode         *string
	_CategoryDescription *string
	_MinimumMarks        *int32
	add_MinimumMarks     *int32
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*EmployeeCategory, error)
	predicates           []predicate.EmployeeCategory
}

var _ ent.Mutation = (*EmployeeCategoryMutation)(nil)

// employeecategoryOption allows management of the mutation configuration using functional options.
type employeecategoryOption func(*EmployeeCategoryMutation)

// newEmployeeCategoryMutation creates new mutation for the EmployeeCategory entity.
func newEmployeeCategoryMutation(c config, op Op, opts ...employeecategoryOption) *EmployeeCategoryMutation {
	m := &EmployeeCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployeeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeCategoryID sets the ID field of the mutation.
func withEmployeeCategoryID(id int32) employeecategoryOption {
	return func(m *EmployeeCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *EmployeeCategory
		)
		m.oldValue = func(ctx context.Context) (*EmployeeCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmployeeCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployeeCategory sets the old EmployeeCategory of the mutation.
func withEmployeeCategory(node *EmployeeCategory) employeecategoryOption {
	return func(m *EmployeeCategoryMutation) {
		m.oldValue = func(context.Context) (*EmployeeCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmployeeCategory entities.
func (m *EmployeeCategoryMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeCategoryMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeCategoryMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmployeeCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCategrycode sets the "Categrycode" field.
func (m *EmployeeCategoryMutation) SetCategrycode(s string) {
	m._Categrycode = &s
}

// Categrycode returns the value of the "Categrycode" field in the mutation.
func (m *EmployeeCategoryMutation) Categrycode() (r string, exists bool) {
	v := m._Categrycode
	if v == nil {
		return
	}
	return *v, true
}

// OldCategrycode returns the old "Categrycode" field's value of the EmployeeCategory entity.
// If the EmployeeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeCategoryMutation) OldCategrycode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategrycode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategrycode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategrycode: %w", err)
	}
	return oldValue.Categrycode, nil
}

// ResetCategrycode resets all changes to the "Categrycode" field.
func (m *EmployeeCategoryMutation) ResetCategrycode() {
	m._Categrycode = nil
}

// SetCategoryDescription sets the "CategoryDescription" field.
func (m *EmployeeCategoryMutation) SetCategoryDescription(s string) {
	m._CategoryDescription = &s
}

// CategoryDescription returns the value of the "CategoryDescription" field in the mutation.
func (m *EmployeeCategoryMutation) CategoryDescription() (r string, exists bool) {
	v := m._CategoryDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryDescription returns the old "CategoryDescription" field's value of the EmployeeCategory entity.
// If the EmployeeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeCategoryMutation) OldCategoryDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryDescription: %w", err)
	}
	return oldValue.CategoryDescription, nil
}

// ResetCategoryDescription resets all changes to the "CategoryDescription" field.
func (m *EmployeeCategoryMutation) ResetCategoryDescription() {
	m._CategoryDescription = nil
}

// SetMinimumMarks sets the "MinimumMarks" field.
func (m *EmployeeCategoryMutation) SetMinimumMarks(i int32) {
	m._MinimumMarks = &i
	m.add_MinimumMarks = nil
}

// MinimumMarks returns the value of the "MinimumMarks" field in the mutation.
func (m *EmployeeCategoryMutation) MinimumMarks() (r int32, exists bool) {
	v := m._MinimumMarks
	if v == nil {
		return
	}
	return *v, true
}

// OldMinimumMarks returns the old "MinimumMarks" field's value of the EmployeeCategory entity.
// If the EmployeeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeCategoryMutation) OldMinimumMarks(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinimumMarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinimumMarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinimumMarks: %w", err)
	}
	return oldValue.MinimumMarks, nil
}

// AddMinimumMarks adds i to the "MinimumMarks" field.
func (m *EmployeeCategoryMutation) AddMinimumMarks(i int32) {
	if m.add_MinimumMarks != nil {
		*m.add_MinimumMarks += i
	} else {
		m.add_MinimumMarks = &i
	}
}

// AddedMinimumMarks returns the value that was added to the "MinimumMarks" field in this mutation.
func (m *EmployeeCategoryMutation) AddedMinimumMarks() (r int32, exists bool) {
	v := m.add_MinimumMarks
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinimumMarks clears the value of the "MinimumMarks" field.
func (m *EmployeeCategoryMutation) ClearMinimumMarks() {
	m._MinimumMarks = nil
	m.add_MinimumMarks = nil
	m.clearedFields[employeecategory.FieldMinimumMarks] = struct{}{}
}

// MinimumMarksCleared returns if the "MinimumMarks" field was cleared in this mutation.
func (m *EmployeeCategoryMutation) MinimumMarksCleared() bool {
	_, ok := m.clearedFields[employeecategory.FieldMinimumMarks]
	return ok
}

// ResetMinimumMarks resets all changes to the "MinimumMarks" field.
func (m *EmployeeCategoryMutation) ResetMinimumMarks() {
	m._MinimumMarks = nil
	m.add_MinimumMarks = nil
	delete(m.clearedFields, employeecategory.FieldMinimumMarks)
}

// Where appends a list predicates to the EmployeeCategoryMutation builder.
func (m *EmployeeCategoryMutation) Where(ps ...predicate.EmployeeCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmployeeCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmployeeCategory).
func (m *EmployeeCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeCategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Categrycode != nil {
		fields = append(fields, employeecategory.FieldCategrycode)
	}
	if m._CategoryDescription != nil {
		fields = append(fields, employeecategory.FieldCategoryDescription)
	}
	if m._MinimumMarks != nil {
		fields = append(fields, employeecategory.FieldMinimumMarks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employeecategory.FieldCategrycode:
		return m.Categrycode()
	case employeecategory.FieldCategoryDescription:
		return m.CategoryDescription()
	case employeecategory.FieldMinimumMarks:
		return m.MinimumMarks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employeecategory.FieldCategrycode:
		return m.OldCategrycode(ctx)
	case employeecategory.FieldCategoryDescription:
		return m.OldCategoryDescription(ctx)
	case employeecategory.FieldMinimumMarks:
		return m.OldMinimumMarks(ctx)
	}
	return nil, fmt.Errorf("unknown EmployeeCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employeecategory.FieldCategrycode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategrycode(v)
		return nil
	case employeecategory.FieldCategoryDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryDescription(v)
		return nil
	case employeecategory.FieldMinimumMarks:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinimumMarks(v)
		return nil
	}
	return fmt.Errorf("unknown EmployeeCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeCategoryMutation) AddedFields() []string {
	var fields []string
	if m.add_MinimumMarks != nil {
		fields = append(fields, employeecategory.FieldMinimumMarks)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case employeecategory.FieldMinimumMarks:
		return m.AddedMinimumMarks()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case employeecategory.FieldMinimumMarks:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinimumMarks(v)
		return nil
	}
	return fmt.Errorf("unknown EmployeeCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employeecategory.FieldMinimumMarks) {
		fields = append(fields, employeecategory.FieldMinimumMarks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeCategoryMutation) ClearField(name string) error {
	switch name {
	case employeecategory.FieldMinimumMarks:
		m.ClearMinimumMarks()
		return nil
	}
	return fmt.Errorf("unknown EmployeeCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeCategoryMutation) ResetField(name string) error {
	switch name {
	case employeecategory.FieldCategrycode:
		m.ResetCategrycode()
		return nil
	case employeecategory.FieldCategoryDescription:
		m.ResetCategoryDescription()
		return nil
	case employeecategory.FieldMinimumMarks:
		m.ResetMinimumMarks()
		return nil
	}
	return fmt.Errorf("unknown EmployeeCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EmployeeCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EmployeeCategory edge %s", name)
}

// EmployeeDesignationMutation represents an operation that mutates the EmployeeDesignation nodes in the graph.
type EmployeeDesignationMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int32
	_DesignationCode        *string
	_DesignationDescription *string
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*EmployeeDesignation, error)
	predicates              []predicate.EmployeeDesignation
}

var _ ent.Mutation = (*EmployeeDesignationMutation)(nil)

// employeedesignationOption allows management of the mutation configuration using functional options.
type employeedesignationOption func(*EmployeeDesignationMutation)

// newEmployeeDesignationMutation creates new mutation for the EmployeeDesignation entity.
func newEmployeeDesignationMutation(c config, op Op, opts ...employeedesignationOption) *EmployeeDesignationMutation {
	m := &EmployeeDesignationMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployeeDesignation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeDesignationID sets the ID field of the mutation.
func withEmployeeDesignationID(id int32) employeedesignationOption {
	return func(m *EmployeeDesignationMutation) {
		var (
			err   error
			once  sync.Once
			value *EmployeeDesignation
		)
		m.oldValue = func(ctx context.Context) (*EmployeeDesignation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmployeeDesignation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployeeDesignation sets the old EmployeeDesignation of the mutation.
func withEmployeeDesignation(node *EmployeeDesignation) employeedesignationOption {
	return func(m *EmployeeDesignationMutation) {
		m.oldValue = func(context.Context) (*EmployeeDesignation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeDesignationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeDesignationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmployeeDesignation entities.
func (m *EmployeeDesignationMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeDesignationMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeDesignationMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmployeeDesignation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDesignationCode sets the "DesignationCode" field.
func (m *EmployeeDesignationMutation) SetDesignationCode(s string) {
	m._DesignationCode = &s
}

// DesignationCode returns the value of the "DesignationCode" field in the mutation.
func (m *EmployeeDesignationMutation) DesignationCode() (r string, exists bool) {
	v := m._DesignationCode
	if v == nil {
		return
	}
	return *v, true
}

// OldDesignationCode returns the old "DesignationCode" field's value of the EmployeeDesignation entity.
// If the EmployeeDesignation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeDesignationMutation) OldDesignationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesignationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesignationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesignationCode: %w", err)
	}
	return oldValue.DesignationCode, nil
}

// ResetDesignationCode resets all changes to the "DesignationCode" field.
func (m *EmployeeDesignationMutation) ResetDesignationCode() {
	m._DesignationCode = nil
}

// SetDesignationDescription sets the "DesignationDescription" field.
func (m *EmployeeDesignationMutation) SetDesignationDescription(s string) {
	m._DesignationDescription = &s
}

// DesignationDescription returns the value of the "DesignationDescription" field in the mutation.
func (m *EmployeeDesignationMutation) DesignationDescription() (r string, exists bool) {
	v := m._DesignationDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldDesignationDescription returns the old "DesignationDescription" field's value of the EmployeeDesignation entity.
// If the EmployeeDesignation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeDesignationMutation) OldDesignationDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesignationDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesignationDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesignationDescription: %w", err)
	}
	return oldValue.DesignationDescription, nil
}

// ResetDesignationDescription resets all changes to the "DesignationDescription" field.
func (m *EmployeeDesignationMutation) ResetDesignationDescription() {
	m._DesignationDescription = nil
}

// Where appends a list predicates to the EmployeeDesignationMutation builder.
func (m *EmployeeDesignationMutation) Where(ps ...predicate.EmployeeDesignation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeDesignationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeDesignationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmployeeDesignation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeDesignationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeDesignationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmployeeDesignation).
func (m *EmployeeDesignationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeDesignationMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._DesignationCode != nil {
		fields = append(fields, employeedesignation.FieldDesignationCode)
	}
	if m._DesignationDescription != nil {
		fields = append(fields, employeedesignation.FieldDesignationDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeDesignationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employeedesignation.FieldDesignationCode:
		return m.DesignationCode()
	case employeedesignation.FieldDesignationDescription:
		return m.DesignationDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeDesignationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employeedesignation.FieldDesignationCode:
		return m.OldDesignationCode(ctx)
	case employeedesignation.FieldDesignationDescription:
		return m.OldDesignationDescription(ctx)
	}
	return nil, fmt.Errorf("unknown EmployeeDesignation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeDesignationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employeedesignation.FieldDesignationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesignationCode(v)
		return nil
	case employeedesignation.FieldDesignationDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesignationDescription(v)
		return nil
	}
	return fmt.Errorf("unknown EmployeeDesignation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeDesignationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeDesignationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeDesignationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmployeeDesignation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeDesignationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeDesignationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeDesignationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EmployeeDesignation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeDesignationMutation) ResetField(name string) error {
	switch name {
	case employeedesignation.FieldDesignationCode:
		m.ResetDesignationCode()
		return nil
	case employeedesignation.FieldDesignationDescription:
		m.ResetDesignationDescription()
		return nil
	}
	return fmt.Errorf("unknown EmployeeDesignation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeDesignationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeDesignationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeDesignationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeDesignationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeDesignationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeDesignationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeDesignationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EmployeeDesignation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeDesignationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EmployeeDesignation edge %s", name)
}

// EmployeePostsMutation represents an operation that mutates the EmployeePosts nodes in the graph.
type EmployeePostsMutation struct {
	config
	op               Op
	typ              string
	id               *int32
	_PostCode        *string
	_PostDescription *string
	_Group           *string
	_PayLevel        *string
	_Scale           *string
	_BaseCadreFlag   *bool
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*EmployeePosts, error)
	predicates       []predicate.EmployeePosts
}

var _ ent.Mutation = (*EmployeePostsMutation)(nil)

// employeepostsOption allows management of the mutation configuration using functional options.
type employeepostsOption func(*EmployeePostsMutation)

// newEmployeePostsMutation creates new mutation for the EmployeePosts entity.
func newEmployeePostsMutation(c config, op Op, opts ...employeepostsOption) *EmployeePostsMutation {
	m := &EmployeePostsMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployeePosts,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeePostsID sets the ID field of the mutation.
func withEmployeePostsID(id int32) employeepostsOption {
	return func(m *EmployeePostsMutation) {
		var (
			err   error
			once  sync.Once
			value *EmployeePosts
		)
		m.oldValue = func(ctx context.Context) (*EmployeePosts, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmployeePosts.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployeePosts sets the old EmployeePosts of the mutation.
func withEmployeePosts(node *EmployeePosts) employeepostsOption {
	return func(m *EmployeePostsMutation) {
		m.oldValue = func(context.Context) (*EmployeePosts, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeePostsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeePostsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmployeePosts entities.
func (m *EmployeePostsMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeePostsMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeePostsMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmployeePosts.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPostCode sets the "PostCode" field.
func (m *EmployeePostsMutation) SetPostCode(s string) {
	m._PostCode = &s
}

// PostCode returns the value of the "PostCode" field in the mutation.
func (m *EmployeePostsMutation) PostCode() (r string, exists bool) {
	v := m._PostCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPostCode returns the old "PostCode" field's value of the EmployeePosts entity.
// If the EmployeePosts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeePostsMutation) OldPostCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostCode: %w", err)
	}
	return oldValue.PostCode, nil
}

// ResetPostCode resets all changes to the "PostCode" field.
func (m *EmployeePostsMutation) ResetPostCode() {
	m._PostCode = nil
}

// SetPostDescription sets the "PostDescription" field.
func (m *EmployeePostsMutation) SetPostDescription(s string) {
	m._PostDescription = &s
}

// PostDescription returns the value of the "PostDescription" field in the mutation.
func (m *EmployeePostsMutation) PostDescription() (r string, exists bool) {
	v := m._PostDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldPostDescription returns the old "PostDescription" field's value of the EmployeePosts entity.
// If the EmployeePosts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeePostsMutation) OldPostDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostDescription: %w", err)
	}
	return oldValue.PostDescription, nil
}

// ResetPostDescription resets all changes to the "PostDescription" field.
func (m *EmployeePostsMutation) ResetPostDescription() {
	m._PostDescription = nil
}

// SetGroup sets the "Group" field.
func (m *EmployeePostsMutation) SetGroup(s string) {
	m._Group = &s
}

// Group returns the value of the "Group" field in the mutation.
func (m *EmployeePostsMutation) Group() (r string, exists bool) {
	v := m._Group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "Group" field's value of the EmployeePosts entity.
// If the EmployeePosts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeePostsMutation) OldGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// ResetGroup resets all changes to the "Group" field.
func (m *EmployeePostsMutation) ResetGroup() {
	m._Group = nil
}

// SetPayLevel sets the "PayLevel" field.
func (m *EmployeePostsMutation) SetPayLevel(s string) {
	m._PayLevel = &s
}

// PayLevel returns the value of the "PayLevel" field in the mutation.
func (m *EmployeePostsMutation) PayLevel() (r string, exists bool) {
	v := m._PayLevel
	if v == nil {
		return
	}
	return *v, true
}

// OldPayLevel returns the old "PayLevel" field's value of the EmployeePosts entity.
// If the EmployeePosts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeePostsMutation) OldPayLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayLevel: %w", err)
	}
	return oldValue.PayLevel, nil
}

// ResetPayLevel resets all changes to the "PayLevel" field.
func (m *EmployeePostsMutation) ResetPayLevel() {
	m._PayLevel = nil
}

// SetScale sets the "Scale" field.
func (m *EmployeePostsMutation) SetScale(s string) {
	m._Scale = &s
}

// Scale returns the value of the "Scale" field in the mutation.
func (m *EmployeePostsMutation) Scale() (r string, exists bool) {
	v := m._Scale
	if v == nil {
		return
	}
	return *v, true
}

// OldScale returns the old "Scale" field's value of the EmployeePosts entity.
// If the EmployeePosts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeePostsMutation) OldScale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScale: %w", err)
	}
	return oldValue.Scale, nil
}

// ResetScale resets all changes to the "Scale" field.
func (m *EmployeePostsMutation) ResetScale() {
	m._Scale = nil
}

// SetBaseCadreFlag sets the "BaseCadreFlag" field.
func (m *EmployeePostsMutation) SetBaseCadreFlag(b bool) {
	m._BaseCadreFlag = &b
}

// BaseCadreFlag returns the value of the "BaseCadreFlag" field in the mutation.
func (m *EmployeePostsMutation) BaseCadreFlag() (r bool, exists bool) {
	v := m._BaseCadreFlag
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseCadreFlag returns the old "BaseCadreFlag" field's value of the EmployeePosts entity.
// If the EmployeePosts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeePostsMutation) OldBaseCadreFlag(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseCadreFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseCadreFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseCadreFlag: %w", err)
	}
	return oldValue.BaseCadreFlag, nil
}

// ResetBaseCadreFlag resets all changes to the "BaseCadreFlag" field.
func (m *EmployeePostsMutation) ResetBaseCadreFlag() {
	m._BaseCadreFlag = nil
}

// Where appends a list predicates to the EmployeePostsMutation builder.
func (m *EmployeePostsMutation) Where(ps ...predicate.EmployeePosts) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeePostsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeePostsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmployeePosts, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeePostsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeePostsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmployeePosts).
func (m *EmployeePostsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeePostsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._PostCode != nil {
		fields = append(fields, employeeposts.FieldPostCode)
	}
	if m._PostDescription != nil {
		fields = append(fields, employeeposts.FieldPostDescription)
	}
	if m._Group != nil {
		fields = append(fields, employeeposts.FieldGroup)
	}
	if m._PayLevel != nil {
		fields = append(fields, employeeposts.FieldPayLevel)
	}
	if m._Scale != nil {
		fields = append(fields, employeeposts.FieldScale)
	}
	if m._BaseCadreFlag != nil {
		fields = append(fields, employeeposts.FieldBaseCadreFlag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeePostsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employeeposts.FieldPostCode:
		return m.PostCode()
	case employeeposts.FieldPostDescription:
		return m.PostDescription()
	case employeeposts.FieldGroup:
		return m.Group()
	case employeeposts.FieldPayLevel:
		return m.PayLevel()
	case employeeposts.FieldScale:
		return m.Scale()
	case employeeposts.FieldBaseCadreFlag:
		return m.BaseCadreFlag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeePostsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employeeposts.FieldPostCode:
		return m.OldPostCode(ctx)
	case employeeposts.FieldPostDescription:
		return m.OldPostDescription(ctx)
	case employeeposts.FieldGroup:
		return m.OldGroup(ctx)
	case employeeposts.FieldPayLevel:
		return m.OldPayLevel(ctx)
	case employeeposts.FieldScale:
		return m.OldScale(ctx)
	case employeeposts.FieldBaseCadreFlag:
		return m.OldBaseCadreFlag(ctx)
	}
	return nil, fmt.Errorf("unknown EmployeePosts field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeePostsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employeeposts.FieldPostCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostCode(v)
		return nil
	case employeeposts.FieldPostDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostDescription(v)
		return nil
	case employeeposts.FieldGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case employeeposts.FieldPayLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayLevel(v)
		return nil
	case employeeposts.FieldScale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScale(v)
		return nil
	case employeeposts.FieldBaseCadreFlag:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseCadreFlag(v)
		return nil
	}
	return fmt.Errorf("unknown EmployeePosts field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeePostsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeePostsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeePostsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmployeePosts numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeePostsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeePostsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeePostsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EmployeePosts nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeePostsMutation) ResetField(name string) error {
	switch name {
	case employeeposts.FieldPostCode:
		m.ResetPostCode()
		return nil
	case employeeposts.FieldPostDescription:
		m.ResetPostDescription()
		return nil
	case employeeposts.FieldGroup:
		m.ResetGroup()
		return nil
	case employeeposts.FieldPayLevel:
		m.ResetPayLevel()
		return nil
	case employeeposts.FieldScale:
		m.ResetScale()
		return nil
	case employeeposts.FieldBaseCadreFlag:
		m.ResetBaseCadreFlag()
		return nil
	}
	return fmt.Errorf("unknown EmployeePosts field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeePostsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeePostsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeePostsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeePostsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeePostsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeePostsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeePostsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EmployeePosts unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeePostsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EmployeePosts edge %s", name)
}

// EmployeesMutation represents an operation that mutates the Employees nodes in the graph.
type EmployeesMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int32
	_EmployeedID                   *int32
	add_EmployeedID                *int32
	_IDVerified                    *bool
	_IDRemStatus                   *bool
	_IDRemarks                     *string
	_EmployeeName                  *string
	nameVerified                   *bool
	nameRemStatus                  *bool
	nameRemarks                    *string
	_EmployeeFathersName           *string
	_FathersNameVerified           *bool
	_FathersNameRemStatus          *bool
	_FathersNameRemarks            *string
	_DOB                           *time.Time
	_DOBVerified                   *bool
	_DOBRemStatus                  *bool
	_DOBRemarks                    *string
	_Gender                        *employees.Gender
	genderVerified                 *bool
	genderRemStatus                *bool
	genderRemarks                  *string
	_MobileNumber                  *int32
	add_MobileNumber               *int32
	_EmailID                       *string
	_Categoryid                    *int32
	add_Categoryid                 *int32
	_EmployeeCategoryCode          *string
	_EmployeeCategory              *string
	_EmployeeCategoryCodeVerified  *bool
	_EmployeeCategoryCodeRemStatus *bool
	_EmployeeCategoryCodeRemarks   *string
	_WithDisability                *string
	_WithDisabilityVerified        *bool
	_WithDisabilityRemStatus       *bool
	_WithDisabilityRemarks         *bool
	_DisabilityType                *string
	_DisabilityTypeVerified        *bool
	_DisabilityTypeRemStatus       *bool
	_DisabilityTypeRemarks         *string
	_DisabilityPercentage          *int32
	add_DisabilityPercentage       *int32
	_DisabilityPercentageVerified  *bool
	_DisabilityPercentageRemStatus *bool
	_DisabilityPercentageRemarks   *string
	_Signature                     *string
	_SignatureVerified             *bool
	_SignatureRemStatus            *bool
	_SignatureRemarks              *string
	_Photo                         *string
	_PhotoVerified                 *bool
	_PhotoRemStatus                *bool
	_PhotoRemarks                  *string
	_Cadreid                       *int32
	add_Cadreid                    *int32
	_EmployeeCadre                 *string
	_EmployeeCadreVerified         *bool
	_EmployeeCadreRemStatus        *bool
	_EmployeeCadreRemarks          *string
	_DesignationID                 *int32
	add_DesignationID              *int32
	_EmployeeDesignation           *string
	_EmployeeDesignationVerified   *bool
	_EmployeeDesignationRemStatus  *bool
	_EmployeeDesignationRemarks    *string
	_CircleID                      *int32
	add_CircleID                   *int32
	_CircleName                    *string
	_CircleVerified                *bool
	_CircleRemStatus               *bool
	_CircleRemarks                 *string
	_RegionID                      *int32
	add_RegionID                   *int32
	_RegionName                    *string
	_RegionVerified                *bool
	_RegionRemStatus               *bool
	_RegionRemarks                 *string
	_DivisionID                    *int32
	add_DivisionID                 *int32
	_DivisionName                  *string
	_DivisionVerified              *bool
	_DivisionRemStatus             *bool
	_DivisionRemarks               *string
	_OfficeID                      *int32
	add_OfficeID                   *int32
	_OfficeName                    *string
	_OfficeVerified                *bool
	_OfficeRemStatus               *bool
	_OfficeRemarks                 *string
	_Role                          *string
	_RoleVerified                  *bool
	_RoleRemStatus                 *bool
	_RoleRemarks                   *string
	_DCCS                          *time.Time
	_DCCSVerified                  *bool
	_DCCSRemStatus                 *bool
	_DCCSRemarks                   *string
	_DCInPresentCadre              *time.Time
	_DCInPresentCadreVerified      *bool
	_DCInPresentCadreRemStatus     *bool
	_DCInPresentCadreRemarks       *string
	_APSWorking                    *bool
	_APSWorkingVerified            *bool
	_APSWorkingRemStatus           *bool
	_APSWorkingRemarks             *string
	profilestatus                  *bool
	clearedFields                  map[string]struct{}
	done                           bool
	oldValue                       func(context.Context) (*Employees, error)
	predicates                     []predicate.Employees
}

var _ ent.Mutation = (*EmployeesMutation)(nil)

// employeesOption allows management of the mutation configuration using functional options.
type employeesOption func(*EmployeesMutation)

// newEmployeesMutation creates new mutation for the Employees entity.
func newEmployeesMutation(c config, op Op, opts ...employeesOption) *EmployeesMutation {
	m := &EmployeesMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployees,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeesID sets the ID field of the mutation.
func withEmployeesID(id int32) employeesOption {
	return func(m *EmployeesMutation) {
		var (
			err   error
			once  sync.Once
			value *Employees
		)
		m.oldValue = func(ctx context.Context) (*Employees, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employees.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployees sets the old Employees of the mutation.
func withEmployees(node *Employees) employeesOption {
	return func(m *EmployeesMutation) {
		m.oldValue = func(context.Context) (*Employees, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Employees entities.
func (m *EmployeesMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeesMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeesMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employees.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeedID sets the "EmployeedID" field.
func (m *EmployeesMutation) SetEmployeedID(i int32) {
	m._EmployeedID = &i
	m.add_EmployeedID = nil
}

// EmployeedID returns the value of the "EmployeedID" field in the mutation.
func (m *EmployeesMutation) EmployeedID() (r int32, exists bool) {
	v := m._EmployeedID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeedID returns the old "EmployeedID" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeedID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeedID: %w", err)
	}
	return oldValue.EmployeedID, nil
}

// AddEmployeedID adds i to the "EmployeedID" field.
func (m *EmployeesMutation) AddEmployeedID(i int32) {
	if m.add_EmployeedID != nil {
		*m.add_EmployeedID += i
	} else {
		m.add_EmployeedID = &i
	}
}

// AddedEmployeedID returns the value that was added to the "EmployeedID" field in this mutation.
func (m *EmployeesMutation) AddedEmployeedID() (r int32, exists bool) {
	v := m.add_EmployeedID
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmployeedID resets all changes to the "EmployeedID" field.
func (m *EmployeesMutation) ResetEmployeedID() {
	m._EmployeedID = nil
	m.add_EmployeedID = nil
}

// SetIDVerified sets the "IDVerified" field.
func (m *EmployeesMutation) SetIDVerified(b bool) {
	m._IDVerified = &b
}

// IDVerified returns the value of the "IDVerified" field in the mutation.
func (m *EmployeesMutation) IDVerified() (r bool, exists bool) {
	v := m._IDVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldIDVerified returns the old "IDVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldIDVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDVerified: %w", err)
	}
	return oldValue.IDVerified, nil
}

// ResetIDVerified resets all changes to the "IDVerified" field.
func (m *EmployeesMutation) ResetIDVerified() {
	m._IDVerified = nil
}

// SetIDRemStatus sets the "IDRemStatus" field.
func (m *EmployeesMutation) SetIDRemStatus(b bool) {
	m._IDRemStatus = &b
}

// IDRemStatus returns the value of the "IDRemStatus" field in the mutation.
func (m *EmployeesMutation) IDRemStatus() (r bool, exists bool) {
	v := m._IDRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldIDRemStatus returns the old "IDRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldIDRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDRemStatus: %w", err)
	}
	return oldValue.IDRemStatus, nil
}

// ResetIDRemStatus resets all changes to the "IDRemStatus" field.
func (m *EmployeesMutation) ResetIDRemStatus() {
	m._IDRemStatus = nil
}

// SetIDRemarks sets the "IDRemarks" field.
func (m *EmployeesMutation) SetIDRemarks(s string) {
	m._IDRemarks = &s
}

// IDRemarks returns the value of the "IDRemarks" field in the mutation.
func (m *EmployeesMutation) IDRemarks() (r string, exists bool) {
	v := m._IDRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldIDRemarks returns the old "IDRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldIDRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDRemarks: %w", err)
	}
	return oldValue.IDRemarks, nil
}

// ClearIDRemarks clears the value of the "IDRemarks" field.
func (m *EmployeesMutation) ClearIDRemarks() {
	m._IDRemarks = nil
	m.clearedFields[employees.FieldIDRemarks] = struct{}{}
}

// IDRemarksCleared returns if the "IDRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) IDRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldIDRemarks]
	return ok
}

// ResetIDRemarks resets all changes to the "IDRemarks" field.
func (m *EmployeesMutation) ResetIDRemarks() {
	m._IDRemarks = nil
	delete(m.clearedFields, employees.FieldIDRemarks)
}

// SetEmployeeName sets the "EmployeeName" field.
func (m *EmployeesMutation) SetEmployeeName(s string) {
	m._EmployeeName = &s
}

// EmployeeName returns the value of the "EmployeeName" field in the mutation.
func (m *EmployeesMutation) EmployeeName() (r string, exists bool) {
	v := m._EmployeeName
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeName returns the old "EmployeeName" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeName: %w", err)
	}
	return oldValue.EmployeeName, nil
}

// ResetEmployeeName resets all changes to the "EmployeeName" field.
func (m *EmployeesMutation) ResetEmployeeName() {
	m._EmployeeName = nil
}

// SetNameVerified sets the "nameVerified" field.
func (m *EmployeesMutation) SetNameVerified(b bool) {
	m.nameVerified = &b
}

// NameVerified returns the value of the "nameVerified" field in the mutation.
func (m *EmployeesMutation) NameVerified() (r bool, exists bool) {
	v := m.nameVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldNameVerified returns the old "nameVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldNameVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameVerified: %w", err)
	}
	return oldValue.NameVerified, nil
}

// ResetNameVerified resets all changes to the "nameVerified" field.
func (m *EmployeesMutation) ResetNameVerified() {
	m.nameVerified = nil
}

// SetNameRemStatus sets the "nameRemStatus" field.
func (m *EmployeesMutation) SetNameRemStatus(b bool) {
	m.nameRemStatus = &b
}

// NameRemStatus returns the value of the "nameRemStatus" field in the mutation.
func (m *EmployeesMutation) NameRemStatus() (r bool, exists bool) {
	v := m.nameRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldNameRemStatus returns the old "nameRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldNameRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameRemStatus: %w", err)
	}
	return oldValue.NameRemStatus, nil
}

// ResetNameRemStatus resets all changes to the "nameRemStatus" field.
func (m *EmployeesMutation) ResetNameRemStatus() {
	m.nameRemStatus = nil
}

// SetNameRemarks sets the "nameRemarks" field.
func (m *EmployeesMutation) SetNameRemarks(s string) {
	m.nameRemarks = &s
}

// NameRemarks returns the value of the "nameRemarks" field in the mutation.
func (m *EmployeesMutation) NameRemarks() (r string, exists bool) {
	v := m.nameRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldNameRemarks returns the old "nameRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldNameRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameRemarks: %w", err)
	}
	return oldValue.NameRemarks, nil
}

// ClearNameRemarks clears the value of the "nameRemarks" field.
func (m *EmployeesMutation) ClearNameRemarks() {
	m.nameRemarks = nil
	m.clearedFields[employees.FieldNameRemarks] = struct{}{}
}

// NameRemarksCleared returns if the "nameRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) NameRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldNameRemarks]
	return ok
}

// ResetNameRemarks resets all changes to the "nameRemarks" field.
func (m *EmployeesMutation) ResetNameRemarks() {
	m.nameRemarks = nil
	delete(m.clearedFields, employees.FieldNameRemarks)
}

// SetEmployeeFathersName sets the "EmployeeFathersName" field.
func (m *EmployeesMutation) SetEmployeeFathersName(s string) {
	m._EmployeeFathersName = &s
}

// EmployeeFathersName returns the value of the "EmployeeFathersName" field in the mutation.
func (m *EmployeesMutation) EmployeeFathersName() (r string, exists bool) {
	v := m._EmployeeFathersName
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeFathersName returns the old "EmployeeFathersName" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeFathersName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeFathersName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeFathersName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeFathersName: %w", err)
	}
	return oldValue.EmployeeFathersName, nil
}

// ResetEmployeeFathersName resets all changes to the "EmployeeFathersName" field.
func (m *EmployeesMutation) ResetEmployeeFathersName() {
	m._EmployeeFathersName = nil
}

// SetFathersNameVerified sets the "FathersNameVerified" field.
func (m *EmployeesMutation) SetFathersNameVerified(b bool) {
	m._FathersNameVerified = &b
}

// FathersNameVerified returns the value of the "FathersNameVerified" field in the mutation.
func (m *EmployeesMutation) FathersNameVerified() (r bool, exists bool) {
	v := m._FathersNameVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldFathersNameVerified returns the old "FathersNameVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldFathersNameVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFathersNameVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFathersNameVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFathersNameVerified: %w", err)
	}
	return oldValue.FathersNameVerified, nil
}

// ResetFathersNameVerified resets all changes to the "FathersNameVerified" field.
func (m *EmployeesMutation) ResetFathersNameVerified() {
	m._FathersNameVerified = nil
}

// SetFathersNameRemStatus sets the "FathersNameRemStatus" field.
func (m *EmployeesMutation) SetFathersNameRemStatus(b bool) {
	m._FathersNameRemStatus = &b
}

// FathersNameRemStatus returns the value of the "FathersNameRemStatus" field in the mutation.
func (m *EmployeesMutation) FathersNameRemStatus() (r bool, exists bool) {
	v := m._FathersNameRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldFathersNameRemStatus returns the old "FathersNameRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldFathersNameRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFathersNameRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFathersNameRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFathersNameRemStatus: %w", err)
	}
	return oldValue.FathersNameRemStatus, nil
}

// ResetFathersNameRemStatus resets all changes to the "FathersNameRemStatus" field.
func (m *EmployeesMutation) ResetFathersNameRemStatus() {
	m._FathersNameRemStatus = nil
}

// SetFathersNameRemarks sets the "FathersNameRemarks" field.
func (m *EmployeesMutation) SetFathersNameRemarks(s string) {
	m._FathersNameRemarks = &s
}

// FathersNameRemarks returns the value of the "FathersNameRemarks" field in the mutation.
func (m *EmployeesMutation) FathersNameRemarks() (r string, exists bool) {
	v := m._FathersNameRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldFathersNameRemarks returns the old "FathersNameRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldFathersNameRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFathersNameRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFathersNameRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFathersNameRemarks: %w", err)
	}
	return oldValue.FathersNameRemarks, nil
}

// ClearFathersNameRemarks clears the value of the "FathersNameRemarks" field.
func (m *EmployeesMutation) ClearFathersNameRemarks() {
	m._FathersNameRemarks = nil
	m.clearedFields[employees.FieldFathersNameRemarks] = struct{}{}
}

// FathersNameRemarksCleared returns if the "FathersNameRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) FathersNameRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldFathersNameRemarks]
	return ok
}

// ResetFathersNameRemarks resets all changes to the "FathersNameRemarks" field.
func (m *EmployeesMutation) ResetFathersNameRemarks() {
	m._FathersNameRemarks = nil
	delete(m.clearedFields, employees.FieldFathersNameRemarks)
}

// SetDOB sets the "DOB" field.
func (m *EmployeesMutation) SetDOB(t time.Time) {
	m._DOB = &t
}

// DOB returns the value of the "DOB" field in the mutation.
func (m *EmployeesMutation) DOB() (r time.Time, exists bool) {
	v := m._DOB
	if v == nil {
		return
	}
	return *v, true
}

// OldDOB returns the old "DOB" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDOB(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOB: %w", err)
	}
	return oldValue.DOB, nil
}

// ResetDOB resets all changes to the "DOB" field.
func (m *EmployeesMutation) ResetDOB() {
	m._DOB = nil
}

// SetDOBVerified sets the "DOBVerified" field.
func (m *EmployeesMutation) SetDOBVerified(b bool) {
	m._DOBVerified = &b
}

// DOBVerified returns the value of the "DOBVerified" field in the mutation.
func (m *EmployeesMutation) DOBVerified() (r bool, exists bool) {
	v := m._DOBVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldDOBVerified returns the old "DOBVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDOBVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOBVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOBVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOBVerified: %w", err)
	}
	return oldValue.DOBVerified, nil
}

// ResetDOBVerified resets all changes to the "DOBVerified" field.
func (m *EmployeesMutation) ResetDOBVerified() {
	m._DOBVerified = nil
}

// SetDOBRemStatus sets the "DOBRemStatus" field.
func (m *EmployeesMutation) SetDOBRemStatus(b bool) {
	m._DOBRemStatus = &b
}

// DOBRemStatus returns the value of the "DOBRemStatus" field in the mutation.
func (m *EmployeesMutation) DOBRemStatus() (r bool, exists bool) {
	v := m._DOBRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldDOBRemStatus returns the old "DOBRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDOBRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOBRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOBRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOBRemStatus: %w", err)
	}
	return oldValue.DOBRemStatus, nil
}

// ResetDOBRemStatus resets all changes to the "DOBRemStatus" field.
func (m *EmployeesMutation) ResetDOBRemStatus() {
	m._DOBRemStatus = nil
}

// SetDOBRemarks sets the "DOBRemarks" field.
func (m *EmployeesMutation) SetDOBRemarks(s string) {
	m._DOBRemarks = &s
}

// DOBRemarks returns the value of the "DOBRemarks" field in the mutation.
func (m *EmployeesMutation) DOBRemarks() (r string, exists bool) {
	v := m._DOBRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldDOBRemarks returns the old "DOBRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDOBRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOBRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOBRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOBRemarks: %w", err)
	}
	return oldValue.DOBRemarks, nil
}

// ClearDOBRemarks clears the value of the "DOBRemarks" field.
func (m *EmployeesMutation) ClearDOBRemarks() {
	m._DOBRemarks = nil
	m.clearedFields[employees.FieldDOBRemarks] = struct{}{}
}

// DOBRemarksCleared returns if the "DOBRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) DOBRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldDOBRemarks]
	return ok
}

// ResetDOBRemarks resets all changes to the "DOBRemarks" field.
func (m *EmployeesMutation) ResetDOBRemarks() {
	m._DOBRemarks = nil
	delete(m.clearedFields, employees.FieldDOBRemarks)
}

// SetGender sets the "Gender" field.
func (m *EmployeesMutation) SetGender(e employees.Gender) {
	m._Gender = &e
}

// Gender returns the value of the "Gender" field in the mutation.
func (m *EmployeesMutation) Gender() (r employees.Gender, exists bool) {
	v := m._Gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "Gender" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldGender(ctx context.Context) (v employees.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "Gender" field.
func (m *EmployeesMutation) ResetGender() {
	m._Gender = nil
}

// SetGenderVerified sets the "genderVerified" field.
func (m *EmployeesMutation) SetGenderVerified(b bool) {
	m.genderVerified = &b
}

// GenderVerified returns the value of the "genderVerified" field in the mutation.
func (m *EmployeesMutation) GenderVerified() (r bool, exists bool) {
	v := m.genderVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderVerified returns the old "genderVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldGenderVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenderVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenderVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderVerified: %w", err)
	}
	return oldValue.GenderVerified, nil
}

// ResetGenderVerified resets all changes to the "genderVerified" field.
func (m *EmployeesMutation) ResetGenderVerified() {
	m.genderVerified = nil
}

// SetGenderRemStatus sets the "genderRemStatus" field.
func (m *EmployeesMutation) SetGenderRemStatus(b bool) {
	m.genderRemStatus = &b
}

// GenderRemStatus returns the value of the "genderRemStatus" field in the mutation.
func (m *EmployeesMutation) GenderRemStatus() (r bool, exists bool) {
	v := m.genderRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderRemStatus returns the old "genderRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldGenderRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenderRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenderRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderRemStatus: %w", err)
	}
	return oldValue.GenderRemStatus, nil
}

// ResetGenderRemStatus resets all changes to the "genderRemStatus" field.
func (m *EmployeesMutation) ResetGenderRemStatus() {
	m.genderRemStatus = nil
}

// SetGenderRemarks sets the "genderRemarks" field.
func (m *EmployeesMutation) SetGenderRemarks(s string) {
	m.genderRemarks = &s
}

// GenderRemarks returns the value of the "genderRemarks" field in the mutation.
func (m *EmployeesMutation) GenderRemarks() (r string, exists bool) {
	v := m.genderRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderRemarks returns the old "genderRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldGenderRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenderRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenderRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderRemarks: %w", err)
	}
	return oldValue.GenderRemarks, nil
}

// ClearGenderRemarks clears the value of the "genderRemarks" field.
func (m *EmployeesMutation) ClearGenderRemarks() {
	m.genderRemarks = nil
	m.clearedFields[employees.FieldGenderRemarks] = struct{}{}
}

// GenderRemarksCleared returns if the "genderRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) GenderRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldGenderRemarks]
	return ok
}

// ResetGenderRemarks resets all changes to the "genderRemarks" field.
func (m *EmployeesMutation) ResetGenderRemarks() {
	m.genderRemarks = nil
	delete(m.clearedFields, employees.FieldGenderRemarks)
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *EmployeesMutation) SetMobileNumber(i int32) {
	m._MobileNumber = &i
	m.add_MobileNumber = nil
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *EmployeesMutation) MobileNumber() (r int32, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldMobileNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// AddMobileNumber adds i to the "MobileNumber" field.
func (m *EmployeesMutation) AddMobileNumber(i int32) {
	if m.add_MobileNumber != nil {
		*m.add_MobileNumber += i
	} else {
		m.add_MobileNumber = &i
	}
}

// AddedMobileNumber returns the value that was added to the "MobileNumber" field in this mutation.
func (m *EmployeesMutation) AddedMobileNumber() (r int32, exists bool) {
	v := m.add_MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearMobileNumber clears the value of the "MobileNumber" field.
func (m *EmployeesMutation) ClearMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	m.clearedFields[employees.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "MobileNumber" field was cleared in this mutation.
func (m *EmployeesMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[employees.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *EmployeesMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	delete(m.clearedFields, employees.FieldMobileNumber)
}

// SetEmailID sets the "EmailID" field.
func (m *EmployeesMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *EmployeesMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ClearEmailID clears the value of the "EmailID" field.
func (m *EmployeesMutation) ClearEmailID() {
	m._EmailID = nil
	m.clearedFields[employees.FieldEmailID] = struct{}{}
}

// EmailIDCleared returns if the "EmailID" field was cleared in this mutation.
func (m *EmployeesMutation) EmailIDCleared() bool {
	_, ok := m.clearedFields[employees.FieldEmailID]
	return ok
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *EmployeesMutation) ResetEmailID() {
	m._EmailID = nil
	delete(m.clearedFields, employees.FieldEmailID)
}

// SetCategoryid sets the "Categoryid" field.
func (m *EmployeesMutation) SetCategoryid(i int32) {
	m._Categoryid = &i
	m.add_Categoryid = nil
}

// Categoryid returns the value of the "Categoryid" field in the mutation.
func (m *EmployeesMutation) Categoryid() (r int32, exists bool) {
	v := m._Categoryid
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryid returns the old "Categoryid" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldCategoryid(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryid: %w", err)
	}
	return oldValue.Categoryid, nil
}

// AddCategoryid adds i to the "Categoryid" field.
func (m *EmployeesMutation) AddCategoryid(i int32) {
	if m.add_Categoryid != nil {
		*m.add_Categoryid += i
	} else {
		m.add_Categoryid = &i
	}
}

// AddedCategoryid returns the value that was added to the "Categoryid" field in this mutation.
func (m *EmployeesMutation) AddedCategoryid() (r int32, exists bool) {
	v := m.add_Categoryid
	if v == nil {
		return
	}
	return *v, true
}

// ClearCategoryid clears the value of the "Categoryid" field.
func (m *EmployeesMutation) ClearCategoryid() {
	m._Categoryid = nil
	m.add_Categoryid = nil
	m.clearedFields[employees.FieldCategoryid] = struct{}{}
}

// CategoryidCleared returns if the "Categoryid" field was cleared in this mutation.
func (m *EmployeesMutation) CategoryidCleared() bool {
	_, ok := m.clearedFields[employees.FieldCategoryid]
	return ok
}

// ResetCategoryid resets all changes to the "Categoryid" field.
func (m *EmployeesMutation) ResetCategoryid() {
	m._Categoryid = nil
	m.add_Categoryid = nil
	delete(m.clearedFields, employees.FieldCategoryid)
}

// SetEmployeeCategoryCode sets the "EmployeeCategoryCode" field.
func (m *EmployeesMutation) SetEmployeeCategoryCode(s string) {
	m._EmployeeCategoryCode = &s
}

// EmployeeCategoryCode returns the value of the "EmployeeCategoryCode" field in the mutation.
func (m *EmployeesMutation) EmployeeCategoryCode() (r string, exists bool) {
	v := m._EmployeeCategoryCode
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCategoryCode returns the old "EmployeeCategoryCode" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeCategoryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCategoryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCategoryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCategoryCode: %w", err)
	}
	return oldValue.EmployeeCategoryCode, nil
}

// ClearEmployeeCategoryCode clears the value of the "EmployeeCategoryCode" field.
func (m *EmployeesMutation) ClearEmployeeCategoryCode() {
	m._EmployeeCategoryCode = nil
	m.clearedFields[employees.FieldEmployeeCategoryCode] = struct{}{}
}

// EmployeeCategoryCodeCleared returns if the "EmployeeCategoryCode" field was cleared in this mutation.
func (m *EmployeesMutation) EmployeeCategoryCodeCleared() bool {
	_, ok := m.clearedFields[employees.FieldEmployeeCategoryCode]
	return ok
}

// ResetEmployeeCategoryCode resets all changes to the "EmployeeCategoryCode" field.
func (m *EmployeesMutation) ResetEmployeeCategoryCode() {
	m._EmployeeCategoryCode = nil
	delete(m.clearedFields, employees.FieldEmployeeCategoryCode)
}

// SetEmployeeCategory sets the "EmployeeCategory" field.
func (m *EmployeesMutation) SetEmployeeCategory(s string) {
	m._EmployeeCategory = &s
}

// EmployeeCategory returns the value of the "EmployeeCategory" field in the mutation.
func (m *EmployeesMutation) EmployeeCategory() (r string, exists bool) {
	v := m._EmployeeCategory
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCategory returns the old "EmployeeCategory" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCategory: %w", err)
	}
	return oldValue.EmployeeCategory, nil
}

// ResetEmployeeCategory resets all changes to the "EmployeeCategory" field.
func (m *EmployeesMutation) ResetEmployeeCategory() {
	m._EmployeeCategory = nil
}

// SetEmployeeCategoryCodeVerified sets the "EmployeeCategoryCodeVerified" field.
func (m *EmployeesMutation) SetEmployeeCategoryCodeVerified(b bool) {
	m._EmployeeCategoryCodeVerified = &b
}

// EmployeeCategoryCodeVerified returns the value of the "EmployeeCategoryCodeVerified" field in the mutation.
func (m *EmployeesMutation) EmployeeCategoryCodeVerified() (r bool, exists bool) {
	v := m._EmployeeCategoryCodeVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCategoryCodeVerified returns the old "EmployeeCategoryCodeVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeCategoryCodeVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCategoryCodeVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCategoryCodeVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCategoryCodeVerified: %w", err)
	}
	return oldValue.EmployeeCategoryCodeVerified, nil
}

// ResetEmployeeCategoryCodeVerified resets all changes to the "EmployeeCategoryCodeVerified" field.
func (m *EmployeesMutation) ResetEmployeeCategoryCodeVerified() {
	m._EmployeeCategoryCodeVerified = nil
}

// SetEmployeeCategoryCodeRemStatus sets the "EmployeeCategoryCodeRemStatus" field.
func (m *EmployeesMutation) SetEmployeeCategoryCodeRemStatus(b bool) {
	m._EmployeeCategoryCodeRemStatus = &b
}

// EmployeeCategoryCodeRemStatus returns the value of the "EmployeeCategoryCodeRemStatus" field in the mutation.
func (m *EmployeesMutation) EmployeeCategoryCodeRemStatus() (r bool, exists bool) {
	v := m._EmployeeCategoryCodeRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCategoryCodeRemStatus returns the old "EmployeeCategoryCodeRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeCategoryCodeRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCategoryCodeRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCategoryCodeRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCategoryCodeRemStatus: %w", err)
	}
	return oldValue.EmployeeCategoryCodeRemStatus, nil
}

// ResetEmployeeCategoryCodeRemStatus resets all changes to the "EmployeeCategoryCodeRemStatus" field.
func (m *EmployeesMutation) ResetEmployeeCategoryCodeRemStatus() {
	m._EmployeeCategoryCodeRemStatus = nil
}

// SetEmployeeCategoryCodeRemarks sets the "EmployeeCategoryCodeRemarks" field.
func (m *EmployeesMutation) SetEmployeeCategoryCodeRemarks(s string) {
	m._EmployeeCategoryCodeRemarks = &s
}

// EmployeeCategoryCodeRemarks returns the value of the "EmployeeCategoryCodeRemarks" field in the mutation.
func (m *EmployeesMutation) EmployeeCategoryCodeRemarks() (r string, exists bool) {
	v := m._EmployeeCategoryCodeRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCategoryCodeRemarks returns the old "EmployeeCategoryCodeRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeCategoryCodeRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCategoryCodeRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCategoryCodeRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCategoryCodeRemarks: %w", err)
	}
	return oldValue.EmployeeCategoryCodeRemarks, nil
}

// ClearEmployeeCategoryCodeRemarks clears the value of the "EmployeeCategoryCodeRemarks" field.
func (m *EmployeesMutation) ClearEmployeeCategoryCodeRemarks() {
	m._EmployeeCategoryCodeRemarks = nil
	m.clearedFields[employees.FieldEmployeeCategoryCodeRemarks] = struct{}{}
}

// EmployeeCategoryCodeRemarksCleared returns if the "EmployeeCategoryCodeRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) EmployeeCategoryCodeRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldEmployeeCategoryCodeRemarks]
	return ok
}

// ResetEmployeeCategoryCodeRemarks resets all changes to the "EmployeeCategoryCodeRemarks" field.
func (m *EmployeesMutation) ResetEmployeeCategoryCodeRemarks() {
	m._EmployeeCategoryCodeRemarks = nil
	delete(m.clearedFields, employees.FieldEmployeeCategoryCodeRemarks)
}

// SetWithDisability sets the "WithDisability" field.
func (m *EmployeesMutation) SetWithDisability(s string) {
	m._WithDisability = &s
}

// WithDisability returns the value of the "WithDisability" field in the mutation.
func (m *EmployeesMutation) WithDisability() (r string, exists bool) {
	v := m._WithDisability
	if v == nil {
		return
	}
	return *v, true
}

// OldWithDisability returns the old "WithDisability" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldWithDisability(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithDisability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithDisability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithDisability: %w", err)
	}
	return oldValue.WithDisability, nil
}

// ResetWithDisability resets all changes to the "WithDisability" field.
func (m *EmployeesMutation) ResetWithDisability() {
	m._WithDisability = nil
}

// SetWithDisabilityVerified sets the "WithDisabilityVerified" field.
func (m *EmployeesMutation) SetWithDisabilityVerified(b bool) {
	m._WithDisabilityVerified = &b
}

// WithDisabilityVerified returns the value of the "WithDisabilityVerified" field in the mutation.
func (m *EmployeesMutation) WithDisabilityVerified() (r bool, exists bool) {
	v := m._WithDisabilityVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldWithDisabilityVerified returns the old "WithDisabilityVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldWithDisabilityVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithDisabilityVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithDisabilityVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithDisabilityVerified: %w", err)
	}
	return oldValue.WithDisabilityVerified, nil
}

// ResetWithDisabilityVerified resets all changes to the "WithDisabilityVerified" field.
func (m *EmployeesMutation) ResetWithDisabilityVerified() {
	m._WithDisabilityVerified = nil
}

// SetWithDisabilityRemStatus sets the "WithDisabilityRemStatus" field.
func (m *EmployeesMutation) SetWithDisabilityRemStatus(b bool) {
	m._WithDisabilityRemStatus = &b
}

// WithDisabilityRemStatus returns the value of the "WithDisabilityRemStatus" field in the mutation.
func (m *EmployeesMutation) WithDisabilityRemStatus() (r bool, exists bool) {
	v := m._WithDisabilityRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldWithDisabilityRemStatus returns the old "WithDisabilityRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldWithDisabilityRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithDisabilityRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithDisabilityRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithDisabilityRemStatus: %w", err)
	}
	return oldValue.WithDisabilityRemStatus, nil
}

// ResetWithDisabilityRemStatus resets all changes to the "WithDisabilityRemStatus" field.
func (m *EmployeesMutation) ResetWithDisabilityRemStatus() {
	m._WithDisabilityRemStatus = nil
}

// SetWithDisabilityRemarks sets the "WithDisabilityRemarks" field.
func (m *EmployeesMutation) SetWithDisabilityRemarks(b bool) {
	m._WithDisabilityRemarks = &b
}

// WithDisabilityRemarks returns the value of the "WithDisabilityRemarks" field in the mutation.
func (m *EmployeesMutation) WithDisabilityRemarks() (r bool, exists bool) {
	v := m._WithDisabilityRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldWithDisabilityRemarks returns the old "WithDisabilityRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldWithDisabilityRemarks(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithDisabilityRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithDisabilityRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithDisabilityRemarks: %w", err)
	}
	return oldValue.WithDisabilityRemarks, nil
}

// ClearWithDisabilityRemarks clears the value of the "WithDisabilityRemarks" field.
func (m *EmployeesMutation) ClearWithDisabilityRemarks() {
	m._WithDisabilityRemarks = nil
	m.clearedFields[employees.FieldWithDisabilityRemarks] = struct{}{}
}

// WithDisabilityRemarksCleared returns if the "WithDisabilityRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) WithDisabilityRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldWithDisabilityRemarks]
	return ok
}

// ResetWithDisabilityRemarks resets all changes to the "WithDisabilityRemarks" field.
func (m *EmployeesMutation) ResetWithDisabilityRemarks() {
	m._WithDisabilityRemarks = nil
	delete(m.clearedFields, employees.FieldWithDisabilityRemarks)
}

// SetDisabilityType sets the "DisabilityType" field.
func (m *EmployeesMutation) SetDisabilityType(s string) {
	m._DisabilityType = &s
}

// DisabilityType returns the value of the "DisabilityType" field in the mutation.
func (m *EmployeesMutation) DisabilityType() (r string, exists bool) {
	v := m._DisabilityType
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityType returns the old "DisabilityType" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityType: %w", err)
	}
	return oldValue.DisabilityType, nil
}

// ClearDisabilityType clears the value of the "DisabilityType" field.
func (m *EmployeesMutation) ClearDisabilityType() {
	m._DisabilityType = nil
	m.clearedFields[employees.FieldDisabilityType] = struct{}{}
}

// DisabilityTypeCleared returns if the "DisabilityType" field was cleared in this mutation.
func (m *EmployeesMutation) DisabilityTypeCleared() bool {
	_, ok := m.clearedFields[employees.FieldDisabilityType]
	return ok
}

// ResetDisabilityType resets all changes to the "DisabilityType" field.
func (m *EmployeesMutation) ResetDisabilityType() {
	m._DisabilityType = nil
	delete(m.clearedFields, employees.FieldDisabilityType)
}

// SetDisabilityTypeVerified sets the "DisabilityTypeVerified" field.
func (m *EmployeesMutation) SetDisabilityTypeVerified(b bool) {
	m._DisabilityTypeVerified = &b
}

// DisabilityTypeVerified returns the value of the "DisabilityTypeVerified" field in the mutation.
func (m *EmployeesMutation) DisabilityTypeVerified() (r bool, exists bool) {
	v := m._DisabilityTypeVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityTypeVerified returns the old "DisabilityTypeVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityTypeVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityTypeVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityTypeVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityTypeVerified: %w", err)
	}
	return oldValue.DisabilityTypeVerified, nil
}

// ResetDisabilityTypeVerified resets all changes to the "DisabilityTypeVerified" field.
func (m *EmployeesMutation) ResetDisabilityTypeVerified() {
	m._DisabilityTypeVerified = nil
}

// SetDisabilityTypeRemStatus sets the "DisabilityTypeRemStatus" field.
func (m *EmployeesMutation) SetDisabilityTypeRemStatus(b bool) {
	m._DisabilityTypeRemStatus = &b
}

// DisabilityTypeRemStatus returns the value of the "DisabilityTypeRemStatus" field in the mutation.
func (m *EmployeesMutation) DisabilityTypeRemStatus() (r bool, exists bool) {
	v := m._DisabilityTypeRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityTypeRemStatus returns the old "DisabilityTypeRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityTypeRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityTypeRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityTypeRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityTypeRemStatus: %w", err)
	}
	return oldValue.DisabilityTypeRemStatus, nil
}

// ResetDisabilityTypeRemStatus resets all changes to the "DisabilityTypeRemStatus" field.
func (m *EmployeesMutation) ResetDisabilityTypeRemStatus() {
	m._DisabilityTypeRemStatus = nil
}

// SetDisabilityTypeRemarks sets the "DisabilityTypeRemarks" field.
func (m *EmployeesMutation) SetDisabilityTypeRemarks(s string) {
	m._DisabilityTypeRemarks = &s
}

// DisabilityTypeRemarks returns the value of the "DisabilityTypeRemarks" field in the mutation.
func (m *EmployeesMutation) DisabilityTypeRemarks() (r string, exists bool) {
	v := m._DisabilityTypeRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityTypeRemarks returns the old "DisabilityTypeRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityTypeRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityTypeRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityTypeRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityTypeRemarks: %w", err)
	}
	return oldValue.DisabilityTypeRemarks, nil
}

// ClearDisabilityTypeRemarks clears the value of the "DisabilityTypeRemarks" field.
func (m *EmployeesMutation) ClearDisabilityTypeRemarks() {
	m._DisabilityTypeRemarks = nil
	m.clearedFields[employees.FieldDisabilityTypeRemarks] = struct{}{}
}

// DisabilityTypeRemarksCleared returns if the "DisabilityTypeRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) DisabilityTypeRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldDisabilityTypeRemarks]
	return ok
}

// ResetDisabilityTypeRemarks resets all changes to the "DisabilityTypeRemarks" field.
func (m *EmployeesMutation) ResetDisabilityTypeRemarks() {
	m._DisabilityTypeRemarks = nil
	delete(m.clearedFields, employees.FieldDisabilityTypeRemarks)
}

// SetDisabilityPercentage sets the "DisabilityPercentage" field.
func (m *EmployeesMutation) SetDisabilityPercentage(i int32) {
	m._DisabilityPercentage = &i
	m.add_DisabilityPercentage = nil
}

// DisabilityPercentage returns the value of the "DisabilityPercentage" field in the mutation.
func (m *EmployeesMutation) DisabilityPercentage() (r int32, exists bool) {
	v := m._DisabilityPercentage
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityPercentage returns the old "DisabilityPercentage" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityPercentage(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityPercentage: %w", err)
	}
	return oldValue.DisabilityPercentage, nil
}

// AddDisabilityPercentage adds i to the "DisabilityPercentage" field.
func (m *EmployeesMutation) AddDisabilityPercentage(i int32) {
	if m.add_DisabilityPercentage != nil {
		*m.add_DisabilityPercentage += i
	} else {
		m.add_DisabilityPercentage = &i
	}
}

// AddedDisabilityPercentage returns the value that was added to the "DisabilityPercentage" field in this mutation.
func (m *EmployeesMutation) AddedDisabilityPercentage() (r int32, exists bool) {
	v := m.add_DisabilityPercentage
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisabilityPercentage clears the value of the "DisabilityPercentage" field.
func (m *EmployeesMutation) ClearDisabilityPercentage() {
	m._DisabilityPercentage = nil
	m.add_DisabilityPercentage = nil
	m.clearedFields[employees.FieldDisabilityPercentage] = struct{}{}
}

// DisabilityPercentageCleared returns if the "DisabilityPercentage" field was cleared in this mutation.
func (m *EmployeesMutation) DisabilityPercentageCleared() bool {
	_, ok := m.clearedFields[employees.FieldDisabilityPercentage]
	return ok
}

// ResetDisabilityPercentage resets all changes to the "DisabilityPercentage" field.
func (m *EmployeesMutation) ResetDisabilityPercentage() {
	m._DisabilityPercentage = nil
	m.add_DisabilityPercentage = nil
	delete(m.clearedFields, employees.FieldDisabilityPercentage)
}

// SetDisabilityPercentageVerified sets the "DisabilityPercentageVerified" field.
func (m *EmployeesMutation) SetDisabilityPercentageVerified(b bool) {
	m._DisabilityPercentageVerified = &b
}

// DisabilityPercentageVerified returns the value of the "DisabilityPercentageVerified" field in the mutation.
func (m *EmployeesMutation) DisabilityPercentageVerified() (r bool, exists bool) {
	v := m._DisabilityPercentageVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityPercentageVerified returns the old "DisabilityPercentageVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityPercentageVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityPercentageVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityPercentageVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityPercentageVerified: %w", err)
	}
	return oldValue.DisabilityPercentageVerified, nil
}

// ResetDisabilityPercentageVerified resets all changes to the "DisabilityPercentageVerified" field.
func (m *EmployeesMutation) ResetDisabilityPercentageVerified() {
	m._DisabilityPercentageVerified = nil
}

// SetDisabilityPercentageRemStatus sets the "DisabilityPercentageRemStatus" field.
func (m *EmployeesMutation) SetDisabilityPercentageRemStatus(b bool) {
	m._DisabilityPercentageRemStatus = &b
}

// DisabilityPercentageRemStatus returns the value of the "DisabilityPercentageRemStatus" field in the mutation.
func (m *EmployeesMutation) DisabilityPercentageRemStatus() (r bool, exists bool) {
	v := m._DisabilityPercentageRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityPercentageRemStatus returns the old "DisabilityPercentageRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityPercentageRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityPercentageRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityPercentageRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityPercentageRemStatus: %w", err)
	}
	return oldValue.DisabilityPercentageRemStatus, nil
}

// ResetDisabilityPercentageRemStatus resets all changes to the "DisabilityPercentageRemStatus" field.
func (m *EmployeesMutation) ResetDisabilityPercentageRemStatus() {
	m._DisabilityPercentageRemStatus = nil
}

// SetDisabilityPercentageRemarks sets the "DisabilityPercentageRemarks" field.
func (m *EmployeesMutation) SetDisabilityPercentageRemarks(s string) {
	m._DisabilityPercentageRemarks = &s
}

// DisabilityPercentageRemarks returns the value of the "DisabilityPercentageRemarks" field in the mutation.
func (m *EmployeesMutation) DisabilityPercentageRemarks() (r string, exists bool) {
	v := m._DisabilityPercentageRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityPercentageRemarks returns the old "DisabilityPercentageRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityPercentageRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityPercentageRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityPercentageRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityPercentageRemarks: %w", err)
	}
	return oldValue.DisabilityPercentageRemarks, nil
}

// ClearDisabilityPercentageRemarks clears the value of the "DisabilityPercentageRemarks" field.
func (m *EmployeesMutation) ClearDisabilityPercentageRemarks() {
	m._DisabilityPercentageRemarks = nil
	m.clearedFields[employees.FieldDisabilityPercentageRemarks] = struct{}{}
}

// DisabilityPercentageRemarksCleared returns if the "DisabilityPercentageRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) DisabilityPercentageRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldDisabilityPercentageRemarks]
	return ok
}

// ResetDisabilityPercentageRemarks resets all changes to the "DisabilityPercentageRemarks" field.
func (m *EmployeesMutation) ResetDisabilityPercentageRemarks() {
	m._DisabilityPercentageRemarks = nil
	delete(m.clearedFields, employees.FieldDisabilityPercentageRemarks)
}

// SetSignature sets the "Signature" field.
func (m *EmployeesMutation) SetSignature(s string) {
	m._Signature = &s
}

// Signature returns the value of the "Signature" field in the mutation.
func (m *EmployeesMutation) Signature() (r string, exists bool) {
	v := m._Signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "Signature" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ResetSignature resets all changes to the "Signature" field.
func (m *EmployeesMutation) ResetSignature() {
	m._Signature = nil
}

// SetSignatureVerified sets the "SignatureVerified" field.
func (m *EmployeesMutation) SetSignatureVerified(b bool) {
	m._SignatureVerified = &b
}

// SignatureVerified returns the value of the "SignatureVerified" field in the mutation.
func (m *EmployeesMutation) SignatureVerified() (r bool, exists bool) {
	v := m._SignatureVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldSignatureVerified returns the old "SignatureVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldSignatureVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignatureVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignatureVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignatureVerified: %w", err)
	}
	return oldValue.SignatureVerified, nil
}

// ResetSignatureVerified resets all changes to the "SignatureVerified" field.
func (m *EmployeesMutation) ResetSignatureVerified() {
	m._SignatureVerified = nil
}

// SetSignatureRemStatus sets the "SignatureRemStatus" field.
func (m *EmployeesMutation) SetSignatureRemStatus(b bool) {
	m._SignatureRemStatus = &b
}

// SignatureRemStatus returns the value of the "SignatureRemStatus" field in the mutation.
func (m *EmployeesMutation) SignatureRemStatus() (r bool, exists bool) {
	v := m._SignatureRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldSignatureRemStatus returns the old "SignatureRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldSignatureRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignatureRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignatureRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignatureRemStatus: %w", err)
	}
	return oldValue.SignatureRemStatus, nil
}

// ResetSignatureRemStatus resets all changes to the "SignatureRemStatus" field.
func (m *EmployeesMutation) ResetSignatureRemStatus() {
	m._SignatureRemStatus = nil
}

// SetSignatureRemarks sets the "SignatureRemarks" field.
func (m *EmployeesMutation) SetSignatureRemarks(s string) {
	m._SignatureRemarks = &s
}

// SignatureRemarks returns the value of the "SignatureRemarks" field in the mutation.
func (m *EmployeesMutation) SignatureRemarks() (r string, exists bool) {
	v := m._SignatureRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldSignatureRemarks returns the old "SignatureRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldSignatureRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignatureRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignatureRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignatureRemarks: %w", err)
	}
	return oldValue.SignatureRemarks, nil
}

// ClearSignatureRemarks clears the value of the "SignatureRemarks" field.
func (m *EmployeesMutation) ClearSignatureRemarks() {
	m._SignatureRemarks = nil
	m.clearedFields[employees.FieldSignatureRemarks] = struct{}{}
}

// SignatureRemarksCleared returns if the "SignatureRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) SignatureRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldSignatureRemarks]
	return ok
}

// ResetSignatureRemarks resets all changes to the "SignatureRemarks" field.
func (m *EmployeesMutation) ResetSignatureRemarks() {
	m._SignatureRemarks = nil
	delete(m.clearedFields, employees.FieldSignatureRemarks)
}

// SetPhoto sets the "Photo" field.
func (m *EmployeesMutation) SetPhoto(s string) {
	m._Photo = &s
}

// Photo returns the value of the "Photo" field in the mutation.
func (m *EmployeesMutation) Photo() (r string, exists bool) {
	v := m._Photo
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoto returns the old "Photo" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoto: %w", err)
	}
	return oldValue.Photo, nil
}

// ResetPhoto resets all changes to the "Photo" field.
func (m *EmployeesMutation) ResetPhoto() {
	m._Photo = nil
}

// SetPhotoVerified sets the "PhotoVerified" field.
func (m *EmployeesMutation) SetPhotoVerified(b bool) {
	m._PhotoVerified = &b
}

// PhotoVerified returns the value of the "PhotoVerified" field in the mutation.
func (m *EmployeesMutation) PhotoVerified() (r bool, exists bool) {
	v := m._PhotoVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoVerified returns the old "PhotoVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldPhotoVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoVerified: %w", err)
	}
	return oldValue.PhotoVerified, nil
}

// ResetPhotoVerified resets all changes to the "PhotoVerified" field.
func (m *EmployeesMutation) ResetPhotoVerified() {
	m._PhotoVerified = nil
}

// SetPhotoRemStatus sets the "PhotoRemStatus" field.
func (m *EmployeesMutation) SetPhotoRemStatus(b bool) {
	m._PhotoRemStatus = &b
}

// PhotoRemStatus returns the value of the "PhotoRemStatus" field in the mutation.
func (m *EmployeesMutation) PhotoRemStatus() (r bool, exists bool) {
	v := m._PhotoRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoRemStatus returns the old "PhotoRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldPhotoRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoRemStatus: %w", err)
	}
	return oldValue.PhotoRemStatus, nil
}

// ResetPhotoRemStatus resets all changes to the "PhotoRemStatus" field.
func (m *EmployeesMutation) ResetPhotoRemStatus() {
	m._PhotoRemStatus = nil
}

// SetPhotoRemarks sets the "PhotoRemarks" field.
func (m *EmployeesMutation) SetPhotoRemarks(s string) {
	m._PhotoRemarks = &s
}

// PhotoRemarks returns the value of the "PhotoRemarks" field in the mutation.
func (m *EmployeesMutation) PhotoRemarks() (r string, exists bool) {
	v := m._PhotoRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoRemarks returns the old "PhotoRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldPhotoRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoRemarks: %w", err)
	}
	return oldValue.PhotoRemarks, nil
}

// ClearPhotoRemarks clears the value of the "PhotoRemarks" field.
func (m *EmployeesMutation) ClearPhotoRemarks() {
	m._PhotoRemarks = nil
	m.clearedFields[employees.FieldPhotoRemarks] = struct{}{}
}

// PhotoRemarksCleared returns if the "PhotoRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) PhotoRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldPhotoRemarks]
	return ok
}

// ResetPhotoRemarks resets all changes to the "PhotoRemarks" field.
func (m *EmployeesMutation) ResetPhotoRemarks() {
	m._PhotoRemarks = nil
	delete(m.clearedFields, employees.FieldPhotoRemarks)
}

// SetCadreid sets the "Cadreid" field.
func (m *EmployeesMutation) SetCadreid(i int32) {
	m._Cadreid = &i
	m.add_Cadreid = nil
}

// Cadreid returns the value of the "Cadreid" field in the mutation.
func (m *EmployeesMutation) Cadreid() (r int32, exists bool) {
	v := m._Cadreid
	if v == nil {
		return
	}
	return *v, true
}

// OldCadreid returns the old "Cadreid" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldCadreid(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadreid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadreid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadreid: %w", err)
	}
	return oldValue.Cadreid, nil
}

// AddCadreid adds i to the "Cadreid" field.
func (m *EmployeesMutation) AddCadreid(i int32) {
	if m.add_Cadreid != nil {
		*m.add_Cadreid += i
	} else {
		m.add_Cadreid = &i
	}
}

// AddedCadreid returns the value that was added to the "Cadreid" field in this mutation.
func (m *EmployeesMutation) AddedCadreid() (r int32, exists bool) {
	v := m.add_Cadreid
	if v == nil {
		return
	}
	return *v, true
}

// ClearCadreid clears the value of the "Cadreid" field.
func (m *EmployeesMutation) ClearCadreid() {
	m._Cadreid = nil
	m.add_Cadreid = nil
	m.clearedFields[employees.FieldCadreid] = struct{}{}
}

// CadreidCleared returns if the "Cadreid" field was cleared in this mutation.
func (m *EmployeesMutation) CadreidCleared() bool {
	_, ok := m.clearedFields[employees.FieldCadreid]
	return ok
}

// ResetCadreid resets all changes to the "Cadreid" field.
func (m *EmployeesMutation) ResetCadreid() {
	m._Cadreid = nil
	m.add_Cadreid = nil
	delete(m.clearedFields, employees.FieldCadreid)
}

// SetEmployeeCadre sets the "EmployeeCadre" field.
func (m *EmployeesMutation) SetEmployeeCadre(s string) {
	m._EmployeeCadre = &s
}

// EmployeeCadre returns the value of the "EmployeeCadre" field in the mutation.
func (m *EmployeesMutation) EmployeeCadre() (r string, exists bool) {
	v := m._EmployeeCadre
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCadre returns the old "EmployeeCadre" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCadre: %w", err)
	}
	return oldValue.EmployeeCadre, nil
}

// ResetEmployeeCadre resets all changes to the "EmployeeCadre" field.
func (m *EmployeesMutation) ResetEmployeeCadre() {
	m._EmployeeCadre = nil
}

// SetEmployeeCadreVerified sets the "EmployeeCadreVerified" field.
func (m *EmployeesMutation) SetEmployeeCadreVerified(b bool) {
	m._EmployeeCadreVerified = &b
}

// EmployeeCadreVerified returns the value of the "EmployeeCadreVerified" field in the mutation.
func (m *EmployeesMutation) EmployeeCadreVerified() (r bool, exists bool) {
	v := m._EmployeeCadreVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCadreVerified returns the old "EmployeeCadreVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeCadreVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCadreVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCadreVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCadreVerified: %w", err)
	}
	return oldValue.EmployeeCadreVerified, nil
}

// ResetEmployeeCadreVerified resets all changes to the "EmployeeCadreVerified" field.
func (m *EmployeesMutation) ResetEmployeeCadreVerified() {
	m._EmployeeCadreVerified = nil
}

// SetEmployeeCadreRemStatus sets the "EmployeeCadreRemStatus" field.
func (m *EmployeesMutation) SetEmployeeCadreRemStatus(b bool) {
	m._EmployeeCadreRemStatus = &b
}

// EmployeeCadreRemStatus returns the value of the "EmployeeCadreRemStatus" field in the mutation.
func (m *EmployeesMutation) EmployeeCadreRemStatus() (r bool, exists bool) {
	v := m._EmployeeCadreRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCadreRemStatus returns the old "EmployeeCadreRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeCadreRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCadreRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCadreRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCadreRemStatus: %w", err)
	}
	return oldValue.EmployeeCadreRemStatus, nil
}

// ResetEmployeeCadreRemStatus resets all changes to the "EmployeeCadreRemStatus" field.
func (m *EmployeesMutation) ResetEmployeeCadreRemStatus() {
	m._EmployeeCadreRemStatus = nil
}

// SetEmployeeCadreRemarks sets the "EmployeeCadreRemarks" field.
func (m *EmployeesMutation) SetEmployeeCadreRemarks(s string) {
	m._EmployeeCadreRemarks = &s
}

// EmployeeCadreRemarks returns the value of the "EmployeeCadreRemarks" field in the mutation.
func (m *EmployeesMutation) EmployeeCadreRemarks() (r string, exists bool) {
	v := m._EmployeeCadreRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCadreRemarks returns the old "EmployeeCadreRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeCadreRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCadreRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCadreRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCadreRemarks: %w", err)
	}
	return oldValue.EmployeeCadreRemarks, nil
}

// ClearEmployeeCadreRemarks clears the value of the "EmployeeCadreRemarks" field.
func (m *EmployeesMutation) ClearEmployeeCadreRemarks() {
	m._EmployeeCadreRemarks = nil
	m.clearedFields[employees.FieldEmployeeCadreRemarks] = struct{}{}
}

// EmployeeCadreRemarksCleared returns if the "EmployeeCadreRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) EmployeeCadreRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldEmployeeCadreRemarks]
	return ok
}

// ResetEmployeeCadreRemarks resets all changes to the "EmployeeCadreRemarks" field.
func (m *EmployeesMutation) ResetEmployeeCadreRemarks() {
	m._EmployeeCadreRemarks = nil
	delete(m.clearedFields, employees.FieldEmployeeCadreRemarks)
}

// SetDesignationID sets the "DesignationID" field.
func (m *EmployeesMutation) SetDesignationID(i int32) {
	m._DesignationID = &i
	m.add_DesignationID = nil
}

// DesignationID returns the value of the "DesignationID" field in the mutation.
func (m *EmployeesMutation) DesignationID() (r int32, exists bool) {
	v := m._DesignationID
	if v == nil {
		return
	}
	return *v, true
}

// OldDesignationID returns the old "DesignationID" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDesignationID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesignationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesignationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesignationID: %w", err)
	}
	return oldValue.DesignationID, nil
}

// AddDesignationID adds i to the "DesignationID" field.
func (m *EmployeesMutation) AddDesignationID(i int32) {
	if m.add_DesignationID != nil {
		*m.add_DesignationID += i
	} else {
		m.add_DesignationID = &i
	}
}

// AddedDesignationID returns the value that was added to the "DesignationID" field in this mutation.
func (m *EmployeesMutation) AddedDesignationID() (r int32, exists bool) {
	v := m.add_DesignationID
	if v == nil {
		return
	}
	return *v, true
}

// ClearDesignationID clears the value of the "DesignationID" field.
func (m *EmployeesMutation) ClearDesignationID() {
	m._DesignationID = nil
	m.add_DesignationID = nil
	m.clearedFields[employees.FieldDesignationID] = struct{}{}
}

// DesignationIDCleared returns if the "DesignationID" field was cleared in this mutation.
func (m *EmployeesMutation) DesignationIDCleared() bool {
	_, ok := m.clearedFields[employees.FieldDesignationID]
	return ok
}

// ResetDesignationID resets all changes to the "DesignationID" field.
func (m *EmployeesMutation) ResetDesignationID() {
	m._DesignationID = nil
	m.add_DesignationID = nil
	delete(m.clearedFields, employees.FieldDesignationID)
}

// SetEmployeeDesignation sets the "EmployeeDesignation" field.
func (m *EmployeesMutation) SetEmployeeDesignation(s string) {
	m._EmployeeDesignation = &s
}

// EmployeeDesignation returns the value of the "EmployeeDesignation" field in the mutation.
func (m *EmployeesMutation) EmployeeDesignation() (r string, exists bool) {
	v := m._EmployeeDesignation
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeDesignation returns the old "EmployeeDesignation" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeDesignation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeDesignation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeDesignation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeDesignation: %w", err)
	}
	return oldValue.EmployeeDesignation, nil
}

// ResetEmployeeDesignation resets all changes to the "EmployeeDesignation" field.
func (m *EmployeesMutation) ResetEmployeeDesignation() {
	m._EmployeeDesignation = nil
}

// SetEmployeeDesignationVerified sets the "EmployeeDesignationVerified" field.
func (m *EmployeesMutation) SetEmployeeDesignationVerified(b bool) {
	m._EmployeeDesignationVerified = &b
}

// EmployeeDesignationVerified returns the value of the "EmployeeDesignationVerified" field in the mutation.
func (m *EmployeesMutation) EmployeeDesignationVerified() (r bool, exists bool) {
	v := m._EmployeeDesignationVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeDesignationVerified returns the old "EmployeeDesignationVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeDesignationVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeDesignationVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeDesignationVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeDesignationVerified: %w", err)
	}
	return oldValue.EmployeeDesignationVerified, nil
}

// ResetEmployeeDesignationVerified resets all changes to the "EmployeeDesignationVerified" field.
func (m *EmployeesMutation) ResetEmployeeDesignationVerified() {
	m._EmployeeDesignationVerified = nil
}

// SetEmployeeDesignationRemStatus sets the "EmployeeDesignationRemStatus" field.
func (m *EmployeesMutation) SetEmployeeDesignationRemStatus(b bool) {
	m._EmployeeDesignationRemStatus = &b
}

// EmployeeDesignationRemStatus returns the value of the "EmployeeDesignationRemStatus" field in the mutation.
func (m *EmployeesMutation) EmployeeDesignationRemStatus() (r bool, exists bool) {
	v := m._EmployeeDesignationRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeDesignationRemStatus returns the old "EmployeeDesignationRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeDesignationRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeDesignationRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeDesignationRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeDesignationRemStatus: %w", err)
	}
	return oldValue.EmployeeDesignationRemStatus, nil
}

// ResetEmployeeDesignationRemStatus resets all changes to the "EmployeeDesignationRemStatus" field.
func (m *EmployeesMutation) ResetEmployeeDesignationRemStatus() {
	m._EmployeeDesignationRemStatus = nil
}

// SetEmployeeDesignationRemarks sets the "EmployeeDesignationRemarks" field.
func (m *EmployeesMutation) SetEmployeeDesignationRemarks(s string) {
	m._EmployeeDesignationRemarks = &s
}

// EmployeeDesignationRemarks returns the value of the "EmployeeDesignationRemarks" field in the mutation.
func (m *EmployeesMutation) EmployeeDesignationRemarks() (r string, exists bool) {
	v := m._EmployeeDesignationRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeDesignationRemarks returns the old "EmployeeDesignationRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeDesignationRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeDesignationRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeDesignationRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeDesignationRemarks: %w", err)
	}
	return oldValue.EmployeeDesignationRemarks, nil
}

// ClearEmployeeDesignationRemarks clears the value of the "EmployeeDesignationRemarks" field.
func (m *EmployeesMutation) ClearEmployeeDesignationRemarks() {
	m._EmployeeDesignationRemarks = nil
	m.clearedFields[employees.FieldEmployeeDesignationRemarks] = struct{}{}
}

// EmployeeDesignationRemarksCleared returns if the "EmployeeDesignationRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) EmployeeDesignationRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldEmployeeDesignationRemarks]
	return ok
}

// ResetEmployeeDesignationRemarks resets all changes to the "EmployeeDesignationRemarks" field.
func (m *EmployeesMutation) ResetEmployeeDesignationRemarks() {
	m._EmployeeDesignationRemarks = nil
	delete(m.clearedFields, employees.FieldEmployeeDesignationRemarks)
}

// SetCircleID sets the "CircleID" field.
func (m *EmployeesMutation) SetCircleID(i int32) {
	m._CircleID = &i
	m.add_CircleID = nil
}

// CircleID returns the value of the "CircleID" field in the mutation.
func (m *EmployeesMutation) CircleID() (r int32, exists bool) {
	v := m._CircleID
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleID returns the old "CircleID" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldCircleID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleID: %w", err)
	}
	return oldValue.CircleID, nil
}

// AddCircleID adds i to the "CircleID" field.
func (m *EmployeesMutation) AddCircleID(i int32) {
	if m.add_CircleID != nil {
		*m.add_CircleID += i
	} else {
		m.add_CircleID = &i
	}
}

// AddedCircleID returns the value that was added to the "CircleID" field in this mutation.
func (m *EmployeesMutation) AddedCircleID() (r int32, exists bool) {
	v := m.add_CircleID
	if v == nil {
		return
	}
	return *v, true
}

// ClearCircleID clears the value of the "CircleID" field.
func (m *EmployeesMutation) ClearCircleID() {
	m._CircleID = nil
	m.add_CircleID = nil
	m.clearedFields[employees.FieldCircleID] = struct{}{}
}

// CircleIDCleared returns if the "CircleID" field was cleared in this mutation.
func (m *EmployeesMutation) CircleIDCleared() bool {
	_, ok := m.clearedFields[employees.FieldCircleID]
	return ok
}

// ResetCircleID resets all changes to the "CircleID" field.
func (m *EmployeesMutation) ResetCircleID() {
	m._CircleID = nil
	m.add_CircleID = nil
	delete(m.clearedFields, employees.FieldCircleID)
}

// SetCircleName sets the "CircleName" field.
func (m *EmployeesMutation) SetCircleName(s string) {
	m._CircleName = &s
}

// CircleName returns the value of the "CircleName" field in the mutation.
func (m *EmployeesMutation) CircleName() (r string, exists bool) {
	v := m._CircleName
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleName returns the old "CircleName" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldCircleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleName: %w", err)
	}
	return oldValue.CircleName, nil
}

// ResetCircleName resets all changes to the "CircleName" field.
func (m *EmployeesMutation) ResetCircleName() {
	m._CircleName = nil
}

// SetCircleVerified sets the "CircleVerified" field.
func (m *EmployeesMutation) SetCircleVerified(b bool) {
	m._CircleVerified = &b
}

// CircleVerified returns the value of the "CircleVerified" field in the mutation.
func (m *EmployeesMutation) CircleVerified() (r bool, exists bool) {
	v := m._CircleVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleVerified returns the old "CircleVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldCircleVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleVerified: %w", err)
	}
	return oldValue.CircleVerified, nil
}

// ResetCircleVerified resets all changes to the "CircleVerified" field.
func (m *EmployeesMutation) ResetCircleVerified() {
	m._CircleVerified = nil
}

// SetCircleRemStatus sets the "CircleRemStatus" field.
func (m *EmployeesMutation) SetCircleRemStatus(b bool) {
	m._CircleRemStatus = &b
}

// CircleRemStatus returns the value of the "CircleRemStatus" field in the mutation.
func (m *EmployeesMutation) CircleRemStatus() (r bool, exists bool) {
	v := m._CircleRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleRemStatus returns the old "CircleRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldCircleRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleRemStatus: %w", err)
	}
	return oldValue.CircleRemStatus, nil
}

// ResetCircleRemStatus resets all changes to the "CircleRemStatus" field.
func (m *EmployeesMutation) ResetCircleRemStatus() {
	m._CircleRemStatus = nil
}

// SetCircleRemarks sets the "CircleRemarks" field.
func (m *EmployeesMutation) SetCircleRemarks(s string) {
	m._CircleRemarks = &s
}

// CircleRemarks returns the value of the "CircleRemarks" field in the mutation.
func (m *EmployeesMutation) CircleRemarks() (r string, exists bool) {
	v := m._CircleRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleRemarks returns the old "CircleRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldCircleRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleRemarks: %w", err)
	}
	return oldValue.CircleRemarks, nil
}

// ClearCircleRemarks clears the value of the "CircleRemarks" field.
func (m *EmployeesMutation) ClearCircleRemarks() {
	m._CircleRemarks = nil
	m.clearedFields[employees.FieldCircleRemarks] = struct{}{}
}

// CircleRemarksCleared returns if the "CircleRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) CircleRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldCircleRemarks]
	return ok
}

// ResetCircleRemarks resets all changes to the "CircleRemarks" field.
func (m *EmployeesMutation) ResetCircleRemarks() {
	m._CircleRemarks = nil
	delete(m.clearedFields, employees.FieldCircleRemarks)
}

// SetRegionID sets the "RegionID" field.
func (m *EmployeesMutation) SetRegionID(i int32) {
	m._RegionID = &i
	m.add_RegionID = nil
}

// RegionID returns the value of the "RegionID" field in the mutation.
func (m *EmployeesMutation) RegionID() (r int32, exists bool) {
	v := m._RegionID
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionID returns the old "RegionID" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRegionID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionID: %w", err)
	}
	return oldValue.RegionID, nil
}

// AddRegionID adds i to the "RegionID" field.
func (m *EmployeesMutation) AddRegionID(i int32) {
	if m.add_RegionID != nil {
		*m.add_RegionID += i
	} else {
		m.add_RegionID = &i
	}
}

// AddedRegionID returns the value that was added to the "RegionID" field in this mutation.
func (m *EmployeesMutation) AddedRegionID() (r int32, exists bool) {
	v := m.add_RegionID
	if v == nil {
		return
	}
	return *v, true
}

// ClearRegionID clears the value of the "RegionID" field.
func (m *EmployeesMutation) ClearRegionID() {
	m._RegionID = nil
	m.add_RegionID = nil
	m.clearedFields[employees.FieldRegionID] = struct{}{}
}

// RegionIDCleared returns if the "RegionID" field was cleared in this mutation.
func (m *EmployeesMutation) RegionIDCleared() bool {
	_, ok := m.clearedFields[employees.FieldRegionID]
	return ok
}

// ResetRegionID resets all changes to the "RegionID" field.
func (m *EmployeesMutation) ResetRegionID() {
	m._RegionID = nil
	m.add_RegionID = nil
	delete(m.clearedFields, employees.FieldRegionID)
}

// SetRegionName sets the "RegionName" field.
func (m *EmployeesMutation) SetRegionName(s string) {
	m._RegionName = &s
}

// RegionName returns the value of the "RegionName" field in the mutation.
func (m *EmployeesMutation) RegionName() (r string, exists bool) {
	v := m._RegionName
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionName returns the old "RegionName" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRegionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionName: %w", err)
	}
	return oldValue.RegionName, nil
}

// ResetRegionName resets all changes to the "RegionName" field.
func (m *EmployeesMutation) ResetRegionName() {
	m._RegionName = nil
}

// SetRegionVerified sets the "RegionVerified" field.
func (m *EmployeesMutation) SetRegionVerified(b bool) {
	m._RegionVerified = &b
}

// RegionVerified returns the value of the "RegionVerified" field in the mutation.
func (m *EmployeesMutation) RegionVerified() (r bool, exists bool) {
	v := m._RegionVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionVerified returns the old "RegionVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRegionVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionVerified: %w", err)
	}
	return oldValue.RegionVerified, nil
}

// ResetRegionVerified resets all changes to the "RegionVerified" field.
func (m *EmployeesMutation) ResetRegionVerified() {
	m._RegionVerified = nil
}

// SetRegionRemStatus sets the "RegionRemStatus" field.
func (m *EmployeesMutation) SetRegionRemStatus(b bool) {
	m._RegionRemStatus = &b
}

// RegionRemStatus returns the value of the "RegionRemStatus" field in the mutation.
func (m *EmployeesMutation) RegionRemStatus() (r bool, exists bool) {
	v := m._RegionRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionRemStatus returns the old "RegionRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRegionRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionRemStatus: %w", err)
	}
	return oldValue.RegionRemStatus, nil
}

// ResetRegionRemStatus resets all changes to the "RegionRemStatus" field.
func (m *EmployeesMutation) ResetRegionRemStatus() {
	m._RegionRemStatus = nil
}

// SetRegionRemarks sets the "RegionRemarks" field.
func (m *EmployeesMutation) SetRegionRemarks(s string) {
	m._RegionRemarks = &s
}

// RegionRemarks returns the value of the "RegionRemarks" field in the mutation.
func (m *EmployeesMutation) RegionRemarks() (r string, exists bool) {
	v := m._RegionRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionRemarks returns the old "RegionRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRegionRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionRemarks: %w", err)
	}
	return oldValue.RegionRemarks, nil
}

// ClearRegionRemarks clears the value of the "RegionRemarks" field.
func (m *EmployeesMutation) ClearRegionRemarks() {
	m._RegionRemarks = nil
	m.clearedFields[employees.FieldRegionRemarks] = struct{}{}
}

// RegionRemarksCleared returns if the "RegionRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) RegionRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldRegionRemarks]
	return ok
}

// ResetRegionRemarks resets all changes to the "RegionRemarks" field.
func (m *EmployeesMutation) ResetRegionRemarks() {
	m._RegionRemarks = nil
	delete(m.clearedFields, employees.FieldRegionRemarks)
}

// SetDivisionID sets the "DivisionID" field.
func (m *EmployeesMutation) SetDivisionID(i int32) {
	m._DivisionID = &i
	m.add_DivisionID = nil
}

// DivisionID returns the value of the "DivisionID" field in the mutation.
func (m *EmployeesMutation) DivisionID() (r int32, exists bool) {
	v := m._DivisionID
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionID returns the old "DivisionID" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDivisionID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionID: %w", err)
	}
	return oldValue.DivisionID, nil
}

// AddDivisionID adds i to the "DivisionID" field.
func (m *EmployeesMutation) AddDivisionID(i int32) {
	if m.add_DivisionID != nil {
		*m.add_DivisionID += i
	} else {
		m.add_DivisionID = &i
	}
}

// AddedDivisionID returns the value that was added to the "DivisionID" field in this mutation.
func (m *EmployeesMutation) AddedDivisionID() (r int32, exists bool) {
	v := m.add_DivisionID
	if v == nil {
		return
	}
	return *v, true
}

// ClearDivisionID clears the value of the "DivisionID" field.
func (m *EmployeesMutation) ClearDivisionID() {
	m._DivisionID = nil
	m.add_DivisionID = nil
	m.clearedFields[employees.FieldDivisionID] = struct{}{}
}

// DivisionIDCleared returns if the "DivisionID" field was cleared in this mutation.
func (m *EmployeesMutation) DivisionIDCleared() bool {
	_, ok := m.clearedFields[employees.FieldDivisionID]
	return ok
}

// ResetDivisionID resets all changes to the "DivisionID" field.
func (m *EmployeesMutation) ResetDivisionID() {
	m._DivisionID = nil
	m.add_DivisionID = nil
	delete(m.clearedFields, employees.FieldDivisionID)
}

// SetDivisionName sets the "DivisionName" field.
func (m *EmployeesMutation) SetDivisionName(s string) {
	m._DivisionName = &s
}

// DivisionName returns the value of the "DivisionName" field in the mutation.
func (m *EmployeesMutation) DivisionName() (r string, exists bool) {
	v := m._DivisionName
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionName returns the old "DivisionName" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDivisionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionName: %w", err)
	}
	return oldValue.DivisionName, nil
}

// ResetDivisionName resets all changes to the "DivisionName" field.
func (m *EmployeesMutation) ResetDivisionName() {
	m._DivisionName = nil
}

// SetDivisionVerified sets the "DivisionVerified" field.
func (m *EmployeesMutation) SetDivisionVerified(b bool) {
	m._DivisionVerified = &b
}

// DivisionVerified returns the value of the "DivisionVerified" field in the mutation.
func (m *EmployeesMutation) DivisionVerified() (r bool, exists bool) {
	v := m._DivisionVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionVerified returns the old "DivisionVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDivisionVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionVerified: %w", err)
	}
	return oldValue.DivisionVerified, nil
}

// ResetDivisionVerified resets all changes to the "DivisionVerified" field.
func (m *EmployeesMutation) ResetDivisionVerified() {
	m._DivisionVerified = nil
}

// SetDivisionRemStatus sets the "DivisionRemStatus" field.
func (m *EmployeesMutation) SetDivisionRemStatus(b bool) {
	m._DivisionRemStatus = &b
}

// DivisionRemStatus returns the value of the "DivisionRemStatus" field in the mutation.
func (m *EmployeesMutation) DivisionRemStatus() (r bool, exists bool) {
	v := m._DivisionRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionRemStatus returns the old "DivisionRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDivisionRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionRemStatus: %w", err)
	}
	return oldValue.DivisionRemStatus, nil
}

// ResetDivisionRemStatus resets all changes to the "DivisionRemStatus" field.
func (m *EmployeesMutation) ResetDivisionRemStatus() {
	m._DivisionRemStatus = nil
}

// SetDivisionRemarks sets the "DivisionRemarks" field.
func (m *EmployeesMutation) SetDivisionRemarks(s string) {
	m._DivisionRemarks = &s
}

// DivisionRemarks returns the value of the "DivisionRemarks" field in the mutation.
func (m *EmployeesMutation) DivisionRemarks() (r string, exists bool) {
	v := m._DivisionRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionRemarks returns the old "DivisionRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDivisionRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionRemarks: %w", err)
	}
	return oldValue.DivisionRemarks, nil
}

// ResetDivisionRemarks resets all changes to the "DivisionRemarks" field.
func (m *EmployeesMutation) ResetDivisionRemarks() {
	m._DivisionRemarks = nil
}

// SetOfficeID sets the "OfficeID" field.
func (m *EmployeesMutation) SetOfficeID(i int32) {
	m._OfficeID = &i
	m.add_OfficeID = nil
}

// OfficeID returns the value of the "OfficeID" field in the mutation.
func (m *EmployeesMutation) OfficeID() (r int32, exists bool) {
	v := m._OfficeID
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeID returns the old "OfficeID" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldOfficeID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeID: %w", err)
	}
	return oldValue.OfficeID, nil
}

// AddOfficeID adds i to the "OfficeID" field.
func (m *EmployeesMutation) AddOfficeID(i int32) {
	if m.add_OfficeID != nil {
		*m.add_OfficeID += i
	} else {
		m.add_OfficeID = &i
	}
}

// AddedOfficeID returns the value that was added to the "OfficeID" field in this mutation.
func (m *EmployeesMutation) AddedOfficeID() (r int32, exists bool) {
	v := m.add_OfficeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearOfficeID clears the value of the "OfficeID" field.
func (m *EmployeesMutation) ClearOfficeID() {
	m._OfficeID = nil
	m.add_OfficeID = nil
	m.clearedFields[employees.FieldOfficeID] = struct{}{}
}

// OfficeIDCleared returns if the "OfficeID" field was cleared in this mutation.
func (m *EmployeesMutation) OfficeIDCleared() bool {
	_, ok := m.clearedFields[employees.FieldOfficeID]
	return ok
}

// ResetOfficeID resets all changes to the "OfficeID" field.
func (m *EmployeesMutation) ResetOfficeID() {
	m._OfficeID = nil
	m.add_OfficeID = nil
	delete(m.clearedFields, employees.FieldOfficeID)
}

// SetOfficeName sets the "OfficeName" field.
func (m *EmployeesMutation) SetOfficeName(s string) {
	m._OfficeName = &s
}

// OfficeName returns the value of the "OfficeName" field in the mutation.
func (m *EmployeesMutation) OfficeName() (r string, exists bool) {
	v := m._OfficeName
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeName returns the old "OfficeName" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldOfficeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeName: %w", err)
	}
	return oldValue.OfficeName, nil
}

// ResetOfficeName resets all changes to the "OfficeName" field.
func (m *EmployeesMutation) ResetOfficeName() {
	m._OfficeName = nil
}

// SetOfficeVerified sets the "OfficeVerified" field.
func (m *EmployeesMutation) SetOfficeVerified(b bool) {
	m._OfficeVerified = &b
}

// OfficeVerified returns the value of the "OfficeVerified" field in the mutation.
func (m *EmployeesMutation) OfficeVerified() (r bool, exists bool) {
	v := m._OfficeVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeVerified returns the old "OfficeVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldOfficeVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeVerified: %w", err)
	}
	return oldValue.OfficeVerified, nil
}

// ResetOfficeVerified resets all changes to the "OfficeVerified" field.
func (m *EmployeesMutation) ResetOfficeVerified() {
	m._OfficeVerified = nil
}

// SetOfficeRemStatus sets the "OfficeRemStatus" field.
func (m *EmployeesMutation) SetOfficeRemStatus(b bool) {
	m._OfficeRemStatus = &b
}

// OfficeRemStatus returns the value of the "OfficeRemStatus" field in the mutation.
func (m *EmployeesMutation) OfficeRemStatus() (r bool, exists bool) {
	v := m._OfficeRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeRemStatus returns the old "OfficeRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldOfficeRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeRemStatus: %w", err)
	}
	return oldValue.OfficeRemStatus, nil
}

// ResetOfficeRemStatus resets all changes to the "OfficeRemStatus" field.
func (m *EmployeesMutation) ResetOfficeRemStatus() {
	m._OfficeRemStatus = nil
}

// SetOfficeRemarks sets the "OfficeRemarks" field.
func (m *EmployeesMutation) SetOfficeRemarks(s string) {
	m._OfficeRemarks = &s
}

// OfficeRemarks returns the value of the "OfficeRemarks" field in the mutation.
func (m *EmployeesMutation) OfficeRemarks() (r string, exists bool) {
	v := m._OfficeRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeRemarks returns the old "OfficeRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldOfficeRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeRemarks: %w", err)
	}
	return oldValue.OfficeRemarks, nil
}

// ClearOfficeRemarks clears the value of the "OfficeRemarks" field.
func (m *EmployeesMutation) ClearOfficeRemarks() {
	m._OfficeRemarks = nil
	m.clearedFields[employees.FieldOfficeRemarks] = struct{}{}
}

// OfficeRemarksCleared returns if the "OfficeRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) OfficeRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldOfficeRemarks]
	return ok
}

// ResetOfficeRemarks resets all changes to the "OfficeRemarks" field.
func (m *EmployeesMutation) ResetOfficeRemarks() {
	m._OfficeRemarks = nil
	delete(m.clearedFields, employees.FieldOfficeRemarks)
}

// SetRole sets the "Role" field.
func (m *EmployeesMutation) SetRole(s string) {
	m._Role = &s
}

// Role returns the value of the "Role" field in the mutation.
func (m *EmployeesMutation) Role() (r string, exists bool) {
	v := m._Role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "Role" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "Role" field.
func (m *EmployeesMutation) ResetRole() {
	m._Role = nil
}

// SetRoleVerified sets the "RoleVerified" field.
func (m *EmployeesMutation) SetRoleVerified(b bool) {
	m._RoleVerified = &b
}

// RoleVerified returns the value of the "RoleVerified" field in the mutation.
func (m *EmployeesMutation) RoleVerified() (r bool, exists bool) {
	v := m._RoleVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleVerified returns the old "RoleVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRoleVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleVerified: %w", err)
	}
	return oldValue.RoleVerified, nil
}

// ResetRoleVerified resets all changes to the "RoleVerified" field.
func (m *EmployeesMutation) ResetRoleVerified() {
	m._RoleVerified = nil
}

// SetRoleRemStatus sets the "RoleRemStatus" field.
func (m *EmployeesMutation) SetRoleRemStatus(b bool) {
	m._RoleRemStatus = &b
}

// RoleRemStatus returns the value of the "RoleRemStatus" field in the mutation.
func (m *EmployeesMutation) RoleRemStatus() (r bool, exists bool) {
	v := m._RoleRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleRemStatus returns the old "RoleRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRoleRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleRemStatus: %w", err)
	}
	return oldValue.RoleRemStatus, nil
}

// ResetRoleRemStatus resets all changes to the "RoleRemStatus" field.
func (m *EmployeesMutation) ResetRoleRemStatus() {
	m._RoleRemStatus = nil
}

// SetRoleRemarks sets the "RoleRemarks" field.
func (m *EmployeesMutation) SetRoleRemarks(s string) {
	m._RoleRemarks = &s
}

// RoleRemarks returns the value of the "RoleRemarks" field in the mutation.
func (m *EmployeesMutation) RoleRemarks() (r string, exists bool) {
	v := m._RoleRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleRemarks returns the old "RoleRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRoleRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleRemarks: %w", err)
	}
	return oldValue.RoleRemarks, nil
}

// ResetRoleRemarks resets all changes to the "RoleRemarks" field.
func (m *EmployeesMutation) ResetRoleRemarks() {
	m._RoleRemarks = nil
}

// SetDCCS sets the "DCCS" field.
func (m *EmployeesMutation) SetDCCS(t time.Time) {
	m._DCCS = &t
}

// DCCS returns the value of the "DCCS" field in the mutation.
func (m *EmployeesMutation) DCCS() (r time.Time, exists bool) {
	v := m._DCCS
	if v == nil {
		return
	}
	return *v, true
}

// OldDCCS returns the old "DCCS" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCCS(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCCS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCCS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCCS: %w", err)
	}
	return oldValue.DCCS, nil
}

// ResetDCCS resets all changes to the "DCCS" field.
func (m *EmployeesMutation) ResetDCCS() {
	m._DCCS = nil
}

// SetDCCSVerified sets the "DCCSVerified" field.
func (m *EmployeesMutation) SetDCCSVerified(b bool) {
	m._DCCSVerified = &b
}

// DCCSVerified returns the value of the "DCCSVerified" field in the mutation.
func (m *EmployeesMutation) DCCSVerified() (r bool, exists bool) {
	v := m._DCCSVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldDCCSVerified returns the old "DCCSVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCCSVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCCSVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCCSVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCCSVerified: %w", err)
	}
	return oldValue.DCCSVerified, nil
}

// ResetDCCSVerified resets all changes to the "DCCSVerified" field.
func (m *EmployeesMutation) ResetDCCSVerified() {
	m._DCCSVerified = nil
}

// SetDCCSRemStatus sets the "DCCSRemStatus" field.
func (m *EmployeesMutation) SetDCCSRemStatus(b bool) {
	m._DCCSRemStatus = &b
}

// DCCSRemStatus returns the value of the "DCCSRemStatus" field in the mutation.
func (m *EmployeesMutation) DCCSRemStatus() (r bool, exists bool) {
	v := m._DCCSRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldDCCSRemStatus returns the old "DCCSRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCCSRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCCSRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCCSRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCCSRemStatus: %w", err)
	}
	return oldValue.DCCSRemStatus, nil
}

// ResetDCCSRemStatus resets all changes to the "DCCSRemStatus" field.
func (m *EmployeesMutation) ResetDCCSRemStatus() {
	m._DCCSRemStatus = nil
}

// SetDCCSRemarks sets the "DCCSRemarks" field.
func (m *EmployeesMutation) SetDCCSRemarks(s string) {
	m._DCCSRemarks = &s
}

// DCCSRemarks returns the value of the "DCCSRemarks" field in the mutation.
func (m *EmployeesMutation) DCCSRemarks() (r string, exists bool) {
	v := m._DCCSRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldDCCSRemarks returns the old "DCCSRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCCSRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCCSRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCCSRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCCSRemarks: %w", err)
	}
	return oldValue.DCCSRemarks, nil
}

// ClearDCCSRemarks clears the value of the "DCCSRemarks" field.
func (m *EmployeesMutation) ClearDCCSRemarks() {
	m._DCCSRemarks = nil
	m.clearedFields[employees.FieldDCCSRemarks] = struct{}{}
}

// DCCSRemarksCleared returns if the "DCCSRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) DCCSRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldDCCSRemarks]
	return ok
}

// ResetDCCSRemarks resets all changes to the "DCCSRemarks" field.
func (m *EmployeesMutation) ResetDCCSRemarks() {
	m._DCCSRemarks = nil
	delete(m.clearedFields, employees.FieldDCCSRemarks)
}

// SetDCInPresentCadre sets the "DCInPresentCadre" field.
func (m *EmployeesMutation) SetDCInPresentCadre(t time.Time) {
	m._DCInPresentCadre = &t
}

// DCInPresentCadre returns the value of the "DCInPresentCadre" field in the mutation.
func (m *EmployeesMutation) DCInPresentCadre() (r time.Time, exists bool) {
	v := m._DCInPresentCadre
	if v == nil {
		return
	}
	return *v, true
}

// OldDCInPresentCadre returns the old "DCInPresentCadre" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCInPresentCadre(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCInPresentCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCInPresentCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCInPresentCadre: %w", err)
	}
	return oldValue.DCInPresentCadre, nil
}

// ResetDCInPresentCadre resets all changes to the "DCInPresentCadre" field.
func (m *EmployeesMutation) ResetDCInPresentCadre() {
	m._DCInPresentCadre = nil
}

// SetDCInPresentCadreVerified sets the "DCInPresentCadreVerified" field.
func (m *EmployeesMutation) SetDCInPresentCadreVerified(b bool) {
	m._DCInPresentCadreVerified = &b
}

// DCInPresentCadreVerified returns the value of the "DCInPresentCadreVerified" field in the mutation.
func (m *EmployeesMutation) DCInPresentCadreVerified() (r bool, exists bool) {
	v := m._DCInPresentCadreVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldDCInPresentCadreVerified returns the old "DCInPresentCadreVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCInPresentCadreVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCInPresentCadreVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCInPresentCadreVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCInPresentCadreVerified: %w", err)
	}
	return oldValue.DCInPresentCadreVerified, nil
}

// ResetDCInPresentCadreVerified resets all changes to the "DCInPresentCadreVerified" field.
func (m *EmployeesMutation) ResetDCInPresentCadreVerified() {
	m._DCInPresentCadreVerified = nil
}

// SetDCInPresentCadreRemStatus sets the "DCInPresentCadreRemStatus" field.
func (m *EmployeesMutation) SetDCInPresentCadreRemStatus(b bool) {
	m._DCInPresentCadreRemStatus = &b
}

// DCInPresentCadreRemStatus returns the value of the "DCInPresentCadreRemStatus" field in the mutation.
func (m *EmployeesMutation) DCInPresentCadreRemStatus() (r bool, exists bool) {
	v := m._DCInPresentCadreRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldDCInPresentCadreRemStatus returns the old "DCInPresentCadreRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCInPresentCadreRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCInPresentCadreRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCInPresentCadreRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCInPresentCadreRemStatus: %w", err)
	}
	return oldValue.DCInPresentCadreRemStatus, nil
}

// ResetDCInPresentCadreRemStatus resets all changes to the "DCInPresentCadreRemStatus" field.
func (m *EmployeesMutation) ResetDCInPresentCadreRemStatus() {
	m._DCInPresentCadreRemStatus = nil
}

// SetDCInPresentCadreRemarks sets the "DCInPresentCadreRemarks" field.
func (m *EmployeesMutation) SetDCInPresentCadreRemarks(s string) {
	m._DCInPresentCadreRemarks = &s
}

// DCInPresentCadreRemarks returns the value of the "DCInPresentCadreRemarks" field in the mutation.
func (m *EmployeesMutation) DCInPresentCadreRemarks() (r string, exists bool) {
	v := m._DCInPresentCadreRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldDCInPresentCadreRemarks returns the old "DCInPresentCadreRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCInPresentCadreRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCInPresentCadreRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCInPresentCadreRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCInPresentCadreRemarks: %w", err)
	}
	return oldValue.DCInPresentCadreRemarks, nil
}

// ClearDCInPresentCadreRemarks clears the value of the "DCInPresentCadreRemarks" field.
func (m *EmployeesMutation) ClearDCInPresentCadreRemarks() {
	m._DCInPresentCadreRemarks = nil
	m.clearedFields[employees.FieldDCInPresentCadreRemarks] = struct{}{}
}

// DCInPresentCadreRemarksCleared returns if the "DCInPresentCadreRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) DCInPresentCadreRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldDCInPresentCadreRemarks]
	return ok
}

// ResetDCInPresentCadreRemarks resets all changes to the "DCInPresentCadreRemarks" field.
func (m *EmployeesMutation) ResetDCInPresentCadreRemarks() {
	m._DCInPresentCadreRemarks = nil
	delete(m.clearedFields, employees.FieldDCInPresentCadreRemarks)
}

// SetAPSWorking sets the "APSWorking" field.
func (m *EmployeesMutation) SetAPSWorking(b bool) {
	m._APSWorking = &b
}

// APSWorking returns the value of the "APSWorking" field in the mutation.
func (m *EmployeesMutation) APSWorking() (r bool, exists bool) {
	v := m._APSWorking
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorking returns the old "APSWorking" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldAPSWorking(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorking is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorking requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorking: %w", err)
	}
	return oldValue.APSWorking, nil
}

// ClearAPSWorking clears the value of the "APSWorking" field.
func (m *EmployeesMutation) ClearAPSWorking() {
	m._APSWorking = nil
	m.clearedFields[employees.FieldAPSWorking] = struct{}{}
}

// APSWorkingCleared returns if the "APSWorking" field was cleared in this mutation.
func (m *EmployeesMutation) APSWorkingCleared() bool {
	_, ok := m.clearedFields[employees.FieldAPSWorking]
	return ok
}

// ResetAPSWorking resets all changes to the "APSWorking" field.
func (m *EmployeesMutation) ResetAPSWorking() {
	m._APSWorking = nil
	delete(m.clearedFields, employees.FieldAPSWorking)
}

// SetAPSWorkingVerified sets the "APSWorkingVerified" field.
func (m *EmployeesMutation) SetAPSWorkingVerified(b bool) {
	m._APSWorkingVerified = &b
}

// APSWorkingVerified returns the value of the "APSWorkingVerified" field in the mutation.
func (m *EmployeesMutation) APSWorkingVerified() (r bool, exists bool) {
	v := m._APSWorkingVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorkingVerified returns the old "APSWorkingVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldAPSWorkingVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorkingVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorkingVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorkingVerified: %w", err)
	}
	return oldValue.APSWorkingVerified, nil
}

// ResetAPSWorkingVerified resets all changes to the "APSWorkingVerified" field.
func (m *EmployeesMutation) ResetAPSWorkingVerified() {
	m._APSWorkingVerified = nil
}

// SetAPSWorkingRemStatus sets the "APSWorkingRemStatus" field.
func (m *EmployeesMutation) SetAPSWorkingRemStatus(b bool) {
	m._APSWorkingRemStatus = &b
}

// APSWorkingRemStatus returns the value of the "APSWorkingRemStatus" field in the mutation.
func (m *EmployeesMutation) APSWorkingRemStatus() (r bool, exists bool) {
	v := m._APSWorkingRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorkingRemStatus returns the old "APSWorkingRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldAPSWorkingRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorkingRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorkingRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorkingRemStatus: %w", err)
	}
	return oldValue.APSWorkingRemStatus, nil
}

// ResetAPSWorkingRemStatus resets all changes to the "APSWorkingRemStatus" field.
func (m *EmployeesMutation) ResetAPSWorkingRemStatus() {
	m._APSWorkingRemStatus = nil
}

// SetAPSWorkingRemarks sets the "APSWorkingRemarks" field.
func (m *EmployeesMutation) SetAPSWorkingRemarks(s string) {
	m._APSWorkingRemarks = &s
}

// APSWorkingRemarks returns the value of the "APSWorkingRemarks" field in the mutation.
func (m *EmployeesMutation) APSWorkingRemarks() (r string, exists bool) {
	v := m._APSWorkingRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorkingRemarks returns the old "APSWorkingRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldAPSWorkingRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorkingRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorkingRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorkingRemarks: %w", err)
	}
	return oldValue.APSWorkingRemarks, nil
}

// ClearAPSWorkingRemarks clears the value of the "APSWorkingRemarks" field.
func (m *EmployeesMutation) ClearAPSWorkingRemarks() {
	m._APSWorkingRemarks = nil
	m.clearedFields[employees.FieldAPSWorkingRemarks] = struct{}{}
}

// APSWorkingRemarksCleared returns if the "APSWorkingRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) APSWorkingRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldAPSWorkingRemarks]
	return ok
}

// ResetAPSWorkingRemarks resets all changes to the "APSWorkingRemarks" field.
func (m *EmployeesMutation) ResetAPSWorkingRemarks() {
	m._APSWorkingRemarks = nil
	delete(m.clearedFields, employees.FieldAPSWorkingRemarks)
}

// SetProfilestatus sets the "profilestatus" field.
func (m *EmployeesMutation) SetProfilestatus(b bool) {
	m.profilestatus = &b
}

// Profilestatus returns the value of the "profilestatus" field in the mutation.
func (m *EmployeesMutation) Profilestatus() (r bool, exists bool) {
	v := m.profilestatus
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilestatus returns the old "profilestatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldProfilestatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilestatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilestatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilestatus: %w", err)
	}
	return oldValue.Profilestatus, nil
}

// ResetProfilestatus resets all changes to the "profilestatus" field.
func (m *EmployeesMutation) ResetProfilestatus() {
	m.profilestatus = nil
}

// Where appends a list predicates to the EmployeesMutation builder.
func (m *EmployeesMutation) Where(ps ...predicate.Employees) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employees, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employees).
func (m *EmployeesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeesMutation) Fields() []string {
	fields := make([]string, 0, 95)
	if m._EmployeedID != nil {
		fields = append(fields, employees.FieldEmployeedID)
	}
	if m._IDVerified != nil {
		fields = append(fields, employees.FieldIDVerified)
	}
	if m._IDRemStatus != nil {
		fields = append(fields, employees.FieldIDRemStatus)
	}
	if m._IDRemarks != nil {
		fields = append(fields, employees.FieldIDRemarks)
	}
	if m._EmployeeName != nil {
		fields = append(fields, employees.FieldEmployeeName)
	}
	if m.nameVerified != nil {
		fields = append(fields, employees.FieldNameVerified)
	}
	if m.nameRemStatus != nil {
		fields = append(fields, employees.FieldNameRemStatus)
	}
	if m.nameRemarks != nil {
		fields = append(fields, employees.FieldNameRemarks)
	}
	if m._EmployeeFathersName != nil {
		fields = append(fields, employees.FieldEmployeeFathersName)
	}
	if m._FathersNameVerified != nil {
		fields = append(fields, employees.FieldFathersNameVerified)
	}
	if m._FathersNameRemStatus != nil {
		fields = append(fields, employees.FieldFathersNameRemStatus)
	}
	if m._FathersNameRemarks != nil {
		fields = append(fields, employees.FieldFathersNameRemarks)
	}
	if m._DOB != nil {
		fields = append(fields, employees.FieldDOB)
	}
	if m._DOBVerified != nil {
		fields = append(fields, employees.FieldDOBVerified)
	}
	if m._DOBRemStatus != nil {
		fields = append(fields, employees.FieldDOBRemStatus)
	}
	if m._DOBRemarks != nil {
		fields = append(fields, employees.FieldDOBRemarks)
	}
	if m._Gender != nil {
		fields = append(fields, employees.FieldGender)
	}
	if m.genderVerified != nil {
		fields = append(fields, employees.FieldGenderVerified)
	}
	if m.genderRemStatus != nil {
		fields = append(fields, employees.FieldGenderRemStatus)
	}
	if m.genderRemarks != nil {
		fields = append(fields, employees.FieldGenderRemarks)
	}
	if m._MobileNumber != nil {
		fields = append(fields, employees.FieldMobileNumber)
	}
	if m._EmailID != nil {
		fields = append(fields, employees.FieldEmailID)
	}
	if m._Categoryid != nil {
		fields = append(fields, employees.FieldCategoryid)
	}
	if m._EmployeeCategoryCode != nil {
		fields = append(fields, employees.FieldEmployeeCategoryCode)
	}
	if m._EmployeeCategory != nil {
		fields = append(fields, employees.FieldEmployeeCategory)
	}
	if m._EmployeeCategoryCodeVerified != nil {
		fields = append(fields, employees.FieldEmployeeCategoryCodeVerified)
	}
	if m._EmployeeCategoryCodeRemStatus != nil {
		fields = append(fields, employees.FieldEmployeeCategoryCodeRemStatus)
	}
	if m._EmployeeCategoryCodeRemarks != nil {
		fields = append(fields, employees.FieldEmployeeCategoryCodeRemarks)
	}
	if m._WithDisability != nil {
		fields = append(fields, employees.FieldWithDisability)
	}
	if m._WithDisabilityVerified != nil {
		fields = append(fields, employees.FieldWithDisabilityVerified)
	}
	if m._WithDisabilityRemStatus != nil {
		fields = append(fields, employees.FieldWithDisabilityRemStatus)
	}
	if m._WithDisabilityRemarks != nil {
		fields = append(fields, employees.FieldWithDisabilityRemarks)
	}
	if m._DisabilityType != nil {
		fields = append(fields, employees.FieldDisabilityType)
	}
	if m._DisabilityTypeVerified != nil {
		fields = append(fields, employees.FieldDisabilityTypeVerified)
	}
	if m._DisabilityTypeRemStatus != nil {
		fields = append(fields, employees.FieldDisabilityTypeRemStatus)
	}
	if m._DisabilityTypeRemarks != nil {
		fields = append(fields, employees.FieldDisabilityTypeRemarks)
	}
	if m._DisabilityPercentage != nil {
		fields = append(fields, employees.FieldDisabilityPercentage)
	}
	if m._DisabilityPercentageVerified != nil {
		fields = append(fields, employees.FieldDisabilityPercentageVerified)
	}
	if m._DisabilityPercentageRemStatus != nil {
		fields = append(fields, employees.FieldDisabilityPercentageRemStatus)
	}
	if m._DisabilityPercentageRemarks != nil {
		fields = append(fields, employees.FieldDisabilityPercentageRemarks)
	}
	if m._Signature != nil {
		fields = append(fields, employees.FieldSignature)
	}
	if m._SignatureVerified != nil {
		fields = append(fields, employees.FieldSignatureVerified)
	}
	if m._SignatureRemStatus != nil {
		fields = append(fields, employees.FieldSignatureRemStatus)
	}
	if m._SignatureRemarks != nil {
		fields = append(fields, employees.FieldSignatureRemarks)
	}
	if m._Photo != nil {
		fields = append(fields, employees.FieldPhoto)
	}
	if m._PhotoVerified != nil {
		fields = append(fields, employees.FieldPhotoVerified)
	}
	if m._PhotoRemStatus != nil {
		fields = append(fields, employees.FieldPhotoRemStatus)
	}
	if m._PhotoRemarks != nil {
		fields = append(fields, employees.FieldPhotoRemarks)
	}
	if m._Cadreid != nil {
		fields = append(fields, employees.FieldCadreid)
	}
	if m._EmployeeCadre != nil {
		fields = append(fields, employees.FieldEmployeeCadre)
	}
	if m._EmployeeCadreVerified != nil {
		fields = append(fields, employees.FieldEmployeeCadreVerified)
	}
	if m._EmployeeCadreRemStatus != nil {
		fields = append(fields, employees.FieldEmployeeCadreRemStatus)
	}
	if m._EmployeeCadreRemarks != nil {
		fields = append(fields, employees.FieldEmployeeCadreRemarks)
	}
	if m._DesignationID != nil {
		fields = append(fields, employees.FieldDesignationID)
	}
	if m._EmployeeDesignation != nil {
		fields = append(fields, employees.FieldEmployeeDesignation)
	}
	if m._EmployeeDesignationVerified != nil {
		fields = append(fields, employees.FieldEmployeeDesignationVerified)
	}
	if m._EmployeeDesignationRemStatus != nil {
		fields = append(fields, employees.FieldEmployeeDesignationRemStatus)
	}
	if m._EmployeeDesignationRemarks != nil {
		fields = append(fields, employees.FieldEmployeeDesignationRemarks)
	}
	if m._CircleID != nil {
		fields = append(fields, employees.FieldCircleID)
	}
	if m._CircleName != nil {
		fields = append(fields, employees.FieldCircleName)
	}
	if m._CircleVerified != nil {
		fields = append(fields, employees.FieldCircleVerified)
	}
	if m._CircleRemStatus != nil {
		fields = append(fields, employees.FieldCircleRemStatus)
	}
	if m._CircleRemarks != nil {
		fields = append(fields, employees.FieldCircleRemarks)
	}
	if m._RegionID != nil {
		fields = append(fields, employees.FieldRegionID)
	}
	if m._RegionName != nil {
		fields = append(fields, employees.FieldRegionName)
	}
	if m._RegionVerified != nil {
		fields = append(fields, employees.FieldRegionVerified)
	}
	if m._RegionRemStatus != nil {
		fields = append(fields, employees.FieldRegionRemStatus)
	}
	if m._RegionRemarks != nil {
		fields = append(fields, employees.FieldRegionRemarks)
	}
	if m._DivisionID != nil {
		fields = append(fields, employees.FieldDivisionID)
	}
	if m._DivisionName != nil {
		fields = append(fields, employees.FieldDivisionName)
	}
	if m._DivisionVerified != nil {
		fields = append(fields, employees.FieldDivisionVerified)
	}
	if m._DivisionRemStatus != nil {
		fields = append(fields, employees.FieldDivisionRemStatus)
	}
	if m._DivisionRemarks != nil {
		fields = append(fields, employees.FieldDivisionRemarks)
	}
	if m._OfficeID != nil {
		fields = append(fields, employees.FieldOfficeID)
	}
	if m._OfficeName != nil {
		fields = append(fields, employees.FieldOfficeName)
	}
	if m._OfficeVerified != nil {
		fields = append(fields, employees.FieldOfficeVerified)
	}
	if m._OfficeRemStatus != nil {
		fields = append(fields, employees.FieldOfficeRemStatus)
	}
	if m._OfficeRemarks != nil {
		fields = append(fields, employees.FieldOfficeRemarks)
	}
	if m._Role != nil {
		fields = append(fields, employees.FieldRole)
	}
	if m._RoleVerified != nil {
		fields = append(fields, employees.FieldRoleVerified)
	}
	if m._RoleRemStatus != nil {
		fields = append(fields, employees.FieldRoleRemStatus)
	}
	if m._RoleRemarks != nil {
		fields = append(fields, employees.FieldRoleRemarks)
	}
	if m._DCCS != nil {
		fields = append(fields, employees.FieldDCCS)
	}
	if m._DCCSVerified != nil {
		fields = append(fields, employees.FieldDCCSVerified)
	}
	if m._DCCSRemStatus != nil {
		fields = append(fields, employees.FieldDCCSRemStatus)
	}
	if m._DCCSRemarks != nil {
		fields = append(fields, employees.FieldDCCSRemarks)
	}
	if m._DCInPresentCadre != nil {
		fields = append(fields, employees.FieldDCInPresentCadre)
	}
	if m._DCInPresentCadreVerified != nil {
		fields = append(fields, employees.FieldDCInPresentCadreVerified)
	}
	if m._DCInPresentCadreRemStatus != nil {
		fields = append(fields, employees.FieldDCInPresentCadreRemStatus)
	}
	if m._DCInPresentCadreRemarks != nil {
		fields = append(fields, employees.FieldDCInPresentCadreRemarks)
	}
	if m._APSWorking != nil {
		fields = append(fields, employees.FieldAPSWorking)
	}
	if m._APSWorkingVerified != nil {
		fields = append(fields, employees.FieldAPSWorkingVerified)
	}
	if m._APSWorkingRemStatus != nil {
		fields = append(fields, employees.FieldAPSWorkingRemStatus)
	}
	if m._APSWorkingRemarks != nil {
		fields = append(fields, employees.FieldAPSWorkingRemarks)
	}
	if m.profilestatus != nil {
		fields = append(fields, employees.FieldProfilestatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employees.FieldEmployeedID:
		return m.EmployeedID()
	case employees.FieldIDVerified:
		return m.IDVerified()
	case employees.FieldIDRemStatus:
		return m.IDRemStatus()
	case employees.FieldIDRemarks:
		return m.IDRemarks()
	case employees.FieldEmployeeName:
		return m.EmployeeName()
	case employees.FieldNameVerified:
		return m.NameVerified()
	case employees.FieldNameRemStatus:
		return m.NameRemStatus()
	case employees.FieldNameRemarks:
		return m.NameRemarks()
	case employees.FieldEmployeeFathersName:
		return m.EmployeeFathersName()
	case employees.FieldFathersNameVerified:
		return m.FathersNameVerified()
	case employees.FieldFathersNameRemStatus:
		return m.FathersNameRemStatus()
	case employees.FieldFathersNameRemarks:
		return m.FathersNameRemarks()
	case employees.FieldDOB:
		return m.DOB()
	case employees.FieldDOBVerified:
		return m.DOBVerified()
	case employees.FieldDOBRemStatus:
		return m.DOBRemStatus()
	case employees.FieldDOBRemarks:
		return m.DOBRemarks()
	case employees.FieldGender:
		return m.Gender()
	case employees.FieldGenderVerified:
		return m.GenderVerified()
	case employees.FieldGenderRemStatus:
		return m.GenderRemStatus()
	case employees.FieldGenderRemarks:
		return m.GenderRemarks()
	case employees.FieldMobileNumber:
		return m.MobileNumber()
	case employees.FieldEmailID:
		return m.EmailID()
	case employees.FieldCategoryid:
		return m.Categoryid()
	case employees.FieldEmployeeCategoryCode:
		return m.EmployeeCategoryCode()
	case employees.FieldEmployeeCategory:
		return m.EmployeeCategory()
	case employees.FieldEmployeeCategoryCodeVerified:
		return m.EmployeeCategoryCodeVerified()
	case employees.FieldEmployeeCategoryCodeRemStatus:
		return m.EmployeeCategoryCodeRemStatus()
	case employees.FieldEmployeeCategoryCodeRemarks:
		return m.EmployeeCategoryCodeRemarks()
	case employees.FieldWithDisability:
		return m.WithDisability()
	case employees.FieldWithDisabilityVerified:
		return m.WithDisabilityVerified()
	case employees.FieldWithDisabilityRemStatus:
		return m.WithDisabilityRemStatus()
	case employees.FieldWithDisabilityRemarks:
		return m.WithDisabilityRemarks()
	case employees.FieldDisabilityType:
		return m.DisabilityType()
	case employees.FieldDisabilityTypeVerified:
		return m.DisabilityTypeVerified()
	case employees.FieldDisabilityTypeRemStatus:
		return m.DisabilityTypeRemStatus()
	case employees.FieldDisabilityTypeRemarks:
		return m.DisabilityTypeRemarks()
	case employees.FieldDisabilityPercentage:
		return m.DisabilityPercentage()
	case employees.FieldDisabilityPercentageVerified:
		return m.DisabilityPercentageVerified()
	case employees.FieldDisabilityPercentageRemStatus:
		return m.DisabilityPercentageRemStatus()
	case employees.FieldDisabilityPercentageRemarks:
		return m.DisabilityPercentageRemarks()
	case employees.FieldSignature:
		return m.Signature()
	case employees.FieldSignatureVerified:
		return m.SignatureVerified()
	case employees.FieldSignatureRemStatus:
		return m.SignatureRemStatus()
	case employees.FieldSignatureRemarks:
		return m.SignatureRemarks()
	case employees.FieldPhoto:
		return m.Photo()
	case employees.FieldPhotoVerified:
		return m.PhotoVerified()
	case employees.FieldPhotoRemStatus:
		return m.PhotoRemStatus()
	case employees.FieldPhotoRemarks:
		return m.PhotoRemarks()
	case employees.FieldCadreid:
		return m.Cadreid()
	case employees.FieldEmployeeCadre:
		return m.EmployeeCadre()
	case employees.FieldEmployeeCadreVerified:
		return m.EmployeeCadreVerified()
	case employees.FieldEmployeeCadreRemStatus:
		return m.EmployeeCadreRemStatus()
	case employees.FieldEmployeeCadreRemarks:
		return m.EmployeeCadreRemarks()
	case employees.FieldDesignationID:
		return m.DesignationID()
	case employees.FieldEmployeeDesignation:
		return m.EmployeeDesignation()
	case employees.FieldEmployeeDesignationVerified:
		return m.EmployeeDesignationVerified()
	case employees.FieldEmployeeDesignationRemStatus:
		return m.EmployeeDesignationRemStatus()
	case employees.FieldEmployeeDesignationRemarks:
		return m.EmployeeDesignationRemarks()
	case employees.FieldCircleID:
		return m.CircleID()
	case employees.FieldCircleName:
		return m.CircleName()
	case employees.FieldCircleVerified:
		return m.CircleVerified()
	case employees.FieldCircleRemStatus:
		return m.CircleRemStatus()
	case employees.FieldCircleRemarks:
		return m.CircleRemarks()
	case employees.FieldRegionID:
		return m.RegionID()
	case employees.FieldRegionName:
		return m.RegionName()
	case employees.FieldRegionVerified:
		return m.RegionVerified()
	case employees.FieldRegionRemStatus:
		return m.RegionRemStatus()
	case employees.FieldRegionRemarks:
		return m.RegionRemarks()
	case employees.FieldDivisionID:
		return m.DivisionID()
	case employees.FieldDivisionName:
		return m.DivisionName()
	case employees.FieldDivisionVerified:
		return m.DivisionVerified()
	case employees.FieldDivisionRemStatus:
		return m.DivisionRemStatus()
	case employees.FieldDivisionRemarks:
		return m.DivisionRemarks()
	case employees.FieldOfficeID:
		return m.OfficeID()
	case employees.FieldOfficeName:
		return m.OfficeName()
	case employees.FieldOfficeVerified:
		return m.OfficeVerified()
	case employees.FieldOfficeRemStatus:
		return m.OfficeRemStatus()
	case employees.FieldOfficeRemarks:
		return m.OfficeRemarks()
	case employees.FieldRole:
		return m.Role()
	case employees.FieldRoleVerified:
		return m.RoleVerified()
	case employees.FieldRoleRemStatus:
		return m.RoleRemStatus()
	case employees.FieldRoleRemarks:
		return m.RoleRemarks()
	case employees.FieldDCCS:
		return m.DCCS()
	case employees.FieldDCCSVerified:
		return m.DCCSVerified()
	case employees.FieldDCCSRemStatus:
		return m.DCCSRemStatus()
	case employees.FieldDCCSRemarks:
		return m.DCCSRemarks()
	case employees.FieldDCInPresentCadre:
		return m.DCInPresentCadre()
	case employees.FieldDCInPresentCadreVerified:
		return m.DCInPresentCadreVerified()
	case employees.FieldDCInPresentCadreRemStatus:
		return m.DCInPresentCadreRemStatus()
	case employees.FieldDCInPresentCadreRemarks:
		return m.DCInPresentCadreRemarks()
	case employees.FieldAPSWorking:
		return m.APSWorking()
	case employees.FieldAPSWorkingVerified:
		return m.APSWorkingVerified()
	case employees.FieldAPSWorkingRemStatus:
		return m.APSWorkingRemStatus()
	case employees.FieldAPSWorkingRemarks:
		return m.APSWorkingRemarks()
	case employees.FieldProfilestatus:
		return m.Profilestatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employees.FieldEmployeedID:
		return m.OldEmployeedID(ctx)
	case employees.FieldIDVerified:
		return m.OldIDVerified(ctx)
	case employees.FieldIDRemStatus:
		return m.OldIDRemStatus(ctx)
	case employees.FieldIDRemarks:
		return m.OldIDRemarks(ctx)
	case employees.FieldEmployeeName:
		return m.OldEmployeeName(ctx)
	case employees.FieldNameVerified:
		return m.OldNameVerified(ctx)
	case employees.FieldNameRemStatus:
		return m.OldNameRemStatus(ctx)
	case employees.FieldNameRemarks:
		return m.OldNameRemarks(ctx)
	case employees.FieldEmployeeFathersName:
		return m.OldEmployeeFathersName(ctx)
	case employees.FieldFathersNameVerified:
		return m.OldFathersNameVerified(ctx)
	case employees.FieldFathersNameRemStatus:
		return m.OldFathersNameRemStatus(ctx)
	case employees.FieldFathersNameRemarks:
		return m.OldFathersNameRemarks(ctx)
	case employees.FieldDOB:
		return m.OldDOB(ctx)
	case employees.FieldDOBVerified:
		return m.OldDOBVerified(ctx)
	case employees.FieldDOBRemStatus:
		return m.OldDOBRemStatus(ctx)
	case employees.FieldDOBRemarks:
		return m.OldDOBRemarks(ctx)
	case employees.FieldGender:
		return m.OldGender(ctx)
	case employees.FieldGenderVerified:
		return m.OldGenderVerified(ctx)
	case employees.FieldGenderRemStatus:
		return m.OldGenderRemStatus(ctx)
	case employees.FieldGenderRemarks:
		return m.OldGenderRemarks(ctx)
	case employees.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case employees.FieldEmailID:
		return m.OldEmailID(ctx)
	case employees.FieldCategoryid:
		return m.OldCategoryid(ctx)
	case employees.FieldEmployeeCategoryCode:
		return m.OldEmployeeCategoryCode(ctx)
	case employees.FieldEmployeeCategory:
		return m.OldEmployeeCategory(ctx)
	case employees.FieldEmployeeCategoryCodeVerified:
		return m.OldEmployeeCategoryCodeVerified(ctx)
	case employees.FieldEmployeeCategoryCodeRemStatus:
		return m.OldEmployeeCategoryCodeRemStatus(ctx)
	case employees.FieldEmployeeCategoryCodeRemarks:
		return m.OldEmployeeCategoryCodeRemarks(ctx)
	case employees.FieldWithDisability:
		return m.OldWithDisability(ctx)
	case employees.FieldWithDisabilityVerified:
		return m.OldWithDisabilityVerified(ctx)
	case employees.FieldWithDisabilityRemStatus:
		return m.OldWithDisabilityRemStatus(ctx)
	case employees.FieldWithDisabilityRemarks:
		return m.OldWithDisabilityRemarks(ctx)
	case employees.FieldDisabilityType:
		return m.OldDisabilityType(ctx)
	case employees.FieldDisabilityTypeVerified:
		return m.OldDisabilityTypeVerified(ctx)
	case employees.FieldDisabilityTypeRemStatus:
		return m.OldDisabilityTypeRemStatus(ctx)
	case employees.FieldDisabilityTypeRemarks:
		return m.OldDisabilityTypeRemarks(ctx)
	case employees.FieldDisabilityPercentage:
		return m.OldDisabilityPercentage(ctx)
	case employees.FieldDisabilityPercentageVerified:
		return m.OldDisabilityPercentageVerified(ctx)
	case employees.FieldDisabilityPercentageRemStatus:
		return m.OldDisabilityPercentageRemStatus(ctx)
	case employees.FieldDisabilityPercentageRemarks:
		return m.OldDisabilityPercentageRemarks(ctx)
	case employees.FieldSignature:
		return m.OldSignature(ctx)
	case employees.FieldSignatureVerified:
		return m.OldSignatureVerified(ctx)
	case employees.FieldSignatureRemStatus:
		return m.OldSignatureRemStatus(ctx)
	case employees.FieldSignatureRemarks:
		return m.OldSignatureRemarks(ctx)
	case employees.FieldPhoto:
		return m.OldPhoto(ctx)
	case employees.FieldPhotoVerified:
		return m.OldPhotoVerified(ctx)
	case employees.FieldPhotoRemStatus:
		return m.OldPhotoRemStatus(ctx)
	case employees.FieldPhotoRemarks:
		return m.OldPhotoRemarks(ctx)
	case employees.FieldCadreid:
		return m.OldCadreid(ctx)
	case employees.FieldEmployeeCadre:
		return m.OldEmployeeCadre(ctx)
	case employees.FieldEmployeeCadreVerified:
		return m.OldEmployeeCadreVerified(ctx)
	case employees.FieldEmployeeCadreRemStatus:
		return m.OldEmployeeCadreRemStatus(ctx)
	case employees.FieldEmployeeCadreRemarks:
		return m.OldEmployeeCadreRemarks(ctx)
	case employees.FieldDesignationID:
		return m.OldDesignationID(ctx)
	case employees.FieldEmployeeDesignation:
		return m.OldEmployeeDesignation(ctx)
	case employees.FieldEmployeeDesignationVerified:
		return m.OldEmployeeDesignationVerified(ctx)
	case employees.FieldEmployeeDesignationRemStatus:
		return m.OldEmployeeDesignationRemStatus(ctx)
	case employees.FieldEmployeeDesignationRemarks:
		return m.OldEmployeeDesignationRemarks(ctx)
	case employees.FieldCircleID:
		return m.OldCircleID(ctx)
	case employees.FieldCircleName:
		return m.OldCircleName(ctx)
	case employees.FieldCircleVerified:
		return m.OldCircleVerified(ctx)
	case employees.FieldCircleRemStatus:
		return m.OldCircleRemStatus(ctx)
	case employees.FieldCircleRemarks:
		return m.OldCircleRemarks(ctx)
	case employees.FieldRegionID:
		return m.OldRegionID(ctx)
	case employees.FieldRegionName:
		return m.OldRegionName(ctx)
	case employees.FieldRegionVerified:
		return m.OldRegionVerified(ctx)
	case employees.FieldRegionRemStatus:
		return m.OldRegionRemStatus(ctx)
	case employees.FieldRegionRemarks:
		return m.OldRegionRemarks(ctx)
	case employees.FieldDivisionID:
		return m.OldDivisionID(ctx)
	case employees.FieldDivisionName:
		return m.OldDivisionName(ctx)
	case employees.FieldDivisionVerified:
		return m.OldDivisionVerified(ctx)
	case employees.FieldDivisionRemStatus:
		return m.OldDivisionRemStatus(ctx)
	case employees.FieldDivisionRemarks:
		return m.OldDivisionRemarks(ctx)
	case employees.FieldOfficeID:
		return m.OldOfficeID(ctx)
	case employees.FieldOfficeName:
		return m.OldOfficeName(ctx)
	case employees.FieldOfficeVerified:
		return m.OldOfficeVerified(ctx)
	case employees.FieldOfficeRemStatus:
		return m.OldOfficeRemStatus(ctx)
	case employees.FieldOfficeRemarks:
		return m.OldOfficeRemarks(ctx)
	case employees.FieldRole:
		return m.OldRole(ctx)
	case employees.FieldRoleVerified:
		return m.OldRoleVerified(ctx)
	case employees.FieldRoleRemStatus:
		return m.OldRoleRemStatus(ctx)
	case employees.FieldRoleRemarks:
		return m.OldRoleRemarks(ctx)
	case employees.FieldDCCS:
		return m.OldDCCS(ctx)
	case employees.FieldDCCSVerified:
		return m.OldDCCSVerified(ctx)
	case employees.FieldDCCSRemStatus:
		return m.OldDCCSRemStatus(ctx)
	case employees.FieldDCCSRemarks:
		return m.OldDCCSRemarks(ctx)
	case employees.FieldDCInPresentCadre:
		return m.OldDCInPresentCadre(ctx)
	case employees.FieldDCInPresentCadreVerified:
		return m.OldDCInPresentCadreVerified(ctx)
	case employees.FieldDCInPresentCadreRemStatus:
		return m.OldDCInPresentCadreRemStatus(ctx)
	case employees.FieldDCInPresentCadreRemarks:
		return m.OldDCInPresentCadreRemarks(ctx)
	case employees.FieldAPSWorking:
		return m.OldAPSWorking(ctx)
	case employees.FieldAPSWorkingVerified:
		return m.OldAPSWorkingVerified(ctx)
	case employees.FieldAPSWorkingRemStatus:
		return m.OldAPSWorkingRemStatus(ctx)
	case employees.FieldAPSWorkingRemarks:
		return m.OldAPSWorkingRemarks(ctx)
	case employees.FieldProfilestatus:
		return m.OldProfilestatus(ctx)
	}
	return nil, fmt.Errorf("unknown Employees field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employees.FieldEmployeedID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeedID(v)
		return nil
	case employees.FieldIDVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDVerified(v)
		return nil
	case employees.FieldIDRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDRemStatus(v)
		return nil
	case employees.FieldIDRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDRemarks(v)
		return nil
	case employees.FieldEmployeeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeName(v)
		return nil
	case employees.FieldNameVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameVerified(v)
		return nil
	case employees.FieldNameRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameRemStatus(v)
		return nil
	case employees.FieldNameRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameRemarks(v)
		return nil
	case employees.FieldEmployeeFathersName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeFathersName(v)
		return nil
	case employees.FieldFathersNameVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFathersNameVerified(v)
		return nil
	case employees.FieldFathersNameRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFathersNameRemStatus(v)
		return nil
	case employees.FieldFathersNameRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFathersNameRemarks(v)
		return nil
	case employees.FieldDOB:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOB(v)
		return nil
	case employees.FieldDOBVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOBVerified(v)
		return nil
	case employees.FieldDOBRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOBRemStatus(v)
		return nil
	case employees.FieldDOBRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOBRemarks(v)
		return nil
	case employees.FieldGender:
		v, ok := value.(employees.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case employees.FieldGenderVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderVerified(v)
		return nil
	case employees.FieldGenderRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderRemStatus(v)
		return nil
	case employees.FieldGenderRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderRemarks(v)
		return nil
	case employees.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case employees.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case employees.FieldCategoryid:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryid(v)
		return nil
	case employees.FieldEmployeeCategoryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCategoryCode(v)
		return nil
	case employees.FieldEmployeeCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCategory(v)
		return nil
	case employees.FieldEmployeeCategoryCodeVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCategoryCodeVerified(v)
		return nil
	case employees.FieldEmployeeCategoryCodeRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCategoryCodeRemStatus(v)
		return nil
	case employees.FieldEmployeeCategoryCodeRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCategoryCodeRemarks(v)
		return nil
	case employees.FieldWithDisability:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithDisability(v)
		return nil
	case employees.FieldWithDisabilityVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithDisabilityVerified(v)
		return nil
	case employees.FieldWithDisabilityRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithDisabilityRemStatus(v)
		return nil
	case employees.FieldWithDisabilityRemarks:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithDisabilityRemarks(v)
		return nil
	case employees.FieldDisabilityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityType(v)
		return nil
	case employees.FieldDisabilityTypeVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityTypeVerified(v)
		return nil
	case employees.FieldDisabilityTypeRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityTypeRemStatus(v)
		return nil
	case employees.FieldDisabilityTypeRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityTypeRemarks(v)
		return nil
	case employees.FieldDisabilityPercentage:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityPercentage(v)
		return nil
	case employees.FieldDisabilityPercentageVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityPercentageVerified(v)
		return nil
	case employees.FieldDisabilityPercentageRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityPercentageRemStatus(v)
		return nil
	case employees.FieldDisabilityPercentageRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityPercentageRemarks(v)
		return nil
	case employees.FieldSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case employees.FieldSignatureVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignatureVerified(v)
		return nil
	case employees.FieldSignatureRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignatureRemStatus(v)
		return nil
	case employees.FieldSignatureRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignatureRemarks(v)
		return nil
	case employees.FieldPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoto(v)
		return nil
	case employees.FieldPhotoVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoVerified(v)
		return nil
	case employees.FieldPhotoRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoRemStatus(v)
		return nil
	case employees.FieldPhotoRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoRemarks(v)
		return nil
	case employees.FieldCadreid:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadreid(v)
		return nil
	case employees.FieldEmployeeCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCadre(v)
		return nil
	case employees.FieldEmployeeCadreVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCadreVerified(v)
		return nil
	case employees.FieldEmployeeCadreRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCadreRemStatus(v)
		return nil
	case employees.FieldEmployeeCadreRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCadreRemarks(v)
		return nil
	case employees.FieldDesignationID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesignationID(v)
		return nil
	case employees.FieldEmployeeDesignation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeDesignation(v)
		return nil
	case employees.FieldEmployeeDesignationVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeDesignationVerified(v)
		return nil
	case employees.FieldEmployeeDesignationRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeDesignationRemStatus(v)
		return nil
	case employees.FieldEmployeeDesignationRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeDesignationRemarks(v)
		return nil
	case employees.FieldCircleID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleID(v)
		return nil
	case employees.FieldCircleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleName(v)
		return nil
	case employees.FieldCircleVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleVerified(v)
		return nil
	case employees.FieldCircleRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleRemStatus(v)
		return nil
	case employees.FieldCircleRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleRemarks(v)
		return nil
	case employees.FieldRegionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionID(v)
		return nil
	case employees.FieldRegionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionName(v)
		return nil
	case employees.FieldRegionVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionVerified(v)
		return nil
	case employees.FieldRegionRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionRemStatus(v)
		return nil
	case employees.FieldRegionRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionRemarks(v)
		return nil
	case employees.FieldDivisionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionID(v)
		return nil
	case employees.FieldDivisionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionName(v)
		return nil
	case employees.FieldDivisionVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionVerified(v)
		return nil
	case employees.FieldDivisionRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionRemStatus(v)
		return nil
	case employees.FieldDivisionRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionRemarks(v)
		return nil
	case employees.FieldOfficeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeID(v)
		return nil
	case employees.FieldOfficeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeName(v)
		return nil
	case employees.FieldOfficeVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeVerified(v)
		return nil
	case employees.FieldOfficeRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeRemStatus(v)
		return nil
	case employees.FieldOfficeRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeRemarks(v)
		return nil
	case employees.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case employees.FieldRoleVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleVerified(v)
		return nil
	case employees.FieldRoleRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleRemStatus(v)
		return nil
	case employees.FieldRoleRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleRemarks(v)
		return nil
	case employees.FieldDCCS:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCCS(v)
		return nil
	case employees.FieldDCCSVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCCSVerified(v)
		return nil
	case employees.FieldDCCSRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCCSRemStatus(v)
		return nil
	case employees.FieldDCCSRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCCSRemarks(v)
		return nil
	case employees.FieldDCInPresentCadre:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCInPresentCadre(v)
		return nil
	case employees.FieldDCInPresentCadreVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCInPresentCadreVerified(v)
		return nil
	case employees.FieldDCInPresentCadreRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCInPresentCadreRemStatus(v)
		return nil
	case employees.FieldDCInPresentCadreRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCInPresentCadreRemarks(v)
		return nil
	case employees.FieldAPSWorking:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorking(v)
		return nil
	case employees.FieldAPSWorkingVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorkingVerified(v)
		return nil
	case employees.FieldAPSWorkingRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorkingRemStatus(v)
		return nil
	case employees.FieldAPSWorkingRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorkingRemarks(v)
		return nil
	case employees.FieldProfilestatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilestatus(v)
		return nil
	}
	return fmt.Errorf("unknown Employees field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeesMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeedID != nil {
		fields = append(fields, employees.FieldEmployeedID)
	}
	if m.add_MobileNumber != nil {
		fields = append(fields, employees.FieldMobileNumber)
	}
	if m.add_Categoryid != nil {
		fields = append(fields, employees.FieldCategoryid)
	}
	if m.add_DisabilityPercentage != nil {
		fields = append(fields, employees.FieldDisabilityPercentage)
	}
	if m.add_Cadreid != nil {
		fields = append(fields, employees.FieldCadreid)
	}
	if m.add_DesignationID != nil {
		fields = append(fields, employees.FieldDesignationID)
	}
	if m.add_CircleID != nil {
		fields = append(fields, employees.FieldCircleID)
	}
	if m.add_RegionID != nil {
		fields = append(fields, employees.FieldRegionID)
	}
	if m.add_DivisionID != nil {
		fields = append(fields, employees.FieldDivisionID)
	}
	if m.add_OfficeID != nil {
		fields = append(fields, employees.FieldOfficeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case employees.FieldEmployeedID:
		return m.AddedEmployeedID()
	case employees.FieldMobileNumber:
		return m.AddedMobileNumber()
	case employees.FieldCategoryid:
		return m.AddedCategoryid()
	case employees.FieldDisabilityPercentage:
		return m.AddedDisabilityPercentage()
	case employees.FieldCadreid:
		return m.AddedCadreid()
	case employees.FieldDesignationID:
		return m.AddedDesignationID()
	case employees.FieldCircleID:
		return m.AddedCircleID()
	case employees.FieldRegionID:
		return m.AddedRegionID()
	case employees.FieldDivisionID:
		return m.AddedDivisionID()
	case employees.FieldOfficeID:
		return m.AddedOfficeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case employees.FieldEmployeedID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeedID(v)
		return nil
	case employees.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMobileNumber(v)
		return nil
	case employees.FieldCategoryid:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryid(v)
		return nil
	case employees.FieldDisabilityPercentage:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisabilityPercentage(v)
		return nil
	case employees.FieldCadreid:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCadreid(v)
		return nil
	case employees.FieldDesignationID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDesignationID(v)
		return nil
	case employees.FieldCircleID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCircleID(v)
		return nil
	case employees.FieldRegionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegionID(v)
		return nil
	case employees.FieldDivisionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDivisionID(v)
		return nil
	case employees.FieldOfficeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOfficeID(v)
		return nil
	}
	return fmt.Errorf("unknown Employees numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employees.FieldIDRemarks) {
		fields = append(fields, employees.FieldIDRemarks)
	}
	if m.FieldCleared(employees.FieldNameRemarks) {
		fields = append(fields, employees.FieldNameRemarks)
	}
	if m.FieldCleared(employees.FieldFathersNameRemarks) {
		fields = append(fields, employees.FieldFathersNameRemarks)
	}
	if m.FieldCleared(employees.FieldDOBRemarks) {
		fields = append(fields, employees.FieldDOBRemarks)
	}
	if m.FieldCleared(employees.FieldGenderRemarks) {
		fields = append(fields, employees.FieldGenderRemarks)
	}
	if m.FieldCleared(employees.FieldMobileNumber) {
		fields = append(fields, employees.FieldMobileNumber)
	}
	if m.FieldCleared(employees.FieldEmailID) {
		fields = append(fields, employees.FieldEmailID)
	}
	if m.FieldCleared(employees.FieldCategoryid) {
		fields = append(fields, employees.FieldCategoryid)
	}
	if m.FieldCleared(employees.FieldEmployeeCategoryCode) {
		fields = append(fields, employees.FieldEmployeeCategoryCode)
	}
	if m.FieldCleared(employees.FieldEmployeeCategoryCodeRemarks) {
		fields = append(fields, employees.FieldEmployeeCategoryCodeRemarks)
	}
	if m.FieldCleared(employees.FieldWithDisabilityRemarks) {
		fields = append(fields, employees.FieldWithDisabilityRemarks)
	}
	if m.FieldCleared(employees.FieldDisabilityType) {
		fields = append(fields, employees.FieldDisabilityType)
	}
	if m.FieldCleared(employees.FieldDisabilityTypeRemarks) {
		fields = append(fields, employees.FieldDisabilityTypeRemarks)
	}
	if m.FieldCleared(employees.FieldDisabilityPercentage) {
		fields = append(fields, employees.FieldDisabilityPercentage)
	}
	if m.FieldCleared(employees.FieldDisabilityPercentageRemarks) {
		fields = append(fields, employees.FieldDisabilityPercentageRemarks)
	}
	if m.FieldCleared(employees.FieldSignatureRemarks) {
		fields = append(fields, employees.FieldSignatureRemarks)
	}
	if m.FieldCleared(employees.FieldPhotoRemarks) {
		fields = append(fields, employees.FieldPhotoRemarks)
	}
	if m.FieldCleared(employees.FieldCadreid) {
		fields = append(fields, employees.FieldCadreid)
	}
	if m.FieldCleared(employees.FieldEmployeeCadreRemarks) {
		fields = append(fields, employees.FieldEmployeeCadreRemarks)
	}
	if m.FieldCleared(employees.FieldDesignationID) {
		fields = append(fields, employees.FieldDesignationID)
	}
	if m.FieldCleared(employees.FieldEmployeeDesignationRemarks) {
		fields = append(fields, employees.FieldEmployeeDesignationRemarks)
	}
	if m.FieldCleared(employees.FieldCircleID) {
		fields = append(fields, employees.FieldCircleID)
	}
	if m.FieldCleared(employees.FieldCircleRemarks) {
		fields = append(fields, employees.FieldCircleRemarks)
	}
	if m.FieldCleared(employees.FieldRegionID) {
		fields = append(fields, employees.FieldRegionID)
	}
	if m.FieldCleared(employees.FieldRegionRemarks) {
		fields = append(fields, employees.FieldRegionRemarks)
	}
	if m.FieldCleared(employees.FieldDivisionID) {
		fields = append(fields, employees.FieldDivisionID)
	}
	if m.FieldCleared(employees.FieldOfficeID) {
		fields = append(fields, employees.FieldOfficeID)
	}
	if m.FieldCleared(employees.FieldOfficeRemarks) {
		fields = append(fields, employees.FieldOfficeRemarks)
	}
	if m.FieldCleared(employees.FieldDCCSRemarks) {
		fields = append(fields, employees.FieldDCCSRemarks)
	}
	if m.FieldCleared(employees.FieldDCInPresentCadreRemarks) {
		fields = append(fields, employees.FieldDCInPresentCadreRemarks)
	}
	if m.FieldCleared(employees.FieldAPSWorking) {
		fields = append(fields, employees.FieldAPSWorking)
	}
	if m.FieldCleared(employees.FieldAPSWorkingRemarks) {
		fields = append(fields, employees.FieldAPSWorkingRemarks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeesMutation) ClearField(name string) error {
	switch name {
	case employees.FieldIDRemarks:
		m.ClearIDRemarks()
		return nil
	case employees.FieldNameRemarks:
		m.ClearNameRemarks()
		return nil
	case employees.FieldFathersNameRemarks:
		m.ClearFathersNameRemarks()
		return nil
	case employees.FieldDOBRemarks:
		m.ClearDOBRemarks()
		return nil
	case employees.FieldGenderRemarks:
		m.ClearGenderRemarks()
		return nil
	case employees.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	case employees.FieldEmailID:
		m.ClearEmailID()
		return nil
	case employees.FieldCategoryid:
		m.ClearCategoryid()
		return nil
	case employees.FieldEmployeeCategoryCode:
		m.ClearEmployeeCategoryCode()
		return nil
	case employees.FieldEmployeeCategoryCodeRemarks:
		m.ClearEmployeeCategoryCodeRemarks()
		return nil
	case employees.FieldWithDisabilityRemarks:
		m.ClearWithDisabilityRemarks()
		return nil
	case employees.FieldDisabilityType:
		m.ClearDisabilityType()
		return nil
	case employees.FieldDisabilityTypeRemarks:
		m.ClearDisabilityTypeRemarks()
		return nil
	case employees.FieldDisabilityPercentage:
		m.ClearDisabilityPercentage()
		return nil
	case employees.FieldDisabilityPercentageRemarks:
		m.ClearDisabilityPercentageRemarks()
		return nil
	case employees.FieldSignatureRemarks:
		m.ClearSignatureRemarks()
		return nil
	case employees.FieldPhotoRemarks:
		m.ClearPhotoRemarks()
		return nil
	case employees.FieldCadreid:
		m.ClearCadreid()
		return nil
	case employees.FieldEmployeeCadreRemarks:
		m.ClearEmployeeCadreRemarks()
		return nil
	case employees.FieldDesignationID:
		m.ClearDesignationID()
		return nil
	case employees.FieldEmployeeDesignationRemarks:
		m.ClearEmployeeDesignationRemarks()
		return nil
	case employees.FieldCircleID:
		m.ClearCircleID()
		return nil
	case employees.FieldCircleRemarks:
		m.ClearCircleRemarks()
		return nil
	case employees.FieldRegionID:
		m.ClearRegionID()
		return nil
	case employees.FieldRegionRemarks:
		m.ClearRegionRemarks()
		return nil
	case employees.FieldDivisionID:
		m.ClearDivisionID()
		return nil
	case employees.FieldOfficeID:
		m.ClearOfficeID()
		return nil
	case employees.FieldOfficeRemarks:
		m.ClearOfficeRemarks()
		return nil
	case employees.FieldDCCSRemarks:
		m.ClearDCCSRemarks()
		return nil
	case employees.FieldDCInPresentCadreRemarks:
		m.ClearDCInPresentCadreRemarks()
		return nil
	case employees.FieldAPSWorking:
		m.ClearAPSWorking()
		return nil
	case employees.FieldAPSWorkingRemarks:
		m.ClearAPSWorkingRemarks()
		return nil
	}
	return fmt.Errorf("unknown Employees nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeesMutation) ResetField(name string) error {
	switch name {
	case employees.FieldEmployeedID:
		m.ResetEmployeedID()
		return nil
	case employees.FieldIDVerified:
		m.ResetIDVerified()
		return nil
	case employees.FieldIDRemStatus:
		m.ResetIDRemStatus()
		return nil
	case employees.FieldIDRemarks:
		m.ResetIDRemarks()
		return nil
	case employees.FieldEmployeeName:
		m.ResetEmployeeName()
		return nil
	case employees.FieldNameVerified:
		m.ResetNameVerified()
		return nil
	case employees.FieldNameRemStatus:
		m.ResetNameRemStatus()
		return nil
	case employees.FieldNameRemarks:
		m.ResetNameRemarks()
		return nil
	case employees.FieldEmployeeFathersName:
		m.ResetEmployeeFathersName()
		return nil
	case employees.FieldFathersNameVerified:
		m.ResetFathersNameVerified()
		return nil
	case employees.FieldFathersNameRemStatus:
		m.ResetFathersNameRemStatus()
		return nil
	case employees.FieldFathersNameRemarks:
		m.ResetFathersNameRemarks()
		return nil
	case employees.FieldDOB:
		m.ResetDOB()
		return nil
	case employees.FieldDOBVerified:
		m.ResetDOBVerified()
		return nil
	case employees.FieldDOBRemStatus:
		m.ResetDOBRemStatus()
		return nil
	case employees.FieldDOBRemarks:
		m.ResetDOBRemarks()
		return nil
	case employees.FieldGender:
		m.ResetGender()
		return nil
	case employees.FieldGenderVerified:
		m.ResetGenderVerified()
		return nil
	case employees.FieldGenderRemStatus:
		m.ResetGenderRemStatus()
		return nil
	case employees.FieldGenderRemarks:
		m.ResetGenderRemarks()
		return nil
	case employees.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case employees.FieldEmailID:
		m.ResetEmailID()
		return nil
	case employees.FieldCategoryid:
		m.ResetCategoryid()
		return nil
	case employees.FieldEmployeeCategoryCode:
		m.ResetEmployeeCategoryCode()
		return nil
	case employees.FieldEmployeeCategory:
		m.ResetEmployeeCategory()
		return nil
	case employees.FieldEmployeeCategoryCodeVerified:
		m.ResetEmployeeCategoryCodeVerified()
		return nil
	case employees.FieldEmployeeCategoryCodeRemStatus:
		m.ResetEmployeeCategoryCodeRemStatus()
		return nil
	case employees.FieldEmployeeCategoryCodeRemarks:
		m.ResetEmployeeCategoryCodeRemarks()
		return nil
	case employees.FieldWithDisability:
		m.ResetWithDisability()
		return nil
	case employees.FieldWithDisabilityVerified:
		m.ResetWithDisabilityVerified()
		return nil
	case employees.FieldWithDisabilityRemStatus:
		m.ResetWithDisabilityRemStatus()
		return nil
	case employees.FieldWithDisabilityRemarks:
		m.ResetWithDisabilityRemarks()
		return nil
	case employees.FieldDisabilityType:
		m.ResetDisabilityType()
		return nil
	case employees.FieldDisabilityTypeVerified:
		m.ResetDisabilityTypeVerified()
		return nil
	case employees.FieldDisabilityTypeRemStatus:
		m.ResetDisabilityTypeRemStatus()
		return nil
	case employees.FieldDisabilityTypeRemarks:
		m.ResetDisabilityTypeRemarks()
		return nil
	case employees.FieldDisabilityPercentage:
		m.ResetDisabilityPercentage()
		return nil
	case employees.FieldDisabilityPercentageVerified:
		m.ResetDisabilityPercentageVerified()
		return nil
	case employees.FieldDisabilityPercentageRemStatus:
		m.ResetDisabilityPercentageRemStatus()
		return nil
	case employees.FieldDisabilityPercentageRemarks:
		m.ResetDisabilityPercentageRemarks()
		return nil
	case employees.FieldSignature:
		m.ResetSignature()
		return nil
	case employees.FieldSignatureVerified:
		m.ResetSignatureVerified()
		return nil
	case employees.FieldSignatureRemStatus:
		m.ResetSignatureRemStatus()
		return nil
	case employees.FieldSignatureRemarks:
		m.ResetSignatureRemarks()
		return nil
	case employees.FieldPhoto:
		m.ResetPhoto()
		return nil
	case employees.FieldPhotoVerified:
		m.ResetPhotoVerified()
		return nil
	case employees.FieldPhotoRemStatus:
		m.ResetPhotoRemStatus()
		return nil
	case employees.FieldPhotoRemarks:
		m.ResetPhotoRemarks()
		return nil
	case employees.FieldCadreid:
		m.ResetCadreid()
		return nil
	case employees.FieldEmployeeCadre:
		m.ResetEmployeeCadre()
		return nil
	case employees.FieldEmployeeCadreVerified:
		m.ResetEmployeeCadreVerified()
		return nil
	case employees.FieldEmployeeCadreRemStatus:
		m.ResetEmployeeCadreRemStatus()
		return nil
	case employees.FieldEmployeeCadreRemarks:
		m.ResetEmployeeCadreRemarks()
		return nil
	case employees.FieldDesignationID:
		m.ResetDesignationID()
		return nil
	case employees.FieldEmployeeDesignation:
		m.ResetEmployeeDesignation()
		return nil
	case employees.FieldEmployeeDesignationVerified:
		m.ResetEmployeeDesignationVerified()
		return nil
	case employees.FieldEmployeeDesignationRemStatus:
		m.ResetEmployeeDesignationRemStatus()
		return nil
	case employees.FieldEmployeeDesignationRemarks:
		m.ResetEmployeeDesignationRemarks()
		return nil
	case employees.FieldCircleID:
		m.ResetCircleID()
		return nil
	case employees.FieldCircleName:
		m.ResetCircleName()
		return nil
	case employees.FieldCircleVerified:
		m.ResetCircleVerified()
		return nil
	case employees.FieldCircleRemStatus:
		m.ResetCircleRemStatus()
		return nil
	case employees.FieldCircleRemarks:
		m.ResetCircleRemarks()
		return nil
	case employees.FieldRegionID:
		m.ResetRegionID()
		return nil
	case employees.FieldRegionName:
		m.ResetRegionName()
		return nil
	case employees.FieldRegionVerified:
		m.ResetRegionVerified()
		return nil
	case employees.FieldRegionRemStatus:
		m.ResetRegionRemStatus()
		return nil
	case employees.FieldRegionRemarks:
		m.ResetRegionRemarks()
		return nil
	case employees.FieldDivisionID:
		m.ResetDivisionID()
		return nil
	case employees.FieldDivisionName:
		m.ResetDivisionName()
		return nil
	case employees.FieldDivisionVerified:
		m.ResetDivisionVerified()
		return nil
	case employees.FieldDivisionRemStatus:
		m.ResetDivisionRemStatus()
		return nil
	case employees.FieldDivisionRemarks:
		m.ResetDivisionRemarks()
		return nil
	case employees.FieldOfficeID:
		m.ResetOfficeID()
		return nil
	case employees.FieldOfficeName:
		m.ResetOfficeName()
		return nil
	case employees.FieldOfficeVerified:
		m.ResetOfficeVerified()
		return nil
	case employees.FieldOfficeRemStatus:
		m.ResetOfficeRemStatus()
		return nil
	case employees.FieldOfficeRemarks:
		m.ResetOfficeRemarks()
		return nil
	case employees.FieldRole:
		m.ResetRole()
		return nil
	case employees.FieldRoleVerified:
		m.ResetRoleVerified()
		return nil
	case employees.FieldRoleRemStatus:
		m.ResetRoleRemStatus()
		return nil
	case employees.FieldRoleRemarks:
		m.ResetRoleRemarks()
		return nil
	case employees.FieldDCCS:
		m.ResetDCCS()
		return nil
	case employees.FieldDCCSVerified:
		m.ResetDCCSVerified()
		return nil
	case employees.FieldDCCSRemStatus:
		m.ResetDCCSRemStatus()
		return nil
	case employees.FieldDCCSRemarks:
		m.ResetDCCSRemarks()
		return nil
	case employees.FieldDCInPresentCadre:
		m.ResetDCInPresentCadre()
		return nil
	case employees.FieldDCInPresentCadreVerified:
		m.ResetDCInPresentCadreVerified()
		return nil
	case employees.FieldDCInPresentCadreRemStatus:
		m.ResetDCInPresentCadreRemStatus()
		return nil
	case employees.FieldDCInPresentCadreRemarks:
		m.ResetDCInPresentCadreRemarks()
		return nil
	case employees.FieldAPSWorking:
		m.ResetAPSWorking()
		return nil
	case employees.FieldAPSWorkingVerified:
		m.ResetAPSWorkingVerified()
		return nil
	case employees.FieldAPSWorkingRemStatus:
		m.ResetAPSWorkingRemStatus()
		return nil
	case employees.FieldAPSWorkingRemarks:
		m.ResetAPSWorkingRemarks()
		return nil
	case employees.FieldProfilestatus:
		m.ResetProfilestatus()
		return nil
	}
	return fmt.Errorf("unknown Employees field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Employees unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Employees edge %s", name)
}

// ExamMutation represents an operation that mutates the Exam nodes in the graph.
type ExamMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int32
	_ExamName             *string
	_NumOfPapers          *int32
	add_NumOfPapers       *int32
	_NotificationBy       *string
	_ConductedBy          *string
	_NodalOfficerLevel    *int32
	add_NodalOfficerLevel *int32
	_CalendarCode         *int32
	add_CalendarCode      *int32
	_PaperCode            *int32
	add_PaperCode         *int32
	clearedFields         map[string]struct{}
	nodal_officers        map[int32]struct{}
	removednodal_officers map[int32]struct{}
	clearednodal_officers bool
	notifications         map[int32]struct{}
	removednotifications  map[int32]struct{}
	clearednotifications  bool
	exams_ref             map[int32]struct{}
	removedexams_ref      map[int32]struct{}
	clearedexams_ref      bool
	papers                map[int32]struct{}
	removedpapers         map[int32]struct{}
	clearedpapers         bool
	done                  bool
	oldValue              func(context.Context) (*Exam, error)
	predicates            []predicate.Exam
}

var _ ent.Mutation = (*ExamMutation)(nil)

// examOption allows management of the mutation configuration using functional options.
type examOption func(*ExamMutation)

// newExamMutation creates new mutation for the Exam entity.
func newExamMutation(c config, op Op, opts ...examOption) *ExamMutation {
	m := &ExamMutation{
		config:        c,
		op:            op,
		typ:           TypeExam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExamID sets the ID field of the mutation.
func withExamID(id int32) examOption {
	return func(m *ExamMutation) {
		var (
			err   error
			once  sync.Once
			value *Exam
		)
		m.oldValue = func(ctx context.Context) (*Exam, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exam.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExam sets the old Exam of the mutation.
func withExam(node *Exam) examOption {
	return func(m *ExamMutation) {
		m.oldValue = func(context.Context) (*Exam, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exam entities.
func (m *ExamMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExamMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExamMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exam.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExamName sets the "ExamName" field.
func (m *ExamMutation) SetExamName(s string) {
	m._ExamName = &s
}

// ExamName returns the value of the "ExamName" field in the mutation.
func (m *ExamMutation) ExamName() (r string, exists bool) {
	v := m._ExamName
	if v == nil {
		return
	}
	return *v, true
}

// OldExamName returns the old "ExamName" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldExamName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamName: %w", err)
	}
	return oldValue.ExamName, nil
}

// ResetExamName resets all changes to the "ExamName" field.
func (m *ExamMutation) ResetExamName() {
	m._ExamName = nil
}

// SetNumOfPapers sets the "NumOfPapers" field.
func (m *ExamMutation) SetNumOfPapers(i int32) {
	m._NumOfPapers = &i
	m.add_NumOfPapers = nil
}

// NumOfPapers returns the value of the "NumOfPapers" field in the mutation.
func (m *ExamMutation) NumOfPapers() (r int32, exists bool) {
	v := m._NumOfPapers
	if v == nil {
		return
	}
	return *v, true
}

// OldNumOfPapers returns the old "NumOfPapers" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldNumOfPapers(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumOfPapers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumOfPapers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumOfPapers: %w", err)
	}
	return oldValue.NumOfPapers, nil
}

// AddNumOfPapers adds i to the "NumOfPapers" field.
func (m *ExamMutation) AddNumOfPapers(i int32) {
	if m.add_NumOfPapers != nil {
		*m.add_NumOfPapers += i
	} else {
		m.add_NumOfPapers = &i
	}
}

// AddedNumOfPapers returns the value that was added to the "NumOfPapers" field in this mutation.
func (m *ExamMutation) AddedNumOfPapers() (r int32, exists bool) {
	v := m.add_NumOfPapers
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumOfPapers resets all changes to the "NumOfPapers" field.
func (m *ExamMutation) ResetNumOfPapers() {
	m._NumOfPapers = nil
	m.add_NumOfPapers = nil
}

// SetNotificationBy sets the "NotificationBy" field.
func (m *ExamMutation) SetNotificationBy(s string) {
	m._NotificationBy = &s
}

// NotificationBy returns the value of the "NotificationBy" field in the mutation.
func (m *ExamMutation) NotificationBy() (r string, exists bool) {
	v := m._NotificationBy
	if v == nil {
		return
	}
	return *v, true
}

// OldNotificationBy returns the old "NotificationBy" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldNotificationBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotificationBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotificationBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotificationBy: %w", err)
	}
	return oldValue.NotificationBy, nil
}

// ResetNotificationBy resets all changes to the "NotificationBy" field.
func (m *ExamMutation) ResetNotificationBy() {
	m._NotificationBy = nil
}

// SetConductedBy sets the "ConductedBy" field.
func (m *ExamMutation) SetConductedBy(s string) {
	m._ConductedBy = &s
}

// ConductedBy returns the value of the "ConductedBy" field in the mutation.
func (m *ExamMutation) ConductedBy() (r string, exists bool) {
	v := m._ConductedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldConductedBy returns the old "ConductedBy" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldConductedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConductedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConductedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConductedBy: %w", err)
	}
	return oldValue.ConductedBy, nil
}

// ResetConductedBy resets all changes to the "ConductedBy" field.
func (m *ExamMutation) ResetConductedBy() {
	m._ConductedBy = nil
}

// SetNodalOfficerLevel sets the "NodalOfficerLevel" field.
func (m *ExamMutation) SetNodalOfficerLevel(i int32) {
	m._NodalOfficerLevel = &i
	m.add_NodalOfficerLevel = nil
}

// NodalOfficerLevel returns the value of the "NodalOfficerLevel" field in the mutation.
func (m *ExamMutation) NodalOfficerLevel() (r int32, exists bool) {
	v := m._NodalOfficerLevel
	if v == nil {
		return
	}
	return *v, true
}

// OldNodalOfficerLevel returns the old "NodalOfficerLevel" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldNodalOfficerLevel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodalOfficerLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodalOfficerLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodalOfficerLevel: %w", err)
	}
	return oldValue.NodalOfficerLevel, nil
}

// AddNodalOfficerLevel adds i to the "NodalOfficerLevel" field.
func (m *ExamMutation) AddNodalOfficerLevel(i int32) {
	if m.add_NodalOfficerLevel != nil {
		*m.add_NodalOfficerLevel += i
	} else {
		m.add_NodalOfficerLevel = &i
	}
}

// AddedNodalOfficerLevel returns the value that was added to the "NodalOfficerLevel" field in this mutation.
func (m *ExamMutation) AddedNodalOfficerLevel() (r int32, exists bool) {
	v := m.add_NodalOfficerLevel
	if v == nil {
		return
	}
	return *v, true
}

// ClearNodalOfficerLevel clears the value of the "NodalOfficerLevel" field.
func (m *ExamMutation) ClearNodalOfficerLevel() {
	m._NodalOfficerLevel = nil
	m.add_NodalOfficerLevel = nil
	m.clearedFields[exam.FieldNodalOfficerLevel] = struct{}{}
}

// NodalOfficerLevelCleared returns if the "NodalOfficerLevel" field was cleared in this mutation.
func (m *ExamMutation) NodalOfficerLevelCleared() bool {
	_, ok := m.clearedFields[exam.FieldNodalOfficerLevel]
	return ok
}

// ResetNodalOfficerLevel resets all changes to the "NodalOfficerLevel" field.
func (m *ExamMutation) ResetNodalOfficerLevel() {
	m._NodalOfficerLevel = nil
	m.add_NodalOfficerLevel = nil
	delete(m.clearedFields, exam.FieldNodalOfficerLevel)
}

// SetCalendarCode sets the "CalendarCode" field.
func (m *ExamMutation) SetCalendarCode(i int32) {
	m._CalendarCode = &i
	m.add_CalendarCode = nil
}

// CalendarCode returns the value of the "CalendarCode" field in the mutation.
func (m *ExamMutation) CalendarCode() (r int32, exists bool) {
	v := m._CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCalendarCode returns the old "CalendarCode" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldCalendarCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalendarCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalendarCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalendarCode: %w", err)
	}
	return oldValue.CalendarCode, nil
}

// AddCalendarCode adds i to the "CalendarCode" field.
func (m *ExamMutation) AddCalendarCode(i int32) {
	if m.add_CalendarCode != nil {
		*m.add_CalendarCode += i
	} else {
		m.add_CalendarCode = &i
	}
}

// AddedCalendarCode returns the value that was added to the "CalendarCode" field in this mutation.
func (m *ExamMutation) AddedCalendarCode() (r int32, exists bool) {
	v := m.add_CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalendarCode clears the value of the "CalendarCode" field.
func (m *ExamMutation) ClearCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	m.clearedFields[exam.FieldCalendarCode] = struct{}{}
}

// CalendarCodeCleared returns if the "CalendarCode" field was cleared in this mutation.
func (m *ExamMutation) CalendarCodeCleared() bool {
	_, ok := m.clearedFields[exam.FieldCalendarCode]
	return ok
}

// ResetCalendarCode resets all changes to the "CalendarCode" field.
func (m *ExamMutation) ResetCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	delete(m.clearedFields, exam.FieldCalendarCode)
}

// SetPaperCode sets the "PaperCode" field.
func (m *ExamMutation) SetPaperCode(i int32) {
	m._PaperCode = &i
	m.add_PaperCode = nil
}

// PaperCode returns the value of the "PaperCode" field in the mutation.
func (m *ExamMutation) PaperCode() (r int32, exists bool) {
	v := m._PaperCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperCode returns the old "PaperCode" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldPaperCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperCode: %w", err)
	}
	return oldValue.PaperCode, nil
}

// AddPaperCode adds i to the "PaperCode" field.
func (m *ExamMutation) AddPaperCode(i int32) {
	if m.add_PaperCode != nil {
		*m.add_PaperCode += i
	} else {
		m.add_PaperCode = &i
	}
}

// AddedPaperCode returns the value that was added to the "PaperCode" field in this mutation.
func (m *ExamMutation) AddedPaperCode() (r int32, exists bool) {
	v := m.add_PaperCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaperCode clears the value of the "PaperCode" field.
func (m *ExamMutation) ClearPaperCode() {
	m._PaperCode = nil
	m.add_PaperCode = nil
	m.clearedFields[exam.FieldPaperCode] = struct{}{}
}

// PaperCodeCleared returns if the "PaperCode" field was cleared in this mutation.
func (m *ExamMutation) PaperCodeCleared() bool {
	_, ok := m.clearedFields[exam.FieldPaperCode]
	return ok
}

// ResetPaperCode resets all changes to the "PaperCode" field.
func (m *ExamMutation) ResetPaperCode() {
	m._PaperCode = nil
	m.add_PaperCode = nil
	delete(m.clearedFields, exam.FieldPaperCode)
}

// AddNodalOfficerIDs adds the "nodal_officers" edge to the NodalOfficer entity by ids.
func (m *ExamMutation) AddNodalOfficerIDs(ids ...int32) {
	if m.nodal_officers == nil {
		m.nodal_officers = make(map[int32]struct{})
	}
	for i := range ids {
		m.nodal_officers[ids[i]] = struct{}{}
	}
}

// ClearNodalOfficers clears the "nodal_officers" edge to the NodalOfficer entity.
func (m *ExamMutation) ClearNodalOfficers() {
	m.clearednodal_officers = true
}

// NodalOfficersCleared reports if the "nodal_officers" edge to the NodalOfficer entity was cleared.
func (m *ExamMutation) NodalOfficersCleared() bool {
	return m.clearednodal_officers
}

// RemoveNodalOfficerIDs removes the "nodal_officers" edge to the NodalOfficer entity by IDs.
func (m *ExamMutation) RemoveNodalOfficerIDs(ids ...int32) {
	if m.removednodal_officers == nil {
		m.removednodal_officers = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.nodal_officers, ids[i])
		m.removednodal_officers[ids[i]] = struct{}{}
	}
}

// RemovedNodalOfficers returns the removed IDs of the "nodal_officers" edge to the NodalOfficer entity.
func (m *ExamMutation) RemovedNodalOfficersIDs() (ids []int32) {
	for id := range m.removednodal_officers {
		ids = append(ids, id)
	}
	return
}

// NodalOfficersIDs returns the "nodal_officers" edge IDs in the mutation.
func (m *ExamMutation) NodalOfficersIDs() (ids []int32) {
	for id := range m.nodal_officers {
		ids = append(ids, id)
	}
	return
}

// ResetNodalOfficers resets all changes to the "nodal_officers" edge.
func (m *ExamMutation) ResetNodalOfficers() {
	m.nodal_officers = nil
	m.clearednodal_officers = false
	m.removednodal_officers = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *ExamMutation) AddNotificationIDs(ids ...int32) {
	if m.notifications == nil {
		m.notifications = make(map[int32]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *ExamMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *ExamMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *ExamMutation) RemoveNotificationIDs(ids ...int32) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *ExamMutation) RemovedNotificationsIDs() (ids []int32) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *ExamMutation) NotificationsIDs() (ids []int32) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *ExamMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// AddExamsRefIDs adds the "exams_ref" edge to the ExamCalendar entity by ids.
func (m *ExamMutation) AddExamsRefIDs(ids ...int32) {
	if m.exams_ref == nil {
		m.exams_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.exams_ref[ids[i]] = struct{}{}
	}
}

// ClearExamsRef clears the "exams_ref" edge to the ExamCalendar entity.
func (m *ExamMutation) ClearExamsRef() {
	m.clearedexams_ref = true
}

// ExamsRefCleared reports if the "exams_ref" edge to the ExamCalendar entity was cleared.
func (m *ExamMutation) ExamsRefCleared() bool {
	return m.clearedexams_ref
}

// RemoveExamsRefIDs removes the "exams_ref" edge to the ExamCalendar entity by IDs.
func (m *ExamMutation) RemoveExamsRefIDs(ids ...int32) {
	if m.removedexams_ref == nil {
		m.removedexams_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.exams_ref, ids[i])
		m.removedexams_ref[ids[i]] = struct{}{}
	}
}

// RemovedExamsRef returns the removed IDs of the "exams_ref" edge to the ExamCalendar entity.
func (m *ExamMutation) RemovedExamsRefIDs() (ids []int32) {
	for id := range m.removedexams_ref {
		ids = append(ids, id)
	}
	return
}

// ExamsRefIDs returns the "exams_ref" edge IDs in the mutation.
func (m *ExamMutation) ExamsRefIDs() (ids []int32) {
	for id := range m.exams_ref {
		ids = append(ids, id)
	}
	return
}

// ResetExamsRef resets all changes to the "exams_ref" edge.
func (m *ExamMutation) ResetExamsRef() {
	m.exams_ref = nil
	m.clearedexams_ref = false
	m.removedexams_ref = nil
}

// AddPaperIDs adds the "papers" edge to the ExamPapers entity by ids.
func (m *ExamMutation) AddPaperIDs(ids ...int32) {
	if m.papers == nil {
		m.papers = make(map[int32]struct{})
	}
	for i := range ids {
		m.papers[ids[i]] = struct{}{}
	}
}

// ClearPapers clears the "papers" edge to the ExamPapers entity.
func (m *ExamMutation) ClearPapers() {
	m.clearedpapers = true
}

// PapersCleared reports if the "papers" edge to the ExamPapers entity was cleared.
func (m *ExamMutation) PapersCleared() bool {
	return m.clearedpapers
}

// RemovePaperIDs removes the "papers" edge to the ExamPapers entity by IDs.
func (m *ExamMutation) RemovePaperIDs(ids ...int32) {
	if m.removedpapers == nil {
		m.removedpapers = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.papers, ids[i])
		m.removedpapers[ids[i]] = struct{}{}
	}
}

// RemovedPapers returns the removed IDs of the "papers" edge to the ExamPapers entity.
func (m *ExamMutation) RemovedPapersIDs() (ids []int32) {
	for id := range m.removedpapers {
		ids = append(ids, id)
	}
	return
}

// PapersIDs returns the "papers" edge IDs in the mutation.
func (m *ExamMutation) PapersIDs() (ids []int32) {
	for id := range m.papers {
		ids = append(ids, id)
	}
	return
}

// ResetPapers resets all changes to the "papers" edge.
func (m *ExamMutation) ResetPapers() {
	m.papers = nil
	m.clearedpapers = false
	m.removedpapers = nil
}

// Where appends a list predicates to the ExamMutation builder.
func (m *ExamMutation) Where(ps ...predicate.Exam) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exam, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exam).
func (m *ExamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExamMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._ExamName != nil {
		fields = append(fields, exam.FieldExamName)
	}
	if m._NumOfPapers != nil {
		fields = append(fields, exam.FieldNumOfPapers)
	}
	if m._NotificationBy != nil {
		fields = append(fields, exam.FieldNotificationBy)
	}
	if m._ConductedBy != nil {
		fields = append(fields, exam.FieldConductedBy)
	}
	if m._NodalOfficerLevel != nil {
		fields = append(fields, exam.FieldNodalOfficerLevel)
	}
	if m._CalendarCode != nil {
		fields = append(fields, exam.FieldCalendarCode)
	}
	if m._PaperCode != nil {
		fields = append(fields, exam.FieldPaperCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exam.FieldExamName:
		return m.ExamName()
	case exam.FieldNumOfPapers:
		return m.NumOfPapers()
	case exam.FieldNotificationBy:
		return m.NotificationBy()
	case exam.FieldConductedBy:
		return m.ConductedBy()
	case exam.FieldNodalOfficerLevel:
		return m.NodalOfficerLevel()
	case exam.FieldCalendarCode:
		return m.CalendarCode()
	case exam.FieldPaperCode:
		return m.PaperCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exam.FieldExamName:
		return m.OldExamName(ctx)
	case exam.FieldNumOfPapers:
		return m.OldNumOfPapers(ctx)
	case exam.FieldNotificationBy:
		return m.OldNotificationBy(ctx)
	case exam.FieldConductedBy:
		return m.OldConductedBy(ctx)
	case exam.FieldNodalOfficerLevel:
		return m.OldNodalOfficerLevel(ctx)
	case exam.FieldCalendarCode:
		return m.OldCalendarCode(ctx)
	case exam.FieldPaperCode:
		return m.OldPaperCode(ctx)
	}
	return nil, fmt.Errorf("unknown Exam field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exam.FieldExamName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamName(v)
		return nil
	case exam.FieldNumOfPapers:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumOfPapers(v)
		return nil
	case exam.FieldNotificationBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotificationBy(v)
		return nil
	case exam.FieldConductedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConductedBy(v)
		return nil
	case exam.FieldNodalOfficerLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodalOfficerLevel(v)
		return nil
	case exam.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalendarCode(v)
		return nil
	case exam.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperCode(v)
		return nil
	}
	return fmt.Errorf("unknown Exam field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExamMutation) AddedFields() []string {
	var fields []string
	if m.add_NumOfPapers != nil {
		fields = append(fields, exam.FieldNumOfPapers)
	}
	if m.add_NodalOfficerLevel != nil {
		fields = append(fields, exam.FieldNodalOfficerLevel)
	}
	if m.add_CalendarCode != nil {
		fields = append(fields, exam.FieldCalendarCode)
	}
	if m.add_PaperCode != nil {
		fields = append(fields, exam.FieldPaperCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exam.FieldNumOfPapers:
		return m.AddedNumOfPapers()
	case exam.FieldNodalOfficerLevel:
		return m.AddedNodalOfficerLevel()
	case exam.FieldCalendarCode:
		return m.AddedCalendarCode()
	case exam.FieldPaperCode:
		return m.AddedPaperCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exam.FieldNumOfPapers:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumOfPapers(v)
		return nil
	case exam.FieldNodalOfficerLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNodalOfficerLevel(v)
		return nil
	case exam.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalendarCode(v)
		return nil
	case exam.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaperCode(v)
		return nil
	}
	return fmt.Errorf("unknown Exam numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exam.FieldNodalOfficerLevel) {
		fields = append(fields, exam.FieldNodalOfficerLevel)
	}
	if m.FieldCleared(exam.FieldCalendarCode) {
		fields = append(fields, exam.FieldCalendarCode)
	}
	if m.FieldCleared(exam.FieldPaperCode) {
		fields = append(fields, exam.FieldPaperCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExamMutation) ClearField(name string) error {
	switch name {
	case exam.FieldNodalOfficerLevel:
		m.ClearNodalOfficerLevel()
		return nil
	case exam.FieldCalendarCode:
		m.ClearCalendarCode()
		return nil
	case exam.FieldPaperCode:
		m.ClearPaperCode()
		return nil
	}
	return fmt.Errorf("unknown Exam nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExamMutation) ResetField(name string) error {
	switch name {
	case exam.FieldExamName:
		m.ResetExamName()
		return nil
	case exam.FieldNumOfPapers:
		m.ResetNumOfPapers()
		return nil
	case exam.FieldNotificationBy:
		m.ResetNotificationBy()
		return nil
	case exam.FieldConductedBy:
		m.ResetConductedBy()
		return nil
	case exam.FieldNodalOfficerLevel:
		m.ResetNodalOfficerLevel()
		return nil
	case exam.FieldCalendarCode:
		m.ResetCalendarCode()
		return nil
	case exam.FieldPaperCode:
		m.ResetPaperCode()
		return nil
	}
	return fmt.Errorf("unknown Exam field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExamMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.nodal_officers != nil {
		edges = append(edges, exam.EdgeNodalOfficers)
	}
	if m.notifications != nil {
		edges = append(edges, exam.EdgeNotifications)
	}
	if m.exams_ref != nil {
		edges = append(edges, exam.EdgeExamsRef)
	}
	if m.papers != nil {
		edges = append(edges, exam.EdgePapers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exam.EdgeNodalOfficers:
		ids := make([]ent.Value, 0, len(m.nodal_officers))
		for id := range m.nodal_officers {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgeExamsRef:
		ids := make([]ent.Value, 0, len(m.exams_ref))
		for id := range m.exams_ref {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgePapers:
		ids := make([]ent.Value, 0, len(m.papers))
		for id := range m.papers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removednodal_officers != nil {
		edges = append(edges, exam.EdgeNodalOfficers)
	}
	if m.removednotifications != nil {
		edges = append(edges, exam.EdgeNotifications)
	}
	if m.removedexams_ref != nil {
		edges = append(edges, exam.EdgeExamsRef)
	}
	if m.removedpapers != nil {
		edges = append(edges, exam.EdgePapers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exam.EdgeNodalOfficers:
		ids := make([]ent.Value, 0, len(m.removednodal_officers))
		for id := range m.removednodal_officers {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgeExamsRef:
		ids := make([]ent.Value, 0, len(m.removedexams_ref))
		for id := range m.removedexams_ref {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgePapers:
		ids := make([]ent.Value, 0, len(m.removedpapers))
		for id := range m.removedpapers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearednodal_officers {
		edges = append(edges, exam.EdgeNodalOfficers)
	}
	if m.clearednotifications {
		edges = append(edges, exam.EdgeNotifications)
	}
	if m.clearedexams_ref {
		edges = append(edges, exam.EdgeExamsRef)
	}
	if m.clearedpapers {
		edges = append(edges, exam.EdgePapers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExamMutation) EdgeCleared(name string) bool {
	switch name {
	case exam.EdgeNodalOfficers:
		return m.clearednodal_officers
	case exam.EdgeNotifications:
		return m.clearednotifications
	case exam.EdgeExamsRef:
		return m.clearedexams_ref
	case exam.EdgePapers:
		return m.clearedpapers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Exam unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExamMutation) ResetEdge(name string) error {
	switch name {
	case exam.EdgeNodalOfficers:
		m.ResetNodalOfficers()
		return nil
	case exam.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case exam.EdgeExamsRef:
		m.ResetExamsRef()
		return nil
	case exam.EdgePapers:
		m.ResetPapers()
		return nil
	}
	return fmt.Errorf("unknown Exam edge %s", name)
}

// ExamCalendarMutation represents an operation that mutates the ExamCalendar nodes in the graph.
type ExamCalendarMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int32
	_ExamYear              *int32
	add_ExamYear           *int32
	_ExamName              *string
	_NotificationDate      *time.Time
	_ModelNotificationDate *time.Time
	_ApplicationEndDate    *time.Time
	_ApprovedOrderDate     *time.Time
	_TentativeResultDate   *time.Time
	_CreatedDate           *time.Time
	_ApprovedOrderNumber   *string
	_VacancyYears          *[]interface{}
	append_VacancyYears    []interface{}
	_ExamPapers            *[]interface{}
	append_ExamPapers      []interface{}
	clearedFields          map[string]struct{}
	vcy_years              *int32
	clearedvcy_years       bool
	exams                  *int32
	clearedexams           bool
	papers                 *int32
	clearedpapers          bool
	_Notify_ref            map[int32]struct{}
	removed_Notify_ref     map[int32]struct{}
	cleared_Notify_ref     bool
	done                   bool
	oldValue               func(context.Context) (*ExamCalendar, error)
	predicates             []predicate.ExamCalendar
}

var _ ent.Mutation = (*ExamCalendarMutation)(nil)

// examcalendarOption allows management of the mutation configuration using functional options.
type examcalendarOption func(*ExamCalendarMutation)

// newExamCalendarMutation creates new mutation for the ExamCalendar entity.
func newExamCalendarMutation(c config, op Op, opts ...examcalendarOption) *ExamCalendarMutation {
	m := &ExamCalendarMutation{
		config:        c,
		op:            op,
		typ:           TypeExamCalendar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExamCalendarID sets the ID field of the mutation.
func withExamCalendarID(id int32) examcalendarOption {
	return func(m *ExamCalendarMutation) {
		var (
			err   error
			once  sync.Once
			value *ExamCalendar
		)
		m.oldValue = func(ctx context.Context) (*ExamCalendar, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExamCalendar.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExamCalendar sets the old ExamCalendar of the mutation.
func withExamCalendar(node *ExamCalendar) examcalendarOption {
	return func(m *ExamCalendarMutation) {
		m.oldValue = func(context.Context) (*ExamCalendar, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExamCalendarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExamCalendarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExamCalendar entities.
func (m *ExamCalendarMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExamCalendarMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExamCalendarMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExamCalendar.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExamYear sets the "ExamYear" field.
func (m *ExamCalendarMutation) SetExamYear(i int32) {
	m._ExamYear = &i
	m.add_ExamYear = nil
}

// ExamYear returns the value of the "ExamYear" field in the mutation.
func (m *ExamCalendarMutation) ExamYear() (r int32, exists bool) {
	v := m._ExamYear
	if v == nil {
		return
	}
	return *v, true
}

// OldExamYear returns the old "ExamYear" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldExamYear(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamYear: %w", err)
	}
	return oldValue.ExamYear, nil
}

// AddExamYear adds i to the "ExamYear" field.
func (m *ExamCalendarMutation) AddExamYear(i int32) {
	if m.add_ExamYear != nil {
		*m.add_ExamYear += i
	} else {
		m.add_ExamYear = &i
	}
}

// AddedExamYear returns the value that was added to the "ExamYear" field in this mutation.
func (m *ExamCalendarMutation) AddedExamYear() (r int32, exists bool) {
	v := m.add_ExamYear
	if v == nil {
		return
	}
	return *v, true
}

// ResetExamYear resets all changes to the "ExamYear" field.
func (m *ExamCalendarMutation) ResetExamYear() {
	m._ExamYear = nil
	m.add_ExamYear = nil
}

// SetExamName sets the "ExamName" field.
func (m *ExamCalendarMutation) SetExamName(s string) {
	m._ExamName = &s
}

// ExamName returns the value of the "ExamName" field in the mutation.
func (m *ExamCalendarMutation) ExamName() (r string, exists bool) {
	v := m._ExamName
	if v == nil {
		return
	}
	return *v, true
}

// OldExamName returns the old "ExamName" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldExamName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamName: %w", err)
	}
	return oldValue.ExamName, nil
}

// ResetExamName resets all changes to the "ExamName" field.
func (m *ExamCalendarMutation) ResetExamName() {
	m._ExamName = nil
}

// SetExamCode sets the "ExamCode" field.
func (m *ExamCalendarMutation) SetExamCode(i int32) {
	m.exams = &i
}

// ExamCode returns the value of the "ExamCode" field in the mutation.
func (m *ExamCalendarMutation) ExamCode() (r int32, exists bool) {
	v := m.exams
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCode returns the old "ExamCode" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldExamCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCode: %w", err)
	}
	return oldValue.ExamCode, nil
}

// ClearExamCode clears the value of the "ExamCode" field.
func (m *ExamCalendarMutation) ClearExamCode() {
	m.exams = nil
	m.clearedFields[examcalendar.FieldExamCode] = struct{}{}
}

// ExamCodeCleared returns if the "ExamCode" field was cleared in this mutation.
func (m *ExamCalendarMutation) ExamCodeCleared() bool {
	_, ok := m.clearedFields[examcalendar.FieldExamCode]
	return ok
}

// ResetExamCode resets all changes to the "ExamCode" field.
func (m *ExamCalendarMutation) ResetExamCode() {
	m.exams = nil
	delete(m.clearedFields, examcalendar.FieldExamCode)
}

// SetNotificationDate sets the "NotificationDate" field.
func (m *ExamCalendarMutation) SetNotificationDate(t time.Time) {
	m._NotificationDate = &t
}

// NotificationDate returns the value of the "NotificationDate" field in the mutation.
func (m *ExamCalendarMutation) NotificationDate() (r time.Time, exists bool) {
	v := m._NotificationDate
	if v == nil {
		return
	}
	return *v, true
}

// OldNotificationDate returns the old "NotificationDate" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldNotificationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotificationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotificationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotificationDate: %w", err)
	}
	return oldValue.NotificationDate, nil
}

// ResetNotificationDate resets all changes to the "NotificationDate" field.
func (m *ExamCalendarMutation) ResetNotificationDate() {
	m._NotificationDate = nil
}

// SetModelNotificationDate sets the "ModelNotificationDate" field.
func (m *ExamCalendarMutation) SetModelNotificationDate(t time.Time) {
	m._ModelNotificationDate = &t
}

// ModelNotificationDate returns the value of the "ModelNotificationDate" field in the mutation.
func (m *ExamCalendarMutation) ModelNotificationDate() (r time.Time, exists bool) {
	v := m._ModelNotificationDate
	if v == nil {
		return
	}
	return *v, true
}

// OldModelNotificationDate returns the old "ModelNotificationDate" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldModelNotificationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelNotificationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelNotificationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelNotificationDate: %w", err)
	}
	return oldValue.ModelNotificationDate, nil
}

// ResetModelNotificationDate resets all changes to the "ModelNotificationDate" field.
func (m *ExamCalendarMutation) ResetModelNotificationDate() {
	m._ModelNotificationDate = nil
}

// SetApplicationEndDate sets the "ApplicationEndDate" field.
func (m *ExamCalendarMutation) SetApplicationEndDate(t time.Time) {
	m._ApplicationEndDate = &t
}

// ApplicationEndDate returns the value of the "ApplicationEndDate" field in the mutation.
func (m *ExamCalendarMutation) ApplicationEndDate() (r time.Time, exists bool) {
	v := m._ApplicationEndDate
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationEndDate returns the old "ApplicationEndDate" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldApplicationEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationEndDate: %w", err)
	}
	return oldValue.ApplicationEndDate, nil
}

// ResetApplicationEndDate resets all changes to the "ApplicationEndDate" field.
func (m *ExamCalendarMutation) ResetApplicationEndDate() {
	m._ApplicationEndDate = nil
}

// SetApprovedOrderDate sets the "ApprovedOrderDate" field.
func (m *ExamCalendarMutation) SetApprovedOrderDate(t time.Time) {
	m._ApprovedOrderDate = &t
}

// ApprovedOrderDate returns the value of the "ApprovedOrderDate" field in the mutation.
func (m *ExamCalendarMutation) ApprovedOrderDate() (r time.Time, exists bool) {
	v := m._ApprovedOrderDate
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedOrderDate returns the old "ApprovedOrderDate" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldApprovedOrderDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedOrderDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedOrderDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedOrderDate: %w", err)
	}
	return oldValue.ApprovedOrderDate, nil
}

// ResetApprovedOrderDate resets all changes to the "ApprovedOrderDate" field.
func (m *ExamCalendarMutation) ResetApprovedOrderDate() {
	m._ApprovedOrderDate = nil
}

// SetTentativeResultDate sets the "TentativeResultDate" field.
func (m *ExamCalendarMutation) SetTentativeResultDate(t time.Time) {
	m._TentativeResultDate = &t
}

// TentativeResultDate returns the value of the "TentativeResultDate" field in the mutation.
func (m *ExamCalendarMutation) TentativeResultDate() (r time.Time, exists bool) {
	v := m._TentativeResultDate
	if v == nil {
		return
	}
	return *v, true
}

// OldTentativeResultDate returns the old "TentativeResultDate" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldTentativeResultDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTentativeResultDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTentativeResultDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTentativeResultDate: %w", err)
	}
	return oldValue.TentativeResultDate, nil
}

// ClearTentativeResultDate clears the value of the "TentativeResultDate" field.
func (m *ExamCalendarMutation) ClearTentativeResultDate() {
	m._TentativeResultDate = nil
	m.clearedFields[examcalendar.FieldTentativeResultDate] = struct{}{}
}

// TentativeResultDateCleared returns if the "TentativeResultDate" field was cleared in this mutation.
func (m *ExamCalendarMutation) TentativeResultDateCleared() bool {
	_, ok := m.clearedFields[examcalendar.FieldTentativeResultDate]
	return ok
}

// ResetTentativeResultDate resets all changes to the "TentativeResultDate" field.
func (m *ExamCalendarMutation) ResetTentativeResultDate() {
	m._TentativeResultDate = nil
	delete(m.clearedFields, examcalendar.FieldTentativeResultDate)
}

// SetCreatedDate sets the "CreatedDate" field.
func (m *ExamCalendarMutation) SetCreatedDate(t time.Time) {
	m._CreatedDate = &t
}

// CreatedDate returns the value of the "CreatedDate" field in the mutation.
func (m *ExamCalendarMutation) CreatedDate() (r time.Time, exists bool) {
	v := m._CreatedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "CreatedDate" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ResetCreatedDate resets all changes to the "CreatedDate" field.
func (m *ExamCalendarMutation) ResetCreatedDate() {
	m._CreatedDate = nil
}

// SetApprovedOrderNumber sets the "ApprovedOrderNumber" field.
func (m *ExamCalendarMutation) SetApprovedOrderNumber(s string) {
	m._ApprovedOrderNumber = &s
}

// ApprovedOrderNumber returns the value of the "ApprovedOrderNumber" field in the mutation.
func (m *ExamCalendarMutation) ApprovedOrderNumber() (r string, exists bool) {
	v := m._ApprovedOrderNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedOrderNumber returns the old "ApprovedOrderNumber" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldApprovedOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedOrderNumber: %w", err)
	}
	return oldValue.ApprovedOrderNumber, nil
}

// ResetApprovedOrderNumber resets all changes to the "ApprovedOrderNumber" field.
func (m *ExamCalendarMutation) ResetApprovedOrderNumber() {
	m._ApprovedOrderNumber = nil
}

// SetVacancyYears sets the "VacancyYears" field.
func (m *ExamCalendarMutation) SetVacancyYears(i []interface{}) {
	m._VacancyYears = &i
	m.append_VacancyYears = nil
}

// VacancyYears returns the value of the "VacancyYears" field in the mutation.
func (m *ExamCalendarMutation) VacancyYears() (r []interface{}, exists bool) {
	v := m._VacancyYears
	if v == nil {
		return
	}
	return *v, true
}

// OldVacancyYears returns the old "VacancyYears" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldVacancyYears(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVacancyYears is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVacancyYears requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVacancyYears: %w", err)
	}
	return oldValue.VacancyYears, nil
}

// AppendVacancyYears adds i to the "VacancyYears" field.
func (m *ExamCalendarMutation) AppendVacancyYears(i []interface{}) {
	m.append_VacancyYears = append(m.append_VacancyYears, i...)
}

// AppendedVacancyYears returns the list of values that were appended to the "VacancyYears" field in this mutation.
func (m *ExamCalendarMutation) AppendedVacancyYears() ([]interface{}, bool) {
	if len(m.append_VacancyYears) == 0 {
		return nil, false
	}
	return m.append_VacancyYears, true
}

// ClearVacancyYears clears the value of the "VacancyYears" field.
func (m *ExamCalendarMutation) ClearVacancyYears() {
	m._VacancyYears = nil
	m.append_VacancyYears = nil
	m.clearedFields[examcalendar.FieldVacancyYears] = struct{}{}
}

// VacancyYearsCleared returns if the "VacancyYears" field was cleared in this mutation.
func (m *ExamCalendarMutation) VacancyYearsCleared() bool {
	_, ok := m.clearedFields[examcalendar.FieldVacancyYears]
	return ok
}

// ResetVacancyYears resets all changes to the "VacancyYears" field.
func (m *ExamCalendarMutation) ResetVacancyYears() {
	m._VacancyYears = nil
	m.append_VacancyYears = nil
	delete(m.clearedFields, examcalendar.FieldVacancyYears)
}

// SetExamPapers sets the "ExamPapers" field.
func (m *ExamCalendarMutation) SetExamPapers(i []interface{}) {
	m._ExamPapers = &i
	m.append_ExamPapers = nil
}

// ExamPapers returns the value of the "ExamPapers" field in the mutation.
func (m *ExamCalendarMutation) ExamPapers() (r []interface{}, exists bool) {
	v := m._ExamPapers
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPapers returns the old "ExamPapers" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldExamPapers(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPapers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPapers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPapers: %w", err)
	}
	return oldValue.ExamPapers, nil
}

// AppendExamPapers adds i to the "ExamPapers" field.
func (m *ExamCalendarMutation) AppendExamPapers(i []interface{}) {
	m.append_ExamPapers = append(m.append_ExamPapers, i...)
}

// AppendedExamPapers returns the list of values that were appended to the "ExamPapers" field in this mutation.
func (m *ExamCalendarMutation) AppendedExamPapers() ([]interface{}, bool) {
	if len(m.append_ExamPapers) == 0 {
		return nil, false
	}
	return m.append_ExamPapers, true
}

// ClearExamPapers clears the value of the "ExamPapers" field.
func (m *ExamCalendarMutation) ClearExamPapers() {
	m._ExamPapers = nil
	m.append_ExamPapers = nil
	m.clearedFields[examcalendar.FieldExamPapers] = struct{}{}
}

// ExamPapersCleared returns if the "ExamPapers" field was cleared in this mutation.
func (m *ExamCalendarMutation) ExamPapersCleared() bool {
	_, ok := m.clearedFields[examcalendar.FieldExamPapers]
	return ok
}

// ResetExamPapers resets all changes to the "ExamPapers" field.
func (m *ExamCalendarMutation) ResetExamPapers() {
	m._ExamPapers = nil
	m.append_ExamPapers = nil
	delete(m.clearedFields, examcalendar.FieldExamPapers)
}

// SetVacancyYearCode sets the "VacancyYearCode" field.
func (m *ExamCalendarMutation) SetVacancyYearCode(i int32) {
	m.vcy_years = &i
}

// VacancyYearCode returns the value of the "VacancyYearCode" field in the mutation.
func (m *ExamCalendarMutation) VacancyYearCode() (r int32, exists bool) {
	v := m.vcy_years
	if v == nil {
		return
	}
	return *v, true
}

// OldVacancyYearCode returns the old "VacancyYearCode" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldVacancyYearCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVacancyYearCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVacancyYearCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVacancyYearCode: %w", err)
	}
	return oldValue.VacancyYearCode, nil
}

// ClearVacancyYearCode clears the value of the "VacancyYearCode" field.
func (m *ExamCalendarMutation) ClearVacancyYearCode() {
	m.vcy_years = nil
	m.clearedFields[examcalendar.FieldVacancyYearCode] = struct{}{}
}

// VacancyYearCodeCleared returns if the "VacancyYearCode" field was cleared in this mutation.
func (m *ExamCalendarMutation) VacancyYearCodeCleared() bool {
	_, ok := m.clearedFields[examcalendar.FieldVacancyYearCode]
	return ok
}

// ResetVacancyYearCode resets all changes to the "VacancyYearCode" field.
func (m *ExamCalendarMutation) ResetVacancyYearCode() {
	m.vcy_years = nil
	delete(m.clearedFields, examcalendar.FieldVacancyYearCode)
}

// SetPaperCode sets the "PaperCode" field.
func (m *ExamCalendarMutation) SetPaperCode(i int32) {
	m.papers = &i
}

// PaperCode returns the value of the "PaperCode" field in the mutation.
func (m *ExamCalendarMutation) PaperCode() (r int32, exists bool) {
	v := m.papers
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperCode returns the old "PaperCode" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldPaperCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperCode: %w", err)
	}
	return oldValue.PaperCode, nil
}

// ClearPaperCode clears the value of the "PaperCode" field.
func (m *ExamCalendarMutation) ClearPaperCode() {
	m.papers = nil
	m.clearedFields[examcalendar.FieldPaperCode] = struct{}{}
}

// PaperCodeCleared returns if the "PaperCode" field was cleared in this mutation.
func (m *ExamCalendarMutation) PaperCodeCleared() bool {
	_, ok := m.clearedFields[examcalendar.FieldPaperCode]
	return ok
}

// ResetPaperCode resets all changes to the "PaperCode" field.
func (m *ExamCalendarMutation) ResetPaperCode() {
	m.papers = nil
	delete(m.clearedFields, examcalendar.FieldPaperCode)
}

// SetVcyYearsID sets the "vcy_years" edge to the VacancyYear entity by id.
func (m *ExamCalendarMutation) SetVcyYearsID(id int32) {
	m.vcy_years = &id
}

// ClearVcyYears clears the "vcy_years" edge to the VacancyYear entity.
func (m *ExamCalendarMutation) ClearVcyYears() {
	m.clearedvcy_years = true
}

// VcyYearsCleared reports if the "vcy_years" edge to the VacancyYear entity was cleared.
func (m *ExamCalendarMutation) VcyYearsCleared() bool {
	return m.VacancyYearCodeCleared() || m.clearedvcy_years
}

// VcyYearsID returns the "vcy_years" edge ID in the mutation.
func (m *ExamCalendarMutation) VcyYearsID() (id int32, exists bool) {
	if m.vcy_years != nil {
		return *m.vcy_years, true
	}
	return
}

// VcyYearsIDs returns the "vcy_years" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VcyYearsID instead. It exists only for internal usage by the builders.
func (m *ExamCalendarMutation) VcyYearsIDs() (ids []int32) {
	if id := m.vcy_years; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVcyYears resets all changes to the "vcy_years" edge.
func (m *ExamCalendarMutation) ResetVcyYears() {
	m.vcy_years = nil
	m.clearedvcy_years = false
}

// SetExamsID sets the "exams" edge to the Exam entity by id.
func (m *ExamCalendarMutation) SetExamsID(id int32) {
	m.exams = &id
}

// ClearExams clears the "exams" edge to the Exam entity.
func (m *ExamCalendarMutation) ClearExams() {
	m.clearedexams = true
}

// ExamsCleared reports if the "exams" edge to the Exam entity was cleared.
func (m *ExamCalendarMutation) ExamsCleared() bool {
	return m.ExamCodeCleared() || m.clearedexams
}

// ExamsID returns the "exams" edge ID in the mutation.
func (m *ExamCalendarMutation) ExamsID() (id int32, exists bool) {
	if m.exams != nil {
		return *m.exams, true
	}
	return
}

// ExamsIDs returns the "exams" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamsID instead. It exists only for internal usage by the builders.
func (m *ExamCalendarMutation) ExamsIDs() (ids []int32) {
	if id := m.exams; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExams resets all changes to the "exams" edge.
func (m *ExamCalendarMutation) ResetExams() {
	m.exams = nil
	m.clearedexams = false
}

// SetPapersID sets the "papers" edge to the ExamPapers entity by id.
func (m *ExamCalendarMutation) SetPapersID(id int32) {
	m.papers = &id
}

// ClearPapers clears the "papers" edge to the ExamPapers entity.
func (m *ExamCalendarMutation) ClearPapers() {
	m.clearedpapers = true
}

// PapersCleared reports if the "papers" edge to the ExamPapers entity was cleared.
func (m *ExamCalendarMutation) PapersCleared() bool {
	return m.PaperCodeCleared() || m.clearedpapers
}

// PapersID returns the "papers" edge ID in the mutation.
func (m *ExamCalendarMutation) PapersID() (id int32, exists bool) {
	if m.papers != nil {
		return *m.papers, true
	}
	return
}

// PapersIDs returns the "papers" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PapersID instead. It exists only for internal usage by the builders.
func (m *ExamCalendarMutation) PapersIDs() (ids []int32) {
	if id := m.papers; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPapers resets all changes to the "papers" edge.
func (m *ExamCalendarMutation) ResetPapers() {
	m.papers = nil
	m.clearedpapers = false
}

// AddNotifyRefIDs adds the "Notify_ref" edge to the Notification entity by ids.
func (m *ExamCalendarMutation) AddNotifyRefIDs(ids ...int32) {
	if m._Notify_ref == nil {
		m._Notify_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m._Notify_ref[ids[i]] = struct{}{}
	}
}

// ClearNotifyRef clears the "Notify_ref" edge to the Notification entity.
func (m *ExamCalendarMutation) ClearNotifyRef() {
	m.cleared_Notify_ref = true
}

// NotifyRefCleared reports if the "Notify_ref" edge to the Notification entity was cleared.
func (m *ExamCalendarMutation) NotifyRefCleared() bool {
	return m.cleared_Notify_ref
}

// RemoveNotifyRefIDs removes the "Notify_ref" edge to the Notification entity by IDs.
func (m *ExamCalendarMutation) RemoveNotifyRefIDs(ids ...int32) {
	if m.removed_Notify_ref == nil {
		m.removed_Notify_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m._Notify_ref, ids[i])
		m.removed_Notify_ref[ids[i]] = struct{}{}
	}
}

// RemovedNotifyRef returns the removed IDs of the "Notify_ref" edge to the Notification entity.
func (m *ExamCalendarMutation) RemovedNotifyRefIDs() (ids []int32) {
	for id := range m.removed_Notify_ref {
		ids = append(ids, id)
	}
	return
}

// NotifyRefIDs returns the "Notify_ref" edge IDs in the mutation.
func (m *ExamCalendarMutation) NotifyRefIDs() (ids []int32) {
	for id := range m._Notify_ref {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyRef resets all changes to the "Notify_ref" edge.
func (m *ExamCalendarMutation) ResetNotifyRef() {
	m._Notify_ref = nil
	m.cleared_Notify_ref = false
	m.removed_Notify_ref = nil
}

// Where appends a list predicates to the ExamCalendarMutation builder.
func (m *ExamCalendarMutation) Where(ps ...predicate.ExamCalendar) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExamCalendarMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExamCalendarMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExamCalendar, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExamCalendarMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExamCalendarMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExamCalendar).
func (m *ExamCalendarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExamCalendarMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m._ExamYear != nil {
		fields = append(fields, examcalendar.FieldExamYear)
	}
	if m._ExamName != nil {
		fields = append(fields, examcalendar.FieldExamName)
	}
	if m.exams != nil {
		fields = append(fields, examcalendar.FieldExamCode)
	}
	if m._NotificationDate != nil {
		fields = append(fields, examcalendar.FieldNotificationDate)
	}
	if m._ModelNotificationDate != nil {
		fields = append(fields, examcalendar.FieldModelNotificationDate)
	}
	if m._ApplicationEndDate != nil {
		fields = append(fields, examcalendar.FieldApplicationEndDate)
	}
	if m._ApprovedOrderDate != nil {
		fields = append(fields, examcalendar.FieldApprovedOrderDate)
	}
	if m._TentativeResultDate != nil {
		fields = append(fields, examcalendar.FieldTentativeResultDate)
	}
	if m._CreatedDate != nil {
		fields = append(fields, examcalendar.FieldCreatedDate)
	}
	if m._ApprovedOrderNumber != nil {
		fields = append(fields, examcalendar.FieldApprovedOrderNumber)
	}
	if m._VacancyYears != nil {
		fields = append(fields, examcalendar.FieldVacancyYears)
	}
	if m._ExamPapers != nil {
		fields = append(fields, examcalendar.FieldExamPapers)
	}
	if m.vcy_years != nil {
		fields = append(fields, examcalendar.FieldVacancyYearCode)
	}
	if m.papers != nil {
		fields = append(fields, examcalendar.FieldPaperCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExamCalendarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case examcalendar.FieldExamYear:
		return m.ExamYear()
	case examcalendar.FieldExamName:
		return m.ExamName()
	case examcalendar.FieldExamCode:
		return m.ExamCode()
	case examcalendar.FieldNotificationDate:
		return m.NotificationDate()
	case examcalendar.FieldModelNotificationDate:
		return m.ModelNotificationDate()
	case examcalendar.FieldApplicationEndDate:
		return m.ApplicationEndDate()
	case examcalendar.FieldApprovedOrderDate:
		return m.ApprovedOrderDate()
	case examcalendar.FieldTentativeResultDate:
		return m.TentativeResultDate()
	case examcalendar.FieldCreatedDate:
		return m.CreatedDate()
	case examcalendar.FieldApprovedOrderNumber:
		return m.ApprovedOrderNumber()
	case examcalendar.FieldVacancyYears:
		return m.VacancyYears()
	case examcalendar.FieldExamPapers:
		return m.ExamPapers()
	case examcalendar.FieldVacancyYearCode:
		return m.VacancyYearCode()
	case examcalendar.FieldPaperCode:
		return m.PaperCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExamCalendarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case examcalendar.FieldExamYear:
		return m.OldExamYear(ctx)
	case examcalendar.FieldExamName:
		return m.OldExamName(ctx)
	case examcalendar.FieldExamCode:
		return m.OldExamCode(ctx)
	case examcalendar.FieldNotificationDate:
		return m.OldNotificationDate(ctx)
	case examcalendar.FieldModelNotificationDate:
		return m.OldModelNotificationDate(ctx)
	case examcalendar.FieldApplicationEndDate:
		return m.OldApplicationEndDate(ctx)
	case examcalendar.FieldApprovedOrderDate:
		return m.OldApprovedOrderDate(ctx)
	case examcalendar.FieldTentativeResultDate:
		return m.OldTentativeResultDate(ctx)
	case examcalendar.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	case examcalendar.FieldApprovedOrderNumber:
		return m.OldApprovedOrderNumber(ctx)
	case examcalendar.FieldVacancyYears:
		return m.OldVacancyYears(ctx)
	case examcalendar.FieldExamPapers:
		return m.OldExamPapers(ctx)
	case examcalendar.FieldVacancyYearCode:
		return m.OldVacancyYearCode(ctx)
	case examcalendar.FieldPaperCode:
		return m.OldPaperCode(ctx)
	}
	return nil, fmt.Errorf("unknown ExamCalendar field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamCalendarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case examcalendar.FieldExamYear:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamYear(v)
		return nil
	case examcalendar.FieldExamName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamName(v)
		return nil
	case examcalendar.FieldExamCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCode(v)
		return nil
	case examcalendar.FieldNotificationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotificationDate(v)
		return nil
	case examcalendar.FieldModelNotificationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelNotificationDate(v)
		return nil
	case examcalendar.FieldApplicationEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationEndDate(v)
		return nil
	case examcalendar.FieldApprovedOrderDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedOrderDate(v)
		return nil
	case examcalendar.FieldTentativeResultDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTentativeResultDate(v)
		return nil
	case examcalendar.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	case examcalendar.FieldApprovedOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedOrderNumber(v)
		return nil
	case examcalendar.FieldVacancyYears:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVacancyYears(v)
		return nil
	case examcalendar.FieldExamPapers:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPapers(v)
		return nil
	case examcalendar.FieldVacancyYearCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVacancyYearCode(v)
		return nil
	case examcalendar.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperCode(v)
		return nil
	}
	return fmt.Errorf("unknown ExamCalendar field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExamCalendarMutation) AddedFields() []string {
	var fields []string
	if m.add_ExamYear != nil {
		fields = append(fields, examcalendar.FieldExamYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExamCalendarMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case examcalendar.FieldExamYear:
		return m.AddedExamYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamCalendarMutation) AddField(name string, value ent.Value) error {
	switch name {
	case examcalendar.FieldExamYear:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamYear(v)
		return nil
	}
	return fmt.Errorf("unknown ExamCalendar numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExamCalendarMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(examcalendar.FieldExamCode) {
		fields = append(fields, examcalendar.FieldExamCode)
	}
	if m.FieldCleared(examcalendar.FieldTentativeResultDate) {
		fields = append(fields, examcalendar.FieldTentativeResultDate)
	}
	if m.FieldCleared(examcalendar.FieldVacancyYears) {
		fields = append(fields, examcalendar.FieldVacancyYears)
	}
	if m.FieldCleared(examcalendar.FieldExamPapers) {
		fields = append(fields, examcalendar.FieldExamPapers)
	}
	if m.FieldCleared(examcalendar.FieldVacancyYearCode) {
		fields = append(fields, examcalendar.FieldVacancyYearCode)
	}
	if m.FieldCleared(examcalendar.FieldPaperCode) {
		fields = append(fields, examcalendar.FieldPaperCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExamCalendarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExamCalendarMutation) ClearField(name string) error {
	switch name {
	case examcalendar.FieldExamCode:
		m.ClearExamCode()
		return nil
	case examcalendar.FieldTentativeResultDate:
		m.ClearTentativeResultDate()
		return nil
	case examcalendar.FieldVacancyYears:
		m.ClearVacancyYears()
		return nil
	case examcalendar.FieldExamPapers:
		m.ClearExamPapers()
		return nil
	case examcalendar.FieldVacancyYearCode:
		m.ClearVacancyYearCode()
		return nil
	case examcalendar.FieldPaperCode:
		m.ClearPaperCode()
		return nil
	}
	return fmt.Errorf("unknown ExamCalendar nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExamCalendarMutation) ResetField(name string) error {
	switch name {
	case examcalendar.FieldExamYear:
		m.ResetExamYear()
		return nil
	case examcalendar.FieldExamName:
		m.ResetExamName()
		return nil
	case examcalendar.FieldExamCode:
		m.ResetExamCode()
		return nil
	case examcalendar.FieldNotificationDate:
		m.ResetNotificationDate()
		return nil
	case examcalendar.FieldModelNotificationDate:
		m.ResetModelNotificationDate()
		return nil
	case examcalendar.FieldApplicationEndDate:
		m.ResetApplicationEndDate()
		return nil
	case examcalendar.FieldApprovedOrderDate:
		m.ResetApprovedOrderDate()
		return nil
	case examcalendar.FieldTentativeResultDate:
		m.ResetTentativeResultDate()
		return nil
	case examcalendar.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	case examcalendar.FieldApprovedOrderNumber:
		m.ResetApprovedOrderNumber()
		return nil
	case examcalendar.FieldVacancyYears:
		m.ResetVacancyYears()
		return nil
	case examcalendar.FieldExamPapers:
		m.ResetExamPapers()
		return nil
	case examcalendar.FieldVacancyYearCode:
		m.ResetVacancyYearCode()
		return nil
	case examcalendar.FieldPaperCode:
		m.ResetPaperCode()
		return nil
	}
	return fmt.Errorf("unknown ExamCalendar field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExamCalendarMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.vcy_years != nil {
		edges = append(edges, examcalendar.EdgeVcyYears)
	}
	if m.exams != nil {
		edges = append(edges, examcalendar.EdgeExams)
	}
	if m.papers != nil {
		edges = append(edges, examcalendar.EdgePapers)
	}
	if m._Notify_ref != nil {
		edges = append(edges, examcalendar.EdgeNotifyRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExamCalendarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case examcalendar.EdgeVcyYears:
		if id := m.vcy_years; id != nil {
			return []ent.Value{*id}
		}
	case examcalendar.EdgeExams:
		if id := m.exams; id != nil {
			return []ent.Value{*id}
		}
	case examcalendar.EdgePapers:
		if id := m.papers; id != nil {
			return []ent.Value{*id}
		}
	case examcalendar.EdgeNotifyRef:
		ids := make([]ent.Value, 0, len(m._Notify_ref))
		for id := range m._Notify_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExamCalendarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_Notify_ref != nil {
		edges = append(edges, examcalendar.EdgeNotifyRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExamCalendarMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case examcalendar.EdgeNotifyRef:
		ids := make([]ent.Value, 0, len(m.removed_Notify_ref))
		for id := range m.removed_Notify_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExamCalendarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedvcy_years {
		edges = append(edges, examcalendar.EdgeVcyYears)
	}
	if m.clearedexams {
		edges = append(edges, examcalendar.EdgeExams)
	}
	if m.clearedpapers {
		edges = append(edges, examcalendar.EdgePapers)
	}
	if m.cleared_Notify_ref {
		edges = append(edges, examcalendar.EdgeNotifyRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExamCalendarMutation) EdgeCleared(name string) bool {
	switch name {
	case examcalendar.EdgeVcyYears:
		return m.clearedvcy_years
	case examcalendar.EdgeExams:
		return m.clearedexams
	case examcalendar.EdgePapers:
		return m.clearedpapers
	case examcalendar.EdgeNotifyRef:
		return m.cleared_Notify_ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExamCalendarMutation) ClearEdge(name string) error {
	switch name {
	case examcalendar.EdgeVcyYears:
		m.ClearVcyYears()
		return nil
	case examcalendar.EdgeExams:
		m.ClearExams()
		return nil
	case examcalendar.EdgePapers:
		m.ClearPapers()
		return nil
	}
	return fmt.Errorf("unknown ExamCalendar unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExamCalendarMutation) ResetEdge(name string) error {
	switch name {
	case examcalendar.EdgeVcyYears:
		m.ResetVcyYears()
		return nil
	case examcalendar.EdgeExams:
		m.ResetExams()
		return nil
	case examcalendar.EdgePapers:
		m.ResetPapers()
		return nil
	case examcalendar.EdgeNotifyRef:
		m.ResetNotifyRef()
		return nil
	}
	return fmt.Errorf("unknown ExamCalendar edge %s", name)
}

// ExamEligibilityMutation represents an operation that mutates the ExamEligibility nodes in the graph.
type ExamEligibilityMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int32
	_Examcode                *int32
	add_Examcode             *int32
	_AgeCriteria             *string
	_ServiceCriteria         *string
	_DrivingLicenseCriteria  *string
	_NotifyCode              *int32
	add_NotifyCode           *int32
	_EmployeeCadreID         *int32
	add_EmployeeCadreID      *int32
	_CategoryID              *int32
	add_CategoryID           *int32
	clearedFields            map[string]struct{}
	age_eligibilities        map[int32]struct{}
	removedage_eligibilities map[int32]struct{}
	clearedage_eligibilities bool
	done                     bool
	oldValue                 func(context.Context) (*ExamEligibility, error)
	predicates               []predicate.ExamEligibility
}

var _ ent.Mutation = (*ExamEligibilityMutation)(nil)

// exameligibilityOption allows management of the mutation configuration using functional options.
type exameligibilityOption func(*ExamEligibilityMutation)

// newExamEligibilityMutation creates new mutation for the ExamEligibility entity.
func newExamEligibilityMutation(c config, op Op, opts ...exameligibilityOption) *ExamEligibilityMutation {
	m := &ExamEligibilityMutation{
		config:        c,
		op:            op,
		typ:           TypeExamEligibility,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExamEligibilityID sets the ID field of the mutation.
func withExamEligibilityID(id int32) exameligibilityOption {
	return func(m *ExamEligibilityMutation) {
		var (
			err   error
			once  sync.Once
			value *ExamEligibility
		)
		m.oldValue = func(ctx context.Context) (*ExamEligibility, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExamEligibility.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExamEligibility sets the old ExamEligibility of the mutation.
func withExamEligibility(node *ExamEligibility) exameligibilityOption {
	return func(m *ExamEligibilityMutation) {
		m.oldValue = func(context.Context) (*ExamEligibility, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExamEligibilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExamEligibilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExamEligibility entities.
func (m *ExamEligibilityMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExamEligibilityMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExamEligibilityMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExamEligibility.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExamcode sets the "Examcode" field.
func (m *ExamEligibilityMutation) SetExamcode(i int32) {
	m._Examcode = &i
	m.add_Examcode = nil
}

// Examcode returns the value of the "Examcode" field in the mutation.
func (m *ExamEligibilityMutation) Examcode() (r int32, exists bool) {
	v := m._Examcode
	if v == nil {
		return
	}
	return *v, true
}

// OldExamcode returns the old "Examcode" field's value of the ExamEligibility entity.
// If the ExamEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamEligibilityMutation) OldExamcode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamcode: %w", err)
	}
	return oldValue.Examcode, nil
}

// AddExamcode adds i to the "Examcode" field.
func (m *ExamEligibilityMutation) AddExamcode(i int32) {
	if m.add_Examcode != nil {
		*m.add_Examcode += i
	} else {
		m.add_Examcode = &i
	}
}

// AddedExamcode returns the value that was added to the "Examcode" field in this mutation.
func (m *ExamEligibilityMutation) AddedExamcode() (r int32, exists bool) {
	v := m.add_Examcode
	if v == nil {
		return
	}
	return *v, true
}

// ResetExamcode resets all changes to the "Examcode" field.
func (m *ExamEligibilityMutation) ResetExamcode() {
	m._Examcode = nil
	m.add_Examcode = nil
}

// SetAgeCriteria sets the "AgeCriteria" field.
func (m *ExamEligibilityMutation) SetAgeCriteria(s string) {
	m._AgeCriteria = &s
}

// AgeCriteria returns the value of the "AgeCriteria" field in the mutation.
func (m *ExamEligibilityMutation) AgeCriteria() (r string, exists bool) {
	v := m._AgeCriteria
	if v == nil {
		return
	}
	return *v, true
}

// OldAgeCriteria returns the old "AgeCriteria" field's value of the ExamEligibility entity.
// If the ExamEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamEligibilityMutation) OldAgeCriteria(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgeCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgeCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgeCriteria: %w", err)
	}
	return oldValue.AgeCriteria, nil
}

// ClearAgeCriteria clears the value of the "AgeCriteria" field.
func (m *ExamEligibilityMutation) ClearAgeCriteria() {
	m._AgeCriteria = nil
	m.clearedFields[exameligibility.FieldAgeCriteria] = struct{}{}
}

// AgeCriteriaCleared returns if the "AgeCriteria" field was cleared in this mutation.
func (m *ExamEligibilityMutation) AgeCriteriaCleared() bool {
	_, ok := m.clearedFields[exameligibility.FieldAgeCriteria]
	return ok
}

// ResetAgeCriteria resets all changes to the "AgeCriteria" field.
func (m *ExamEligibilityMutation) ResetAgeCriteria() {
	m._AgeCriteria = nil
	delete(m.clearedFields, exameligibility.FieldAgeCriteria)
}

// SetServiceCriteria sets the "ServiceCriteria" field.
func (m *ExamEligibilityMutation) SetServiceCriteria(s string) {
	m._ServiceCriteria = &s
}

// ServiceCriteria returns the value of the "ServiceCriteria" field in the mutation.
func (m *ExamEligibilityMutation) ServiceCriteria() (r string, exists bool) {
	v := m._ServiceCriteria
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceCriteria returns the old "ServiceCriteria" field's value of the ExamEligibility entity.
// If the ExamEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamEligibilityMutation) OldServiceCriteria(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceCriteria: %w", err)
	}
	return oldValue.ServiceCriteria, nil
}

// ClearServiceCriteria clears the value of the "ServiceCriteria" field.
func (m *ExamEligibilityMutation) ClearServiceCriteria() {
	m._ServiceCriteria = nil
	m.clearedFields[exameligibility.FieldServiceCriteria] = struct{}{}
}

// ServiceCriteriaCleared returns if the "ServiceCriteria" field was cleared in this mutation.
func (m *ExamEligibilityMutation) ServiceCriteriaCleared() bool {
	_, ok := m.clearedFields[exameligibility.FieldServiceCriteria]
	return ok
}

// ResetServiceCriteria resets all changes to the "ServiceCriteria" field.
func (m *ExamEligibilityMutation) ResetServiceCriteria() {
	m._ServiceCriteria = nil
	delete(m.clearedFields, exameligibility.FieldServiceCriteria)
}

// SetDrivingLicenseCriteria sets the "DrivingLicenseCriteria" field.
func (m *ExamEligibilityMutation) SetDrivingLicenseCriteria(s string) {
	m._DrivingLicenseCriteria = &s
}

// DrivingLicenseCriteria returns the value of the "DrivingLicenseCriteria" field in the mutation.
func (m *ExamEligibilityMutation) DrivingLicenseCriteria() (r string, exists bool) {
	v := m._DrivingLicenseCriteria
	if v == nil {
		return
	}
	return *v, true
}

// OldDrivingLicenseCriteria returns the old "DrivingLicenseCriteria" field's value of the ExamEligibility entity.
// If the ExamEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamEligibilityMutation) OldDrivingLicenseCriteria(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrivingLicenseCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrivingLicenseCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrivingLicenseCriteria: %w", err)
	}
	return oldValue.DrivingLicenseCriteria, nil
}

// ClearDrivingLicenseCriteria clears the value of the "DrivingLicenseCriteria" field.
func (m *ExamEligibilityMutation) ClearDrivingLicenseCriteria() {
	m._DrivingLicenseCriteria = nil
	m.clearedFields[exameligibility.FieldDrivingLicenseCriteria] = struct{}{}
}

// DrivingLicenseCriteriaCleared returns if the "DrivingLicenseCriteria" field was cleared in this mutation.
func (m *ExamEligibilityMutation) DrivingLicenseCriteriaCleared() bool {
	_, ok := m.clearedFields[exameligibility.FieldDrivingLicenseCriteria]
	return ok
}

// ResetDrivingLicenseCriteria resets all changes to the "DrivingLicenseCriteria" field.
func (m *ExamEligibilityMutation) ResetDrivingLicenseCriteria() {
	m._DrivingLicenseCriteria = nil
	delete(m.clearedFields, exameligibility.FieldDrivingLicenseCriteria)
}

// SetNotifyCode sets the "NotifyCode" field.
func (m *ExamEligibilityMutation) SetNotifyCode(i int32) {
	m._NotifyCode = &i
	m.add_NotifyCode = nil
}

// NotifyCode returns the value of the "NotifyCode" field in the mutation.
func (m *ExamEligibilityMutation) NotifyCode() (r int32, exists bool) {
	v := m._NotifyCode
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyCode returns the old "NotifyCode" field's value of the ExamEligibility entity.
// If the ExamEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamEligibilityMutation) OldNotifyCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyCode: %w", err)
	}
	return oldValue.NotifyCode, nil
}

// AddNotifyCode adds i to the "NotifyCode" field.
func (m *ExamEligibilityMutation) AddNotifyCode(i int32) {
	if m.add_NotifyCode != nil {
		*m.add_NotifyCode += i
	} else {
		m.add_NotifyCode = &i
	}
}

// AddedNotifyCode returns the value that was added to the "NotifyCode" field in this mutation.
func (m *ExamEligibilityMutation) AddedNotifyCode() (r int32, exists bool) {
	v := m.add_NotifyCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearNotifyCode clears the value of the "NotifyCode" field.
func (m *ExamEligibilityMutation) ClearNotifyCode() {
	m._NotifyCode = nil
	m.add_NotifyCode = nil
	m.clearedFields[exameligibility.FieldNotifyCode] = struct{}{}
}

// NotifyCodeCleared returns if the "NotifyCode" field was cleared in this mutation.
func (m *ExamEligibilityMutation) NotifyCodeCleared() bool {
	_, ok := m.clearedFields[exameligibility.FieldNotifyCode]
	return ok
}

// ResetNotifyCode resets all changes to the "NotifyCode" field.
func (m *ExamEligibilityMutation) ResetNotifyCode() {
	m._NotifyCode = nil
	m.add_NotifyCode = nil
	delete(m.clearedFields, exameligibility.FieldNotifyCode)
}

// SetEmployeeCadreID sets the "EmployeeCadreID" field.
func (m *ExamEligibilityMutation) SetEmployeeCadreID(i int32) {
	m._EmployeeCadreID = &i
	m.add_EmployeeCadreID = nil
}

// EmployeeCadreID returns the value of the "EmployeeCadreID" field in the mutation.
func (m *ExamEligibilityMutation) EmployeeCadreID() (r int32, exists bool) {
	v := m._EmployeeCadreID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCadreID returns the old "EmployeeCadreID" field's value of the ExamEligibility entity.
// If the ExamEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamEligibilityMutation) OldEmployeeCadreID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCadreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCadreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCadreID: %w", err)
	}
	return oldValue.EmployeeCadreID, nil
}

// AddEmployeeCadreID adds i to the "EmployeeCadreID" field.
func (m *ExamEligibilityMutation) AddEmployeeCadreID(i int32) {
	if m.add_EmployeeCadreID != nil {
		*m.add_EmployeeCadreID += i
	} else {
		m.add_EmployeeCadreID = &i
	}
}

// AddedEmployeeCadreID returns the value that was added to the "EmployeeCadreID" field in this mutation.
func (m *ExamEligibilityMutation) AddedEmployeeCadreID() (r int32, exists bool) {
	v := m.add_EmployeeCadreID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeeCadreID clears the value of the "EmployeeCadreID" field.
func (m *ExamEligibilityMutation) ClearEmployeeCadreID() {
	m._EmployeeCadreID = nil
	m.add_EmployeeCadreID = nil
	m.clearedFields[exameligibility.FieldEmployeeCadreID] = struct{}{}
}

// EmployeeCadreIDCleared returns if the "EmployeeCadreID" field was cleared in this mutation.
func (m *ExamEligibilityMutation) EmployeeCadreIDCleared() bool {
	_, ok := m.clearedFields[exameligibility.FieldEmployeeCadreID]
	return ok
}

// ResetEmployeeCadreID resets all changes to the "EmployeeCadreID" field.
func (m *ExamEligibilityMutation) ResetEmployeeCadreID() {
	m._EmployeeCadreID = nil
	m.add_EmployeeCadreID = nil
	delete(m.clearedFields, exameligibility.FieldEmployeeCadreID)
}

// SetCategoryID sets the "CategoryID" field.
func (m *ExamEligibilityMutation) SetCategoryID(i int32) {
	m._CategoryID = &i
	m.add_CategoryID = nil
}

// CategoryID returns the value of the "CategoryID" field in the mutation.
func (m *ExamEligibilityMutation) CategoryID() (r int32, exists bool) {
	v := m._CategoryID
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "CategoryID" field's value of the ExamEligibility entity.
// If the ExamEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamEligibilityMutation) OldCategoryID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "CategoryID" field.
func (m *ExamEligibilityMutation) AddCategoryID(i int32) {
	if m.add_CategoryID != nil {
		*m.add_CategoryID += i
	} else {
		m.add_CategoryID = &i
	}
}

// AddedCategoryID returns the value that was added to the "CategoryID" field in this mutation.
func (m *ExamEligibilityMutation) AddedCategoryID() (r int32, exists bool) {
	v := m.add_CategoryID
	if v == nil {
		return
	}
	return *v, true
}

// ClearCategoryID clears the value of the "CategoryID" field.
func (m *ExamEligibilityMutation) ClearCategoryID() {
	m._CategoryID = nil
	m.add_CategoryID = nil
	m.clearedFields[exameligibility.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "CategoryID" field was cleared in this mutation.
func (m *ExamEligibilityMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[exameligibility.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "CategoryID" field.
func (m *ExamEligibilityMutation) ResetCategoryID() {
	m._CategoryID = nil
	m.add_CategoryID = nil
	delete(m.clearedFields, exameligibility.FieldCategoryID)
}

// AddAgeEligibilityIDs adds the "age_eligibilities" edge to the AgeEligibility entity by ids.
func (m *ExamEligibilityMutation) AddAgeEligibilityIDs(ids ...int32) {
	if m.age_eligibilities == nil {
		m.age_eligibilities = make(map[int32]struct{})
	}
	for i := range ids {
		m.age_eligibilities[ids[i]] = struct{}{}
	}
}

// ClearAgeEligibilities clears the "age_eligibilities" edge to the AgeEligibility entity.
func (m *ExamEligibilityMutation) ClearAgeEligibilities() {
	m.clearedage_eligibilities = true
}

// AgeEligibilitiesCleared reports if the "age_eligibilities" edge to the AgeEligibility entity was cleared.
func (m *ExamEligibilityMutation) AgeEligibilitiesCleared() bool {
	return m.clearedage_eligibilities
}

// RemoveAgeEligibilityIDs removes the "age_eligibilities" edge to the AgeEligibility entity by IDs.
func (m *ExamEligibilityMutation) RemoveAgeEligibilityIDs(ids ...int32) {
	if m.removedage_eligibilities == nil {
		m.removedage_eligibilities = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.age_eligibilities, ids[i])
		m.removedage_eligibilities[ids[i]] = struct{}{}
	}
}

// RemovedAgeEligibilities returns the removed IDs of the "age_eligibilities" edge to the AgeEligibility entity.
func (m *ExamEligibilityMutation) RemovedAgeEligibilitiesIDs() (ids []int32) {
	for id := range m.removedage_eligibilities {
		ids = append(ids, id)
	}
	return
}

// AgeEligibilitiesIDs returns the "age_eligibilities" edge IDs in the mutation.
func (m *ExamEligibilityMutation) AgeEligibilitiesIDs() (ids []int32) {
	for id := range m.age_eligibilities {
		ids = append(ids, id)
	}
	return
}

// ResetAgeEligibilities resets all changes to the "age_eligibilities" edge.
func (m *ExamEligibilityMutation) ResetAgeEligibilities() {
	m.age_eligibilities = nil
	m.clearedage_eligibilities = false
	m.removedage_eligibilities = nil
}

// Where appends a list predicates to the ExamEligibilityMutation builder.
func (m *ExamEligibilityMutation) Where(ps ...predicate.ExamEligibility) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExamEligibilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExamEligibilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExamEligibility, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExamEligibilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExamEligibilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExamEligibility).
func (m *ExamEligibilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExamEligibilityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._Examcode != nil {
		fields = append(fields, exameligibility.FieldExamcode)
	}
	if m._AgeCriteria != nil {
		fields = append(fields, exameligibility.FieldAgeCriteria)
	}
	if m._ServiceCriteria != nil {
		fields = append(fields, exameligibility.FieldServiceCriteria)
	}
	if m._DrivingLicenseCriteria != nil {
		fields = append(fields, exameligibility.FieldDrivingLicenseCriteria)
	}
	if m._NotifyCode != nil {
		fields = append(fields, exameligibility.FieldNotifyCode)
	}
	if m._EmployeeCadreID != nil {
		fields = append(fields, exameligibility.FieldEmployeeCadreID)
	}
	if m._CategoryID != nil {
		fields = append(fields, exameligibility.FieldCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExamEligibilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exameligibility.FieldExamcode:
		return m.Examcode()
	case exameligibility.FieldAgeCriteria:
		return m.AgeCriteria()
	case exameligibility.FieldServiceCriteria:
		return m.ServiceCriteria()
	case exameligibility.FieldDrivingLicenseCriteria:
		return m.DrivingLicenseCriteria()
	case exameligibility.FieldNotifyCode:
		return m.NotifyCode()
	case exameligibility.FieldEmployeeCadreID:
		return m.EmployeeCadreID()
	case exameligibility.FieldCategoryID:
		return m.CategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExamEligibilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exameligibility.FieldExamcode:
		return m.OldExamcode(ctx)
	case exameligibility.FieldAgeCriteria:
		return m.OldAgeCriteria(ctx)
	case exameligibility.FieldServiceCriteria:
		return m.OldServiceCriteria(ctx)
	case exameligibility.FieldDrivingLicenseCriteria:
		return m.OldDrivingLicenseCriteria(ctx)
	case exameligibility.FieldNotifyCode:
		return m.OldNotifyCode(ctx)
	case exameligibility.FieldEmployeeCadreID:
		return m.OldEmployeeCadreID(ctx)
	case exameligibility.FieldCategoryID:
		return m.OldCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown ExamEligibility field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamEligibilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exameligibility.FieldExamcode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamcode(v)
		return nil
	case exameligibility.FieldAgeCriteria:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgeCriteria(v)
		return nil
	case exameligibility.FieldServiceCriteria:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceCriteria(v)
		return nil
	case exameligibility.FieldDrivingLicenseCriteria:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrivingLicenseCriteria(v)
		return nil
	case exameligibility.FieldNotifyCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyCode(v)
		return nil
	case exameligibility.FieldEmployeeCadreID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCadreID(v)
		return nil
	case exameligibility.FieldCategoryID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown ExamEligibility field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExamEligibilityMutation) AddedFields() []string {
	var fields []string
	if m.add_Examcode != nil {
		fields = append(fields, exameligibility.FieldExamcode)
	}
	if m.add_NotifyCode != nil {
		fields = append(fields, exameligibility.FieldNotifyCode)
	}
	if m.add_EmployeeCadreID != nil {
		fields = append(fields, exameligibility.FieldEmployeeCadreID)
	}
	if m.add_CategoryID != nil {
		fields = append(fields, exameligibility.FieldCategoryID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExamEligibilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exameligibility.FieldExamcode:
		return m.AddedExamcode()
	case exameligibility.FieldNotifyCode:
		return m.AddedNotifyCode()
	case exameligibility.FieldEmployeeCadreID:
		return m.AddedEmployeeCadreID()
	case exameligibility.FieldCategoryID:
		return m.AddedCategoryID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamEligibilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exameligibility.FieldExamcode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamcode(v)
		return nil
	case exameligibility.FieldNotifyCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotifyCode(v)
		return nil
	case exameligibility.FieldEmployeeCadreID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeCadreID(v)
		return nil
	case exameligibility.FieldCategoryID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown ExamEligibility numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExamEligibilityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exameligibility.FieldAgeCriteria) {
		fields = append(fields, exameligibility.FieldAgeCriteria)
	}
	if m.FieldCleared(exameligibility.FieldServiceCriteria) {
		fields = append(fields, exameligibility.FieldServiceCriteria)
	}
	if m.FieldCleared(exameligibility.FieldDrivingLicenseCriteria) {
		fields = append(fields, exameligibility.FieldDrivingLicenseCriteria)
	}
	if m.FieldCleared(exameligibility.FieldNotifyCode) {
		fields = append(fields, exameligibility.FieldNotifyCode)
	}
	if m.FieldCleared(exameligibility.FieldEmployeeCadreID) {
		fields = append(fields, exameligibility.FieldEmployeeCadreID)
	}
	if m.FieldCleared(exameligibility.FieldCategoryID) {
		fields = append(fields, exameligibility.FieldCategoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExamEligibilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExamEligibilityMutation) ClearField(name string) error {
	switch name {
	case exameligibility.FieldAgeCriteria:
		m.ClearAgeCriteria()
		return nil
	case exameligibility.FieldServiceCriteria:
		m.ClearServiceCriteria()
		return nil
	case exameligibility.FieldDrivingLicenseCriteria:
		m.ClearDrivingLicenseCriteria()
		return nil
	case exameligibility.FieldNotifyCode:
		m.ClearNotifyCode()
		return nil
	case exameligibility.FieldEmployeeCadreID:
		m.ClearEmployeeCadreID()
		return nil
	case exameligibility.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	}
	return fmt.Errorf("unknown ExamEligibility nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExamEligibilityMutation) ResetField(name string) error {
	switch name {
	case exameligibility.FieldExamcode:
		m.ResetExamcode()
		return nil
	case exameligibility.FieldAgeCriteria:
		m.ResetAgeCriteria()
		return nil
	case exameligibility.FieldServiceCriteria:
		m.ResetServiceCriteria()
		return nil
	case exameligibility.FieldDrivingLicenseCriteria:
		m.ResetDrivingLicenseCriteria()
		return nil
	case exameligibility.FieldNotifyCode:
		m.ResetNotifyCode()
		return nil
	case exameligibility.FieldEmployeeCadreID:
		m.ResetEmployeeCadreID()
		return nil
	case exameligibility.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	}
	return fmt.Errorf("unknown ExamEligibility field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExamEligibilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.age_eligibilities != nil {
		edges = append(edges, exameligibility.EdgeAgeEligibilities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExamEligibilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exameligibility.EdgeAgeEligibilities:
		ids := make([]ent.Value, 0, len(m.age_eligibilities))
		for id := range m.age_eligibilities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExamEligibilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedage_eligibilities != nil {
		edges = append(edges, exameligibility.EdgeAgeEligibilities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExamEligibilityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exameligibility.EdgeAgeEligibilities:
		ids := make([]ent.Value, 0, len(m.removedage_eligibilities))
		for id := range m.removedage_eligibilities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExamEligibilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedage_eligibilities {
		edges = append(edges, exameligibility.EdgeAgeEligibilities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExamEligibilityMutation) EdgeCleared(name string) bool {
	switch name {
	case exameligibility.EdgeAgeEligibilities:
		return m.clearedage_eligibilities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExamEligibilityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ExamEligibility unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExamEligibilityMutation) ResetEdge(name string) error {
	switch name {
	case exameligibility.EdgeAgeEligibilities:
		m.ResetAgeEligibilities()
		return nil
	}
	return fmt.Errorf("unknown ExamEligibility edge %s", name)
}

// ExamPapersMutation represents an operation that mutates the ExamPapers nodes in the graph.
type ExamPapersMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int32
	_PaperDescription                 *string
	competitiveQualifying             *string
	exceptionForDisability            *string
	_MaximumMarks                     *int
	add_MaximumMarks                  *int
	_Duration                         *int
	add_Duration                      *int
	localLanguageAllowedQuestionPaper *string
	localLanguageAllowedAnswerPaper   *string
	_OrderNumber                      *string
	_PaperStatus                      *string
	_CalendarCode                     *int32
	add_CalendarCode                  *int32
	_CreatedDate                      *time.Time
	clearedFields                     map[string]struct{}
	centers                           map[int32]struct{}
	removedcenters                    map[int32]struct{}
	clearedcenters                    bool
	exam                              *int32
	clearedexam                       bool
	exampapers_types                  map[int32]struct{}
	removedexampapers_types           map[int32]struct{}
	clearedexampapers_types           bool
	papers_ref                        map[int32]struct{}
	removedpapers_ref                 map[int32]struct{}
	clearedpapers_ref                 bool
	done                              bool
	oldValue                          func(context.Context) (*ExamPapers, error)
	predicates                        []predicate.ExamPapers
}

var _ ent.Mutation = (*ExamPapersMutation)(nil)

// exampapersOption allows management of the mutation configuration using functional options.
type exampapersOption func(*ExamPapersMutation)

// newExamPapersMutation creates new mutation for the ExamPapers entity.
func newExamPapersMutation(c config, op Op, opts ...exampapersOption) *ExamPapersMutation {
	m := &ExamPapersMutation{
		config:        c,
		op:            op,
		typ:           TypeExamPapers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExamPapersID sets the ID field of the mutation.
func withExamPapersID(id int32) exampapersOption {
	return func(m *ExamPapersMutation) {
		var (
			err   error
			once  sync.Once
			value *ExamPapers
		)
		m.oldValue = func(ctx context.Context) (*ExamPapers, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExamPapers.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExamPapers sets the old ExamPapers of the mutation.
func withExamPapers(node *ExamPapers) exampapersOption {
	return func(m *ExamPapersMutation) {
		m.oldValue = func(context.Context) (*ExamPapers, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExamPapersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExamPapersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExamPapers entities.
func (m *ExamPapersMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExamPapersMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExamPapersMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExamPapers.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPaperDescription sets the "PaperDescription" field.
func (m *ExamPapersMutation) SetPaperDescription(s string) {
	m._PaperDescription = &s
}

// PaperDescription returns the value of the "PaperDescription" field in the mutation.
func (m *ExamPapersMutation) PaperDescription() (r string, exists bool) {
	v := m._PaperDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperDescription returns the old "PaperDescription" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldPaperDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperDescription: %w", err)
	}
	return oldValue.PaperDescription, nil
}

// ResetPaperDescription resets all changes to the "PaperDescription" field.
func (m *ExamPapersMutation) ResetPaperDescription() {
	m._PaperDescription = nil
}

// SetExamCode sets the "ExamCode" field.
func (m *ExamPapersMutation) SetExamCode(i int32) {
	m.exam = &i
}

// ExamCode returns the value of the "ExamCode" field in the mutation.
func (m *ExamPapersMutation) ExamCode() (r int32, exists bool) {
	v := m.exam
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCode returns the old "ExamCode" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldExamCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCode: %w", err)
	}
	return oldValue.ExamCode, nil
}

// ClearExamCode clears the value of the "ExamCode" field.
func (m *ExamPapersMutation) ClearExamCode() {
	m.exam = nil
	m.clearedFields[exampapers.FieldExamCode] = struct{}{}
}

// ExamCodeCleared returns if the "ExamCode" field was cleared in this mutation.
func (m *ExamPapersMutation) ExamCodeCleared() bool {
	_, ok := m.clearedFields[exampapers.FieldExamCode]
	return ok
}

// ResetExamCode resets all changes to the "ExamCode" field.
func (m *ExamPapersMutation) ResetExamCode() {
	m.exam = nil
	delete(m.clearedFields, exampapers.FieldExamCode)
}

// SetCompetitiveQualifying sets the "competitiveQualifying" field.
func (m *ExamPapersMutation) SetCompetitiveQualifying(s string) {
	m.competitiveQualifying = &s
}

// CompetitiveQualifying returns the value of the "competitiveQualifying" field in the mutation.
func (m *ExamPapersMutation) CompetitiveQualifying() (r string, exists bool) {
	v := m.competitiveQualifying
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitiveQualifying returns the old "competitiveQualifying" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldCompetitiveQualifying(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitiveQualifying is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitiveQualifying requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitiveQualifying: %w", err)
	}
	return oldValue.CompetitiveQualifying, nil
}

// ResetCompetitiveQualifying resets all changes to the "competitiveQualifying" field.
func (m *ExamPapersMutation) ResetCompetitiveQualifying() {
	m.competitiveQualifying = nil
}

// SetExceptionForDisability sets the "exceptionForDisability" field.
func (m *ExamPapersMutation) SetExceptionForDisability(s string) {
	m.exceptionForDisability = &s
}

// ExceptionForDisability returns the value of the "exceptionForDisability" field in the mutation.
func (m *ExamPapersMutation) ExceptionForDisability() (r string, exists bool) {
	v := m.exceptionForDisability
	if v == nil {
		return
	}
	return *v, true
}

// OldExceptionForDisability returns the old "exceptionForDisability" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldExceptionForDisability(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExceptionForDisability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExceptionForDisability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExceptionForDisability: %w", err)
	}
	return oldValue.ExceptionForDisability, nil
}

// ResetExceptionForDisability resets all changes to the "exceptionForDisability" field.
func (m *ExamPapersMutation) ResetExceptionForDisability() {
	m.exceptionForDisability = nil
}

// SetMaximumMarks sets the "MaximumMarks" field.
func (m *ExamPapersMutation) SetMaximumMarks(i int) {
	m._MaximumMarks = &i
	m.add_MaximumMarks = nil
}

// MaximumMarks returns the value of the "MaximumMarks" field in the mutation.
func (m *ExamPapersMutation) MaximumMarks() (r int, exists bool) {
	v := m._MaximumMarks
	if v == nil {
		return
	}
	return *v, true
}

// OldMaximumMarks returns the old "MaximumMarks" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldMaximumMarks(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaximumMarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaximumMarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaximumMarks: %w", err)
	}
	return oldValue.MaximumMarks, nil
}

// AddMaximumMarks adds i to the "MaximumMarks" field.
func (m *ExamPapersMutation) AddMaximumMarks(i int) {
	if m.add_MaximumMarks != nil {
		*m.add_MaximumMarks += i
	} else {
		m.add_MaximumMarks = &i
	}
}

// AddedMaximumMarks returns the value that was added to the "MaximumMarks" field in this mutation.
func (m *ExamPapersMutation) AddedMaximumMarks() (r int, exists bool) {
	v := m.add_MaximumMarks
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaximumMarks resets all changes to the "MaximumMarks" field.
func (m *ExamPapersMutation) ResetMaximumMarks() {
	m._MaximumMarks = nil
	m.add_MaximumMarks = nil
}

// SetDuration sets the "Duration" field.
func (m *ExamPapersMutation) SetDuration(i int) {
	m._Duration = &i
	m.add_Duration = nil
}

// Duration returns the value of the "Duration" field in the mutation.
func (m *ExamPapersMutation) Duration() (r int, exists bool) {
	v := m._Duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "Duration" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "Duration" field.
func (m *ExamPapersMutation) AddDuration(i int) {
	if m.add_Duration != nil {
		*m.add_Duration += i
	} else {
		m.add_Duration = &i
	}
}

// AddedDuration returns the value that was added to the "Duration" field in this mutation.
func (m *ExamPapersMutation) AddedDuration() (r int, exists bool) {
	v := m.add_Duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "Duration" field.
func (m *ExamPapersMutation) ResetDuration() {
	m._Duration = nil
	m.add_Duration = nil
}

// SetLocalLanguageAllowedQuestionPaper sets the "localLanguageAllowedQuestionPaper" field.
func (m *ExamPapersMutation) SetLocalLanguageAllowedQuestionPaper(s string) {
	m.localLanguageAllowedQuestionPaper = &s
}

// LocalLanguageAllowedQuestionPaper returns the value of the "localLanguageAllowedQuestionPaper" field in the mutation.
func (m *ExamPapersMutation) LocalLanguageAllowedQuestionPaper() (r string, exists bool) {
	v := m.localLanguageAllowedQuestionPaper
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalLanguageAllowedQuestionPaper returns the old "localLanguageAllowedQuestionPaper" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldLocalLanguageAllowedQuestionPaper(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalLanguageAllowedQuestionPaper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalLanguageAllowedQuestionPaper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalLanguageAllowedQuestionPaper: %w", err)
	}
	return oldValue.LocalLanguageAllowedQuestionPaper, nil
}

// ResetLocalLanguageAllowedQuestionPaper resets all changes to the "localLanguageAllowedQuestionPaper" field.
func (m *ExamPapersMutation) ResetLocalLanguageAllowedQuestionPaper() {
	m.localLanguageAllowedQuestionPaper = nil
}

// SetLocalLanguageAllowedAnswerPaper sets the "localLanguageAllowedAnswerPaper" field.
func (m *ExamPapersMutation) SetLocalLanguageAllowedAnswerPaper(s string) {
	m.localLanguageAllowedAnswerPaper = &s
}

// LocalLanguageAllowedAnswerPaper returns the value of the "localLanguageAllowedAnswerPaper" field in the mutation.
func (m *ExamPapersMutation) LocalLanguageAllowedAnswerPaper() (r string, exists bool) {
	v := m.localLanguageAllowedAnswerPaper
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalLanguageAllowedAnswerPaper returns the old "localLanguageAllowedAnswerPaper" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldLocalLanguageAllowedAnswerPaper(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalLanguageAllowedAnswerPaper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalLanguageAllowedAnswerPaper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalLanguageAllowedAnswerPaper: %w", err)
	}
	return oldValue.LocalLanguageAllowedAnswerPaper, nil
}

// ResetLocalLanguageAllowedAnswerPaper resets all changes to the "localLanguageAllowedAnswerPaper" field.
func (m *ExamPapersMutation) ResetLocalLanguageAllowedAnswerPaper() {
	m.localLanguageAllowedAnswerPaper = nil
}

// SetOrderNumber sets the "OrderNumber" field.
func (m *ExamPapersMutation) SetOrderNumber(s string) {
	m._OrderNumber = &s
}

// OrderNumber returns the value of the "OrderNumber" field in the mutation.
func (m *ExamPapersMutation) OrderNumber() (r string, exists bool) {
	v := m._OrderNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNumber returns the old "OrderNumber" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNumber: %w", err)
	}
	return oldValue.OrderNumber, nil
}

// ResetOrderNumber resets all changes to the "OrderNumber" field.
func (m *ExamPapersMutation) ResetOrderNumber() {
	m._OrderNumber = nil
}

// SetPaperStatus sets the "PaperStatus" field.
func (m *ExamPapersMutation) SetPaperStatus(s string) {
	m._PaperStatus = &s
}

// PaperStatus returns the value of the "PaperStatus" field in the mutation.
func (m *ExamPapersMutation) PaperStatus() (r string, exists bool) {
	v := m._PaperStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperStatus returns the old "PaperStatus" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldPaperStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperStatus: %w", err)
	}
	return oldValue.PaperStatus, nil
}

// ResetPaperStatus resets all changes to the "PaperStatus" field.
func (m *ExamPapersMutation) ResetPaperStatus() {
	m._PaperStatus = nil
}

// SetCalendarCode sets the "CalendarCode" field.
func (m *ExamPapersMutation) SetCalendarCode(i int32) {
	m._CalendarCode = &i
	m.add_CalendarCode = nil
}

// CalendarCode returns the value of the "CalendarCode" field in the mutation.
func (m *ExamPapersMutation) CalendarCode() (r int32, exists bool) {
	v := m._CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCalendarCode returns the old "CalendarCode" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldCalendarCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalendarCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalendarCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalendarCode: %w", err)
	}
	return oldValue.CalendarCode, nil
}

// AddCalendarCode adds i to the "CalendarCode" field.
func (m *ExamPapersMutation) AddCalendarCode(i int32) {
	if m.add_CalendarCode != nil {
		*m.add_CalendarCode += i
	} else {
		m.add_CalendarCode = &i
	}
}

// AddedCalendarCode returns the value that was added to the "CalendarCode" field in this mutation.
func (m *ExamPapersMutation) AddedCalendarCode() (r int32, exists bool) {
	v := m.add_CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalendarCode clears the value of the "CalendarCode" field.
func (m *ExamPapersMutation) ClearCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	m.clearedFields[exampapers.FieldCalendarCode] = struct{}{}
}

// CalendarCodeCleared returns if the "CalendarCode" field was cleared in this mutation.
func (m *ExamPapersMutation) CalendarCodeCleared() bool {
	_, ok := m.clearedFields[exampapers.FieldCalendarCode]
	return ok
}

// ResetCalendarCode resets all changes to the "CalendarCode" field.
func (m *ExamPapersMutation) ResetCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	delete(m.clearedFields, exampapers.FieldCalendarCode)
}

// SetCreatedDate sets the "CreatedDate" field.
func (m *ExamPapersMutation) SetCreatedDate(t time.Time) {
	m._CreatedDate = &t
}

// CreatedDate returns the value of the "CreatedDate" field in the mutation.
func (m *ExamPapersMutation) CreatedDate() (r time.Time, exists bool) {
	v := m._CreatedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "CreatedDate" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ResetCreatedDate resets all changes to the "CreatedDate" field.
func (m *ExamPapersMutation) ResetCreatedDate() {
	m._CreatedDate = nil
}

// AddCenterIDs adds the "centers" edge to the Center entity by ids.
func (m *ExamPapersMutation) AddCenterIDs(ids ...int32) {
	if m.centers == nil {
		m.centers = make(map[int32]struct{})
	}
	for i := range ids {
		m.centers[ids[i]] = struct{}{}
	}
}

// ClearCenters clears the "centers" edge to the Center entity.
func (m *ExamPapersMutation) ClearCenters() {
	m.clearedcenters = true
}

// CentersCleared reports if the "centers" edge to the Center entity was cleared.
func (m *ExamPapersMutation) CentersCleared() bool {
	return m.clearedcenters
}

// RemoveCenterIDs removes the "centers" edge to the Center entity by IDs.
func (m *ExamPapersMutation) RemoveCenterIDs(ids ...int32) {
	if m.removedcenters == nil {
		m.removedcenters = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.centers, ids[i])
		m.removedcenters[ids[i]] = struct{}{}
	}
}

// RemovedCenters returns the removed IDs of the "centers" edge to the Center entity.
func (m *ExamPapersMutation) RemovedCentersIDs() (ids []int32) {
	for id := range m.removedcenters {
		ids = append(ids, id)
	}
	return
}

// CentersIDs returns the "centers" edge IDs in the mutation.
func (m *ExamPapersMutation) CentersIDs() (ids []int32) {
	for id := range m.centers {
		ids = append(ids, id)
	}
	return
}

// ResetCenters resets all changes to the "centers" edge.
func (m *ExamPapersMutation) ResetCenters() {
	m.centers = nil
	m.clearedcenters = false
	m.removedcenters = nil
}

// SetExamID sets the "exam" edge to the Exam entity by id.
func (m *ExamPapersMutation) SetExamID(id int32) {
	m.exam = &id
}

// ClearExam clears the "exam" edge to the Exam entity.
func (m *ExamPapersMutation) ClearExam() {
	m.clearedexam = true
}

// ExamCleared reports if the "exam" edge to the Exam entity was cleared.
func (m *ExamPapersMutation) ExamCleared() bool {
	return m.ExamCodeCleared() || m.clearedexam
}

// ExamID returns the "exam" edge ID in the mutation.
func (m *ExamPapersMutation) ExamID() (id int32, exists bool) {
	if m.exam != nil {
		return *m.exam, true
	}
	return
}

// ExamIDs returns the "exam" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamID instead. It exists only for internal usage by the builders.
func (m *ExamPapersMutation) ExamIDs() (ids []int32) {
	if id := m.exam; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExam resets all changes to the "exam" edge.
func (m *ExamPapersMutation) ResetExam() {
	m.exam = nil
	m.clearedexam = false
}

// AddExampapersTypeIDs adds the "exampapers_types" edge to the PaperTypes entity by ids.
func (m *ExamPapersMutation) AddExampapersTypeIDs(ids ...int32) {
	if m.exampapers_types == nil {
		m.exampapers_types = make(map[int32]struct{})
	}
	for i := range ids {
		m.exampapers_types[ids[i]] = struct{}{}
	}
}

// ClearExampapersTypes clears the "exampapers_types" edge to the PaperTypes entity.
func (m *ExamPapersMutation) ClearExampapersTypes() {
	m.clearedexampapers_types = true
}

// ExampapersTypesCleared reports if the "exampapers_types" edge to the PaperTypes entity was cleared.
func (m *ExamPapersMutation) ExampapersTypesCleared() bool {
	return m.clearedexampapers_types
}

// RemoveExampapersTypeIDs removes the "exampapers_types" edge to the PaperTypes entity by IDs.
func (m *ExamPapersMutation) RemoveExampapersTypeIDs(ids ...int32) {
	if m.removedexampapers_types == nil {
		m.removedexampapers_types = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.exampapers_types, ids[i])
		m.removedexampapers_types[ids[i]] = struct{}{}
	}
}

// RemovedExampapersTypes returns the removed IDs of the "exampapers_types" edge to the PaperTypes entity.
func (m *ExamPapersMutation) RemovedExampapersTypesIDs() (ids []int32) {
	for id := range m.removedexampapers_types {
		ids = append(ids, id)
	}
	return
}

// ExampapersTypesIDs returns the "exampapers_types" edge IDs in the mutation.
func (m *ExamPapersMutation) ExampapersTypesIDs() (ids []int32) {
	for id := range m.exampapers_types {
		ids = append(ids, id)
	}
	return
}

// ResetExampapersTypes resets all changes to the "exampapers_types" edge.
func (m *ExamPapersMutation) ResetExampapersTypes() {
	m.exampapers_types = nil
	m.clearedexampapers_types = false
	m.removedexampapers_types = nil
}

// AddPapersRefIDs adds the "papers_ref" edge to the ExamCalendar entity by ids.
func (m *ExamPapersMutation) AddPapersRefIDs(ids ...int32) {
	if m.papers_ref == nil {
		m.papers_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.papers_ref[ids[i]] = struct{}{}
	}
}

// ClearPapersRef clears the "papers_ref" edge to the ExamCalendar entity.
func (m *ExamPapersMutation) ClearPapersRef() {
	m.clearedpapers_ref = true
}

// PapersRefCleared reports if the "papers_ref" edge to the ExamCalendar entity was cleared.
func (m *ExamPapersMutation) PapersRefCleared() bool {
	return m.clearedpapers_ref
}

// RemovePapersRefIDs removes the "papers_ref" edge to the ExamCalendar entity by IDs.
func (m *ExamPapersMutation) RemovePapersRefIDs(ids ...int32) {
	if m.removedpapers_ref == nil {
		m.removedpapers_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.papers_ref, ids[i])
		m.removedpapers_ref[ids[i]] = struct{}{}
	}
}

// RemovedPapersRef returns the removed IDs of the "papers_ref" edge to the ExamCalendar entity.
func (m *ExamPapersMutation) RemovedPapersRefIDs() (ids []int32) {
	for id := range m.removedpapers_ref {
		ids = append(ids, id)
	}
	return
}

// PapersRefIDs returns the "papers_ref" edge IDs in the mutation.
func (m *ExamPapersMutation) PapersRefIDs() (ids []int32) {
	for id := range m.papers_ref {
		ids = append(ids, id)
	}
	return
}

// ResetPapersRef resets all changes to the "papers_ref" edge.
func (m *ExamPapersMutation) ResetPapersRef() {
	m.papers_ref = nil
	m.clearedpapers_ref = false
	m.removedpapers_ref = nil
}

// Where appends a list predicates to the ExamPapersMutation builder.
func (m *ExamPapersMutation) Where(ps ...predicate.ExamPapers) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExamPapersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExamPapersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExamPapers, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExamPapersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExamPapersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExamPapers).
func (m *ExamPapersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExamPapersMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m._PaperDescription != nil {
		fields = append(fields, exampapers.FieldPaperDescription)
	}
	if m.exam != nil {
		fields = append(fields, exampapers.FieldExamCode)
	}
	if m.competitiveQualifying != nil {
		fields = append(fields, exampapers.FieldCompetitiveQualifying)
	}
	if m.exceptionForDisability != nil {
		fields = append(fields, exampapers.FieldExceptionForDisability)
	}
	if m._MaximumMarks != nil {
		fields = append(fields, exampapers.FieldMaximumMarks)
	}
	if m._Duration != nil {
		fields = append(fields, exampapers.FieldDuration)
	}
	if m.localLanguageAllowedQuestionPaper != nil {
		fields = append(fields, exampapers.FieldLocalLanguageAllowedQuestionPaper)
	}
	if m.localLanguageAllowedAnswerPaper != nil {
		fields = append(fields, exampapers.FieldLocalLanguageAllowedAnswerPaper)
	}
	if m._OrderNumber != nil {
		fields = append(fields, exampapers.FieldOrderNumber)
	}
	if m._PaperStatus != nil {
		fields = append(fields, exampapers.FieldPaperStatus)
	}
	if m._CalendarCode != nil {
		fields = append(fields, exampapers.FieldCalendarCode)
	}
	if m._CreatedDate != nil {
		fields = append(fields, exampapers.FieldCreatedDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExamPapersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exampapers.FieldPaperDescription:
		return m.PaperDescription()
	case exampapers.FieldExamCode:
		return m.ExamCode()
	case exampapers.FieldCompetitiveQualifying:
		return m.CompetitiveQualifying()
	case exampapers.FieldExceptionForDisability:
		return m.ExceptionForDisability()
	case exampapers.FieldMaximumMarks:
		return m.MaximumMarks()
	case exampapers.FieldDuration:
		return m.Duration()
	case exampapers.FieldLocalLanguageAllowedQuestionPaper:
		return m.LocalLanguageAllowedQuestionPaper()
	case exampapers.FieldLocalLanguageAllowedAnswerPaper:
		return m.LocalLanguageAllowedAnswerPaper()
	case exampapers.FieldOrderNumber:
		return m.OrderNumber()
	case exampapers.FieldPaperStatus:
		return m.PaperStatus()
	case exampapers.FieldCalendarCode:
		return m.CalendarCode()
	case exampapers.FieldCreatedDate:
		return m.CreatedDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExamPapersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exampapers.FieldPaperDescription:
		return m.OldPaperDescription(ctx)
	case exampapers.FieldExamCode:
		return m.OldExamCode(ctx)
	case exampapers.FieldCompetitiveQualifying:
		return m.OldCompetitiveQualifying(ctx)
	case exampapers.FieldExceptionForDisability:
		return m.OldExceptionForDisability(ctx)
	case exampapers.FieldMaximumMarks:
		return m.OldMaximumMarks(ctx)
	case exampapers.FieldDuration:
		return m.OldDuration(ctx)
	case exampapers.FieldLocalLanguageAllowedQuestionPaper:
		return m.OldLocalLanguageAllowedQuestionPaper(ctx)
	case exampapers.FieldLocalLanguageAllowedAnswerPaper:
		return m.OldLocalLanguageAllowedAnswerPaper(ctx)
	case exampapers.FieldOrderNumber:
		return m.OldOrderNumber(ctx)
	case exampapers.FieldPaperStatus:
		return m.OldPaperStatus(ctx)
	case exampapers.FieldCalendarCode:
		return m.OldCalendarCode(ctx)
	case exampapers.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	}
	return nil, fmt.Errorf("unknown ExamPapers field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamPapersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exampapers.FieldPaperDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperDescription(v)
		return nil
	case exampapers.FieldExamCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCode(v)
		return nil
	case exampapers.FieldCompetitiveQualifying:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitiveQualifying(v)
		return nil
	case exampapers.FieldExceptionForDisability:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExceptionForDisability(v)
		return nil
	case exampapers.FieldMaximumMarks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaximumMarks(v)
		return nil
	case exampapers.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case exampapers.FieldLocalLanguageAllowedQuestionPaper:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalLanguageAllowedQuestionPaper(v)
		return nil
	case exampapers.FieldLocalLanguageAllowedAnswerPaper:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalLanguageAllowedAnswerPaper(v)
		return nil
	case exampapers.FieldOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNumber(v)
		return nil
	case exampapers.FieldPaperStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperStatus(v)
		return nil
	case exampapers.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalendarCode(v)
		return nil
	case exampapers.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	}
	return fmt.Errorf("unknown ExamPapers field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExamPapersMutation) AddedFields() []string {
	var fields []string
	if m.add_MaximumMarks != nil {
		fields = append(fields, exampapers.FieldMaximumMarks)
	}
	if m.add_Duration != nil {
		fields = append(fields, exampapers.FieldDuration)
	}
	if m.add_CalendarCode != nil {
		fields = append(fields, exampapers.FieldCalendarCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExamPapersMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exampapers.FieldMaximumMarks:
		return m.AddedMaximumMarks()
	case exampapers.FieldDuration:
		return m.AddedDuration()
	case exampapers.FieldCalendarCode:
		return m.AddedCalendarCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamPapersMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exampapers.FieldMaximumMarks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaximumMarks(v)
		return nil
	case exampapers.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case exampapers.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalendarCode(v)
		return nil
	}
	return fmt.Errorf("unknown ExamPapers numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExamPapersMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exampapers.FieldExamCode) {
		fields = append(fields, exampapers.FieldExamCode)
	}
	if m.FieldCleared(exampapers.FieldCalendarCode) {
		fields = append(fields, exampapers.FieldCalendarCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExamPapersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExamPapersMutation) ClearField(name string) error {
	switch name {
	case exampapers.FieldExamCode:
		m.ClearExamCode()
		return nil
	case exampapers.FieldCalendarCode:
		m.ClearCalendarCode()
		return nil
	}
	return fmt.Errorf("unknown ExamPapers nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExamPapersMutation) ResetField(name string) error {
	switch name {
	case exampapers.FieldPaperDescription:
		m.ResetPaperDescription()
		return nil
	case exampapers.FieldExamCode:
		m.ResetExamCode()
		return nil
	case exampapers.FieldCompetitiveQualifying:
		m.ResetCompetitiveQualifying()
		return nil
	case exampapers.FieldExceptionForDisability:
		m.ResetExceptionForDisability()
		return nil
	case exampapers.FieldMaximumMarks:
		m.ResetMaximumMarks()
		return nil
	case exampapers.FieldDuration:
		m.ResetDuration()
		return nil
	case exampapers.FieldLocalLanguageAllowedQuestionPaper:
		m.ResetLocalLanguageAllowedQuestionPaper()
		return nil
	case exampapers.FieldLocalLanguageAllowedAnswerPaper:
		m.ResetLocalLanguageAllowedAnswerPaper()
		return nil
	case exampapers.FieldOrderNumber:
		m.ResetOrderNumber()
		return nil
	case exampapers.FieldPaperStatus:
		m.ResetPaperStatus()
		return nil
	case exampapers.FieldCalendarCode:
		m.ResetCalendarCode()
		return nil
	case exampapers.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	}
	return fmt.Errorf("unknown ExamPapers field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExamPapersMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.centers != nil {
		edges = append(edges, exampapers.EdgeCenters)
	}
	if m.exam != nil {
		edges = append(edges, exampapers.EdgeExam)
	}
	if m.exampapers_types != nil {
		edges = append(edges, exampapers.EdgeExampapersTypes)
	}
	if m.papers_ref != nil {
		edges = append(edges, exampapers.EdgePapersRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExamPapersMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exampapers.EdgeCenters:
		ids := make([]ent.Value, 0, len(m.centers))
		for id := range m.centers {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgeExam:
		if id := m.exam; id != nil {
			return []ent.Value{*id}
		}
	case exampapers.EdgeExampapersTypes:
		ids := make([]ent.Value, 0, len(m.exampapers_types))
		for id := range m.exampapers_types {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgePapersRef:
		ids := make([]ent.Value, 0, len(m.papers_ref))
		for id := range m.papers_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExamPapersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcenters != nil {
		edges = append(edges, exampapers.EdgeCenters)
	}
	if m.removedexampapers_types != nil {
		edges = append(edges, exampapers.EdgeExampapersTypes)
	}
	if m.removedpapers_ref != nil {
		edges = append(edges, exampapers.EdgePapersRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExamPapersMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exampapers.EdgeCenters:
		ids := make([]ent.Value, 0, len(m.removedcenters))
		for id := range m.removedcenters {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgeExampapersTypes:
		ids := make([]ent.Value, 0, len(m.removedexampapers_types))
		for id := range m.removedexampapers_types {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgePapersRef:
		ids := make([]ent.Value, 0, len(m.removedpapers_ref))
		for id := range m.removedpapers_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExamPapersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcenters {
		edges = append(edges, exampapers.EdgeCenters)
	}
	if m.clearedexam {
		edges = append(edges, exampapers.EdgeExam)
	}
	if m.clearedexampapers_types {
		edges = append(edges, exampapers.EdgeExampapersTypes)
	}
	if m.clearedpapers_ref {
		edges = append(edges, exampapers.EdgePapersRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExamPapersMutation) EdgeCleared(name string) bool {
	switch name {
	case exampapers.EdgeCenters:
		return m.clearedcenters
	case exampapers.EdgeExam:
		return m.clearedexam
	case exampapers.EdgeExampapersTypes:
		return m.clearedexampapers_types
	case exampapers.EdgePapersRef:
		return m.clearedpapers_ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExamPapersMutation) ClearEdge(name string) error {
	switch name {
	case exampapers.EdgeExam:
		m.ClearExam()
		return nil
	}
	return fmt.Errorf("unknown ExamPapers unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExamPapersMutation) ResetEdge(name string) error {
	switch name {
	case exampapers.EdgeCenters:
		m.ResetCenters()
		return nil
	case exampapers.EdgeExam:
		m.ResetExam()
		return nil
	case exampapers.EdgeExampapersTypes:
		m.ResetExampapersTypes()
		return nil
	case exampapers.EdgePapersRef:
		m.ResetPapersRef()
		return nil
	}
	return fmt.Errorf("unknown ExamPapers edge %s", name)
}

// FacilityMutation represents an operation that mutates the Facility nodes in the graph.
type FacilityMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int32
	_FacilityCode        *string
	_OfficeType          *string
	_FacilityName        *string
	_ReportingOfficeType *string
	_ReportingOfficeCode *string
	_EmailID             *string
	_MobileNumber        *int32
	add_MobileNumber     *int32
	_DivisionCode        *int32
	add_DivisionCode     *int32
	_RegionCode          *int32
	add_RegionCode       *int32
	_CircleCode          *int32
	add_CircleCode       *int32
	clearedFields        map[string]struct{}
	region_ref           map[int32]struct{}
	removedregion_ref    map[int32]struct{}
	clearedregion_ref    bool
	circle_ref           map[int32]struct{}
	removedcircle_ref    map[int32]struct{}
	clearedcircle_ref    bool
	done                 bool
	oldValue             func(context.Context) (*Facility, error)
	predicates           []predicate.Facility
}

var _ ent.Mutation = (*FacilityMutation)(nil)

// facilityOption allows management of the mutation configuration using functional options.
type facilityOption func(*FacilityMutation)

// newFacilityMutation creates new mutation for the Facility entity.
func newFacilityMutation(c config, op Op, opts ...facilityOption) *FacilityMutation {
	m := &FacilityMutation{
		config:        c,
		op:            op,
		typ:           TypeFacility,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFacilityID sets the ID field of the mutation.
func withFacilityID(id int32) facilityOption {
	return func(m *FacilityMutation) {
		var (
			err   error
			once  sync.Once
			value *Facility
		)
		m.oldValue = func(ctx context.Context) (*Facility, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Facility.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFacility sets the old Facility of the mutation.
func withFacility(node *Facility) facilityOption {
	return func(m *FacilityMutation) {
		m.oldValue = func(context.Context) (*Facility, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FacilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FacilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Facility entities.
func (m *FacilityMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FacilityMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FacilityMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Facility.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFacilityCode sets the "FacilityCode" field.
func (m *FacilityMutation) SetFacilityCode(s string) {
	m._FacilityCode = &s
}

// FacilityCode returns the value of the "FacilityCode" field in the mutation.
func (m *FacilityMutation) FacilityCode() (r string, exists bool) {
	v := m._FacilityCode
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityCode returns the old "FacilityCode" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldFacilityCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacilityCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacilityCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityCode: %w", err)
	}
	return oldValue.FacilityCode, nil
}

// ResetFacilityCode resets all changes to the "FacilityCode" field.
func (m *FacilityMutation) ResetFacilityCode() {
	m._FacilityCode = nil
}

// SetOfficeType sets the "OfficeType" field.
func (m *FacilityMutation) SetOfficeType(s string) {
	m._OfficeType = &s
}

// OfficeType returns the value of the "OfficeType" field in the mutation.
func (m *FacilityMutation) OfficeType() (r string, exists bool) {
	v := m._OfficeType
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeType returns the old "OfficeType" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldOfficeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeType: %w", err)
	}
	return oldValue.OfficeType, nil
}

// ResetOfficeType resets all changes to the "OfficeType" field.
func (m *FacilityMutation) ResetOfficeType() {
	m._OfficeType = nil
}

// SetFacilityName sets the "FacilityName" field.
func (m *FacilityMutation) SetFacilityName(s string) {
	m._FacilityName = &s
}

// FacilityName returns the value of the "FacilityName" field in the mutation.
func (m *FacilityMutation) FacilityName() (r string, exists bool) {
	v := m._FacilityName
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityName returns the old "FacilityName" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldFacilityName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacilityName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacilityName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityName: %w", err)
	}
	return oldValue.FacilityName, nil
}

// ResetFacilityName resets all changes to the "FacilityName" field.
func (m *FacilityMutation) ResetFacilityName() {
	m._FacilityName = nil
}

// SetReportingOfficeType sets the "ReportingOfficeType" field.
func (m *FacilityMutation) SetReportingOfficeType(s string) {
	m._ReportingOfficeType = &s
}

// ReportingOfficeType returns the value of the "ReportingOfficeType" field in the mutation.
func (m *FacilityMutation) ReportingOfficeType() (r string, exists bool) {
	v := m._ReportingOfficeType
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingOfficeType returns the old "ReportingOfficeType" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldReportingOfficeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingOfficeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingOfficeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingOfficeType: %w", err)
	}
	return oldValue.ReportingOfficeType, nil
}

// ClearReportingOfficeType clears the value of the "ReportingOfficeType" field.
func (m *FacilityMutation) ClearReportingOfficeType() {
	m._ReportingOfficeType = nil
	m.clearedFields[facility.FieldReportingOfficeType] = struct{}{}
}

// ReportingOfficeTypeCleared returns if the "ReportingOfficeType" field was cleared in this mutation.
func (m *FacilityMutation) ReportingOfficeTypeCleared() bool {
	_, ok := m.clearedFields[facility.FieldReportingOfficeType]
	return ok
}

// ResetReportingOfficeType resets all changes to the "ReportingOfficeType" field.
func (m *FacilityMutation) ResetReportingOfficeType() {
	m._ReportingOfficeType = nil
	delete(m.clearedFields, facility.FieldReportingOfficeType)
}

// SetReportingOfficeCode sets the "ReportingOfficeCode" field.
func (m *FacilityMutation) SetReportingOfficeCode(s string) {
	m._ReportingOfficeCode = &s
}

// ReportingOfficeCode returns the value of the "ReportingOfficeCode" field in the mutation.
func (m *FacilityMutation) ReportingOfficeCode() (r string, exists bool) {
	v := m._ReportingOfficeCode
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingOfficeCode returns the old "ReportingOfficeCode" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldReportingOfficeCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingOfficeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingOfficeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingOfficeCode: %w", err)
	}
	return oldValue.ReportingOfficeCode, nil
}

// ClearReportingOfficeCode clears the value of the "ReportingOfficeCode" field.
func (m *FacilityMutation) ClearReportingOfficeCode() {
	m._ReportingOfficeCode = nil
	m.clearedFields[facility.FieldReportingOfficeCode] = struct{}{}
}

// ReportingOfficeCodeCleared returns if the "ReportingOfficeCode" field was cleared in this mutation.
func (m *FacilityMutation) ReportingOfficeCodeCleared() bool {
	_, ok := m.clearedFields[facility.FieldReportingOfficeCode]
	return ok
}

// ResetReportingOfficeCode resets all changes to the "ReportingOfficeCode" field.
func (m *FacilityMutation) ResetReportingOfficeCode() {
	m._ReportingOfficeCode = nil
	delete(m.clearedFields, facility.FieldReportingOfficeCode)
}

// SetEmailID sets the "EmailID" field.
func (m *FacilityMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *FacilityMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ClearEmailID clears the value of the "EmailID" field.
func (m *FacilityMutation) ClearEmailID() {
	m._EmailID = nil
	m.clearedFields[facility.FieldEmailID] = struct{}{}
}

// EmailIDCleared returns if the "EmailID" field was cleared in this mutation.
func (m *FacilityMutation) EmailIDCleared() bool {
	_, ok := m.clearedFields[facility.FieldEmailID]
	return ok
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *FacilityMutation) ResetEmailID() {
	m._EmailID = nil
	delete(m.clearedFields, facility.FieldEmailID)
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *FacilityMutation) SetMobileNumber(i int32) {
	m._MobileNumber = &i
	m.add_MobileNumber = nil
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *FacilityMutation) MobileNumber() (r int32, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldMobileNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// AddMobileNumber adds i to the "MobileNumber" field.
func (m *FacilityMutation) AddMobileNumber(i int32) {
	if m.add_MobileNumber != nil {
		*m.add_MobileNumber += i
	} else {
		m.add_MobileNumber = &i
	}
}

// AddedMobileNumber returns the value that was added to the "MobileNumber" field in this mutation.
func (m *FacilityMutation) AddedMobileNumber() (r int32, exists bool) {
	v := m.add_MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearMobileNumber clears the value of the "MobileNumber" field.
func (m *FacilityMutation) ClearMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	m.clearedFields[facility.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "MobileNumber" field was cleared in this mutation.
func (m *FacilityMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[facility.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *FacilityMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	delete(m.clearedFields, facility.FieldMobileNumber)
}

// SetDivisionCode sets the "DivisionCode" field.
func (m *FacilityMutation) SetDivisionCode(i int32) {
	m._DivisionCode = &i
	m.add_DivisionCode = nil
}

// DivisionCode returns the value of the "DivisionCode" field in the mutation.
func (m *FacilityMutation) DivisionCode() (r int32, exists bool) {
	v := m._DivisionCode
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionCode returns the old "DivisionCode" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldDivisionCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionCode: %w", err)
	}
	return oldValue.DivisionCode, nil
}

// AddDivisionCode adds i to the "DivisionCode" field.
func (m *FacilityMutation) AddDivisionCode(i int32) {
	if m.add_DivisionCode != nil {
		*m.add_DivisionCode += i
	} else {
		m.add_DivisionCode = &i
	}
}

// AddedDivisionCode returns the value that was added to the "DivisionCode" field in this mutation.
func (m *FacilityMutation) AddedDivisionCode() (r int32, exists bool) {
	v := m.add_DivisionCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearDivisionCode clears the value of the "DivisionCode" field.
func (m *FacilityMutation) ClearDivisionCode() {
	m._DivisionCode = nil
	m.add_DivisionCode = nil
	m.clearedFields[facility.FieldDivisionCode] = struct{}{}
}

// DivisionCodeCleared returns if the "DivisionCode" field was cleared in this mutation.
func (m *FacilityMutation) DivisionCodeCleared() bool {
	_, ok := m.clearedFields[facility.FieldDivisionCode]
	return ok
}

// ResetDivisionCode resets all changes to the "DivisionCode" field.
func (m *FacilityMutation) ResetDivisionCode() {
	m._DivisionCode = nil
	m.add_DivisionCode = nil
	delete(m.clearedFields, facility.FieldDivisionCode)
}

// SetRegionCode sets the "RegionCode" field.
func (m *FacilityMutation) SetRegionCode(i int32) {
	m._RegionCode = &i
	m.add_RegionCode = nil
}

// RegionCode returns the value of the "RegionCode" field in the mutation.
func (m *FacilityMutation) RegionCode() (r int32, exists bool) {
	v := m._RegionCode
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionCode returns the old "RegionCode" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldRegionCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionCode: %w", err)
	}
	return oldValue.RegionCode, nil
}

// AddRegionCode adds i to the "RegionCode" field.
func (m *FacilityMutation) AddRegionCode(i int32) {
	if m.add_RegionCode != nil {
		*m.add_RegionCode += i
	} else {
		m.add_RegionCode = &i
	}
}

// AddedRegionCode returns the value that was added to the "RegionCode" field in this mutation.
func (m *FacilityMutation) AddedRegionCode() (r int32, exists bool) {
	v := m.add_RegionCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearRegionCode clears the value of the "RegionCode" field.
func (m *FacilityMutation) ClearRegionCode() {
	m._RegionCode = nil
	m.add_RegionCode = nil
	m.clearedFields[facility.FieldRegionCode] = struct{}{}
}

// RegionCodeCleared returns if the "RegionCode" field was cleared in this mutation.
func (m *FacilityMutation) RegionCodeCleared() bool {
	_, ok := m.clearedFields[facility.FieldRegionCode]
	return ok
}

// ResetRegionCode resets all changes to the "RegionCode" field.
func (m *FacilityMutation) ResetRegionCode() {
	m._RegionCode = nil
	m.add_RegionCode = nil
	delete(m.clearedFields, facility.FieldRegionCode)
}

// SetCircleCode sets the "CircleCode" field.
func (m *FacilityMutation) SetCircleCode(i int32) {
	m._CircleCode = &i
	m.add_CircleCode = nil
}

// CircleCode returns the value of the "CircleCode" field in the mutation.
func (m *FacilityMutation) CircleCode() (r int32, exists bool) {
	v := m._CircleCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleCode returns the old "CircleCode" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldCircleCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleCode: %w", err)
	}
	return oldValue.CircleCode, nil
}

// AddCircleCode adds i to the "CircleCode" field.
func (m *FacilityMutation) AddCircleCode(i int32) {
	if m.add_CircleCode != nil {
		*m.add_CircleCode += i
	} else {
		m.add_CircleCode = &i
	}
}

// AddedCircleCode returns the value that was added to the "CircleCode" field in this mutation.
func (m *FacilityMutation) AddedCircleCode() (r int32, exists bool) {
	v := m.add_CircleCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearCircleCode clears the value of the "CircleCode" field.
func (m *FacilityMutation) ClearCircleCode() {
	m._CircleCode = nil
	m.add_CircleCode = nil
	m.clearedFields[facility.FieldCircleCode] = struct{}{}
}

// CircleCodeCleared returns if the "CircleCode" field was cleared in this mutation.
func (m *FacilityMutation) CircleCodeCleared() bool {
	_, ok := m.clearedFields[facility.FieldCircleCode]
	return ok
}

// ResetCircleCode resets all changes to the "CircleCode" field.
func (m *FacilityMutation) ResetCircleCode() {
	m._CircleCode = nil
	m.add_CircleCode = nil
	delete(m.clearedFields, facility.FieldCircleCode)
}

// AddRegionRefIDs adds the "region_ref" edge to the RegionMaster entity by ids.
func (m *FacilityMutation) AddRegionRefIDs(ids ...int32) {
	if m.region_ref == nil {
		m.region_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.region_ref[ids[i]] = struct{}{}
	}
}

// ClearRegionRef clears the "region_ref" edge to the RegionMaster entity.
func (m *FacilityMutation) ClearRegionRef() {
	m.clearedregion_ref = true
}

// RegionRefCleared reports if the "region_ref" edge to the RegionMaster entity was cleared.
func (m *FacilityMutation) RegionRefCleared() bool {
	return m.clearedregion_ref
}

// RemoveRegionRefIDs removes the "region_ref" edge to the RegionMaster entity by IDs.
func (m *FacilityMutation) RemoveRegionRefIDs(ids ...int32) {
	if m.removedregion_ref == nil {
		m.removedregion_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.region_ref, ids[i])
		m.removedregion_ref[ids[i]] = struct{}{}
	}
}

// RemovedRegionRef returns the removed IDs of the "region_ref" edge to the RegionMaster entity.
func (m *FacilityMutation) RemovedRegionRefIDs() (ids []int32) {
	for id := range m.removedregion_ref {
		ids = append(ids, id)
	}
	return
}

// RegionRefIDs returns the "region_ref" edge IDs in the mutation.
func (m *FacilityMutation) RegionRefIDs() (ids []int32) {
	for id := range m.region_ref {
		ids = append(ids, id)
	}
	return
}

// ResetRegionRef resets all changes to the "region_ref" edge.
func (m *FacilityMutation) ResetRegionRef() {
	m.region_ref = nil
	m.clearedregion_ref = false
	m.removedregion_ref = nil
}

// AddCircleRefIDs adds the "circle_ref" edge to the CircleMaster entity by ids.
func (m *FacilityMutation) AddCircleRefIDs(ids ...int32) {
	if m.circle_ref == nil {
		m.circle_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.circle_ref[ids[i]] = struct{}{}
	}
}

// ClearCircleRef clears the "circle_ref" edge to the CircleMaster entity.
func (m *FacilityMutation) ClearCircleRef() {
	m.clearedcircle_ref = true
}

// CircleRefCleared reports if the "circle_ref" edge to the CircleMaster entity was cleared.
func (m *FacilityMutation) CircleRefCleared() bool {
	return m.clearedcircle_ref
}

// RemoveCircleRefIDs removes the "circle_ref" edge to the CircleMaster entity by IDs.
func (m *FacilityMutation) RemoveCircleRefIDs(ids ...int32) {
	if m.removedcircle_ref == nil {
		m.removedcircle_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.circle_ref, ids[i])
		m.removedcircle_ref[ids[i]] = struct{}{}
	}
}

// RemovedCircleRef returns the removed IDs of the "circle_ref" edge to the CircleMaster entity.
func (m *FacilityMutation) RemovedCircleRefIDs() (ids []int32) {
	for id := range m.removedcircle_ref {
		ids = append(ids, id)
	}
	return
}

// CircleRefIDs returns the "circle_ref" edge IDs in the mutation.
func (m *FacilityMutation) CircleRefIDs() (ids []int32) {
	for id := range m.circle_ref {
		ids = append(ids, id)
	}
	return
}

// ResetCircleRef resets all changes to the "circle_ref" edge.
func (m *FacilityMutation) ResetCircleRef() {
	m.circle_ref = nil
	m.clearedcircle_ref = false
	m.removedcircle_ref = nil
}

// Where appends a list predicates to the FacilityMutation builder.
func (m *FacilityMutation) Where(ps ...predicate.Facility) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FacilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FacilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Facility, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FacilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FacilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Facility).
func (m *FacilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FacilityMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m._FacilityCode != nil {
		fields = append(fields, facility.FieldFacilityCode)
	}
	if m._OfficeType != nil {
		fields = append(fields, facility.FieldOfficeType)
	}
	if m._FacilityName != nil {
		fields = append(fields, facility.FieldFacilityName)
	}
	if m._ReportingOfficeType != nil {
		fields = append(fields, facility.FieldReportingOfficeType)
	}
	if m._ReportingOfficeCode != nil {
		fields = append(fields, facility.FieldReportingOfficeCode)
	}
	if m._EmailID != nil {
		fields = append(fields, facility.FieldEmailID)
	}
	if m._MobileNumber != nil {
		fields = append(fields, facility.FieldMobileNumber)
	}
	if m._DivisionCode != nil {
		fields = append(fields, facility.FieldDivisionCode)
	}
	if m._RegionCode != nil {
		fields = append(fields, facility.FieldRegionCode)
	}
	if m._CircleCode != nil {
		fields = append(fields, facility.FieldCircleCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FacilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case facility.FieldFacilityCode:
		return m.FacilityCode()
	case facility.FieldOfficeType:
		return m.OfficeType()
	case facility.FieldFacilityName:
		return m.FacilityName()
	case facility.FieldReportingOfficeType:
		return m.ReportingOfficeType()
	case facility.FieldReportingOfficeCode:
		return m.ReportingOfficeCode()
	case facility.FieldEmailID:
		return m.EmailID()
	case facility.FieldMobileNumber:
		return m.MobileNumber()
	case facility.FieldDivisionCode:
		return m.DivisionCode()
	case facility.FieldRegionCode:
		return m.RegionCode()
	case facility.FieldCircleCode:
		return m.CircleCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FacilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case facility.FieldFacilityCode:
		return m.OldFacilityCode(ctx)
	case facility.FieldOfficeType:
		return m.OldOfficeType(ctx)
	case facility.FieldFacilityName:
		return m.OldFacilityName(ctx)
	case facility.FieldReportingOfficeType:
		return m.OldReportingOfficeType(ctx)
	case facility.FieldReportingOfficeCode:
		return m.OldReportingOfficeCode(ctx)
	case facility.FieldEmailID:
		return m.OldEmailID(ctx)
	case facility.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case facility.FieldDivisionCode:
		return m.OldDivisionCode(ctx)
	case facility.FieldRegionCode:
		return m.OldRegionCode(ctx)
	case facility.FieldCircleCode:
		return m.OldCircleCode(ctx)
	}
	return nil, fmt.Errorf("unknown Facility field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case facility.FieldFacilityCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityCode(v)
		return nil
	case facility.FieldOfficeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeType(v)
		return nil
	case facility.FieldFacilityName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityName(v)
		return nil
	case facility.FieldReportingOfficeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingOfficeType(v)
		return nil
	case facility.FieldReportingOfficeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingOfficeCode(v)
		return nil
	case facility.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case facility.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case facility.FieldDivisionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionCode(v)
		return nil
	case facility.FieldRegionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionCode(v)
		return nil
	case facility.FieldCircleCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleCode(v)
		return nil
	}
	return fmt.Errorf("unknown Facility field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FacilityMutation) AddedFields() []string {
	var fields []string
	if m.add_MobileNumber != nil {
		fields = append(fields, facility.FieldMobileNumber)
	}
	if m.add_DivisionCode != nil {
		fields = append(fields, facility.FieldDivisionCode)
	}
	if m.add_RegionCode != nil {
		fields = append(fields, facility.FieldRegionCode)
	}
	if m.add_CircleCode != nil {
		fields = append(fields, facility.FieldCircleCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FacilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case facility.FieldMobileNumber:
		return m.AddedMobileNumber()
	case facility.FieldDivisionCode:
		return m.AddedDivisionCode()
	case facility.FieldRegionCode:
		return m.AddedRegionCode()
	case facility.FieldCircleCode:
		return m.AddedCircleCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case facility.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMobileNumber(v)
		return nil
	case facility.FieldDivisionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDivisionCode(v)
		return nil
	case facility.FieldRegionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegionCode(v)
		return nil
	case facility.FieldCircleCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCircleCode(v)
		return nil
	}
	return fmt.Errorf("unknown Facility numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FacilityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(facility.FieldReportingOfficeType) {
		fields = append(fields, facility.FieldReportingOfficeType)
	}
	if m.FieldCleared(facility.FieldReportingOfficeCode) {
		fields = append(fields, facility.FieldReportingOfficeCode)
	}
	if m.FieldCleared(facility.FieldEmailID) {
		fields = append(fields, facility.FieldEmailID)
	}
	if m.FieldCleared(facility.FieldMobileNumber) {
		fields = append(fields, facility.FieldMobileNumber)
	}
	if m.FieldCleared(facility.FieldDivisionCode) {
		fields = append(fields, facility.FieldDivisionCode)
	}
	if m.FieldCleared(facility.FieldRegionCode) {
		fields = append(fields, facility.FieldRegionCode)
	}
	if m.FieldCleared(facility.FieldCircleCode) {
		fields = append(fields, facility.FieldCircleCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FacilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FacilityMutation) ClearField(name string) error {
	switch name {
	case facility.FieldReportingOfficeType:
		m.ClearReportingOfficeType()
		return nil
	case facility.FieldReportingOfficeCode:
		m.ClearReportingOfficeCode()
		return nil
	case facility.FieldEmailID:
		m.ClearEmailID()
		return nil
	case facility.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	case facility.FieldDivisionCode:
		m.ClearDivisionCode()
		return nil
	case facility.FieldRegionCode:
		m.ClearRegionCode()
		return nil
	case facility.FieldCircleCode:
		m.ClearCircleCode()
		return nil
	}
	return fmt.Errorf("unknown Facility nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FacilityMutation) ResetField(name string) error {
	switch name {
	case facility.FieldFacilityCode:
		m.ResetFacilityCode()
		return nil
	case facility.FieldOfficeType:
		m.ResetOfficeType()
		return nil
	case facility.FieldFacilityName:
		m.ResetFacilityName()
		return nil
	case facility.FieldReportingOfficeType:
		m.ResetReportingOfficeType()
		return nil
	case facility.FieldReportingOfficeCode:
		m.ResetReportingOfficeCode()
		return nil
	case facility.FieldEmailID:
		m.ResetEmailID()
		return nil
	case facility.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case facility.FieldDivisionCode:
		m.ResetDivisionCode()
		return nil
	case facility.FieldRegionCode:
		m.ResetRegionCode()
		return nil
	case facility.FieldCircleCode:
		m.ResetCircleCode()
		return nil
	}
	return fmt.Errorf("unknown Facility field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FacilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.region_ref != nil {
		edges = append(edges, facility.EdgeRegionRef)
	}
	if m.circle_ref != nil {
		edges = append(edges, facility.EdgeCircleRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FacilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case facility.EdgeRegionRef:
		ids := make([]ent.Value, 0, len(m.region_ref))
		for id := range m.region_ref {
			ids = append(ids, id)
		}
		return ids
	case facility.EdgeCircleRef:
		ids := make([]ent.Value, 0, len(m.circle_ref))
		for id := range m.circle_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FacilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedregion_ref != nil {
		edges = append(edges, facility.EdgeRegionRef)
	}
	if m.removedcircle_ref != nil {
		edges = append(edges, facility.EdgeCircleRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FacilityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case facility.EdgeRegionRef:
		ids := make([]ent.Value, 0, len(m.removedregion_ref))
		for id := range m.removedregion_ref {
			ids = append(ids, id)
		}
		return ids
	case facility.EdgeCircleRef:
		ids := make([]ent.Value, 0, len(m.removedcircle_ref))
		for id := range m.removedcircle_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FacilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedregion_ref {
		edges = append(edges, facility.EdgeRegionRef)
	}
	if m.clearedcircle_ref {
		edges = append(edges, facility.EdgeCircleRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FacilityMutation) EdgeCleared(name string) bool {
	switch name {
	case facility.EdgeRegionRef:
		return m.clearedregion_ref
	case facility.EdgeCircleRef:
		return m.clearedcircle_ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FacilityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Facility unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FacilityMutation) ResetEdge(name string) error {
	switch name {
	case facility.EdgeRegionRef:
		m.ResetRegionRef()
		return nil
	case facility.EdgeCircleRef:
		m.ResetCircleRef()
		return nil
	}
	return fmt.Errorf("unknown Facility edge %s", name)
}

// NodalOfficerMutation represents an operation that mutates the NodalOfficer nodes in the graph.
type NodalOfficerMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int32
	_NodalOfficerName   *string
	_DesignationID      *int32
	add_DesignationID   *int32
	_EmailID            *string
	_MobileNumber       *string
	_HallTicketApproved *string
	clearedFields       map[string]struct{}
	centers             map[int32]struct{}
	removedcenters      map[int32]struct{}
	clearedcenters      bool
	exam                *int32
	clearedexam         bool
	notification        *int32
	clearednotification bool
	done                bool
	oldValue            func(context.Context) (*NodalOfficer, error)
	predicates          []predicate.NodalOfficer
}

var _ ent.Mutation = (*NodalOfficerMutation)(nil)

// nodalofficerOption allows management of the mutation configuration using functional options.
type nodalofficerOption func(*NodalOfficerMutation)

// newNodalOfficerMutation creates new mutation for the NodalOfficer entity.
func newNodalOfficerMutation(c config, op Op, opts ...nodalofficerOption) *NodalOfficerMutation {
	m := &NodalOfficerMutation{
		config:        c,
		op:            op,
		typ:           TypeNodalOfficer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNodalOfficerID sets the ID field of the mutation.
func withNodalOfficerID(id int32) nodalofficerOption {
	return func(m *NodalOfficerMutation) {
		var (
			err   error
			once  sync.Once
			value *NodalOfficer
		)
		m.oldValue = func(ctx context.Context) (*NodalOfficer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NodalOfficer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNodalOfficer sets the old NodalOfficer of the mutation.
func withNodalOfficer(node *NodalOfficer) nodalofficerOption {
	return func(m *NodalOfficerMutation) {
		m.oldValue = func(context.Context) (*NodalOfficer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NodalOfficerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NodalOfficerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NodalOfficer entities.
func (m *NodalOfficerMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NodalOfficerMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NodalOfficerMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NodalOfficer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNodalOfficerName sets the "NodalOfficerName" field.
func (m *NodalOfficerMutation) SetNodalOfficerName(s string) {
	m._NodalOfficerName = &s
}

// NodalOfficerName returns the value of the "NodalOfficerName" field in the mutation.
func (m *NodalOfficerMutation) NodalOfficerName() (r string, exists bool) {
	v := m._NodalOfficerName
	if v == nil {
		return
	}
	return *v, true
}

// OldNodalOfficerName returns the old "NodalOfficerName" field's value of the NodalOfficer entity.
// If the NodalOfficer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodalOfficerMutation) OldNodalOfficerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodalOfficerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodalOfficerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodalOfficerName: %w", err)
	}
	return oldValue.NodalOfficerName, nil
}

// ResetNodalOfficerName resets all changes to the "NodalOfficerName" field.
func (m *NodalOfficerMutation) ResetNodalOfficerName() {
	m._NodalOfficerName = nil
}

// SetDesignationID sets the "DesignationID" field.
func (m *NodalOfficerMutation) SetDesignationID(i int32) {
	m._DesignationID = &i
	m.add_DesignationID = nil
}

// DesignationID returns the value of the "DesignationID" field in the mutation.
func (m *NodalOfficerMutation) DesignationID() (r int32, exists bool) {
	v := m._DesignationID
	if v == nil {
		return
	}
	return *v, true
}

// OldDesignationID returns the old "DesignationID" field's value of the NodalOfficer entity.
// If the NodalOfficer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodalOfficerMutation) OldDesignationID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesignationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesignationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesignationID: %w", err)
	}
	return oldValue.DesignationID, nil
}

// AddDesignationID adds i to the "DesignationID" field.
func (m *NodalOfficerMutation) AddDesignationID(i int32) {
	if m.add_DesignationID != nil {
		*m.add_DesignationID += i
	} else {
		m.add_DesignationID = &i
	}
}

// AddedDesignationID returns the value that was added to the "DesignationID" field in this mutation.
func (m *NodalOfficerMutation) AddedDesignationID() (r int32, exists bool) {
	v := m.add_DesignationID
	if v == nil {
		return
	}
	return *v, true
}

// ResetDesignationID resets all changes to the "DesignationID" field.
func (m *NodalOfficerMutation) ResetDesignationID() {
	m._DesignationID = nil
	m.add_DesignationID = nil
}

// SetEmailID sets the "EmailID" field.
func (m *NodalOfficerMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *NodalOfficerMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the NodalOfficer entity.
// If the NodalOfficer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodalOfficerMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *NodalOfficerMutation) ResetEmailID() {
	m._EmailID = nil
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *NodalOfficerMutation) SetMobileNumber(s string) {
	m._MobileNumber = &s
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *NodalOfficerMutation) MobileNumber() (r string, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the NodalOfficer entity.
// If the NodalOfficer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodalOfficerMutation) OldMobileNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *NodalOfficerMutation) ResetMobileNumber() {
	m._MobileNumber = nil
}

// SetNotifyCode sets the "NotifyCode" field.
func (m *NodalOfficerMutation) SetNotifyCode(i int32) {
	m.notification = &i
}

// NotifyCode returns the value of the "NotifyCode" field in the mutation.
func (m *NodalOfficerMutation) NotifyCode() (r int32, exists bool) {
	v := m.notification
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyCode returns the old "NotifyCode" field's value of the NodalOfficer entity.
// If the NodalOfficer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodalOfficerMutation) OldNotifyCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyCode: %w", err)
	}
	return oldValue.NotifyCode, nil
}

// ClearNotifyCode clears the value of the "NotifyCode" field.
func (m *NodalOfficerMutation) ClearNotifyCode() {
	m.notification = nil
	m.clearedFields[nodalofficer.FieldNotifyCode] = struct{}{}
}

// NotifyCodeCleared returns if the "NotifyCode" field was cleared in this mutation.
func (m *NodalOfficerMutation) NotifyCodeCleared() bool {
	_, ok := m.clearedFields[nodalofficer.FieldNotifyCode]
	return ok
}

// ResetNotifyCode resets all changes to the "NotifyCode" field.
func (m *NodalOfficerMutation) ResetNotifyCode() {
	m.notification = nil
	delete(m.clearedFields, nodalofficer.FieldNotifyCode)
}

// SetExamCode sets the "ExamCode" field.
func (m *NodalOfficerMutation) SetExamCode(i int32) {
	m.exam = &i
}

// ExamCode returns the value of the "ExamCode" field in the mutation.
func (m *NodalOfficerMutation) ExamCode() (r int32, exists bool) {
	v := m.exam
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCode returns the old "ExamCode" field's value of the NodalOfficer entity.
// If the NodalOfficer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodalOfficerMutation) OldExamCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCode: %w", err)
	}
	return oldValue.ExamCode, nil
}

// ClearExamCode clears the value of the "ExamCode" field.
func (m *NodalOfficerMutation) ClearExamCode() {
	m.exam = nil
	m.clearedFields[nodalofficer.FieldExamCode] = struct{}{}
}

// ExamCodeCleared returns if the "ExamCode" field was cleared in this mutation.
func (m *NodalOfficerMutation) ExamCodeCleared() bool {
	_, ok := m.clearedFields[nodalofficer.FieldExamCode]
	return ok
}

// ResetExamCode resets all changes to the "ExamCode" field.
func (m *NodalOfficerMutation) ResetExamCode() {
	m.exam = nil
	delete(m.clearedFields, nodalofficer.FieldExamCode)
}

// SetHallTicketApproved sets the "HallTicketApproved" field.
func (m *NodalOfficerMutation) SetHallTicketApproved(s string) {
	m._HallTicketApproved = &s
}

// HallTicketApproved returns the value of the "HallTicketApproved" field in the mutation.
func (m *NodalOfficerMutation) HallTicketApproved() (r string, exists bool) {
	v := m._HallTicketApproved
	if v == nil {
		return
	}
	return *v, true
}

// OldHallTicketApproved returns the old "HallTicketApproved" field's value of the NodalOfficer entity.
// If the NodalOfficer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodalOfficerMutation) OldHallTicketApproved(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHallTicketApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHallTicketApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHallTicketApproved: %w", err)
	}
	return oldValue.HallTicketApproved, nil
}

// ClearHallTicketApproved clears the value of the "HallTicketApproved" field.
func (m *NodalOfficerMutation) ClearHallTicketApproved() {
	m._HallTicketApproved = nil
	m.clearedFields[nodalofficer.FieldHallTicketApproved] = struct{}{}
}

// HallTicketApprovedCleared returns if the "HallTicketApproved" field was cleared in this mutation.
func (m *NodalOfficerMutation) HallTicketApprovedCleared() bool {
	_, ok := m.clearedFields[nodalofficer.FieldHallTicketApproved]
	return ok
}

// ResetHallTicketApproved resets all changes to the "HallTicketApproved" field.
func (m *NodalOfficerMutation) ResetHallTicketApproved() {
	m._HallTicketApproved = nil
	delete(m.clearedFields, nodalofficer.FieldHallTicketApproved)
}

// AddCenterIDs adds the "centers" edge to the Center entity by ids.
func (m *NodalOfficerMutation) AddCenterIDs(ids ...int32) {
	if m.centers == nil {
		m.centers = make(map[int32]struct{})
	}
	for i := range ids {
		m.centers[ids[i]] = struct{}{}
	}
}

// ClearCenters clears the "centers" edge to the Center entity.
func (m *NodalOfficerMutation) ClearCenters() {
	m.clearedcenters = true
}

// CentersCleared reports if the "centers" edge to the Center entity was cleared.
func (m *NodalOfficerMutation) CentersCleared() bool {
	return m.clearedcenters
}

// RemoveCenterIDs removes the "centers" edge to the Center entity by IDs.
func (m *NodalOfficerMutation) RemoveCenterIDs(ids ...int32) {
	if m.removedcenters == nil {
		m.removedcenters = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.centers, ids[i])
		m.removedcenters[ids[i]] = struct{}{}
	}
}

// RemovedCenters returns the removed IDs of the "centers" edge to the Center entity.
func (m *NodalOfficerMutation) RemovedCentersIDs() (ids []int32) {
	for id := range m.removedcenters {
		ids = append(ids, id)
	}
	return
}

// CentersIDs returns the "centers" edge IDs in the mutation.
func (m *NodalOfficerMutation) CentersIDs() (ids []int32) {
	for id := range m.centers {
		ids = append(ids, id)
	}
	return
}

// ResetCenters resets all changes to the "centers" edge.
func (m *NodalOfficerMutation) ResetCenters() {
	m.centers = nil
	m.clearedcenters = false
	m.removedcenters = nil
}

// SetExamID sets the "exam" edge to the Exam entity by id.
func (m *NodalOfficerMutation) SetExamID(id int32) {
	m.exam = &id
}

// ClearExam clears the "exam" edge to the Exam entity.
func (m *NodalOfficerMutation) ClearExam() {
	m.clearedexam = true
}

// ExamCleared reports if the "exam" edge to the Exam entity was cleared.
func (m *NodalOfficerMutation) ExamCleared() bool {
	return m.ExamCodeCleared() || m.clearedexam
}

// ExamID returns the "exam" edge ID in the mutation.
func (m *NodalOfficerMutation) ExamID() (id int32, exists bool) {
	if m.exam != nil {
		return *m.exam, true
	}
	return
}

// ExamIDs returns the "exam" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamID instead. It exists only for internal usage by the builders.
func (m *NodalOfficerMutation) ExamIDs() (ids []int32) {
	if id := m.exam; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExam resets all changes to the "exam" edge.
func (m *NodalOfficerMutation) ResetExam() {
	m.exam = nil
	m.clearedexam = false
}

// SetNotificationID sets the "notification" edge to the Notification entity by id.
func (m *NodalOfficerMutation) SetNotificationID(id int32) {
	m.notification = &id
}

// ClearNotification clears the "notification" edge to the Notification entity.
func (m *NodalOfficerMutation) ClearNotification() {
	m.clearednotification = true
}

// NotificationCleared reports if the "notification" edge to the Notification entity was cleared.
func (m *NodalOfficerMutation) NotificationCleared() bool {
	return m.NotifyCodeCleared() || m.clearednotification
}

// NotificationID returns the "notification" edge ID in the mutation.
func (m *NodalOfficerMutation) NotificationID() (id int32, exists bool) {
	if m.notification != nil {
		return *m.notification, true
	}
	return
}

// NotificationIDs returns the "notification" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotificationID instead. It exists only for internal usage by the builders.
func (m *NodalOfficerMutation) NotificationIDs() (ids []int32) {
	if id := m.notification; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotification resets all changes to the "notification" edge.
func (m *NodalOfficerMutation) ResetNotification() {
	m.notification = nil
	m.clearednotification = false
}

// Where appends a list predicates to the NodalOfficerMutation builder.
func (m *NodalOfficerMutation) Where(ps ...predicate.NodalOfficer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NodalOfficerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NodalOfficerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NodalOfficer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NodalOfficerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NodalOfficerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NodalOfficer).
func (m *NodalOfficerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NodalOfficerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._NodalOfficerName != nil {
		fields = append(fields, nodalofficer.FieldNodalOfficerName)
	}
	if m._DesignationID != nil {
		fields = append(fields, nodalofficer.FieldDesignationID)
	}
	if m._EmailID != nil {
		fields = append(fields, nodalofficer.FieldEmailID)
	}
	if m._MobileNumber != nil {
		fields = append(fields, nodalofficer.FieldMobileNumber)
	}
	if m.notification != nil {
		fields = append(fields, nodalofficer.FieldNotifyCode)
	}
	if m.exam != nil {
		fields = append(fields, nodalofficer.FieldExamCode)
	}
	if m._HallTicketApproved != nil {
		fields = append(fields, nodalofficer.FieldHallTicketApproved)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NodalOfficerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nodalofficer.FieldNodalOfficerName:
		return m.NodalOfficerName()
	case nodalofficer.FieldDesignationID:
		return m.DesignationID()
	case nodalofficer.FieldEmailID:
		return m.EmailID()
	case nodalofficer.FieldMobileNumber:
		return m.MobileNumber()
	case nodalofficer.FieldNotifyCode:
		return m.NotifyCode()
	case nodalofficer.FieldExamCode:
		return m.ExamCode()
	case nodalofficer.FieldHallTicketApproved:
		return m.HallTicketApproved()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NodalOfficerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nodalofficer.FieldNodalOfficerName:
		return m.OldNodalOfficerName(ctx)
	case nodalofficer.FieldDesignationID:
		return m.OldDesignationID(ctx)
	case nodalofficer.FieldEmailID:
		return m.OldEmailID(ctx)
	case nodalofficer.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case nodalofficer.FieldNotifyCode:
		return m.OldNotifyCode(ctx)
	case nodalofficer.FieldExamCode:
		return m.OldExamCode(ctx)
	case nodalofficer.FieldHallTicketApproved:
		return m.OldHallTicketApproved(ctx)
	}
	return nil, fmt.Errorf("unknown NodalOfficer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodalOfficerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nodalofficer.FieldNodalOfficerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodalOfficerName(v)
		return nil
	case nodalofficer.FieldDesignationID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesignationID(v)
		return nil
	case nodalofficer.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case nodalofficer.FieldMobileNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case nodalofficer.FieldNotifyCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyCode(v)
		return nil
	case nodalofficer.FieldExamCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCode(v)
		return nil
	case nodalofficer.FieldHallTicketApproved:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHallTicketApproved(v)
		return nil
	}
	return fmt.Errorf("unknown NodalOfficer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NodalOfficerMutation) AddedFields() []string {
	var fields []string
	if m.add_DesignationID != nil {
		fields = append(fields, nodalofficer.FieldDesignationID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NodalOfficerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case nodalofficer.FieldDesignationID:
		return m.AddedDesignationID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodalOfficerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case nodalofficer.FieldDesignationID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDesignationID(v)
		return nil
	}
	return fmt.Errorf("unknown NodalOfficer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NodalOfficerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(nodalofficer.FieldNotifyCode) {
		fields = append(fields, nodalofficer.FieldNotifyCode)
	}
	if m.FieldCleared(nodalofficer.FieldExamCode) {
		fields = append(fields, nodalofficer.FieldExamCode)
	}
	if m.FieldCleared(nodalofficer.FieldHallTicketApproved) {
		fields = append(fields, nodalofficer.FieldHallTicketApproved)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NodalOfficerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NodalOfficerMutation) ClearField(name string) error {
	switch name {
	case nodalofficer.FieldNotifyCode:
		m.ClearNotifyCode()
		return nil
	case nodalofficer.FieldExamCode:
		m.ClearExamCode()
		return nil
	case nodalofficer.FieldHallTicketApproved:
		m.ClearHallTicketApproved()
		return nil
	}
	return fmt.Errorf("unknown NodalOfficer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NodalOfficerMutation) ResetField(name string) error {
	switch name {
	case nodalofficer.FieldNodalOfficerName:
		m.ResetNodalOfficerName()
		return nil
	case nodalofficer.FieldDesignationID:
		m.ResetDesignationID()
		return nil
	case nodalofficer.FieldEmailID:
		m.ResetEmailID()
		return nil
	case nodalofficer.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case nodalofficer.FieldNotifyCode:
		m.ResetNotifyCode()
		return nil
	case nodalofficer.FieldExamCode:
		m.ResetExamCode()
		return nil
	case nodalofficer.FieldHallTicketApproved:
		m.ResetHallTicketApproved()
		return nil
	}
	return fmt.Errorf("unknown NodalOfficer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NodalOfficerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.centers != nil {
		edges = append(edges, nodalofficer.EdgeCenters)
	}
	if m.exam != nil {
		edges = append(edges, nodalofficer.EdgeExam)
	}
	if m.notification != nil {
		edges = append(edges, nodalofficer.EdgeNotification)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NodalOfficerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nodalofficer.EdgeCenters:
		ids := make([]ent.Value, 0, len(m.centers))
		for id := range m.centers {
			ids = append(ids, id)
		}
		return ids
	case nodalofficer.EdgeExam:
		if id := m.exam; id != nil {
			return []ent.Value{*id}
		}
	case nodalofficer.EdgeNotification:
		if id := m.notification; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NodalOfficerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcenters != nil {
		edges = append(edges, nodalofficer.EdgeCenters)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NodalOfficerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nodalofficer.EdgeCenters:
		ids := make([]ent.Value, 0, len(m.removedcenters))
		for id := range m.removedcenters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NodalOfficerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcenters {
		edges = append(edges, nodalofficer.EdgeCenters)
	}
	if m.clearedexam {
		edges = append(edges, nodalofficer.EdgeExam)
	}
	if m.clearednotification {
		edges = append(edges, nodalofficer.EdgeNotification)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NodalOfficerMutation) EdgeCleared(name string) bool {
	switch name {
	case nodalofficer.EdgeCenters:
		return m.clearedcenters
	case nodalofficer.EdgeExam:
		return m.clearedexam
	case nodalofficer.EdgeNotification:
		return m.clearednotification
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NodalOfficerMutation) ClearEdge(name string) error {
	switch name {
	case nodalofficer.EdgeExam:
		m.ClearExam()
		return nil
	case nodalofficer.EdgeNotification:
		m.ClearNotification()
		return nil
	}
	return fmt.Errorf("unknown NodalOfficer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NodalOfficerMutation) ResetEdge(name string) error {
	switch name {
	case nodalofficer.EdgeCenters:
		m.ResetCenters()
		return nil
	case nodalofficer.EdgeExam:
		m.ResetExam()
		return nil
	case nodalofficer.EdgeNotification:
		m.ResetNotification()
		return nil
	}
	return fmt.Errorf("unknown NodalOfficer edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *int32
	_ExamYear                              *int32
	add_ExamYear                           *int32
	_ApplicationStartDate                  *time.Time
	_ApplicationEndDate                    *time.Time
	_VerificationDateByController          *time.Time
	_CorrectionDateByCandidate             *time.Time
	_CorrectionVeriyDateByController       *time.Time
	_HallTicketAllotmentDateByNodalOfficer *time.Time
	_HallTicketDownloadDate                *time.Time
	_NotifyFile                            *string
	_SyllabusFile                          *string
	_VacanciesFile                         *string
	clearedFields                          map[string]struct{}
	applications                           map[int32]struct{}
	removedapplications                    map[int32]struct{}
	clearedapplications                    bool
	centers                                map[int32]struct{}
	removedcenters                         map[int32]struct{}
	clearedcenters                         bool
	nodal_officers                         map[int32]struct{}
	removednodal_officers                  map[int32]struct{}
	clearednodal_officers                  bool
	exam                                   *int32
	clearedexam                            bool
	vacancy_years                          map[int32]struct{}
	removedvacancy_years                   map[int32]struct{}
	clearedvacancy_years                   bool
	notify_ref                             map[int32]struct{}
	removednotify_ref                      map[int32]struct{}
	clearednotify_ref                      bool
	done                                   bool
	oldValue                               func(context.Context) (*Notification, error)
	predicates                             []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id int32) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notification entities.
func (m *NotificationMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExamCode sets the "ExamCode" field.
func (m *NotificationMutation) SetExamCode(i int32) {
	m.exam = &i
}

// ExamCode returns the value of the "ExamCode" field in the mutation.
func (m *NotificationMutation) ExamCode() (r int32, exists bool) {
	v := m.exam
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCode returns the old "ExamCode" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldExamCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCode: %w", err)
	}
	return oldValue.ExamCode, nil
}

// ClearExamCode clears the value of the "ExamCode" field.
func (m *NotificationMutation) ClearExamCode() {
	m.exam = nil
	m.clearedFields[notification.FieldExamCode] = struct{}{}
}

// ExamCodeCleared returns if the "ExamCode" field was cleared in this mutation.
func (m *NotificationMutation) ExamCodeCleared() bool {
	_, ok := m.clearedFields[notification.FieldExamCode]
	return ok
}

// ResetExamCode resets all changes to the "ExamCode" field.
func (m *NotificationMutation) ResetExamCode() {
	m.exam = nil
	delete(m.clearedFields, notification.FieldExamCode)
}

// SetExamYear sets the "ExamYear" field.
func (m *NotificationMutation) SetExamYear(i int32) {
	m._ExamYear = &i
	m.add_ExamYear = nil
}

// ExamYear returns the value of the "ExamYear" field in the mutation.
func (m *NotificationMutation) ExamYear() (r int32, exists bool) {
	v := m._ExamYear
	if v == nil {
		return
	}
	return *v, true
}

// OldExamYear returns the old "ExamYear" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldExamYear(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamYear: %w", err)
	}
	return oldValue.ExamYear, nil
}

// AddExamYear adds i to the "ExamYear" field.
func (m *NotificationMutation) AddExamYear(i int32) {
	if m.add_ExamYear != nil {
		*m.add_ExamYear += i
	} else {
		m.add_ExamYear = &i
	}
}

// AddedExamYear returns the value that was added to the "ExamYear" field in this mutation.
func (m *NotificationMutation) AddedExamYear() (r int32, exists bool) {
	v := m.add_ExamYear
	if v == nil {
		return
	}
	return *v, true
}

// ResetExamYear resets all changes to the "ExamYear" field.
func (m *NotificationMutation) ResetExamYear() {
	m._ExamYear = nil
	m.add_ExamYear = nil
}

// SetApplicationStartDate sets the "ApplicationStartDate" field.
func (m *NotificationMutation) SetApplicationStartDate(t time.Time) {
	m._ApplicationStartDate = &t
}

// ApplicationStartDate returns the value of the "ApplicationStartDate" field in the mutation.
func (m *NotificationMutation) ApplicationStartDate() (r time.Time, exists bool) {
	v := m._ApplicationStartDate
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationStartDate returns the old "ApplicationStartDate" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldApplicationStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationStartDate: %w", err)
	}
	return oldValue.ApplicationStartDate, nil
}

// ResetApplicationStartDate resets all changes to the "ApplicationStartDate" field.
func (m *NotificationMutation) ResetApplicationStartDate() {
	m._ApplicationStartDate = nil
}

// SetApplicationEndDate sets the "ApplicationEndDate" field.
func (m *NotificationMutation) SetApplicationEndDate(t time.Time) {
	m._ApplicationEndDate = &t
}

// ApplicationEndDate returns the value of the "ApplicationEndDate" field in the mutation.
func (m *NotificationMutation) ApplicationEndDate() (r time.Time, exists bool) {
	v := m._ApplicationEndDate
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationEndDate returns the old "ApplicationEndDate" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldApplicationEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationEndDate: %w", err)
	}
	return oldValue.ApplicationEndDate, nil
}

// ResetApplicationEndDate resets all changes to the "ApplicationEndDate" field.
func (m *NotificationMutation) ResetApplicationEndDate() {
	m._ApplicationEndDate = nil
}

// SetVerificationDateByController sets the "VerificationDateByController" field.
func (m *NotificationMutation) SetVerificationDateByController(t time.Time) {
	m._VerificationDateByController = &t
}

// VerificationDateByController returns the value of the "VerificationDateByController" field in the mutation.
func (m *NotificationMutation) VerificationDateByController() (r time.Time, exists bool) {
	v := m._VerificationDateByController
	if v == nil {
		return
	}
	return *v, true
}

// OldVerificationDateByController returns the old "VerificationDateByController" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldVerificationDateByController(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerificationDateByController is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerificationDateByController requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerificationDateByController: %w", err)
	}
	return oldValue.VerificationDateByController, nil
}

// ResetVerificationDateByController resets all changes to the "VerificationDateByController" field.
func (m *NotificationMutation) ResetVerificationDateByController() {
	m._VerificationDateByController = nil
}

// SetCorrectionDateByCandidate sets the "CorrectionDateByCandidate" field.
func (m *NotificationMutation) SetCorrectionDateByCandidate(t time.Time) {
	m._CorrectionDateByCandidate = &t
}

// CorrectionDateByCandidate returns the value of the "CorrectionDateByCandidate" field in the mutation.
func (m *NotificationMutation) CorrectionDateByCandidate() (r time.Time, exists bool) {
	v := m._CorrectionDateByCandidate
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrectionDateByCandidate returns the old "CorrectionDateByCandidate" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCorrectionDateByCandidate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrectionDateByCandidate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrectionDateByCandidate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrectionDateByCandidate: %w", err)
	}
	return oldValue.CorrectionDateByCandidate, nil
}

// ResetCorrectionDateByCandidate resets all changes to the "CorrectionDateByCandidate" field.
func (m *NotificationMutation) ResetCorrectionDateByCandidate() {
	m._CorrectionDateByCandidate = nil
}

// SetCorrectionVeriyDateByController sets the "CorrectionVeriyDateByController" field.
func (m *NotificationMutation) SetCorrectionVeriyDateByController(t time.Time) {
	m._CorrectionVeriyDateByController = &t
}

// CorrectionVeriyDateByController returns the value of the "CorrectionVeriyDateByController" field in the mutation.
func (m *NotificationMutation) CorrectionVeriyDateByController() (r time.Time, exists bool) {
	v := m._CorrectionVeriyDateByController
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrectionVeriyDateByController returns the old "CorrectionVeriyDateByController" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCorrectionVeriyDateByController(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrectionVeriyDateByController is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrectionVeriyDateByController requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrectionVeriyDateByController: %w", err)
	}
	return oldValue.CorrectionVeriyDateByController, nil
}

// ResetCorrectionVeriyDateByController resets all changes to the "CorrectionVeriyDateByController" field.
func (m *NotificationMutation) ResetCorrectionVeriyDateByController() {
	m._CorrectionVeriyDateByController = nil
}

// SetHallTicketAllotmentDateByNodalOfficer sets the "HallTicketAllotmentDateByNodalOfficer" field.
func (m *NotificationMutation) SetHallTicketAllotmentDateByNodalOfficer(t time.Time) {
	m._HallTicketAllotmentDateByNodalOfficer = &t
}

// HallTicketAllotmentDateByNodalOfficer returns the value of the "HallTicketAllotmentDateByNodalOfficer" field in the mutation.
func (m *NotificationMutation) HallTicketAllotmentDateByNodalOfficer() (r time.Time, exists bool) {
	v := m._HallTicketAllotmentDateByNodalOfficer
	if v == nil {
		return
	}
	return *v, true
}

// OldHallTicketAllotmentDateByNodalOfficer returns the old "HallTicketAllotmentDateByNodalOfficer" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldHallTicketAllotmentDateByNodalOfficer(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHallTicketAllotmentDateByNodalOfficer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHallTicketAllotmentDateByNodalOfficer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHallTicketAllotmentDateByNodalOfficer: %w", err)
	}
	return oldValue.HallTicketAllotmentDateByNodalOfficer, nil
}

// ResetHallTicketAllotmentDateByNodalOfficer resets all changes to the "HallTicketAllotmentDateByNodalOfficer" field.
func (m *NotificationMutation) ResetHallTicketAllotmentDateByNodalOfficer() {
	m._HallTicketAllotmentDateByNodalOfficer = nil
}

// SetHallTicketDownloadDate sets the "HallTicketDownloadDate" field.
func (m *NotificationMutation) SetHallTicketDownloadDate(t time.Time) {
	m._HallTicketDownloadDate = &t
}

// HallTicketDownloadDate returns the value of the "HallTicketDownloadDate" field in the mutation.
func (m *NotificationMutation) HallTicketDownloadDate() (r time.Time, exists bool) {
	v := m._HallTicketDownloadDate
	if v == nil {
		return
	}
	return *v, true
}

// OldHallTicketDownloadDate returns the old "HallTicketDownloadDate" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldHallTicketDownloadDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHallTicketDownloadDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHallTicketDownloadDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHallTicketDownloadDate: %w", err)
	}
	return oldValue.HallTicketDownloadDate, nil
}

// ClearHallTicketDownloadDate clears the value of the "HallTicketDownloadDate" field.
func (m *NotificationMutation) ClearHallTicketDownloadDate() {
	m._HallTicketDownloadDate = nil
	m.clearedFields[notification.FieldHallTicketDownloadDate] = struct{}{}
}

// HallTicketDownloadDateCleared returns if the "HallTicketDownloadDate" field was cleared in this mutation.
func (m *NotificationMutation) HallTicketDownloadDateCleared() bool {
	_, ok := m.clearedFields[notification.FieldHallTicketDownloadDate]
	return ok
}

// ResetHallTicketDownloadDate resets all changes to the "HallTicketDownloadDate" field.
func (m *NotificationMutation) ResetHallTicketDownloadDate() {
	m._HallTicketDownloadDate = nil
	delete(m.clearedFields, notification.FieldHallTicketDownloadDate)
}

// SetNotifyFile sets the "NotifyFile" field.
func (m *NotificationMutation) SetNotifyFile(s string) {
	m._NotifyFile = &s
}

// NotifyFile returns the value of the "NotifyFile" field in the mutation.
func (m *NotificationMutation) NotifyFile() (r string, exists bool) {
	v := m._NotifyFile
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyFile returns the old "NotifyFile" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldNotifyFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyFile: %w", err)
	}
	return oldValue.NotifyFile, nil
}

// ClearNotifyFile clears the value of the "NotifyFile" field.
func (m *NotificationMutation) ClearNotifyFile() {
	m._NotifyFile = nil
	m.clearedFields[notification.FieldNotifyFile] = struct{}{}
}

// NotifyFileCleared returns if the "NotifyFile" field was cleared in this mutation.
func (m *NotificationMutation) NotifyFileCleared() bool {
	_, ok := m.clearedFields[notification.FieldNotifyFile]
	return ok
}

// ResetNotifyFile resets all changes to the "NotifyFile" field.
func (m *NotificationMutation) ResetNotifyFile() {
	m._NotifyFile = nil
	delete(m.clearedFields, notification.FieldNotifyFile)
}

// SetSyllabusFile sets the "SyllabusFile" field.
func (m *NotificationMutation) SetSyllabusFile(s string) {
	m._SyllabusFile = &s
}

// SyllabusFile returns the value of the "SyllabusFile" field in the mutation.
func (m *NotificationMutation) SyllabusFile() (r string, exists bool) {
	v := m._SyllabusFile
	if v == nil {
		return
	}
	return *v, true
}

// OldSyllabusFile returns the old "SyllabusFile" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldSyllabusFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyllabusFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyllabusFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyllabusFile: %w", err)
	}
	return oldValue.SyllabusFile, nil
}

// ClearSyllabusFile clears the value of the "SyllabusFile" field.
func (m *NotificationMutation) ClearSyllabusFile() {
	m._SyllabusFile = nil
	m.clearedFields[notification.FieldSyllabusFile] = struct{}{}
}

// SyllabusFileCleared returns if the "SyllabusFile" field was cleared in this mutation.
func (m *NotificationMutation) SyllabusFileCleared() bool {
	_, ok := m.clearedFields[notification.FieldSyllabusFile]
	return ok
}

// ResetSyllabusFile resets all changes to the "SyllabusFile" field.
func (m *NotificationMutation) ResetSyllabusFile() {
	m._SyllabusFile = nil
	delete(m.clearedFields, notification.FieldSyllabusFile)
}

// SetVacanciesFile sets the "VacanciesFile" field.
func (m *NotificationMutation) SetVacanciesFile(s string) {
	m._VacanciesFile = &s
}

// VacanciesFile returns the value of the "VacanciesFile" field in the mutation.
func (m *NotificationMutation) VacanciesFile() (r string, exists bool) {
	v := m._VacanciesFile
	if v == nil {
		return
	}
	return *v, true
}

// OldVacanciesFile returns the old "VacanciesFile" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldVacanciesFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVacanciesFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVacanciesFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVacanciesFile: %w", err)
	}
	return oldValue.VacanciesFile, nil
}

// ClearVacanciesFile clears the value of the "VacanciesFile" field.
func (m *NotificationMutation) ClearVacanciesFile() {
	m._VacanciesFile = nil
	m.clearedFields[notification.FieldVacanciesFile] = struct{}{}
}

// VacanciesFileCleared returns if the "VacanciesFile" field was cleared in this mutation.
func (m *NotificationMutation) VacanciesFileCleared() bool {
	_, ok := m.clearedFields[notification.FieldVacanciesFile]
	return ok
}

// ResetVacanciesFile resets all changes to the "VacanciesFile" field.
func (m *NotificationMutation) ResetVacanciesFile() {
	m._VacanciesFile = nil
	delete(m.clearedFields, notification.FieldVacanciesFile)
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *NotificationMutation) AddApplicationIDs(ids ...int32) {
	if m.applications == nil {
		m.applications = make(map[int32]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *NotificationMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *NotificationMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *NotificationMutation) RemoveApplicationIDs(ids ...int32) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *NotificationMutation) RemovedApplicationsIDs() (ids []int32) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *NotificationMutation) ApplicationsIDs() (ids []int32) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *NotificationMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// AddCenterIDs adds the "centers" edge to the Center entity by ids.
func (m *NotificationMutation) AddCenterIDs(ids ...int32) {
	if m.centers == nil {
		m.centers = make(map[int32]struct{})
	}
	for i := range ids {
		m.centers[ids[i]] = struct{}{}
	}
}

// ClearCenters clears the "centers" edge to the Center entity.
func (m *NotificationMutation) ClearCenters() {
	m.clearedcenters = true
}

// CentersCleared reports if the "centers" edge to the Center entity was cleared.
func (m *NotificationMutation) CentersCleared() bool {
	return m.clearedcenters
}

// RemoveCenterIDs removes the "centers" edge to the Center entity by IDs.
func (m *NotificationMutation) RemoveCenterIDs(ids ...int32) {
	if m.removedcenters == nil {
		m.removedcenters = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.centers, ids[i])
		m.removedcenters[ids[i]] = struct{}{}
	}
}

// RemovedCenters returns the removed IDs of the "centers" edge to the Center entity.
func (m *NotificationMutation) RemovedCentersIDs() (ids []int32) {
	for id := range m.removedcenters {
		ids = append(ids, id)
	}
	return
}

// CentersIDs returns the "centers" edge IDs in the mutation.
func (m *NotificationMutation) CentersIDs() (ids []int32) {
	for id := range m.centers {
		ids = append(ids, id)
	}
	return
}

// ResetCenters resets all changes to the "centers" edge.
func (m *NotificationMutation) ResetCenters() {
	m.centers = nil
	m.clearedcenters = false
	m.removedcenters = nil
}

// AddNodalOfficerIDs adds the "nodal_officers" edge to the NodalOfficer entity by ids.
func (m *NotificationMutation) AddNodalOfficerIDs(ids ...int32) {
	if m.nodal_officers == nil {
		m.nodal_officers = make(map[int32]struct{})
	}
	for i := range ids {
		m.nodal_officers[ids[i]] = struct{}{}
	}
}

// ClearNodalOfficers clears the "nodal_officers" edge to the NodalOfficer entity.
func (m *NotificationMutation) ClearNodalOfficers() {
	m.clearednodal_officers = true
}

// NodalOfficersCleared reports if the "nodal_officers" edge to the NodalOfficer entity was cleared.
func (m *NotificationMutation) NodalOfficersCleared() bool {
	return m.clearednodal_officers
}

// RemoveNodalOfficerIDs removes the "nodal_officers" edge to the NodalOfficer entity by IDs.
func (m *NotificationMutation) RemoveNodalOfficerIDs(ids ...int32) {
	if m.removednodal_officers == nil {
		m.removednodal_officers = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.nodal_officers, ids[i])
		m.removednodal_officers[ids[i]] = struct{}{}
	}
}

// RemovedNodalOfficers returns the removed IDs of the "nodal_officers" edge to the NodalOfficer entity.
func (m *NotificationMutation) RemovedNodalOfficersIDs() (ids []int32) {
	for id := range m.removednodal_officers {
		ids = append(ids, id)
	}
	return
}

// NodalOfficersIDs returns the "nodal_officers" edge IDs in the mutation.
func (m *NotificationMutation) NodalOfficersIDs() (ids []int32) {
	for id := range m.nodal_officers {
		ids = append(ids, id)
	}
	return
}

// ResetNodalOfficers resets all changes to the "nodal_officers" edge.
func (m *NotificationMutation) ResetNodalOfficers() {
	m.nodal_officers = nil
	m.clearednodal_officers = false
	m.removednodal_officers = nil
}

// SetExamID sets the "exam" edge to the Exam entity by id.
func (m *NotificationMutation) SetExamID(id int32) {
	m.exam = &id
}

// ClearExam clears the "exam" edge to the Exam entity.
func (m *NotificationMutation) ClearExam() {
	m.clearedexam = true
}

// ExamCleared reports if the "exam" edge to the Exam entity was cleared.
func (m *NotificationMutation) ExamCleared() bool {
	return m.ExamCodeCleared() || m.clearedexam
}

// ExamID returns the "exam" edge ID in the mutation.
func (m *NotificationMutation) ExamID() (id int32, exists bool) {
	if m.exam != nil {
		return *m.exam, true
	}
	return
}

// ExamIDs returns the "exam" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) ExamIDs() (ids []int32) {
	if id := m.exam; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExam resets all changes to the "exam" edge.
func (m *NotificationMutation) ResetExam() {
	m.exam = nil
	m.clearedexam = false
}

// AddVacancyYearIDs adds the "vacancy_years" edge to the VacancyYear entity by ids.
func (m *NotificationMutation) AddVacancyYearIDs(ids ...int32) {
	if m.vacancy_years == nil {
		m.vacancy_years = make(map[int32]struct{})
	}
	for i := range ids {
		m.vacancy_years[ids[i]] = struct{}{}
	}
}

// ClearVacancyYears clears the "vacancy_years" edge to the VacancyYear entity.
func (m *NotificationMutation) ClearVacancyYears() {
	m.clearedvacancy_years = true
}

// VacancyYearsCleared reports if the "vacancy_years" edge to the VacancyYear entity was cleared.
func (m *NotificationMutation) VacancyYearsCleared() bool {
	return m.clearedvacancy_years
}

// RemoveVacancyYearIDs removes the "vacancy_years" edge to the VacancyYear entity by IDs.
func (m *NotificationMutation) RemoveVacancyYearIDs(ids ...int32) {
	if m.removedvacancy_years == nil {
		m.removedvacancy_years = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.vacancy_years, ids[i])
		m.removedvacancy_years[ids[i]] = struct{}{}
	}
}

// RemovedVacancyYears returns the removed IDs of the "vacancy_years" edge to the VacancyYear entity.
func (m *NotificationMutation) RemovedVacancyYearsIDs() (ids []int32) {
	for id := range m.removedvacancy_years {
		ids = append(ids, id)
	}
	return
}

// VacancyYearsIDs returns the "vacancy_years" edge IDs in the mutation.
func (m *NotificationMutation) VacancyYearsIDs() (ids []int32) {
	for id := range m.vacancy_years {
		ids = append(ids, id)
	}
	return
}

// ResetVacancyYears resets all changes to the "vacancy_years" edge.
func (m *NotificationMutation) ResetVacancyYears() {
	m.vacancy_years = nil
	m.clearedvacancy_years = false
	m.removedvacancy_years = nil
}

// AddNotifyRefIDs adds the "notify_ref" edge to the Notification entity by ids.
func (m *NotificationMutation) AddNotifyRefIDs(ids ...int32) {
	if m.notify_ref == nil {
		m.notify_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.notify_ref[ids[i]] = struct{}{}
	}
}

// ClearNotifyRef clears the "notify_ref" edge to the Notification entity.
func (m *NotificationMutation) ClearNotifyRef() {
	m.clearednotify_ref = true
}

// NotifyRefCleared reports if the "notify_ref" edge to the Notification entity was cleared.
func (m *NotificationMutation) NotifyRefCleared() bool {
	return m.clearednotify_ref
}

// RemoveNotifyRefIDs removes the "notify_ref" edge to the Notification entity by IDs.
func (m *NotificationMutation) RemoveNotifyRefIDs(ids ...int32) {
	if m.removednotify_ref == nil {
		m.removednotify_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.notify_ref, ids[i])
		m.removednotify_ref[ids[i]] = struct{}{}
	}
}

// RemovedNotifyRef returns the removed IDs of the "notify_ref" edge to the Notification entity.
func (m *NotificationMutation) RemovedNotifyRefIDs() (ids []int32) {
	for id := range m.removednotify_ref {
		ids = append(ids, id)
	}
	return
}

// NotifyRefIDs returns the "notify_ref" edge IDs in the mutation.
func (m *NotificationMutation) NotifyRefIDs() (ids []int32) {
	for id := range m.notify_ref {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyRef resets all changes to the "notify_ref" edge.
func (m *NotificationMutation) ResetNotifyRef() {
	m.notify_ref = nil
	m.clearednotify_ref = false
	m.removednotify_ref = nil
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.exam != nil {
		fields = append(fields, notification.FieldExamCode)
	}
	if m._ExamYear != nil {
		fields = append(fields, notification.FieldExamYear)
	}
	if m._ApplicationStartDate != nil {
		fields = append(fields, notification.FieldApplicationStartDate)
	}
	if m._ApplicationEndDate != nil {
		fields = append(fields, notification.FieldApplicationEndDate)
	}
	if m._VerificationDateByController != nil {
		fields = append(fields, notification.FieldVerificationDateByController)
	}
	if m._CorrectionDateByCandidate != nil {
		fields = append(fields, notification.FieldCorrectionDateByCandidate)
	}
	if m._CorrectionVeriyDateByController != nil {
		fields = append(fields, notification.FieldCorrectionVeriyDateByController)
	}
	if m._HallTicketAllotmentDateByNodalOfficer != nil {
		fields = append(fields, notification.FieldHallTicketAllotmentDateByNodalOfficer)
	}
	if m._HallTicketDownloadDate != nil {
		fields = append(fields, notification.FieldHallTicketDownloadDate)
	}
	if m._NotifyFile != nil {
		fields = append(fields, notification.FieldNotifyFile)
	}
	if m._SyllabusFile != nil {
		fields = append(fields, notification.FieldSyllabusFile)
	}
	if m._VacanciesFile != nil {
		fields = append(fields, notification.FieldVacanciesFile)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldExamCode:
		return m.ExamCode()
	case notification.FieldExamYear:
		return m.ExamYear()
	case notification.FieldApplicationStartDate:
		return m.ApplicationStartDate()
	case notification.FieldApplicationEndDate:
		return m.ApplicationEndDate()
	case notification.FieldVerificationDateByController:
		return m.VerificationDateByController()
	case notification.FieldCorrectionDateByCandidate:
		return m.CorrectionDateByCandidate()
	case notification.FieldCorrectionVeriyDateByController:
		return m.CorrectionVeriyDateByController()
	case notification.FieldHallTicketAllotmentDateByNodalOfficer:
		return m.HallTicketAllotmentDateByNodalOfficer()
	case notification.FieldHallTicketDownloadDate:
		return m.HallTicketDownloadDate()
	case notification.FieldNotifyFile:
		return m.NotifyFile()
	case notification.FieldSyllabusFile:
		return m.SyllabusFile()
	case notification.FieldVacanciesFile:
		return m.VacanciesFile()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldExamCode:
		return m.OldExamCode(ctx)
	case notification.FieldExamYear:
		return m.OldExamYear(ctx)
	case notification.FieldApplicationStartDate:
		return m.OldApplicationStartDate(ctx)
	case notification.FieldApplicationEndDate:
		return m.OldApplicationEndDate(ctx)
	case notification.FieldVerificationDateByController:
		return m.OldVerificationDateByController(ctx)
	case notification.FieldCorrectionDateByCandidate:
		return m.OldCorrectionDateByCandidate(ctx)
	case notification.FieldCorrectionVeriyDateByController:
		return m.OldCorrectionVeriyDateByController(ctx)
	case notification.FieldHallTicketAllotmentDateByNodalOfficer:
		return m.OldHallTicketAllotmentDateByNodalOfficer(ctx)
	case notification.FieldHallTicketDownloadDate:
		return m.OldHallTicketDownloadDate(ctx)
	case notification.FieldNotifyFile:
		return m.OldNotifyFile(ctx)
	case notification.FieldSyllabusFile:
		return m.OldSyllabusFile(ctx)
	case notification.FieldVacanciesFile:
		return m.OldVacanciesFile(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldExamCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCode(v)
		return nil
	case notification.FieldExamYear:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamYear(v)
		return nil
	case notification.FieldApplicationStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationStartDate(v)
		return nil
	case notification.FieldApplicationEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationEndDate(v)
		return nil
	case notification.FieldVerificationDateByController:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerificationDateByController(v)
		return nil
	case notification.FieldCorrectionDateByCandidate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrectionDateByCandidate(v)
		return nil
	case notification.FieldCorrectionVeriyDateByController:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrectionVeriyDateByController(v)
		return nil
	case notification.FieldHallTicketAllotmentDateByNodalOfficer:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHallTicketAllotmentDateByNodalOfficer(v)
		return nil
	case notification.FieldHallTicketDownloadDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHallTicketDownloadDate(v)
		return nil
	case notification.FieldNotifyFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyFile(v)
		return nil
	case notification.FieldSyllabusFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyllabusFile(v)
		return nil
	case notification.FieldVacanciesFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVacanciesFile(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	var fields []string
	if m.add_ExamYear != nil {
		fields = append(fields, notification.FieldExamYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldExamYear:
		return m.AddedExamYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notification.FieldExamYear:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamYear(v)
		return nil
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldExamCode) {
		fields = append(fields, notification.FieldExamCode)
	}
	if m.FieldCleared(notification.FieldHallTicketDownloadDate) {
		fields = append(fields, notification.FieldHallTicketDownloadDate)
	}
	if m.FieldCleared(notification.FieldNotifyFile) {
		fields = append(fields, notification.FieldNotifyFile)
	}
	if m.FieldCleared(notification.FieldSyllabusFile) {
		fields = append(fields, notification.FieldSyllabusFile)
	}
	if m.FieldCleared(notification.FieldVacanciesFile) {
		fields = append(fields, notification.FieldVacanciesFile)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldExamCode:
		m.ClearExamCode()
		return nil
	case notification.FieldHallTicketDownloadDate:
		m.ClearHallTicketDownloadDate()
		return nil
	case notification.FieldNotifyFile:
		m.ClearNotifyFile()
		return nil
	case notification.FieldSyllabusFile:
		m.ClearSyllabusFile()
		return nil
	case notification.FieldVacanciesFile:
		m.ClearVacanciesFile()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldExamCode:
		m.ResetExamCode()
		return nil
	case notification.FieldExamYear:
		m.ResetExamYear()
		return nil
	case notification.FieldApplicationStartDate:
		m.ResetApplicationStartDate()
		return nil
	case notification.FieldApplicationEndDate:
		m.ResetApplicationEndDate()
		return nil
	case notification.FieldVerificationDateByController:
		m.ResetVerificationDateByController()
		return nil
	case notification.FieldCorrectionDateByCandidate:
		m.ResetCorrectionDateByCandidate()
		return nil
	case notification.FieldCorrectionVeriyDateByController:
		m.ResetCorrectionVeriyDateByController()
		return nil
	case notification.FieldHallTicketAllotmentDateByNodalOfficer:
		m.ResetHallTicketAllotmentDateByNodalOfficer()
		return nil
	case notification.FieldHallTicketDownloadDate:
		m.ResetHallTicketDownloadDate()
		return nil
	case notification.FieldNotifyFile:
		m.ResetNotifyFile()
		return nil
	case notification.FieldSyllabusFile:
		m.ResetSyllabusFile()
		return nil
	case notification.FieldVacanciesFile:
		m.ResetVacanciesFile()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.applications != nil {
		edges = append(edges, notification.EdgeApplications)
	}
	if m.centers != nil {
		edges = append(edges, notification.EdgeCenters)
	}
	if m.nodal_officers != nil {
		edges = append(edges, notification.EdgeNodalOfficers)
	}
	if m.exam != nil {
		edges = append(edges, notification.EdgeExam)
	}
	if m.vacancy_years != nil {
		edges = append(edges, notification.EdgeVacancyYears)
	}
	if m.notify_ref != nil {
		edges = append(edges, notification.EdgeNotifyRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeCenters:
		ids := make([]ent.Value, 0, len(m.centers))
		for id := range m.centers {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeNodalOfficers:
		ids := make([]ent.Value, 0, len(m.nodal_officers))
		for id := range m.nodal_officers {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeExam:
		if id := m.exam; id != nil {
			return []ent.Value{*id}
		}
	case notification.EdgeVacancyYears:
		ids := make([]ent.Value, 0, len(m.vacancy_years))
		for id := range m.vacancy_years {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeNotifyRef:
		ids := make([]ent.Value, 0, len(m.notify_ref))
		for id := range m.notify_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedapplications != nil {
		edges = append(edges, notification.EdgeApplications)
	}
	if m.removedcenters != nil {
		edges = append(edges, notification.EdgeCenters)
	}
	if m.removednodal_officers != nil {
		edges = append(edges, notification.EdgeNodalOfficers)
	}
	if m.removedvacancy_years != nil {
		edges = append(edges, notification.EdgeVacancyYears)
	}
	if m.removednotify_ref != nil {
		edges = append(edges, notification.EdgeNotifyRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeCenters:
		ids := make([]ent.Value, 0, len(m.removedcenters))
		for id := range m.removedcenters {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeNodalOfficers:
		ids := make([]ent.Value, 0, len(m.removednodal_officers))
		for id := range m.removednodal_officers {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeVacancyYears:
		ids := make([]ent.Value, 0, len(m.removedvacancy_years))
		for id := range m.removedvacancy_years {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeNotifyRef:
		ids := make([]ent.Value, 0, len(m.removednotify_ref))
		for id := range m.removednotify_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedapplications {
		edges = append(edges, notification.EdgeApplications)
	}
	if m.clearedcenters {
		edges = append(edges, notification.EdgeCenters)
	}
	if m.clearednodal_officers {
		edges = append(edges, notification.EdgeNodalOfficers)
	}
	if m.clearedexam {
		edges = append(edges, notification.EdgeExam)
	}
	if m.clearedvacancy_years {
		edges = append(edges, notification.EdgeVacancyYears)
	}
	if m.clearednotify_ref {
		edges = append(edges, notification.EdgeNotifyRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case notification.EdgeApplications:
		return m.clearedapplications
	case notification.EdgeCenters:
		return m.clearedcenters
	case notification.EdgeNodalOfficers:
		return m.clearednodal_officers
	case notification.EdgeExam:
		return m.clearedexam
	case notification.EdgeVacancyYears:
		return m.clearedvacancy_years
	case notification.EdgeNotifyRef:
		return m.clearednotify_ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	switch name {
	case notification.EdgeExam:
		m.ClearExam()
		return nil
	}
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	switch name {
	case notification.EdgeApplications:
		m.ResetApplications()
		return nil
	case notification.EdgeCenters:
		m.ResetCenters()
		return nil
	case notification.EdgeNodalOfficers:
		m.ResetNodalOfficers()
		return nil
	case notification.EdgeExam:
		m.ResetExam()
		return nil
	case notification.EdgeVacancyYears:
		m.ResetVacancyYears()
		return nil
	case notification.EdgeNotifyRef:
		m.ResetNotifyRef()
		return nil
	}
	return fmt.Errorf("unknown Notification edge %s", name)
}

// PaperTypesMutation represents an operation that mutates the PaperTypes nodes in the graph.
type PaperTypesMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int32
	_PaperTypeDescription *string
	_OrderNumber          *string
	_SequenceNumber       *int32
	add_SequenceNumber    *int32
	_CreatedDate          *time.Time
	clearedFields         map[string]struct{}
	papercode             *int32
	clearedpapercode      bool
	done                  bool
	oldValue              func(context.Context) (*PaperTypes, error)
	predicates            []predicate.PaperTypes
}

var _ ent.Mutation = (*PaperTypesMutation)(nil)

// papertypesOption allows management of the mutation configuration using functional options.
type papertypesOption func(*PaperTypesMutation)

// newPaperTypesMutation creates new mutation for the PaperTypes entity.
func newPaperTypesMutation(c config, op Op, opts ...papertypesOption) *PaperTypesMutation {
	m := &PaperTypesMutation{
		config:        c,
		op:            op,
		typ:           TypePaperTypes,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaperTypesID sets the ID field of the mutation.
func withPaperTypesID(id int32) papertypesOption {
	return func(m *PaperTypesMutation) {
		var (
			err   error
			once  sync.Once
			value *PaperTypes
		)
		m.oldValue = func(ctx context.Context) (*PaperTypes, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaperTypes.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaperTypes sets the old PaperTypes of the mutation.
func withPaperTypes(node *PaperTypes) papertypesOption {
	return func(m *PaperTypesMutation) {
		m.oldValue = func(context.Context) (*PaperTypes, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaperTypesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaperTypesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaperTypes entities.
func (m *PaperTypesMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaperTypesMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaperTypesMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaperTypes.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPaperCode sets the "PaperCode" field.
func (m *PaperTypesMutation) SetPaperCode(i int32) {
	m.papercode = &i
}

// PaperCode returns the value of the "PaperCode" field in the mutation.
func (m *PaperTypesMutation) PaperCode() (r int32, exists bool) {
	v := m.papercode
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperCode returns the old "PaperCode" field's value of the PaperTypes entity.
// If the PaperTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaperTypesMutation) OldPaperCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperCode: %w", err)
	}
	return oldValue.PaperCode, nil
}

// ClearPaperCode clears the value of the "PaperCode" field.
func (m *PaperTypesMutation) ClearPaperCode() {
	m.papercode = nil
	m.clearedFields[papertypes.FieldPaperCode] = struct{}{}
}

// PaperCodeCleared returns if the "PaperCode" field was cleared in this mutation.
func (m *PaperTypesMutation) PaperCodeCleared() bool {
	_, ok := m.clearedFields[papertypes.FieldPaperCode]
	return ok
}

// ResetPaperCode resets all changes to the "PaperCode" field.
func (m *PaperTypesMutation) ResetPaperCode() {
	m.papercode = nil
	delete(m.clearedFields, papertypes.FieldPaperCode)
}

// SetPaperTypeDescription sets the "PaperTypeDescription" field.
func (m *PaperTypesMutation) SetPaperTypeDescription(s string) {
	m._PaperTypeDescription = &s
}

// PaperTypeDescription returns the value of the "PaperTypeDescription" field in the mutation.
func (m *PaperTypesMutation) PaperTypeDescription() (r string, exists bool) {
	v := m._PaperTypeDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperTypeDescription returns the old "PaperTypeDescription" field's value of the PaperTypes entity.
// If the PaperTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaperTypesMutation) OldPaperTypeDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperTypeDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperTypeDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperTypeDescription: %w", err)
	}
	return oldValue.PaperTypeDescription, nil
}

// ResetPaperTypeDescription resets all changes to the "PaperTypeDescription" field.
func (m *PaperTypesMutation) ResetPaperTypeDescription() {
	m._PaperTypeDescription = nil
}

// SetOrderNumber sets the "OrderNumber" field.
func (m *PaperTypesMutation) SetOrderNumber(s string) {
	m._OrderNumber = &s
}

// OrderNumber returns the value of the "OrderNumber" field in the mutation.
func (m *PaperTypesMutation) OrderNumber() (r string, exists bool) {
	v := m._OrderNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNumber returns the old "OrderNumber" field's value of the PaperTypes entity.
// If the PaperTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaperTypesMutation) OldOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNumber: %w", err)
	}
	return oldValue.OrderNumber, nil
}

// ResetOrderNumber resets all changes to the "OrderNumber" field.
func (m *PaperTypesMutation) ResetOrderNumber() {
	m._OrderNumber = nil
}

// SetSequenceNumber sets the "SequenceNumber" field.
func (m *PaperTypesMutation) SetSequenceNumber(i int32) {
	m._SequenceNumber = &i
	m.add_SequenceNumber = nil
}

// SequenceNumber returns the value of the "SequenceNumber" field in the mutation.
func (m *PaperTypesMutation) SequenceNumber() (r int32, exists bool) {
	v := m._SequenceNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceNumber returns the old "SequenceNumber" field's value of the PaperTypes entity.
// If the PaperTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaperTypesMutation) OldSequenceNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequenceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequenceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceNumber: %w", err)
	}
	return oldValue.SequenceNumber, nil
}

// AddSequenceNumber adds i to the "SequenceNumber" field.
func (m *PaperTypesMutation) AddSequenceNumber(i int32) {
	if m.add_SequenceNumber != nil {
		*m.add_SequenceNumber += i
	} else {
		m.add_SequenceNumber = &i
	}
}

// AddedSequenceNumber returns the value that was added to the "SequenceNumber" field in this mutation.
func (m *PaperTypesMutation) AddedSequenceNumber() (r int32, exists bool) {
	v := m.add_SequenceNumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequenceNumber resets all changes to the "SequenceNumber" field.
func (m *PaperTypesMutation) ResetSequenceNumber() {
	m._SequenceNumber = nil
	m.add_SequenceNumber = nil
}

// SetCreatedDate sets the "CreatedDate" field.
func (m *PaperTypesMutation) SetCreatedDate(t time.Time) {
	m._CreatedDate = &t
}

// CreatedDate returns the value of the "CreatedDate" field in the mutation.
func (m *PaperTypesMutation) CreatedDate() (r time.Time, exists bool) {
	v := m._CreatedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "CreatedDate" field's value of the PaperTypes entity.
// If the PaperTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaperTypesMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ResetCreatedDate resets all changes to the "CreatedDate" field.
func (m *PaperTypesMutation) ResetCreatedDate() {
	m._CreatedDate = nil
}

// SetPapercodeID sets the "papercode" edge to the ExamPapers entity by id.
func (m *PaperTypesMutation) SetPapercodeID(id int32) {
	m.papercode = &id
}

// ClearPapercode clears the "papercode" edge to the ExamPapers entity.
func (m *PaperTypesMutation) ClearPapercode() {
	m.clearedpapercode = true
}

// PapercodeCleared reports if the "papercode" edge to the ExamPapers entity was cleared.
func (m *PaperTypesMutation) PapercodeCleared() bool {
	return m.PaperCodeCleared() || m.clearedpapercode
}

// PapercodeID returns the "papercode" edge ID in the mutation.
func (m *PaperTypesMutation) PapercodeID() (id int32, exists bool) {
	if m.papercode != nil {
		return *m.papercode, true
	}
	return
}

// PapercodeIDs returns the "papercode" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PapercodeID instead. It exists only for internal usage by the builders.
func (m *PaperTypesMutation) PapercodeIDs() (ids []int32) {
	if id := m.papercode; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPapercode resets all changes to the "papercode" edge.
func (m *PaperTypesMutation) ResetPapercode() {
	m.papercode = nil
	m.clearedpapercode = false
}

// Where appends a list predicates to the PaperTypesMutation builder.
func (m *PaperTypesMutation) Where(ps ...predicate.PaperTypes) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaperTypesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaperTypesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaperTypes, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaperTypesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaperTypesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaperTypes).
func (m *PaperTypesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaperTypesMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.papercode != nil {
		fields = append(fields, papertypes.FieldPaperCode)
	}
	if m._PaperTypeDescription != nil {
		fields = append(fields, papertypes.FieldPaperTypeDescription)
	}
	if m._OrderNumber != nil {
		fields = append(fields, papertypes.FieldOrderNumber)
	}
	if m._SequenceNumber != nil {
		fields = append(fields, papertypes.FieldSequenceNumber)
	}
	if m._CreatedDate != nil {
		fields = append(fields, papertypes.FieldCreatedDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaperTypesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case papertypes.FieldPaperCode:
		return m.PaperCode()
	case papertypes.FieldPaperTypeDescription:
		return m.PaperTypeDescription()
	case papertypes.FieldOrderNumber:
		return m.OrderNumber()
	case papertypes.FieldSequenceNumber:
		return m.SequenceNumber()
	case papertypes.FieldCreatedDate:
		return m.CreatedDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaperTypesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case papertypes.FieldPaperCode:
		return m.OldPaperCode(ctx)
	case papertypes.FieldPaperTypeDescription:
		return m.OldPaperTypeDescription(ctx)
	case papertypes.FieldOrderNumber:
		return m.OldOrderNumber(ctx)
	case papertypes.FieldSequenceNumber:
		return m.OldSequenceNumber(ctx)
	case papertypes.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	}
	return nil, fmt.Errorf("unknown PaperTypes field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaperTypesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case papertypes.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperCode(v)
		return nil
	case papertypes.FieldPaperTypeDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperTypeDescription(v)
		return nil
	case papertypes.FieldOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNumber(v)
		return nil
	case papertypes.FieldSequenceNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceNumber(v)
		return nil
	case papertypes.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	}
	return fmt.Errorf("unknown PaperTypes field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaperTypesMutation) AddedFields() []string {
	var fields []string
	if m.add_SequenceNumber != nil {
		fields = append(fields, papertypes.FieldSequenceNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaperTypesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case papertypes.FieldSequenceNumber:
		return m.AddedSequenceNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaperTypesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case papertypes.FieldSequenceNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequenceNumber(v)
		return nil
	}
	return fmt.Errorf("unknown PaperTypes numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaperTypesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(papertypes.FieldPaperCode) {
		fields = append(fields, papertypes.FieldPaperCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaperTypesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaperTypesMutation) ClearField(name string) error {
	switch name {
	case papertypes.FieldPaperCode:
		m.ClearPaperCode()
		return nil
	}
	return fmt.Errorf("unknown PaperTypes nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaperTypesMutation) ResetField(name string) error {
	switch name {
	case papertypes.FieldPaperCode:
		m.ResetPaperCode()
		return nil
	case papertypes.FieldPaperTypeDescription:
		m.ResetPaperTypeDescription()
		return nil
	case papertypes.FieldOrderNumber:
		m.ResetOrderNumber()
		return nil
	case papertypes.FieldSequenceNumber:
		m.ResetSequenceNumber()
		return nil
	case papertypes.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	}
	return fmt.Errorf("unknown PaperTypes field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaperTypesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.papercode != nil {
		edges = append(edges, papertypes.EdgePapercode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaperTypesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case papertypes.EdgePapercode:
		if id := m.papercode; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaperTypesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaperTypesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaperTypesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpapercode {
		edges = append(edges, papertypes.EdgePapercode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaperTypesMutation) EdgeCleared(name string) bool {
	switch name {
	case papertypes.EdgePapercode:
		return m.clearedpapercode
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaperTypesMutation) ClearEdge(name string) error {
	switch name {
	case papertypes.EdgePapercode:
		m.ClearPapercode()
		return nil
	}
	return fmt.Errorf("unknown PaperTypes unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaperTypesMutation) ResetEdge(name string) error {
	switch name {
	case papertypes.EdgePapercode:
		m.ResetPapercode()
		return nil
	}
	return fmt.Errorf("unknown PaperTypes edge %s", name)
}

// RegionMasterMutation represents an operation that mutates the RegionMaster nodes in the graph.
type RegionMasterMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int32
	_RegionCode           *int32
	add_RegionCode        *int32
	_RegionOfficeId       *string
	_OfficeType           *string
	_RegionOfficeName     *string
	_ReportingOfficeType  *string
	_ReportingOfficeCode  *string
	_EmailID              *string
	_MobileNumber         *int32
	add_MobileNumber      *int32
	_CircleCode           *int32
	add_CircleCode        *int32
	clearedFields         map[string]struct{}
	circle_ref            map[int32]struct{}
	removedcircle_ref     map[int32]struct{}
	clearedcircle_ref     bool
	regions               map[int32]struct{}
	removedregions        map[int32]struct{}
	clearedregions        bool
	region_ref_ref        map[int32]struct{}
	removedregion_ref_ref map[int32]struct{}
	clearedregion_ref_ref bool
	done                  bool
	oldValue              func(context.Context) (*RegionMaster, error)
	predicates            []predicate.RegionMaster
}

var _ ent.Mutation = (*RegionMasterMutation)(nil)

// regionmasterOption allows management of the mutation configuration using functional options.
type regionmasterOption func(*RegionMasterMutation)

// newRegionMasterMutation creates new mutation for the RegionMaster entity.
func newRegionMasterMutation(c config, op Op, opts ...regionmasterOption) *RegionMasterMutation {
	m := &RegionMasterMutation{
		config:        c,
		op:            op,
		typ:           TypeRegionMaster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegionMasterID sets the ID field of the mutation.
func withRegionMasterID(id int32) regionmasterOption {
	return func(m *RegionMasterMutation) {
		var (
			err   error
			once  sync.Once
			value *RegionMaster
		)
		m.oldValue = func(ctx context.Context) (*RegionMaster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RegionMaster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegionMaster sets the old RegionMaster of the mutation.
func withRegionMaster(node *RegionMaster) regionmasterOption {
	return func(m *RegionMasterMutation) {
		m.oldValue = func(context.Context) (*RegionMaster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegionMasterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegionMasterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RegionMaster entities.
func (m *RegionMasterMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RegionMasterMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RegionMasterMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RegionMaster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRegionCode sets the "RegionCode" field.
func (m *RegionMasterMutation) SetRegionCode(i int32) {
	m._RegionCode = &i
	m.add_RegionCode = nil
}

// RegionCode returns the value of the "RegionCode" field in the mutation.
func (m *RegionMasterMutation) RegionCode() (r int32, exists bool) {
	v := m._RegionCode
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionCode returns the old "RegionCode" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldRegionCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionCode: %w", err)
	}
	return oldValue.RegionCode, nil
}

// AddRegionCode adds i to the "RegionCode" field.
func (m *RegionMasterMutation) AddRegionCode(i int32) {
	if m.add_RegionCode != nil {
		*m.add_RegionCode += i
	} else {
		m.add_RegionCode = &i
	}
}

// AddedRegionCode returns the value that was added to the "RegionCode" field in this mutation.
func (m *RegionMasterMutation) AddedRegionCode() (r int32, exists bool) {
	v := m.add_RegionCode
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegionCode resets all changes to the "RegionCode" field.
func (m *RegionMasterMutation) ResetRegionCode() {
	m._RegionCode = nil
	m.add_RegionCode = nil
}

// SetRegionOfficeId sets the "RegionOfficeId" field.
func (m *RegionMasterMutation) SetRegionOfficeId(s string) {
	m._RegionOfficeId = &s
}

// RegionOfficeId returns the value of the "RegionOfficeId" field in the mutation.
func (m *RegionMasterMutation) RegionOfficeId() (r string, exists bool) {
	v := m._RegionOfficeId
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionOfficeId returns the old "RegionOfficeId" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldRegionOfficeId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionOfficeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionOfficeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionOfficeId: %w", err)
	}
	return oldValue.RegionOfficeId, nil
}

// ResetRegionOfficeId resets all changes to the "RegionOfficeId" field.
func (m *RegionMasterMutation) ResetRegionOfficeId() {
	m._RegionOfficeId = nil
}

// SetOfficeType sets the "OfficeType" field.
func (m *RegionMasterMutation) SetOfficeType(s string) {
	m._OfficeType = &s
}

// OfficeType returns the value of the "OfficeType" field in the mutation.
func (m *RegionMasterMutation) OfficeType() (r string, exists bool) {
	v := m._OfficeType
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeType returns the old "OfficeType" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldOfficeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeType: %w", err)
	}
	return oldValue.OfficeType, nil
}

// ResetOfficeType resets all changes to the "OfficeType" field.
func (m *RegionMasterMutation) ResetOfficeType() {
	m._OfficeType = nil
}

// SetRegionOfficeName sets the "RegionOfficeName" field.
func (m *RegionMasterMutation) SetRegionOfficeName(s string) {
	m._RegionOfficeName = &s
}

// RegionOfficeName returns the value of the "RegionOfficeName" field in the mutation.
func (m *RegionMasterMutation) RegionOfficeName() (r string, exists bool) {
	v := m._RegionOfficeName
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionOfficeName returns the old "RegionOfficeName" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldRegionOfficeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionOfficeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionOfficeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionOfficeName: %w", err)
	}
	return oldValue.RegionOfficeName, nil
}

// ResetRegionOfficeName resets all changes to the "RegionOfficeName" field.
func (m *RegionMasterMutation) ResetRegionOfficeName() {
	m._RegionOfficeName = nil
}

// SetReportingOfficeType sets the "ReportingOfficeType" field.
func (m *RegionMasterMutation) SetReportingOfficeType(s string) {
	m._ReportingOfficeType = &s
}

// ReportingOfficeType returns the value of the "ReportingOfficeType" field in the mutation.
func (m *RegionMasterMutation) ReportingOfficeType() (r string, exists bool) {
	v := m._ReportingOfficeType
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingOfficeType returns the old "ReportingOfficeType" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldReportingOfficeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingOfficeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingOfficeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingOfficeType: %w", err)
	}
	return oldValue.ReportingOfficeType, nil
}

// ClearReportingOfficeType clears the value of the "ReportingOfficeType" field.
func (m *RegionMasterMutation) ClearReportingOfficeType() {
	m._ReportingOfficeType = nil
	m.clearedFields[regionmaster.FieldReportingOfficeType] = struct{}{}
}

// ReportingOfficeTypeCleared returns if the "ReportingOfficeType" field was cleared in this mutation.
func (m *RegionMasterMutation) ReportingOfficeTypeCleared() bool {
	_, ok := m.clearedFields[regionmaster.FieldReportingOfficeType]
	return ok
}

// ResetReportingOfficeType resets all changes to the "ReportingOfficeType" field.
func (m *RegionMasterMutation) ResetReportingOfficeType() {
	m._ReportingOfficeType = nil
	delete(m.clearedFields, regionmaster.FieldReportingOfficeType)
}

// SetReportingOfficeCode sets the "ReportingOfficeCode" field.
func (m *RegionMasterMutation) SetReportingOfficeCode(s string) {
	m._ReportingOfficeCode = &s
}

// ReportingOfficeCode returns the value of the "ReportingOfficeCode" field in the mutation.
func (m *RegionMasterMutation) ReportingOfficeCode() (r string, exists bool) {
	v := m._ReportingOfficeCode
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingOfficeCode returns the old "ReportingOfficeCode" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldReportingOfficeCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingOfficeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingOfficeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingOfficeCode: %w", err)
	}
	return oldValue.ReportingOfficeCode, nil
}

// ClearReportingOfficeCode clears the value of the "ReportingOfficeCode" field.
func (m *RegionMasterMutation) ClearReportingOfficeCode() {
	m._ReportingOfficeCode = nil
	m.clearedFields[regionmaster.FieldReportingOfficeCode] = struct{}{}
}

// ReportingOfficeCodeCleared returns if the "ReportingOfficeCode" field was cleared in this mutation.
func (m *RegionMasterMutation) ReportingOfficeCodeCleared() bool {
	_, ok := m.clearedFields[regionmaster.FieldReportingOfficeCode]
	return ok
}

// ResetReportingOfficeCode resets all changes to the "ReportingOfficeCode" field.
func (m *RegionMasterMutation) ResetReportingOfficeCode() {
	m._ReportingOfficeCode = nil
	delete(m.clearedFields, regionmaster.FieldReportingOfficeCode)
}

// SetEmailID sets the "EmailID" field.
func (m *RegionMasterMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *RegionMasterMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ClearEmailID clears the value of the "EmailID" field.
func (m *RegionMasterMutation) ClearEmailID() {
	m._EmailID = nil
	m.clearedFields[regionmaster.FieldEmailID] = struct{}{}
}

// EmailIDCleared returns if the "EmailID" field was cleared in this mutation.
func (m *RegionMasterMutation) EmailIDCleared() bool {
	_, ok := m.clearedFields[regionmaster.FieldEmailID]
	return ok
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *RegionMasterMutation) ResetEmailID() {
	m._EmailID = nil
	delete(m.clearedFields, regionmaster.FieldEmailID)
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *RegionMasterMutation) SetMobileNumber(i int32) {
	m._MobileNumber = &i
	m.add_MobileNumber = nil
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *RegionMasterMutation) MobileNumber() (r int32, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldMobileNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// AddMobileNumber adds i to the "MobileNumber" field.
func (m *RegionMasterMutation) AddMobileNumber(i int32) {
	if m.add_MobileNumber != nil {
		*m.add_MobileNumber += i
	} else {
		m.add_MobileNumber = &i
	}
}

// AddedMobileNumber returns the value that was added to the "MobileNumber" field in this mutation.
func (m *RegionMasterMutation) AddedMobileNumber() (r int32, exists bool) {
	v := m.add_MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearMobileNumber clears the value of the "MobileNumber" field.
func (m *RegionMasterMutation) ClearMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	m.clearedFields[regionmaster.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "MobileNumber" field was cleared in this mutation.
func (m *RegionMasterMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[regionmaster.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *RegionMasterMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	delete(m.clearedFields, regionmaster.FieldMobileNumber)
}

// SetCircleCode sets the "CircleCode" field.
func (m *RegionMasterMutation) SetCircleCode(i int32) {
	m._CircleCode = &i
	m.add_CircleCode = nil
}

// CircleCode returns the value of the "CircleCode" field in the mutation.
func (m *RegionMasterMutation) CircleCode() (r int32, exists bool) {
	v := m._CircleCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleCode returns the old "CircleCode" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldCircleCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleCode: %w", err)
	}
	return oldValue.CircleCode, nil
}

// AddCircleCode adds i to the "CircleCode" field.
func (m *RegionMasterMutation) AddCircleCode(i int32) {
	if m.add_CircleCode != nil {
		*m.add_CircleCode += i
	} else {
		m.add_CircleCode = &i
	}
}

// AddedCircleCode returns the value that was added to the "CircleCode" field in this mutation.
func (m *RegionMasterMutation) AddedCircleCode() (r int32, exists bool) {
	v := m.add_CircleCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearCircleCode clears the value of the "CircleCode" field.
func (m *RegionMasterMutation) ClearCircleCode() {
	m._CircleCode = nil
	m.add_CircleCode = nil
	m.clearedFields[regionmaster.FieldCircleCode] = struct{}{}
}

// CircleCodeCleared returns if the "CircleCode" field was cleared in this mutation.
func (m *RegionMasterMutation) CircleCodeCleared() bool {
	_, ok := m.clearedFields[regionmaster.FieldCircleCode]
	return ok
}

// ResetCircleCode resets all changes to the "CircleCode" field.
func (m *RegionMasterMutation) ResetCircleCode() {
	m._CircleCode = nil
	m.add_CircleCode = nil
	delete(m.clearedFields, regionmaster.FieldCircleCode)
}

// AddCircleRefIDs adds the "circle_ref" edge to the CircleMaster entity by ids.
func (m *RegionMasterMutation) AddCircleRefIDs(ids ...int32) {
	if m.circle_ref == nil {
		m.circle_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.circle_ref[ids[i]] = struct{}{}
	}
}

// ClearCircleRef clears the "circle_ref" edge to the CircleMaster entity.
func (m *RegionMasterMutation) ClearCircleRef() {
	m.clearedcircle_ref = true
}

// CircleRefCleared reports if the "circle_ref" edge to the CircleMaster entity was cleared.
func (m *RegionMasterMutation) CircleRefCleared() bool {
	return m.clearedcircle_ref
}

// RemoveCircleRefIDs removes the "circle_ref" edge to the CircleMaster entity by IDs.
func (m *RegionMasterMutation) RemoveCircleRefIDs(ids ...int32) {
	if m.removedcircle_ref == nil {
		m.removedcircle_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.circle_ref, ids[i])
		m.removedcircle_ref[ids[i]] = struct{}{}
	}
}

// RemovedCircleRef returns the removed IDs of the "circle_ref" edge to the CircleMaster entity.
func (m *RegionMasterMutation) RemovedCircleRefIDs() (ids []int32) {
	for id := range m.removedcircle_ref {
		ids = append(ids, id)
	}
	return
}

// CircleRefIDs returns the "circle_ref" edge IDs in the mutation.
func (m *RegionMasterMutation) CircleRefIDs() (ids []int32) {
	for id := range m.circle_ref {
		ids = append(ids, id)
	}
	return
}

// ResetCircleRef resets all changes to the "circle_ref" edge.
func (m *RegionMasterMutation) ResetCircleRef() {
	m.circle_ref = nil
	m.clearedcircle_ref = false
	m.removedcircle_ref = nil
}

// AddRegionIDs adds the "regions" edge to the DivisionMaster entity by ids.
func (m *RegionMasterMutation) AddRegionIDs(ids ...int32) {
	if m.regions == nil {
		m.regions = make(map[int32]struct{})
	}
	for i := range ids {
		m.regions[ids[i]] = struct{}{}
	}
}

// ClearRegions clears the "regions" edge to the DivisionMaster entity.
func (m *RegionMasterMutation) ClearRegions() {
	m.clearedregions = true
}

// RegionsCleared reports if the "regions" edge to the DivisionMaster entity was cleared.
func (m *RegionMasterMutation) RegionsCleared() bool {
	return m.clearedregions
}

// RemoveRegionIDs removes the "regions" edge to the DivisionMaster entity by IDs.
func (m *RegionMasterMutation) RemoveRegionIDs(ids ...int32) {
	if m.removedregions == nil {
		m.removedregions = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.regions, ids[i])
		m.removedregions[ids[i]] = struct{}{}
	}
}

// RemovedRegions returns the removed IDs of the "regions" edge to the DivisionMaster entity.
func (m *RegionMasterMutation) RemovedRegionsIDs() (ids []int32) {
	for id := range m.removedregions {
		ids = append(ids, id)
	}
	return
}

// RegionsIDs returns the "regions" edge IDs in the mutation.
func (m *RegionMasterMutation) RegionsIDs() (ids []int32) {
	for id := range m.regions {
		ids = append(ids, id)
	}
	return
}

// ResetRegions resets all changes to the "regions" edge.
func (m *RegionMasterMutation) ResetRegions() {
	m.regions = nil
	m.clearedregions = false
	m.removedregions = nil
}

// AddRegionRefRefIDs adds the "region_ref_ref" edge to the Facility entity by ids.
func (m *RegionMasterMutation) AddRegionRefRefIDs(ids ...int32) {
	if m.region_ref_ref == nil {
		m.region_ref_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.region_ref_ref[ids[i]] = struct{}{}
	}
}

// ClearRegionRefRef clears the "region_ref_ref" edge to the Facility entity.
func (m *RegionMasterMutation) ClearRegionRefRef() {
	m.clearedregion_ref_ref = true
}

// RegionRefRefCleared reports if the "region_ref_ref" edge to the Facility entity was cleared.
func (m *RegionMasterMutation) RegionRefRefCleared() bool {
	return m.clearedregion_ref_ref
}

// RemoveRegionRefRefIDs removes the "region_ref_ref" edge to the Facility entity by IDs.
func (m *RegionMasterMutation) RemoveRegionRefRefIDs(ids ...int32) {
	if m.removedregion_ref_ref == nil {
		m.removedregion_ref_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.region_ref_ref, ids[i])
		m.removedregion_ref_ref[ids[i]] = struct{}{}
	}
}

// RemovedRegionRefRef returns the removed IDs of the "region_ref_ref" edge to the Facility entity.
func (m *RegionMasterMutation) RemovedRegionRefRefIDs() (ids []int32) {
	for id := range m.removedregion_ref_ref {
		ids = append(ids, id)
	}
	return
}

// RegionRefRefIDs returns the "region_ref_ref" edge IDs in the mutation.
func (m *RegionMasterMutation) RegionRefRefIDs() (ids []int32) {
	for id := range m.region_ref_ref {
		ids = append(ids, id)
	}
	return
}

// ResetRegionRefRef resets all changes to the "region_ref_ref" edge.
func (m *RegionMasterMutation) ResetRegionRefRef() {
	m.region_ref_ref = nil
	m.clearedregion_ref_ref = false
	m.removedregion_ref_ref = nil
}

// Where appends a list predicates to the RegionMasterMutation builder.
func (m *RegionMasterMutation) Where(ps ...predicate.RegionMaster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RegionMasterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RegionMasterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RegionMaster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RegionMasterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RegionMasterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RegionMaster).
func (m *RegionMasterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RegionMasterMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._RegionCode != nil {
		fields = append(fields, regionmaster.FieldRegionCode)
	}
	if m._RegionOfficeId != nil {
		fields = append(fields, regionmaster.FieldRegionOfficeId)
	}
	if m._OfficeType != nil {
		fields = append(fields, regionmaster.FieldOfficeType)
	}
	if m._RegionOfficeName != nil {
		fields = append(fields, regionmaster.FieldRegionOfficeName)
	}
	if m._ReportingOfficeType != nil {
		fields = append(fields, regionmaster.FieldReportingOfficeType)
	}
	if m._ReportingOfficeCode != nil {
		fields = append(fields, regionmaster.FieldReportingOfficeCode)
	}
	if m._EmailID != nil {
		fields = append(fields, regionmaster.FieldEmailID)
	}
	if m._MobileNumber != nil {
		fields = append(fields, regionmaster.FieldMobileNumber)
	}
	if m._CircleCode != nil {
		fields = append(fields, regionmaster.FieldCircleCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RegionMasterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case regionmaster.FieldRegionCode:
		return m.RegionCode()
	case regionmaster.FieldRegionOfficeId:
		return m.RegionOfficeId()
	case regionmaster.FieldOfficeType:
		return m.OfficeType()
	case regionmaster.FieldRegionOfficeName:
		return m.RegionOfficeName()
	case regionmaster.FieldReportingOfficeType:
		return m.ReportingOfficeType()
	case regionmaster.FieldReportingOfficeCode:
		return m.ReportingOfficeCode()
	case regionmaster.FieldEmailID:
		return m.EmailID()
	case regionmaster.FieldMobileNumber:
		return m.MobileNumber()
	case regionmaster.FieldCircleCode:
		return m.CircleCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RegionMasterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case regionmaster.FieldRegionCode:
		return m.OldRegionCode(ctx)
	case regionmaster.FieldRegionOfficeId:
		return m.OldRegionOfficeId(ctx)
	case regionmaster.FieldOfficeType:
		return m.OldOfficeType(ctx)
	case regionmaster.FieldRegionOfficeName:
		return m.OldRegionOfficeName(ctx)
	case regionmaster.FieldReportingOfficeType:
		return m.OldReportingOfficeType(ctx)
	case regionmaster.FieldReportingOfficeCode:
		return m.OldReportingOfficeCode(ctx)
	case regionmaster.FieldEmailID:
		return m.OldEmailID(ctx)
	case regionmaster.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case regionmaster.FieldCircleCode:
		return m.OldCircleCode(ctx)
	}
	return nil, fmt.Errorf("unknown RegionMaster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMasterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case regionmaster.FieldRegionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionCode(v)
		return nil
	case regionmaster.FieldRegionOfficeId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionOfficeId(v)
		return nil
	case regionmaster.FieldOfficeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeType(v)
		return nil
	case regionmaster.FieldRegionOfficeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionOfficeName(v)
		return nil
	case regionmaster.FieldReportingOfficeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingOfficeType(v)
		return nil
	case regionmaster.FieldReportingOfficeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingOfficeCode(v)
		return nil
	case regionmaster.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case regionmaster.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case regionmaster.FieldCircleCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleCode(v)
		return nil
	}
	return fmt.Errorf("unknown RegionMaster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RegionMasterMutation) AddedFields() []string {
	var fields []string
	if m.add_RegionCode != nil {
		fields = append(fields, regionmaster.FieldRegionCode)
	}
	if m.add_MobileNumber != nil {
		fields = append(fields, regionmaster.FieldMobileNumber)
	}
	if m.add_CircleCode != nil {
		fields = append(fields, regionmaster.FieldCircleCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RegionMasterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case regionmaster.FieldRegionCode:
		return m.AddedRegionCode()
	case regionmaster.FieldMobileNumber:
		return m.AddedMobileNumber()
	case regionmaster.FieldCircleCode:
		return m.AddedCircleCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMasterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case regionmaster.FieldRegionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegionCode(v)
		return nil
	case regionmaster.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMobileNumber(v)
		return nil
	case regionmaster.FieldCircleCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCircleCode(v)
		return nil
	}
	return fmt.Errorf("unknown RegionMaster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RegionMasterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(regionmaster.FieldReportingOfficeType) {
		fields = append(fields, regionmaster.FieldReportingOfficeType)
	}
	if m.FieldCleared(regionmaster.FieldReportingOfficeCode) {
		fields = append(fields, regionmaster.FieldReportingOfficeCode)
	}
	if m.FieldCleared(regionmaster.FieldEmailID) {
		fields = append(fields, regionmaster.FieldEmailID)
	}
	if m.FieldCleared(regionmaster.FieldMobileNumber) {
		fields = append(fields, regionmaster.FieldMobileNumber)
	}
	if m.FieldCleared(regionmaster.FieldCircleCode) {
		fields = append(fields, regionmaster.FieldCircleCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RegionMasterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegionMasterMutation) ClearField(name string) error {
	switch name {
	case regionmaster.FieldReportingOfficeType:
		m.ClearReportingOfficeType()
		return nil
	case regionmaster.FieldReportingOfficeCode:
		m.ClearReportingOfficeCode()
		return nil
	case regionmaster.FieldEmailID:
		m.ClearEmailID()
		return nil
	case regionmaster.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	case regionmaster.FieldCircleCode:
		m.ClearCircleCode()
		return nil
	}
	return fmt.Errorf("unknown RegionMaster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RegionMasterMutation) ResetField(name string) error {
	switch name {
	case regionmaster.FieldRegionCode:
		m.ResetRegionCode()
		return nil
	case regionmaster.FieldRegionOfficeId:
		m.ResetRegionOfficeId()
		return nil
	case regionmaster.FieldOfficeType:
		m.ResetOfficeType()
		return nil
	case regionmaster.FieldRegionOfficeName:
		m.ResetRegionOfficeName()
		return nil
	case regionmaster.FieldReportingOfficeType:
		m.ResetReportingOfficeType()
		return nil
	case regionmaster.FieldReportingOfficeCode:
		m.ResetReportingOfficeCode()
		return nil
	case regionmaster.FieldEmailID:
		m.ResetEmailID()
		return nil
	case regionmaster.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case regionmaster.FieldCircleCode:
		m.ResetCircleCode()
		return nil
	}
	return fmt.Errorf("unknown RegionMaster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RegionMasterMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.circle_ref != nil {
		edges = append(edges, regionmaster.EdgeCircleRef)
	}
	if m.regions != nil {
		edges = append(edges, regionmaster.EdgeRegions)
	}
	if m.region_ref_ref != nil {
		edges = append(edges, regionmaster.EdgeRegionRefRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RegionMasterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case regionmaster.EdgeCircleRef:
		ids := make([]ent.Value, 0, len(m.circle_ref))
		for id := range m.circle_ref {
			ids = append(ids, id)
		}
		return ids
	case regionmaster.EdgeRegions:
		ids := make([]ent.Value, 0, len(m.regions))
		for id := range m.regions {
			ids = append(ids, id)
		}
		return ids
	case regionmaster.EdgeRegionRefRef:
		ids := make([]ent.Value, 0, len(m.region_ref_ref))
		for id := range m.region_ref_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RegionMasterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcircle_ref != nil {
		edges = append(edges, regionmaster.EdgeCircleRef)
	}
	if m.removedregions != nil {
		edges = append(edges, regionmaster.EdgeRegions)
	}
	if m.removedregion_ref_ref != nil {
		edges = append(edges, regionmaster.EdgeRegionRefRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RegionMasterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case regionmaster.EdgeCircleRef:
		ids := make([]ent.Value, 0, len(m.removedcircle_ref))
		for id := range m.removedcircle_ref {
			ids = append(ids, id)
		}
		return ids
	case regionmaster.EdgeRegions:
		ids := make([]ent.Value, 0, len(m.removedregions))
		for id := range m.removedregions {
			ids = append(ids, id)
		}
		return ids
	case regionmaster.EdgeRegionRefRef:
		ids := make([]ent.Value, 0, len(m.removedregion_ref_ref))
		for id := range m.removedregion_ref_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RegionMasterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcircle_ref {
		edges = append(edges, regionmaster.EdgeCircleRef)
	}
	if m.clearedregions {
		edges = append(edges, regionmaster.EdgeRegions)
	}
	if m.clearedregion_ref_ref {
		edges = append(edges, regionmaster.EdgeRegionRefRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RegionMasterMutation) EdgeCleared(name string) bool {
	switch name {
	case regionmaster.EdgeCircleRef:
		return m.clearedcircle_ref
	case regionmaster.EdgeRegions:
		return m.clearedregions
	case regionmaster.EdgeRegionRefRef:
		return m.clearedregion_ref_ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RegionMasterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown RegionMaster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RegionMasterMutation) ResetEdge(name string) error {
	switch name {
	case regionmaster.EdgeCircleRef:
		m.ResetCircleRef()
		return nil
	case regionmaster.EdgeRegions:
		m.ResetRegions()
		return nil
	case regionmaster.EdgeRegionRefRef:
		m.ResetRegionRefRef()
		return nil
	}
	return fmt.Errorf("unknown RegionMaster edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_EmployeedID         *string
	_IDVerified          *bool
	_IDRemStatus         *bool
	_IDRemarks           *string
	_EmployeedName       *string
	nameVerified         *bool
	nameRemStatus        *bool
	nameRemarks          *string
	_DOB                 *time.Time
	_DOBVerified         *bool
	_DOBRemStatus        *bool
	_DOBRemarks          *string
	_Gender              *user.Gender
	genderVerified       *bool
	genderRemStatus      *bool
	genderRemarks        *string
	_Cadreid             *int32
	add_Cadreid          *int32
	cadreidVerified      *bool
	cadreidRemStatus     *bool
	cadreidRemarks       *string
	_OfficeID            *int32
	add_OfficeID         *int32
	officeIDVerified     *bool
	officeIDRemStatus    *bool
	officeIDRemarks      *string
	_PH                  *bool
	_PHVerified          *bool
	_PHRemStatus         *bool
	_PHRemarks           *string
	_PHDetails           *string
	_PHDetailsVerified   *bool
	_PHDetailsRemStatus  *bool
	_PHDetailsRemarks    *string
	_APSWorking          *bool
	_APSWorkingVerified  *bool
	_APSWorkingRemStatus *bool
	_APSWorkingRemarks   *string
	profilestatus        *bool
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeedID sets the "EmployeedID" field.
func (m *UserMutation) SetEmployeedID(s string) {
	m._EmployeedID = &s
}

// EmployeedID returns the value of the "EmployeedID" field in the mutation.
func (m *UserMutation) EmployeedID() (r string, exists bool) {
	v := m._EmployeedID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeedID returns the old "EmployeedID" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmployeedID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeedID: %w", err)
	}
	return oldValue.EmployeedID, nil
}

// ResetEmployeedID resets all changes to the "EmployeedID" field.
func (m *UserMutation) ResetEmployeedID() {
	m._EmployeedID = nil
}

// SetIDVerified sets the "IDVerified" field.
func (m *UserMutation) SetIDVerified(b bool) {
	m._IDVerified = &b
}

// IDVerified returns the value of the "IDVerified" field in the mutation.
func (m *UserMutation) IDVerified() (r bool, exists bool) {
	v := m._IDVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldIDVerified returns the old "IDVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIDVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDVerified: %w", err)
	}
	return oldValue.IDVerified, nil
}

// ResetIDVerified resets all changes to the "IDVerified" field.
func (m *UserMutation) ResetIDVerified() {
	m._IDVerified = nil
}

// SetIDRemStatus sets the "IDRemStatus" field.
func (m *UserMutation) SetIDRemStatus(b bool) {
	m._IDRemStatus = &b
}

// IDRemStatus returns the value of the "IDRemStatus" field in the mutation.
func (m *UserMutation) IDRemStatus() (r bool, exists bool) {
	v := m._IDRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldIDRemStatus returns the old "IDRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIDRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDRemStatus: %w", err)
	}
	return oldValue.IDRemStatus, nil
}

// ResetIDRemStatus resets all changes to the "IDRemStatus" field.
func (m *UserMutation) ResetIDRemStatus() {
	m._IDRemStatus = nil
}

// SetIDRemarks sets the "IDRemarks" field.
func (m *UserMutation) SetIDRemarks(s string) {
	m._IDRemarks = &s
}

// IDRemarks returns the value of the "IDRemarks" field in the mutation.
func (m *UserMutation) IDRemarks() (r string, exists bool) {
	v := m._IDRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldIDRemarks returns the old "IDRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIDRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDRemarks: %w", err)
	}
	return oldValue.IDRemarks, nil
}

// ResetIDRemarks resets all changes to the "IDRemarks" field.
func (m *UserMutation) ResetIDRemarks() {
	m._IDRemarks = nil
}

// SetEmployeedName sets the "EmployeedName" field.
func (m *UserMutation) SetEmployeedName(s string) {
	m._EmployeedName = &s
}

// EmployeedName returns the value of the "EmployeedName" field in the mutation.
func (m *UserMutation) EmployeedName() (r string, exists bool) {
	v := m._EmployeedName
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeedName returns the old "EmployeedName" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmployeedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeedName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeedName: %w", err)
	}
	return oldValue.EmployeedName, nil
}

// ResetEmployeedName resets all changes to the "EmployeedName" field.
func (m *UserMutation) ResetEmployeedName() {
	m._EmployeedName = nil
}

// SetNameVerified sets the "nameVerified" field.
func (m *UserMutation) SetNameVerified(b bool) {
	m.nameVerified = &b
}

// NameVerified returns the value of the "nameVerified" field in the mutation.
func (m *UserMutation) NameVerified() (r bool, exists bool) {
	v := m.nameVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldNameVerified returns the old "nameVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNameVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameVerified: %w", err)
	}
	return oldValue.NameVerified, nil
}

// ResetNameVerified resets all changes to the "nameVerified" field.
func (m *UserMutation) ResetNameVerified() {
	m.nameVerified = nil
}

// SetNameRemStatus sets the "nameRemStatus" field.
func (m *UserMutation) SetNameRemStatus(b bool) {
	m.nameRemStatus = &b
}

// NameRemStatus returns the value of the "nameRemStatus" field in the mutation.
func (m *UserMutation) NameRemStatus() (r bool, exists bool) {
	v := m.nameRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldNameRemStatus returns the old "nameRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNameRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameRemStatus: %w", err)
	}
	return oldValue.NameRemStatus, nil
}

// ResetNameRemStatus resets all changes to the "nameRemStatus" field.
func (m *UserMutation) ResetNameRemStatus() {
	m.nameRemStatus = nil
}

// SetNameRemarks sets the "nameRemarks" field.
func (m *UserMutation) SetNameRemarks(s string) {
	m.nameRemarks = &s
}

// NameRemarks returns the value of the "nameRemarks" field in the mutation.
func (m *UserMutation) NameRemarks() (r string, exists bool) {
	v := m.nameRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldNameRemarks returns the old "nameRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNameRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameRemarks: %w", err)
	}
	return oldValue.NameRemarks, nil
}

// ResetNameRemarks resets all changes to the "nameRemarks" field.
func (m *UserMutation) ResetNameRemarks() {
	m.nameRemarks = nil
}

// SetDOB sets the "DOB" field.
func (m *UserMutation) SetDOB(t time.Time) {
	m._DOB = &t
}

// DOB returns the value of the "DOB" field in the mutation.
func (m *UserMutation) DOB() (r time.Time, exists bool) {
	v := m._DOB
	if v == nil {
		return
	}
	return *v, true
}

// OldDOB returns the old "DOB" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDOB(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOB: %w", err)
	}
	return oldValue.DOB, nil
}

// ResetDOB resets all changes to the "DOB" field.
func (m *UserMutation) ResetDOB() {
	m._DOB = nil
}

// SetDOBVerified sets the "DOBVerified" field.
func (m *UserMutation) SetDOBVerified(b bool) {
	m._DOBVerified = &b
}

// DOBVerified returns the value of the "DOBVerified" field in the mutation.
func (m *UserMutation) DOBVerified() (r bool, exists bool) {
	v := m._DOBVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldDOBVerified returns the old "DOBVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDOBVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOBVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOBVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOBVerified: %w", err)
	}
	return oldValue.DOBVerified, nil
}

// ResetDOBVerified resets all changes to the "DOBVerified" field.
func (m *UserMutation) ResetDOBVerified() {
	m._DOBVerified = nil
}

// SetDOBRemStatus sets the "DOBRemStatus" field.
func (m *UserMutation) SetDOBRemStatus(b bool) {
	m._DOBRemStatus = &b
}

// DOBRemStatus returns the value of the "DOBRemStatus" field in the mutation.
func (m *UserMutation) DOBRemStatus() (r bool, exists bool) {
	v := m._DOBRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldDOBRemStatus returns the old "DOBRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDOBRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOBRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOBRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOBRemStatus: %w", err)
	}
	return oldValue.DOBRemStatus, nil
}

// ResetDOBRemStatus resets all changes to the "DOBRemStatus" field.
func (m *UserMutation) ResetDOBRemStatus() {
	m._DOBRemStatus = nil
}

// SetDOBRemarks sets the "DOBRemarks" field.
func (m *UserMutation) SetDOBRemarks(s string) {
	m._DOBRemarks = &s
}

// DOBRemarks returns the value of the "DOBRemarks" field in the mutation.
func (m *UserMutation) DOBRemarks() (r string, exists bool) {
	v := m._DOBRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldDOBRemarks returns the old "DOBRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDOBRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOBRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOBRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOBRemarks: %w", err)
	}
	return oldValue.DOBRemarks, nil
}

// ResetDOBRemarks resets all changes to the "DOBRemarks" field.
func (m *UserMutation) ResetDOBRemarks() {
	m._DOBRemarks = nil
}

// SetGender sets the "Gender" field.
func (m *UserMutation) SetGender(u user.Gender) {
	m._Gender = &u
}

// Gender returns the value of the "Gender" field in the mutation.
func (m *UserMutation) Gender() (r user.Gender, exists bool) {
	v := m._Gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "Gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v user.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "Gender" field.
func (m *UserMutation) ResetGender() {
	m._Gender = nil
}

// SetGenderVerified sets the "genderVerified" field.
func (m *UserMutation) SetGenderVerified(b bool) {
	m.genderVerified = &b
}

// GenderVerified returns the value of the "genderVerified" field in the mutation.
func (m *UserMutation) GenderVerified() (r bool, exists bool) {
	v := m.genderVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderVerified returns the old "genderVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGenderVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenderVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenderVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderVerified: %w", err)
	}
	return oldValue.GenderVerified, nil
}

// ResetGenderVerified resets all changes to the "genderVerified" field.
func (m *UserMutation) ResetGenderVerified() {
	m.genderVerified = nil
}

// SetGenderRemStatus sets the "genderRemStatus" field.
func (m *UserMutation) SetGenderRemStatus(b bool) {
	m.genderRemStatus = &b
}

// GenderRemStatus returns the value of the "genderRemStatus" field in the mutation.
func (m *UserMutation) GenderRemStatus() (r bool, exists bool) {
	v := m.genderRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderRemStatus returns the old "genderRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGenderRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenderRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenderRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderRemStatus: %w", err)
	}
	return oldValue.GenderRemStatus, nil
}

// ResetGenderRemStatus resets all changes to the "genderRemStatus" field.
func (m *UserMutation) ResetGenderRemStatus() {
	m.genderRemStatus = nil
}

// SetGenderRemarks sets the "genderRemarks" field.
func (m *UserMutation) SetGenderRemarks(s string) {
	m.genderRemarks = &s
}

// GenderRemarks returns the value of the "genderRemarks" field in the mutation.
func (m *UserMutation) GenderRemarks() (r string, exists bool) {
	v := m.genderRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderRemarks returns the old "genderRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGenderRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenderRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenderRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderRemarks: %w", err)
	}
	return oldValue.GenderRemarks, nil
}

// ResetGenderRemarks resets all changes to the "genderRemarks" field.
func (m *UserMutation) ResetGenderRemarks() {
	m.genderRemarks = nil
}

// SetCadreid sets the "Cadreid" field.
func (m *UserMutation) SetCadreid(i int32) {
	m._Cadreid = &i
	m.add_Cadreid = nil
}

// Cadreid returns the value of the "Cadreid" field in the mutation.
func (m *UserMutation) Cadreid() (r int32, exists bool) {
	v := m._Cadreid
	if v == nil {
		return
	}
	return *v, true
}

// OldCadreid returns the old "Cadreid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCadreid(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadreid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadreid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadreid: %w", err)
	}
	return oldValue.Cadreid, nil
}

// AddCadreid adds i to the "Cadreid" field.
func (m *UserMutation) AddCadreid(i int32) {
	if m.add_Cadreid != nil {
		*m.add_Cadreid += i
	} else {
		m.add_Cadreid = &i
	}
}

// AddedCadreid returns the value that was added to the "Cadreid" field in this mutation.
func (m *UserMutation) AddedCadreid() (r int32, exists bool) {
	v := m.add_Cadreid
	if v == nil {
		return
	}
	return *v, true
}

// ResetCadreid resets all changes to the "Cadreid" field.
func (m *UserMutation) ResetCadreid() {
	m._Cadreid = nil
	m.add_Cadreid = nil
}

// SetCadreidVerified sets the "cadreidVerified" field.
func (m *UserMutation) SetCadreidVerified(b bool) {
	m.cadreidVerified = &b
}

// CadreidVerified returns the value of the "cadreidVerified" field in the mutation.
func (m *UserMutation) CadreidVerified() (r bool, exists bool) {
	v := m.cadreidVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldCadreidVerified returns the old "cadreidVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCadreidVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadreidVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadreidVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadreidVerified: %w", err)
	}
	return oldValue.CadreidVerified, nil
}

// ResetCadreidVerified resets all changes to the "cadreidVerified" field.
func (m *UserMutation) ResetCadreidVerified() {
	m.cadreidVerified = nil
}

// SetCadreidRemStatus sets the "cadreidRemStatus" field.
func (m *UserMutation) SetCadreidRemStatus(b bool) {
	m.cadreidRemStatus = &b
}

// CadreidRemStatus returns the value of the "cadreidRemStatus" field in the mutation.
func (m *UserMutation) CadreidRemStatus() (r bool, exists bool) {
	v := m.cadreidRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldCadreidRemStatus returns the old "cadreidRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCadreidRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadreidRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadreidRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadreidRemStatus: %w", err)
	}
	return oldValue.CadreidRemStatus, nil
}

// ResetCadreidRemStatus resets all changes to the "cadreidRemStatus" field.
func (m *UserMutation) ResetCadreidRemStatus() {
	m.cadreidRemStatus = nil
}

// SetCadreidRemarks sets the "cadreidRemarks" field.
func (m *UserMutation) SetCadreidRemarks(s string) {
	m.cadreidRemarks = &s
}

// CadreidRemarks returns the value of the "cadreidRemarks" field in the mutation.
func (m *UserMutation) CadreidRemarks() (r string, exists bool) {
	v := m.cadreidRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldCadreidRemarks returns the old "cadreidRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCadreidRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadreidRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadreidRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadreidRemarks: %w", err)
	}
	return oldValue.CadreidRemarks, nil
}

// ResetCadreidRemarks resets all changes to the "cadreidRemarks" field.
func (m *UserMutation) ResetCadreidRemarks() {
	m.cadreidRemarks = nil
}

// SetOfficeID sets the "OfficeID" field.
func (m *UserMutation) SetOfficeID(i int32) {
	m._OfficeID = &i
	m.add_OfficeID = nil
}

// OfficeID returns the value of the "OfficeID" field in the mutation.
func (m *UserMutation) OfficeID() (r int32, exists bool) {
	v := m._OfficeID
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeID returns the old "OfficeID" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOfficeID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeID: %w", err)
	}
	return oldValue.OfficeID, nil
}

// AddOfficeID adds i to the "OfficeID" field.
func (m *UserMutation) AddOfficeID(i int32) {
	if m.add_OfficeID != nil {
		*m.add_OfficeID += i
	} else {
		m.add_OfficeID = &i
	}
}

// AddedOfficeID returns the value that was added to the "OfficeID" field in this mutation.
func (m *UserMutation) AddedOfficeID() (r int32, exists bool) {
	v := m.add_OfficeID
	if v == nil {
		return
	}
	return *v, true
}

// ResetOfficeID resets all changes to the "OfficeID" field.
func (m *UserMutation) ResetOfficeID() {
	m._OfficeID = nil
	m.add_OfficeID = nil
}

// SetOfficeIDVerified sets the "officeIDVerified" field.
func (m *UserMutation) SetOfficeIDVerified(b bool) {
	m.officeIDVerified = &b
}

// OfficeIDVerified returns the value of the "officeIDVerified" field in the mutation.
func (m *UserMutation) OfficeIDVerified() (r bool, exists bool) {
	v := m.officeIDVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeIDVerified returns the old "officeIDVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOfficeIDVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeIDVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeIDVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeIDVerified: %w", err)
	}
	return oldValue.OfficeIDVerified, nil
}

// ResetOfficeIDVerified resets all changes to the "officeIDVerified" field.
func (m *UserMutation) ResetOfficeIDVerified() {
	m.officeIDVerified = nil
}

// SetOfficeIDRemStatus sets the "officeIDRemStatus" field.
func (m *UserMutation) SetOfficeIDRemStatus(b bool) {
	m.officeIDRemStatus = &b
}

// OfficeIDRemStatus returns the value of the "officeIDRemStatus" field in the mutation.
func (m *UserMutation) OfficeIDRemStatus() (r bool, exists bool) {
	v := m.officeIDRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeIDRemStatus returns the old "officeIDRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOfficeIDRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeIDRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeIDRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeIDRemStatus: %w", err)
	}
	return oldValue.OfficeIDRemStatus, nil
}

// ResetOfficeIDRemStatus resets all changes to the "officeIDRemStatus" field.
func (m *UserMutation) ResetOfficeIDRemStatus() {
	m.officeIDRemStatus = nil
}

// SetOfficeIDRemarks sets the "officeIDRemarks" field.
func (m *UserMutation) SetOfficeIDRemarks(s string) {
	m.officeIDRemarks = &s
}

// OfficeIDRemarks returns the value of the "officeIDRemarks" field in the mutation.
func (m *UserMutation) OfficeIDRemarks() (r string, exists bool) {
	v := m.officeIDRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeIDRemarks returns the old "officeIDRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOfficeIDRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeIDRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeIDRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeIDRemarks: %w", err)
	}
	return oldValue.OfficeIDRemarks, nil
}

// ResetOfficeIDRemarks resets all changes to the "officeIDRemarks" field.
func (m *UserMutation) ResetOfficeIDRemarks() {
	m.officeIDRemarks = nil
}

// SetPH sets the "PH" field.
func (m *UserMutation) SetPH(b bool) {
	m._PH = &b
}

// PH returns the value of the "PH" field in the mutation.
func (m *UserMutation) PH() (r bool, exists bool) {
	v := m._PH
	if v == nil {
		return
	}
	return *v, true
}

// OldPH returns the old "PH" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPH(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPH: %w", err)
	}
	return oldValue.PH, nil
}

// ResetPH resets all changes to the "PH" field.
func (m *UserMutation) ResetPH() {
	m._PH = nil
}

// SetPHVerified sets the "PHVerified" field.
func (m *UserMutation) SetPHVerified(b bool) {
	m._PHVerified = &b
}

// PHVerified returns the value of the "PHVerified" field in the mutation.
func (m *UserMutation) PHVerified() (r bool, exists bool) {
	v := m._PHVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldPHVerified returns the old "PHVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPHVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPHVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPHVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHVerified: %w", err)
	}
	return oldValue.PHVerified, nil
}

// ResetPHVerified resets all changes to the "PHVerified" field.
func (m *UserMutation) ResetPHVerified() {
	m._PHVerified = nil
}

// SetPHRemStatus sets the "PHRemStatus" field.
func (m *UserMutation) SetPHRemStatus(b bool) {
	m._PHRemStatus = &b
}

// PHRemStatus returns the value of the "PHRemStatus" field in the mutation.
func (m *UserMutation) PHRemStatus() (r bool, exists bool) {
	v := m._PHRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldPHRemStatus returns the old "PHRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPHRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPHRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPHRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHRemStatus: %w", err)
	}
	return oldValue.PHRemStatus, nil
}

// ResetPHRemStatus resets all changes to the "PHRemStatus" field.
func (m *UserMutation) ResetPHRemStatus() {
	m._PHRemStatus = nil
}

// SetPHRemarks sets the "PHRemarks" field.
func (m *UserMutation) SetPHRemarks(s string) {
	m._PHRemarks = &s
}

// PHRemarks returns the value of the "PHRemarks" field in the mutation.
func (m *UserMutation) PHRemarks() (r string, exists bool) {
	v := m._PHRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldPHRemarks returns the old "PHRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPHRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPHRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPHRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHRemarks: %w", err)
	}
	return oldValue.PHRemarks, nil
}

// ResetPHRemarks resets all changes to the "PHRemarks" field.
func (m *UserMutation) ResetPHRemarks() {
	m._PHRemarks = nil
}

// SetPHDetails sets the "PHDetails" field.
func (m *UserMutation) SetPHDetails(s string) {
	m._PHDetails = &s
}

// PHDetails returns the value of the "PHDetails" field in the mutation.
func (m *UserMutation) PHDetails() (r string, exists bool) {
	v := m._PHDetails
	if v == nil {
		return
	}
	return *v, true
}

// OldPHDetails returns the old "PHDetails" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPHDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPHDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPHDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHDetails: %w", err)
	}
	return oldValue.PHDetails, nil
}

// ClearPHDetails clears the value of the "PHDetails" field.
func (m *UserMutation) ClearPHDetails() {
	m._PHDetails = nil
	m.clearedFields[user.FieldPHDetails] = struct{}{}
}

// PHDetailsCleared returns if the "PHDetails" field was cleared in this mutation.
func (m *UserMutation) PHDetailsCleared() bool {
	_, ok := m.clearedFields[user.FieldPHDetails]
	return ok
}

// ResetPHDetails resets all changes to the "PHDetails" field.
func (m *UserMutation) ResetPHDetails() {
	m._PHDetails = nil
	delete(m.clearedFields, user.FieldPHDetails)
}

// SetPHDetailsVerified sets the "PHDetailsVerified" field.
func (m *UserMutation) SetPHDetailsVerified(b bool) {
	m._PHDetailsVerified = &b
}

// PHDetailsVerified returns the value of the "PHDetailsVerified" field in the mutation.
func (m *UserMutation) PHDetailsVerified() (r bool, exists bool) {
	v := m._PHDetailsVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldPHDetailsVerified returns the old "PHDetailsVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPHDetailsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPHDetailsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPHDetailsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHDetailsVerified: %w", err)
	}
	return oldValue.PHDetailsVerified, nil
}

// ResetPHDetailsVerified resets all changes to the "PHDetailsVerified" field.
func (m *UserMutation) ResetPHDetailsVerified() {
	m._PHDetailsVerified = nil
}

// SetPHDetailsRemStatus sets the "PHDetailsRemStatus" field.
func (m *UserMutation) SetPHDetailsRemStatus(b bool) {
	m._PHDetailsRemStatus = &b
}

// PHDetailsRemStatus returns the value of the "PHDetailsRemStatus" field in the mutation.
func (m *UserMutation) PHDetailsRemStatus() (r bool, exists bool) {
	v := m._PHDetailsRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldPHDetailsRemStatus returns the old "PHDetailsRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPHDetailsRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPHDetailsRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPHDetailsRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHDetailsRemStatus: %w", err)
	}
	return oldValue.PHDetailsRemStatus, nil
}

// ResetPHDetailsRemStatus resets all changes to the "PHDetailsRemStatus" field.
func (m *UserMutation) ResetPHDetailsRemStatus() {
	m._PHDetailsRemStatus = nil
}

// SetPHDetailsRemarks sets the "PHDetailsRemarks" field.
func (m *UserMutation) SetPHDetailsRemarks(s string) {
	m._PHDetailsRemarks = &s
}

// PHDetailsRemarks returns the value of the "PHDetailsRemarks" field in the mutation.
func (m *UserMutation) PHDetailsRemarks() (r string, exists bool) {
	v := m._PHDetailsRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldPHDetailsRemarks returns the old "PHDetailsRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPHDetailsRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPHDetailsRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPHDetailsRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHDetailsRemarks: %w", err)
	}
	return oldValue.PHDetailsRemarks, nil
}

// ResetPHDetailsRemarks resets all changes to the "PHDetailsRemarks" field.
func (m *UserMutation) ResetPHDetailsRemarks() {
	m._PHDetailsRemarks = nil
}

// SetAPSWorking sets the "APSWorking" field.
func (m *UserMutation) SetAPSWorking(b bool) {
	m._APSWorking = &b
}

// APSWorking returns the value of the "APSWorking" field in the mutation.
func (m *UserMutation) APSWorking() (r bool, exists bool) {
	v := m._APSWorking
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorking returns the old "APSWorking" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAPSWorking(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorking is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorking requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorking: %w", err)
	}
	return oldValue.APSWorking, nil
}

// ResetAPSWorking resets all changes to the "APSWorking" field.
func (m *UserMutation) ResetAPSWorking() {
	m._APSWorking = nil
}

// SetAPSWorkingVerified sets the "APSWorkingVerified" field.
func (m *UserMutation) SetAPSWorkingVerified(b bool) {
	m._APSWorkingVerified = &b
}

// APSWorkingVerified returns the value of the "APSWorkingVerified" field in the mutation.
func (m *UserMutation) APSWorkingVerified() (r bool, exists bool) {
	v := m._APSWorkingVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorkingVerified returns the old "APSWorkingVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAPSWorkingVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorkingVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorkingVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorkingVerified: %w", err)
	}
	return oldValue.APSWorkingVerified, nil
}

// ResetAPSWorkingVerified resets all changes to the "APSWorkingVerified" field.
func (m *UserMutation) ResetAPSWorkingVerified() {
	m._APSWorkingVerified = nil
}

// SetAPSWorkingRemStatus sets the "APSWorkingRemStatus" field.
func (m *UserMutation) SetAPSWorkingRemStatus(b bool) {
	m._APSWorkingRemStatus = &b
}

// APSWorkingRemStatus returns the value of the "APSWorkingRemStatus" field in the mutation.
func (m *UserMutation) APSWorkingRemStatus() (r bool, exists bool) {
	v := m._APSWorkingRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorkingRemStatus returns the old "APSWorkingRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAPSWorkingRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorkingRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorkingRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorkingRemStatus: %w", err)
	}
	return oldValue.APSWorkingRemStatus, nil
}

// ResetAPSWorkingRemStatus resets all changes to the "APSWorkingRemStatus" field.
func (m *UserMutation) ResetAPSWorkingRemStatus() {
	m._APSWorkingRemStatus = nil
}

// SetAPSWorkingRemarks sets the "APSWorkingRemarks" field.
func (m *UserMutation) SetAPSWorkingRemarks(s string) {
	m._APSWorkingRemarks = &s
}

// APSWorkingRemarks returns the value of the "APSWorkingRemarks" field in the mutation.
func (m *UserMutation) APSWorkingRemarks() (r string, exists bool) {
	v := m._APSWorkingRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorkingRemarks returns the old "APSWorkingRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAPSWorkingRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorkingRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorkingRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorkingRemarks: %w", err)
	}
	return oldValue.APSWorkingRemarks, nil
}

// ResetAPSWorkingRemarks resets all changes to the "APSWorkingRemarks" field.
func (m *UserMutation) ResetAPSWorkingRemarks() {
	m._APSWorkingRemarks = nil
}

// SetProfilestatus sets the "profilestatus" field.
func (m *UserMutation) SetProfilestatus(b bool) {
	m.profilestatus = &b
}

// Profilestatus returns the value of the "profilestatus" field in the mutation.
func (m *UserMutation) Profilestatus() (r bool, exists bool) {
	v := m.profilestatus
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilestatus returns the old "profilestatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfilestatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilestatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilestatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilestatus: %w", err)
	}
	return oldValue.Profilestatus, nil
}

// ResetProfilestatus resets all changes to the "profilestatus" field.
func (m *UserMutation) ResetProfilestatus() {
	m.profilestatus = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 37)
	if m._EmployeedID != nil {
		fields = append(fields, user.FieldEmployeedID)
	}
	if m._IDVerified != nil {
		fields = append(fields, user.FieldIDVerified)
	}
	if m._IDRemStatus != nil {
		fields = append(fields, user.FieldIDRemStatus)
	}
	if m._IDRemarks != nil {
		fields = append(fields, user.FieldIDRemarks)
	}
	if m._EmployeedName != nil {
		fields = append(fields, user.FieldEmployeedName)
	}
	if m.nameVerified != nil {
		fields = append(fields, user.FieldNameVerified)
	}
	if m.nameRemStatus != nil {
		fields = append(fields, user.FieldNameRemStatus)
	}
	if m.nameRemarks != nil {
		fields = append(fields, user.FieldNameRemarks)
	}
	if m._DOB != nil {
		fields = append(fields, user.FieldDOB)
	}
	if m._DOBVerified != nil {
		fields = append(fields, user.FieldDOBVerified)
	}
	if m._DOBRemStatus != nil {
		fields = append(fields, user.FieldDOBRemStatus)
	}
	if m._DOBRemarks != nil {
		fields = append(fields, user.FieldDOBRemarks)
	}
	if m._Gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.genderVerified != nil {
		fields = append(fields, user.FieldGenderVerified)
	}
	if m.genderRemStatus != nil {
		fields = append(fields, user.FieldGenderRemStatus)
	}
	if m.genderRemarks != nil {
		fields = append(fields, user.FieldGenderRemarks)
	}
	if m._Cadreid != nil {
		fields = append(fields, user.FieldCadreid)
	}
	if m.cadreidVerified != nil {
		fields = append(fields, user.FieldCadreidVerified)
	}
	if m.cadreidRemStatus != nil {
		fields = append(fields, user.FieldCadreidRemStatus)
	}
	if m.cadreidRemarks != nil {
		fields = append(fields, user.FieldCadreidRemarks)
	}
	if m._OfficeID != nil {
		fields = append(fields, user.FieldOfficeID)
	}
	if m.officeIDVerified != nil {
		fields = append(fields, user.FieldOfficeIDVerified)
	}
	if m.officeIDRemStatus != nil {
		fields = append(fields, user.FieldOfficeIDRemStatus)
	}
	if m.officeIDRemarks != nil {
		fields = append(fields, user.FieldOfficeIDRemarks)
	}
	if m._PH != nil {
		fields = append(fields, user.FieldPH)
	}
	if m._PHVerified != nil {
		fields = append(fields, user.FieldPHVerified)
	}
	if m._PHRemStatus != nil {
		fields = append(fields, user.FieldPHRemStatus)
	}
	if m._PHRemarks != nil {
		fields = append(fields, user.FieldPHRemarks)
	}
	if m._PHDetails != nil {
		fields = append(fields, user.FieldPHDetails)
	}
	if m._PHDetailsVerified != nil {
		fields = append(fields, user.FieldPHDetailsVerified)
	}
	if m._PHDetailsRemStatus != nil {
		fields = append(fields, user.FieldPHDetailsRemStatus)
	}
	if m._PHDetailsRemarks != nil {
		fields = append(fields, user.FieldPHDetailsRemarks)
	}
	if m._APSWorking != nil {
		fields = append(fields, user.FieldAPSWorking)
	}
	if m._APSWorkingVerified != nil {
		fields = append(fields, user.FieldAPSWorkingVerified)
	}
	if m._APSWorkingRemStatus != nil {
		fields = append(fields, user.FieldAPSWorkingRemStatus)
	}
	if m._APSWorkingRemarks != nil {
		fields = append(fields, user.FieldAPSWorkingRemarks)
	}
	if m.profilestatus != nil {
		fields = append(fields, user.FieldProfilestatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmployeedID:
		return m.EmployeedID()
	case user.FieldIDVerified:
		return m.IDVerified()
	case user.FieldIDRemStatus:
		return m.IDRemStatus()
	case user.FieldIDRemarks:
		return m.IDRemarks()
	case user.FieldEmployeedName:
		return m.EmployeedName()
	case user.FieldNameVerified:
		return m.NameVerified()
	case user.FieldNameRemStatus:
		return m.NameRemStatus()
	case user.FieldNameRemarks:
		return m.NameRemarks()
	case user.FieldDOB:
		return m.DOB()
	case user.FieldDOBVerified:
		return m.DOBVerified()
	case user.FieldDOBRemStatus:
		return m.DOBRemStatus()
	case user.FieldDOBRemarks:
		return m.DOBRemarks()
	case user.FieldGender:
		return m.Gender()
	case user.FieldGenderVerified:
		return m.GenderVerified()
	case user.FieldGenderRemStatus:
		return m.GenderRemStatus()
	case user.FieldGenderRemarks:
		return m.GenderRemarks()
	case user.FieldCadreid:
		return m.Cadreid()
	case user.FieldCadreidVerified:
		return m.CadreidVerified()
	case user.FieldCadreidRemStatus:
		return m.CadreidRemStatus()
	case user.FieldCadreidRemarks:
		return m.CadreidRemarks()
	case user.FieldOfficeID:
		return m.OfficeID()
	case user.FieldOfficeIDVerified:
		return m.OfficeIDVerified()
	case user.FieldOfficeIDRemStatus:
		return m.OfficeIDRemStatus()
	case user.FieldOfficeIDRemarks:
		return m.OfficeIDRemarks()
	case user.FieldPH:
		return m.PH()
	case user.FieldPHVerified:
		return m.PHVerified()
	case user.FieldPHRemStatus:
		return m.PHRemStatus()
	case user.FieldPHRemarks:
		return m.PHRemarks()
	case user.FieldPHDetails:
		return m.PHDetails()
	case user.FieldPHDetailsVerified:
		return m.PHDetailsVerified()
	case user.FieldPHDetailsRemStatus:
		return m.PHDetailsRemStatus()
	case user.FieldPHDetailsRemarks:
		return m.PHDetailsRemarks()
	case user.FieldAPSWorking:
		return m.APSWorking()
	case user.FieldAPSWorkingVerified:
		return m.APSWorkingVerified()
	case user.FieldAPSWorkingRemStatus:
		return m.APSWorkingRemStatus()
	case user.FieldAPSWorkingRemarks:
		return m.APSWorkingRemarks()
	case user.FieldProfilestatus:
		return m.Profilestatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmployeedID:
		return m.OldEmployeedID(ctx)
	case user.FieldIDVerified:
		return m.OldIDVerified(ctx)
	case user.FieldIDRemStatus:
		return m.OldIDRemStatus(ctx)
	case user.FieldIDRemarks:
		return m.OldIDRemarks(ctx)
	case user.FieldEmployeedName:
		return m.OldEmployeedName(ctx)
	case user.FieldNameVerified:
		return m.OldNameVerified(ctx)
	case user.FieldNameRemStatus:
		return m.OldNameRemStatus(ctx)
	case user.FieldNameRemarks:
		return m.OldNameRemarks(ctx)
	case user.FieldDOB:
		return m.OldDOB(ctx)
	case user.FieldDOBVerified:
		return m.OldDOBVerified(ctx)
	case user.FieldDOBRemStatus:
		return m.OldDOBRemStatus(ctx)
	case user.FieldDOBRemarks:
		return m.OldDOBRemarks(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldGenderVerified:
		return m.OldGenderVerified(ctx)
	case user.FieldGenderRemStatus:
		return m.OldGenderRemStatus(ctx)
	case user.FieldGenderRemarks:
		return m.OldGenderRemarks(ctx)
	case user.FieldCadreid:
		return m.OldCadreid(ctx)
	case user.FieldCadreidVerified:
		return m.OldCadreidVerified(ctx)
	case user.FieldCadreidRemStatus:
		return m.OldCadreidRemStatus(ctx)
	case user.FieldCadreidRemarks:
		return m.OldCadreidRemarks(ctx)
	case user.FieldOfficeID:
		return m.OldOfficeID(ctx)
	case user.FieldOfficeIDVerified:
		return m.OldOfficeIDVerified(ctx)
	case user.FieldOfficeIDRemStatus:
		return m.OldOfficeIDRemStatus(ctx)
	case user.FieldOfficeIDRemarks:
		return m.OldOfficeIDRemarks(ctx)
	case user.FieldPH:
		return m.OldPH(ctx)
	case user.FieldPHVerified:
		return m.OldPHVerified(ctx)
	case user.FieldPHRemStatus:
		return m.OldPHRemStatus(ctx)
	case user.FieldPHRemarks:
		return m.OldPHRemarks(ctx)
	case user.FieldPHDetails:
		return m.OldPHDetails(ctx)
	case user.FieldPHDetailsVerified:
		return m.OldPHDetailsVerified(ctx)
	case user.FieldPHDetailsRemStatus:
		return m.OldPHDetailsRemStatus(ctx)
	case user.FieldPHDetailsRemarks:
		return m.OldPHDetailsRemarks(ctx)
	case user.FieldAPSWorking:
		return m.OldAPSWorking(ctx)
	case user.FieldAPSWorkingVerified:
		return m.OldAPSWorkingVerified(ctx)
	case user.FieldAPSWorkingRemStatus:
		return m.OldAPSWorkingRemStatus(ctx)
	case user.FieldAPSWorkingRemarks:
		return m.OldAPSWorkingRemarks(ctx)
	case user.FieldProfilestatus:
		return m.OldProfilestatus(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmployeedID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeedID(v)
		return nil
	case user.FieldIDVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDVerified(v)
		return nil
	case user.FieldIDRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDRemStatus(v)
		return nil
	case user.FieldIDRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDRemarks(v)
		return nil
	case user.FieldEmployeedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeedName(v)
		return nil
	case user.FieldNameVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameVerified(v)
		return nil
	case user.FieldNameRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameRemStatus(v)
		return nil
	case user.FieldNameRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameRemarks(v)
		return nil
	case user.FieldDOB:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOB(v)
		return nil
	case user.FieldDOBVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOBVerified(v)
		return nil
	case user.FieldDOBRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOBRemStatus(v)
		return nil
	case user.FieldDOBRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOBRemarks(v)
		return nil
	case user.FieldGender:
		v, ok := value.(user.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldGenderVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderVerified(v)
		return nil
	case user.FieldGenderRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderRemStatus(v)
		return nil
	case user.FieldGenderRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderRemarks(v)
		return nil
	case user.FieldCadreid:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadreid(v)
		return nil
	case user.FieldCadreidVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadreidVerified(v)
		return nil
	case user.FieldCadreidRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadreidRemStatus(v)
		return nil
	case user.FieldCadreidRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadreidRemarks(v)
		return nil
	case user.FieldOfficeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeID(v)
		return nil
	case user.FieldOfficeIDVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeIDVerified(v)
		return nil
	case user.FieldOfficeIDRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeIDRemStatus(v)
		return nil
	case user.FieldOfficeIDRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeIDRemarks(v)
		return nil
	case user.FieldPH:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPH(v)
		return nil
	case user.FieldPHVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHVerified(v)
		return nil
	case user.FieldPHRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHRemStatus(v)
		return nil
	case user.FieldPHRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHRemarks(v)
		return nil
	case user.FieldPHDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHDetails(v)
		return nil
	case user.FieldPHDetailsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHDetailsVerified(v)
		return nil
	case user.FieldPHDetailsRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHDetailsRemStatus(v)
		return nil
	case user.FieldPHDetailsRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHDetailsRemarks(v)
		return nil
	case user.FieldAPSWorking:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorking(v)
		return nil
	case user.FieldAPSWorkingVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorkingVerified(v)
		return nil
	case user.FieldAPSWorkingRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorkingRemStatus(v)
		return nil
	case user.FieldAPSWorkingRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorkingRemarks(v)
		return nil
	case user.FieldProfilestatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilestatus(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.add_Cadreid != nil {
		fields = append(fields, user.FieldCadreid)
	}
	if m.add_OfficeID != nil {
		fields = append(fields, user.FieldOfficeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCadreid:
		return m.AddedCadreid()
	case user.FieldOfficeID:
		return m.AddedOfficeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCadreid:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCadreid(v)
		return nil
	case user.FieldOfficeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOfficeID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPHDetails) {
		fields = append(fields, user.FieldPHDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPHDetails:
		m.ClearPHDetails()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmployeedID:
		m.ResetEmployeedID()
		return nil
	case user.FieldIDVerified:
		m.ResetIDVerified()
		return nil
	case user.FieldIDRemStatus:
		m.ResetIDRemStatus()
		return nil
	case user.FieldIDRemarks:
		m.ResetIDRemarks()
		return nil
	case user.FieldEmployeedName:
		m.ResetEmployeedName()
		return nil
	case user.FieldNameVerified:
		m.ResetNameVerified()
		return nil
	case user.FieldNameRemStatus:
		m.ResetNameRemStatus()
		return nil
	case user.FieldNameRemarks:
		m.ResetNameRemarks()
		return nil
	case user.FieldDOB:
		m.ResetDOB()
		return nil
	case user.FieldDOBVerified:
		m.ResetDOBVerified()
		return nil
	case user.FieldDOBRemStatus:
		m.ResetDOBRemStatus()
		return nil
	case user.FieldDOBRemarks:
		m.ResetDOBRemarks()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldGenderVerified:
		m.ResetGenderVerified()
		return nil
	case user.FieldGenderRemStatus:
		m.ResetGenderRemStatus()
		return nil
	case user.FieldGenderRemarks:
		m.ResetGenderRemarks()
		return nil
	case user.FieldCadreid:
		m.ResetCadreid()
		return nil
	case user.FieldCadreidVerified:
		m.ResetCadreidVerified()
		return nil
	case user.FieldCadreidRemStatus:
		m.ResetCadreidRemStatus()
		return nil
	case user.FieldCadreidRemarks:
		m.ResetCadreidRemarks()
		return nil
	case user.FieldOfficeID:
		m.ResetOfficeID()
		return nil
	case user.FieldOfficeIDVerified:
		m.ResetOfficeIDVerified()
		return nil
	case user.FieldOfficeIDRemStatus:
		m.ResetOfficeIDRemStatus()
		return nil
	case user.FieldOfficeIDRemarks:
		m.ResetOfficeIDRemarks()
		return nil
	case user.FieldPH:
		m.ResetPH()
		return nil
	case user.FieldPHVerified:
		m.ResetPHVerified()
		return nil
	case user.FieldPHRemStatus:
		m.ResetPHRemStatus()
		return nil
	case user.FieldPHRemarks:
		m.ResetPHRemarks()
		return nil
	case user.FieldPHDetails:
		m.ResetPHDetails()
		return nil
	case user.FieldPHDetailsVerified:
		m.ResetPHDetailsVerified()
		return nil
	case user.FieldPHDetailsRemStatus:
		m.ResetPHDetailsRemStatus()
		return nil
	case user.FieldPHDetailsRemarks:
		m.ResetPHDetailsRemarks()
		return nil
	case user.FieldAPSWorking:
		m.ResetAPSWorking()
		return nil
	case user.FieldAPSWorkingVerified:
		m.ResetAPSWorkingVerified()
		return nil
	case user.FieldAPSWorkingRemStatus:
		m.ResetAPSWorkingRemStatus()
		return nil
	case user.FieldAPSWorkingRemarks:
		m.ResetAPSWorkingRemarks()
		return nil
	case user.FieldProfilestatus:
		m.ResetProfilestatus()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// VacancyYearMutation represents an operation that mutates the VacancyYear nodes in the graph.
type VacancyYearMutation struct {
	config
	op                 Op
	typ                string
	id                 *int32
	_FromDate          *time.Time
	_ToDate            *time.Time
	_NotifyCode        *int32
	add_NotifyCode     *int32
	_VacancyYear       *string
	_CalendarCode      *int32
	add_CalendarCode   *int32
	clearedFields      map[string]struct{}
	vacancy_ref        map[int32]struct{}
	removedvacancy_ref map[int32]struct{}
	clearedvacancy_ref bool
	exams              map[int32]struct{}
	removedexams       map[int32]struct{}
	clearedexams       bool
	done               bool
	oldValue           func(context.Context) (*VacancyYear, error)
	predicates         []predicate.VacancyYear
}

var _ ent.Mutation = (*VacancyYearMutation)(nil)

// vacancyyearOption allows management of the mutation configuration using functional options.
type vacancyyearOption func(*VacancyYearMutation)

// newVacancyYearMutation creates new mutation for the VacancyYear entity.
func newVacancyYearMutation(c config, op Op, opts ...vacancyyearOption) *VacancyYearMutation {
	m := &VacancyYearMutation{
		config:        c,
		op:            op,
		typ:           TypeVacancyYear,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVacancyYearID sets the ID field of the mutation.
func withVacancyYearID(id int32) vacancyyearOption {
	return func(m *VacancyYearMutation) {
		var (
			err   error
			once  sync.Once
			value *VacancyYear
		)
		m.oldValue = func(ctx context.Context) (*VacancyYear, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VacancyYear.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVacancyYear sets the old VacancyYear of the mutation.
func withVacancyYear(node *VacancyYear) vacancyyearOption {
	return func(m *VacancyYearMutation) {
		m.oldValue = func(context.Context) (*VacancyYear, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VacancyYearMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VacancyYearMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VacancyYear entities.
func (m *VacancyYearMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VacancyYearMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VacancyYearMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VacancyYear.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFromDate sets the "FromDate" field.
func (m *VacancyYearMutation) SetFromDate(t time.Time) {
	m._FromDate = &t
}

// FromDate returns the value of the "FromDate" field in the mutation.
func (m *VacancyYearMutation) FromDate() (r time.Time, exists bool) {
	v := m._FromDate
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDate returns the old "FromDate" field's value of the VacancyYear entity.
// If the VacancyYear object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VacancyYearMutation) OldFromDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDate: %w", err)
	}
	return oldValue.FromDate, nil
}

// ResetFromDate resets all changes to the "FromDate" field.
func (m *VacancyYearMutation) ResetFromDate() {
	m._FromDate = nil
}

// SetToDate sets the "ToDate" field.
func (m *VacancyYearMutation) SetToDate(t time.Time) {
	m._ToDate = &t
}

// ToDate returns the value of the "ToDate" field in the mutation.
func (m *VacancyYearMutation) ToDate() (r time.Time, exists bool) {
	v := m._ToDate
	if v == nil {
		return
	}
	return *v, true
}

// OldToDate returns the old "ToDate" field's value of the VacancyYear entity.
// If the VacancyYear object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VacancyYearMutation) OldToDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToDate: %w", err)
	}
	return oldValue.ToDate, nil
}

// ResetToDate resets all changes to the "ToDate" field.
func (m *VacancyYearMutation) ResetToDate() {
	m._ToDate = nil
}

// SetNotifyCode sets the "NotifyCode" field.
func (m *VacancyYearMutation) SetNotifyCode(i int32) {
	m._NotifyCode = &i
	m.add_NotifyCode = nil
}

// NotifyCode returns the value of the "NotifyCode" field in the mutation.
func (m *VacancyYearMutation) NotifyCode() (r int32, exists bool) {
	v := m._NotifyCode
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyCode returns the old "NotifyCode" field's value of the VacancyYear entity.
// If the VacancyYear object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VacancyYearMutation) OldNotifyCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyCode: %w", err)
	}
	return oldValue.NotifyCode, nil
}

// AddNotifyCode adds i to the "NotifyCode" field.
func (m *VacancyYearMutation) AddNotifyCode(i int32) {
	if m.add_NotifyCode != nil {
		*m.add_NotifyCode += i
	} else {
		m.add_NotifyCode = &i
	}
}

// AddedNotifyCode returns the value that was added to the "NotifyCode" field in this mutation.
func (m *VacancyYearMutation) AddedNotifyCode() (r int32, exists bool) {
	v := m.add_NotifyCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearNotifyCode clears the value of the "NotifyCode" field.
func (m *VacancyYearMutation) ClearNotifyCode() {
	m._NotifyCode = nil
	m.add_NotifyCode = nil
	m.clearedFields[vacancyyear.FieldNotifyCode] = struct{}{}
}

// NotifyCodeCleared returns if the "NotifyCode" field was cleared in this mutation.
func (m *VacancyYearMutation) NotifyCodeCleared() bool {
	_, ok := m.clearedFields[vacancyyear.FieldNotifyCode]
	return ok
}

// ResetNotifyCode resets all changes to the "NotifyCode" field.
func (m *VacancyYearMutation) ResetNotifyCode() {
	m._NotifyCode = nil
	m.add_NotifyCode = nil
	delete(m.clearedFields, vacancyyear.FieldNotifyCode)
}

// SetVacancyYear sets the "VacancyYear" field.
func (m *VacancyYearMutation) SetVacancyYear(s string) {
	m._VacancyYear = &s
}

// VacancyYear returns the value of the "VacancyYear" field in the mutation.
func (m *VacancyYearMutation) VacancyYear() (r string, exists bool) {
	v := m._VacancyYear
	if v == nil {
		return
	}
	return *v, true
}

// OldVacancyYear returns the old "VacancyYear" field's value of the VacancyYear entity.
// If the VacancyYear object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VacancyYearMutation) OldVacancyYear(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVacancyYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVacancyYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVacancyYear: %w", err)
	}
	return oldValue.VacancyYear, nil
}

// ResetVacancyYear resets all changes to the "VacancyYear" field.
func (m *VacancyYearMutation) ResetVacancyYear() {
	m._VacancyYear = nil
}

// SetCalendarCode sets the "CalendarCode" field.
func (m *VacancyYearMutation) SetCalendarCode(i int32) {
	m._CalendarCode = &i
	m.add_CalendarCode = nil
}

// CalendarCode returns the value of the "CalendarCode" field in the mutation.
func (m *VacancyYearMutation) CalendarCode() (r int32, exists bool) {
	v := m._CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCalendarCode returns the old "CalendarCode" field's value of the VacancyYear entity.
// If the VacancyYear object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VacancyYearMutation) OldCalendarCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalendarCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalendarCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalendarCode: %w", err)
	}
	return oldValue.CalendarCode, nil
}

// AddCalendarCode adds i to the "CalendarCode" field.
func (m *VacancyYearMutation) AddCalendarCode(i int32) {
	if m.add_CalendarCode != nil {
		*m.add_CalendarCode += i
	} else {
		m.add_CalendarCode = &i
	}
}

// AddedCalendarCode returns the value that was added to the "CalendarCode" field in this mutation.
func (m *VacancyYearMutation) AddedCalendarCode() (r int32, exists bool) {
	v := m.add_CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalendarCode clears the value of the "CalendarCode" field.
func (m *VacancyYearMutation) ClearCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	m.clearedFields[vacancyyear.FieldCalendarCode] = struct{}{}
}

// CalendarCodeCleared returns if the "CalendarCode" field was cleared in this mutation.
func (m *VacancyYearMutation) CalendarCodeCleared() bool {
	_, ok := m.clearedFields[vacancyyear.FieldCalendarCode]
	return ok
}

// ResetCalendarCode resets all changes to the "CalendarCode" field.
func (m *VacancyYearMutation) ResetCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	delete(m.clearedFields, vacancyyear.FieldCalendarCode)
}

// AddVacancyRefIDs adds the "vacancy_ref" edge to the ExamCalendar entity by ids.
func (m *VacancyYearMutation) AddVacancyRefIDs(ids ...int32) {
	if m.vacancy_ref == nil {
		m.vacancy_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.vacancy_ref[ids[i]] = struct{}{}
	}
}

// ClearVacancyRef clears the "vacancy_ref" edge to the ExamCalendar entity.
func (m *VacancyYearMutation) ClearVacancyRef() {
	m.clearedvacancy_ref = true
}

// VacancyRefCleared reports if the "vacancy_ref" edge to the ExamCalendar entity was cleared.
func (m *VacancyYearMutation) VacancyRefCleared() bool {
	return m.clearedvacancy_ref
}

// RemoveVacancyRefIDs removes the "vacancy_ref" edge to the ExamCalendar entity by IDs.
func (m *VacancyYearMutation) RemoveVacancyRefIDs(ids ...int32) {
	if m.removedvacancy_ref == nil {
		m.removedvacancy_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.vacancy_ref, ids[i])
		m.removedvacancy_ref[ids[i]] = struct{}{}
	}
}

// RemovedVacancyRef returns the removed IDs of the "vacancy_ref" edge to the ExamCalendar entity.
func (m *VacancyYearMutation) RemovedVacancyRefIDs() (ids []int32) {
	for id := range m.removedvacancy_ref {
		ids = append(ids, id)
	}
	return
}

// VacancyRefIDs returns the "vacancy_ref" edge IDs in the mutation.
func (m *VacancyYearMutation) VacancyRefIDs() (ids []int32) {
	for id := range m.vacancy_ref {
		ids = append(ids, id)
	}
	return
}

// ResetVacancyRef resets all changes to the "vacancy_ref" edge.
func (m *VacancyYearMutation) ResetVacancyRef() {
	m.vacancy_ref = nil
	m.clearedvacancy_ref = false
	m.removedvacancy_ref = nil
}

// AddExamIDs adds the "exams" edge to the Exam entity by ids.
func (m *VacancyYearMutation) AddExamIDs(ids ...int32) {
	if m.exams == nil {
		m.exams = make(map[int32]struct{})
	}
	for i := range ids {
		m.exams[ids[i]] = struct{}{}
	}
}

// ClearExams clears the "exams" edge to the Exam entity.
func (m *VacancyYearMutation) ClearExams() {
	m.clearedexams = true
}

// ExamsCleared reports if the "exams" edge to the Exam entity was cleared.
func (m *VacancyYearMutation) ExamsCleared() bool {
	return m.clearedexams
}

// RemoveExamIDs removes the "exams" edge to the Exam entity by IDs.
func (m *VacancyYearMutation) RemoveExamIDs(ids ...int32) {
	if m.removedexams == nil {
		m.removedexams = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.exams, ids[i])
		m.removedexams[ids[i]] = struct{}{}
	}
}

// RemovedExams returns the removed IDs of the "exams" edge to the Exam entity.
func (m *VacancyYearMutation) RemovedExamsIDs() (ids []int32) {
	for id := range m.removedexams {
		ids = append(ids, id)
	}
	return
}

// ExamsIDs returns the "exams" edge IDs in the mutation.
func (m *VacancyYearMutation) ExamsIDs() (ids []int32) {
	for id := range m.exams {
		ids = append(ids, id)
	}
	return
}

// ResetExams resets all changes to the "exams" edge.
func (m *VacancyYearMutation) ResetExams() {
	m.exams = nil
	m.clearedexams = false
	m.removedexams = nil
}

// Where appends a list predicates to the VacancyYearMutation builder.
func (m *VacancyYearMutation) Where(ps ...predicate.VacancyYear) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VacancyYearMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VacancyYearMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VacancyYear, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VacancyYearMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VacancyYearMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VacancyYear).
func (m *VacancyYearMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VacancyYearMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._FromDate != nil {
		fields = append(fields, vacancyyear.FieldFromDate)
	}
	if m._ToDate != nil {
		fields = append(fields, vacancyyear.FieldToDate)
	}
	if m._NotifyCode != nil {
		fields = append(fields, vacancyyear.FieldNotifyCode)
	}
	if m._VacancyYear != nil {
		fields = append(fields, vacancyyear.FieldVacancyYear)
	}
	if m._CalendarCode != nil {
		fields = append(fields, vacancyyear.FieldCalendarCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VacancyYearMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vacancyyear.FieldFromDate:
		return m.FromDate()
	case vacancyyear.FieldToDate:
		return m.ToDate()
	case vacancyyear.FieldNotifyCode:
		return m.NotifyCode()
	case vacancyyear.FieldVacancyYear:
		return m.VacancyYear()
	case vacancyyear.FieldCalendarCode:
		return m.CalendarCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VacancyYearMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vacancyyear.FieldFromDate:
		return m.OldFromDate(ctx)
	case vacancyyear.FieldToDate:
		return m.OldToDate(ctx)
	case vacancyyear.FieldNotifyCode:
		return m.OldNotifyCode(ctx)
	case vacancyyear.FieldVacancyYear:
		return m.OldVacancyYear(ctx)
	case vacancyyear.FieldCalendarCode:
		return m.OldCalendarCode(ctx)
	}
	return nil, fmt.Errorf("unknown VacancyYear field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VacancyYearMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vacancyyear.FieldFromDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDate(v)
		return nil
	case vacancyyear.FieldToDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToDate(v)
		return nil
	case vacancyyear.FieldNotifyCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyCode(v)
		return nil
	case vacancyyear.FieldVacancyYear:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVacancyYear(v)
		return nil
	case vacancyyear.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalendarCode(v)
		return nil
	}
	return fmt.Errorf("unknown VacancyYear field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VacancyYearMutation) AddedFields() []string {
	var fields []string
	if m.add_NotifyCode != nil {
		fields = append(fields, vacancyyear.FieldNotifyCode)
	}
	if m.add_CalendarCode != nil {
		fields = append(fields, vacancyyear.FieldCalendarCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VacancyYearMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vacancyyear.FieldNotifyCode:
		return m.AddedNotifyCode()
	case vacancyyear.FieldCalendarCode:
		return m.AddedCalendarCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VacancyYearMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vacancyyear.FieldNotifyCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotifyCode(v)
		return nil
	case vacancyyear.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalendarCode(v)
		return nil
	}
	return fmt.Errorf("unknown VacancyYear numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VacancyYearMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vacancyyear.FieldNotifyCode) {
		fields = append(fields, vacancyyear.FieldNotifyCode)
	}
	if m.FieldCleared(vacancyyear.FieldCalendarCode) {
		fields = append(fields, vacancyyear.FieldCalendarCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VacancyYearMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VacancyYearMutation) ClearField(name string) error {
	switch name {
	case vacancyyear.FieldNotifyCode:
		m.ClearNotifyCode()
		return nil
	case vacancyyear.FieldCalendarCode:
		m.ClearCalendarCode()
		return nil
	}
	return fmt.Errorf("unknown VacancyYear nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VacancyYearMutation) ResetField(name string) error {
	switch name {
	case vacancyyear.FieldFromDate:
		m.ResetFromDate()
		return nil
	case vacancyyear.FieldToDate:
		m.ResetToDate()
		return nil
	case vacancyyear.FieldNotifyCode:
		m.ResetNotifyCode()
		return nil
	case vacancyyear.FieldVacancyYear:
		m.ResetVacancyYear()
		return nil
	case vacancyyear.FieldCalendarCode:
		m.ResetCalendarCode()
		return nil
	}
	return fmt.Errorf("unknown VacancyYear field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VacancyYearMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.vacancy_ref != nil {
		edges = append(edges, vacancyyear.EdgeVacancyRef)
	}
	if m.exams != nil {
		edges = append(edges, vacancyyear.EdgeExams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VacancyYearMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vacancyyear.EdgeVacancyRef:
		ids := make([]ent.Value, 0, len(m.vacancy_ref))
		for id := range m.vacancy_ref {
			ids = append(ids, id)
		}
		return ids
	case vacancyyear.EdgeExams:
		ids := make([]ent.Value, 0, len(m.exams))
		for id := range m.exams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VacancyYearMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvacancy_ref != nil {
		edges = append(edges, vacancyyear.EdgeVacancyRef)
	}
	if m.removedexams != nil {
		edges = append(edges, vacancyyear.EdgeExams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VacancyYearMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vacancyyear.EdgeVacancyRef:
		ids := make([]ent.Value, 0, len(m.removedvacancy_ref))
		for id := range m.removedvacancy_ref {
			ids = append(ids, id)
		}
		return ids
	case vacancyyear.EdgeExams:
		ids := make([]ent.Value, 0, len(m.removedexams))
		for id := range m.removedexams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VacancyYearMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvacancy_ref {
		edges = append(edges, vacancyyear.EdgeVacancyRef)
	}
	if m.clearedexams {
		edges = append(edges, vacancyyear.EdgeExams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VacancyYearMutation) EdgeCleared(name string) bool {
	switch name {
	case vacancyyear.EdgeVacancyRef:
		return m.clearedvacancy_ref
	case vacancyyear.EdgeExams:
		return m.clearedexams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VacancyYearMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown VacancyYear unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VacancyYearMutation) ResetEdge(name string) error {
	switch name {
	case vacancyyear.EdgeVacancyRef:
		m.ResetVacancyRef()
		return nil
	case vacancyyear.EdgeExams:
		m.ResetExams()
		return nil
	}
	return fmt.Errorf("unknown VacancyYear edge %s", name)
}
