// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"recruit/ent/adminlogin"
	"recruit/ent/ageeligibility"
	"recruit/ent/application"
	"recruit/ent/cadre_choice_ip"
	"recruit/ent/cadre_choice_pa"
	"recruit/ent/cadre_choice_pm"
	"recruit/ent/cadre_choice_ps"
	"recruit/ent/center"
	"recruit/ent/circlemaster"
	"recruit/ent/directorateusers"
	"recruit/ent/disability"
	"recruit/ent/division_choice_pa"
	"recruit/ent/division_choice_pm"
	"recruit/ent/division_choice_ps"
	"recruit/ent/divisionmaster"
	"recruit/ent/eligibilitymaster"
	"recruit/ent/employeecadre"
	"recruit/ent/employeecategory"
	"recruit/ent/employeedesignation"
	"recruit/ent/employeemaster"
	"recruit/ent/employeeposts"
	"recruit/ent/employees"
	"recruit/ent/exam"
	"recruit/ent/exam_applications_ip"
	"recruit/ent/exam_applications_ps"
	"recruit/ent/exam_ip"
	"recruit/ent/exam_pa"
	"recruit/ent/exam_pm"
	"recruit/ent/exam_ps"
	"recruit/ent/examcalendar"
	"recruit/ent/exampapers"
	"recruit/ent/examtype"
	"recruit/ent/facility"
	"recruit/ent/login"
	"recruit/ent/nodalofficer"
	"recruit/ent/notification"
	"recruit/ent/papertypes"
	"recruit/ent/placeofpreferenceip"
	"recruit/ent/predicate"
	"recruit/ent/recommendationsipapplications"
	"recruit/ent/regionmaster"
	"recruit/ent/reversal_application_ip"
	"recruit/ent/rolemaster"
	"recruit/ent/user"
	"recruit/ent/usermaster"
	"recruit/ent/vacancyyear"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdminLogin                    = "AdminLogin"
	TypeAgeEligibility                = "AgeEligibility"
	TypeApplication                   = "Application"
	TypeCadreChoiceIP                 = "Cadre_Choice_IP"
	TypeCadreChoicePA                 = "Cadre_Choice_PA"
	TypeCadreChoicePM                 = "Cadre_Choice_PM"
	TypeCadreChoicePS                 = "Cadre_Choice_PS"
	TypeCenter                        = "Center"
	TypeCircleMaster                  = "CircleMaster"
	TypeDirectorateUsers              = "DirectorateUsers"
	TypeDisability                    = "Disability"
	TypeDivisionMaster                = "DivisionMaster"
	TypeDivisionChoicePA              = "Division_Choice_PA"
	TypeDivisionChoicePM              = "Division_Choice_PM"
	TypeDivisionChoicePS              = "Division_Choice_PS"
	TypeEligibilityMaster             = "EligibilityMaster"
	TypeEmployeeCadre                 = "EmployeeCadre"
	TypeEmployeeCategory              = "EmployeeCategory"
	TypeEmployeeDesignation           = "EmployeeDesignation"
	TypeEmployeeMaster                = "EmployeeMaster"
	TypeEmployeePosts                 = "EmployeePosts"
	TypeEmployees                     = "Employees"
	TypeExam                          = "Exam"
	TypeExamCalendar                  = "ExamCalendar"
	TypeExamPapers                    = "ExamPapers"
	TypeExamType                      = "ExamType"
	TypeExamApplicationsIP            = "Exam_Applications_IP"
	TypeExamApplicationsPS            = "Exam_Applications_PS"
	TypeExamIP                        = "Exam_IP"
	TypeExamPA                        = "Exam_PA"
	TypeExamPM                        = "Exam_PM"
	TypeExamPS                        = "Exam_PS"
	TypeFacility                      = "Facility"
	TypeLogin                         = "Login"
	TypeNodalOfficer                  = "NodalOfficer"
	TypeNotification                  = "Notification"
	TypePaperTypes                    = "PaperTypes"
	TypePlaceOfPreferenceIP           = "PlaceOfPreferenceIP"
	TypeRecommendationsIPApplications = "RecommendationsIPApplications"
	TypeRegionMaster                  = "RegionMaster"
	TypeReversalApplicationIP         = "Reversal_Application_IP"
	TypeRoleMaster                    = "RoleMaster"
	TypeUser                          = "User"
	TypeUserMaster                    = "UserMaster"
	TypeVacancyYear                   = "VacancyYear"
)

// AdminLoginMutation represents an operation that mutates the AdminLogin nodes in the graph.
type AdminLoginMutation struct {
	config
	op                 Op
	typ                string
	id                 *int32
	_RoleName          *string
	_CreatedDate       *time.Time
	_Status            *string
	_EmployeedID       *int32
	add_EmployeedID    *int32
	_EmployeeName      *string
	_Emailid           *string
	_MobileNumber      *int64
	add_MobileNumber   *int64
	_Username          *string
	_OTP               *int32
	add_OTP            *int32
	_Password          *string
	_VerifyRemarks     *string
	clearedFields      map[string]struct{}
	role_master        *int32
	clearedrole_master bool
	done               bool
	oldValue           func(context.Context) (*AdminLogin, error)
	predicates         []predicate.AdminLogin
}

var _ ent.Mutation = (*AdminLoginMutation)(nil)

// adminloginOption allows management of the mutation configuration using functional options.
type adminloginOption func(*AdminLoginMutation)

// newAdminLoginMutation creates new mutation for the AdminLogin entity.
func newAdminLoginMutation(c config, op Op, opts ...adminloginOption) *AdminLoginMutation {
	m := &AdminLoginMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminLogin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminLoginID sets the ID field of the mutation.
func withAdminLoginID(id int32) adminloginOption {
	return func(m *AdminLoginMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminLogin
		)
		m.oldValue = func(ctx context.Context) (*AdminLogin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminLogin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminLogin sets the old AdminLogin of the mutation.
func withAdminLogin(node *AdminLogin) adminloginOption {
	return func(m *AdminLoginMutation) {
		m.oldValue = func(context.Context) (*AdminLogin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminLoginMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminLoginMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdminLogin entities.
func (m *AdminLoginMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminLoginMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminLoginMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdminLogin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoleUserCode sets the "RoleUserCode" field.
func (m *AdminLoginMutation) SetRoleUserCode(i int32) {
	m.role_master = &i
}

// RoleUserCode returns the value of the "RoleUserCode" field in the mutation.
func (m *AdminLoginMutation) RoleUserCode() (r int32, exists bool) {
	v := m.role_master
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleUserCode returns the old "RoleUserCode" field's value of the AdminLogin entity.
// If the AdminLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginMutation) OldRoleUserCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleUserCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleUserCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleUserCode: %w", err)
	}
	return oldValue.RoleUserCode, nil
}

// ClearRoleUserCode clears the value of the "RoleUserCode" field.
func (m *AdminLoginMutation) ClearRoleUserCode() {
	m.role_master = nil
	m.clearedFields[adminlogin.FieldRoleUserCode] = struct{}{}
}

// RoleUserCodeCleared returns if the "RoleUserCode" field was cleared in this mutation.
func (m *AdminLoginMutation) RoleUserCodeCleared() bool {
	_, ok := m.clearedFields[adminlogin.FieldRoleUserCode]
	return ok
}

// ResetRoleUserCode resets all changes to the "RoleUserCode" field.
func (m *AdminLoginMutation) ResetRoleUserCode() {
	m.role_master = nil
	delete(m.clearedFields, adminlogin.FieldRoleUserCode)
}

// SetRoleName sets the "RoleName" field.
func (m *AdminLoginMutation) SetRoleName(s string) {
	m._RoleName = &s
}

// RoleName returns the value of the "RoleName" field in the mutation.
func (m *AdminLoginMutation) RoleName() (r string, exists bool) {
	v := m._RoleName
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleName returns the old "RoleName" field's value of the AdminLogin entity.
// If the AdminLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginMutation) OldRoleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleName: %w", err)
	}
	return oldValue.RoleName, nil
}

// ClearRoleName clears the value of the "RoleName" field.
func (m *AdminLoginMutation) ClearRoleName() {
	m._RoleName = nil
	m.clearedFields[adminlogin.FieldRoleName] = struct{}{}
}

// RoleNameCleared returns if the "RoleName" field was cleared in this mutation.
func (m *AdminLoginMutation) RoleNameCleared() bool {
	_, ok := m.clearedFields[adminlogin.FieldRoleName]
	return ok
}

// ResetRoleName resets all changes to the "RoleName" field.
func (m *AdminLoginMutation) ResetRoleName() {
	m._RoleName = nil
	delete(m.clearedFields, adminlogin.FieldRoleName)
}

// SetCreatedDate sets the "CreatedDate" field.
func (m *AdminLoginMutation) SetCreatedDate(t time.Time) {
	m._CreatedDate = &t
}

// CreatedDate returns the value of the "CreatedDate" field in the mutation.
func (m *AdminLoginMutation) CreatedDate() (r time.Time, exists bool) {
	v := m._CreatedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "CreatedDate" field's value of the AdminLogin entity.
// If the AdminLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ClearCreatedDate clears the value of the "CreatedDate" field.
func (m *AdminLoginMutation) ClearCreatedDate() {
	m._CreatedDate = nil
	m.clearedFields[adminlogin.FieldCreatedDate] = struct{}{}
}

// CreatedDateCleared returns if the "CreatedDate" field was cleared in this mutation.
func (m *AdminLoginMutation) CreatedDateCleared() bool {
	_, ok := m.clearedFields[adminlogin.FieldCreatedDate]
	return ok
}

// ResetCreatedDate resets all changes to the "CreatedDate" field.
func (m *AdminLoginMutation) ResetCreatedDate() {
	m._CreatedDate = nil
	delete(m.clearedFields, adminlogin.FieldCreatedDate)
}

// SetStatus sets the "Status" field.
func (m *AdminLoginMutation) SetStatus(s string) {
	m._Status = &s
}

// Status returns the value of the "Status" field in the mutation.
func (m *AdminLoginMutation) Status() (r string, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the AdminLogin entity.
// If the AdminLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "Status" field.
func (m *AdminLoginMutation) ClearStatus() {
	m._Status = nil
	m.clearedFields[adminlogin.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "Status" field was cleared in this mutation.
func (m *AdminLoginMutation) StatusCleared() bool {
	_, ok := m.clearedFields[adminlogin.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "Status" field.
func (m *AdminLoginMutation) ResetStatus() {
	m._Status = nil
	delete(m.clearedFields, adminlogin.FieldStatus)
}

// SetEmployeedID sets the "EmployeedID" field.
func (m *AdminLoginMutation) SetEmployeedID(i int32) {
	m._EmployeedID = &i
	m.add_EmployeedID = nil
}

// EmployeedID returns the value of the "EmployeedID" field in the mutation.
func (m *AdminLoginMutation) EmployeedID() (r int32, exists bool) {
	v := m._EmployeedID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeedID returns the old "EmployeedID" field's value of the AdminLogin entity.
// If the AdminLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginMutation) OldEmployeedID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeedID: %w", err)
	}
	return oldValue.EmployeedID, nil
}

// AddEmployeedID adds i to the "EmployeedID" field.
func (m *AdminLoginMutation) AddEmployeedID(i int32) {
	if m.add_EmployeedID != nil {
		*m.add_EmployeedID += i
	} else {
		m.add_EmployeedID = &i
	}
}

// AddedEmployeedID returns the value that was added to the "EmployeedID" field in this mutation.
func (m *AdminLoginMutation) AddedEmployeedID() (r int32, exists bool) {
	v := m.add_EmployeedID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeedID clears the value of the "EmployeedID" field.
func (m *AdminLoginMutation) ClearEmployeedID() {
	m._EmployeedID = nil
	m.add_EmployeedID = nil
	m.clearedFields[adminlogin.FieldEmployeedID] = struct{}{}
}

// EmployeedIDCleared returns if the "EmployeedID" field was cleared in this mutation.
func (m *AdminLoginMutation) EmployeedIDCleared() bool {
	_, ok := m.clearedFields[adminlogin.FieldEmployeedID]
	return ok
}

// ResetEmployeedID resets all changes to the "EmployeedID" field.
func (m *AdminLoginMutation) ResetEmployeedID() {
	m._EmployeedID = nil
	m.add_EmployeedID = nil
	delete(m.clearedFields, adminlogin.FieldEmployeedID)
}

// SetEmployeeName sets the "EmployeeName" field.
func (m *AdminLoginMutation) SetEmployeeName(s string) {
	m._EmployeeName = &s
}

// EmployeeName returns the value of the "EmployeeName" field in the mutation.
func (m *AdminLoginMutation) EmployeeName() (r string, exists bool) {
	v := m._EmployeeName
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeName returns the old "EmployeeName" field's value of the AdminLogin entity.
// If the AdminLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginMutation) OldEmployeeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeName: %w", err)
	}
	return oldValue.EmployeeName, nil
}

// ClearEmployeeName clears the value of the "EmployeeName" field.
func (m *AdminLoginMutation) ClearEmployeeName() {
	m._EmployeeName = nil
	m.clearedFields[adminlogin.FieldEmployeeName] = struct{}{}
}

// EmployeeNameCleared returns if the "EmployeeName" field was cleared in this mutation.
func (m *AdminLoginMutation) EmployeeNameCleared() bool {
	_, ok := m.clearedFields[adminlogin.FieldEmployeeName]
	return ok
}

// ResetEmployeeName resets all changes to the "EmployeeName" field.
func (m *AdminLoginMutation) ResetEmployeeName() {
	m._EmployeeName = nil
	delete(m.clearedFields, adminlogin.FieldEmployeeName)
}

// SetEmailid sets the "Emailid" field.
func (m *AdminLoginMutation) SetEmailid(s string) {
	m._Emailid = &s
}

// Emailid returns the value of the "Emailid" field in the mutation.
func (m *AdminLoginMutation) Emailid() (r string, exists bool) {
	v := m._Emailid
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailid returns the old "Emailid" field's value of the AdminLogin entity.
// If the AdminLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginMutation) OldEmailid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailid: %w", err)
	}
	return oldValue.Emailid, nil
}

// ClearEmailid clears the value of the "Emailid" field.
func (m *AdminLoginMutation) ClearEmailid() {
	m._Emailid = nil
	m.clearedFields[adminlogin.FieldEmailid] = struct{}{}
}

// EmailidCleared returns if the "Emailid" field was cleared in this mutation.
func (m *AdminLoginMutation) EmailidCleared() bool {
	_, ok := m.clearedFields[adminlogin.FieldEmailid]
	return ok
}

// ResetEmailid resets all changes to the "Emailid" field.
func (m *AdminLoginMutation) ResetEmailid() {
	m._Emailid = nil
	delete(m.clearedFields, adminlogin.FieldEmailid)
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *AdminLoginMutation) SetMobileNumber(i int64) {
	m._MobileNumber = &i
	m.add_MobileNumber = nil
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *AdminLoginMutation) MobileNumber() (r int64, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the AdminLogin entity.
// If the AdminLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginMutation) OldMobileNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// AddMobileNumber adds i to the "MobileNumber" field.
func (m *AdminLoginMutation) AddMobileNumber(i int64) {
	if m.add_MobileNumber != nil {
		*m.add_MobileNumber += i
	} else {
		m.add_MobileNumber = &i
	}
}

// AddedMobileNumber returns the value that was added to the "MobileNumber" field in this mutation.
func (m *AdminLoginMutation) AddedMobileNumber() (r int64, exists bool) {
	v := m.add_MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearMobileNumber clears the value of the "MobileNumber" field.
func (m *AdminLoginMutation) ClearMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	m.clearedFields[adminlogin.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "MobileNumber" field was cleared in this mutation.
func (m *AdminLoginMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[adminlogin.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *AdminLoginMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	delete(m.clearedFields, adminlogin.FieldMobileNumber)
}

// SetUsername sets the "Username" field.
func (m *AdminLoginMutation) SetUsername(s string) {
	m._Username = &s
}

// Username returns the value of the "Username" field in the mutation.
func (m *AdminLoginMutation) Username() (r string, exists bool) {
	v := m._Username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "Username" field's value of the AdminLogin entity.
// If the AdminLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "Username" field.
func (m *AdminLoginMutation) ResetUsername() {
	m._Username = nil
}

// SetOTP sets the "OTP" field.
func (m *AdminLoginMutation) SetOTP(i int32) {
	m._OTP = &i
	m.add_OTP = nil
}

// OTP returns the value of the "OTP" field in the mutation.
func (m *AdminLoginMutation) OTP() (r int32, exists bool) {
	v := m._OTP
	if v == nil {
		return
	}
	return *v, true
}

// OldOTP returns the old "OTP" field's value of the AdminLogin entity.
// If the AdminLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginMutation) OldOTP(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOTP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOTP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOTP: %w", err)
	}
	return oldValue.OTP, nil
}

// AddOTP adds i to the "OTP" field.
func (m *AdminLoginMutation) AddOTP(i int32) {
	if m.add_OTP != nil {
		*m.add_OTP += i
	} else {
		m.add_OTP = &i
	}
}

// AddedOTP returns the value that was added to the "OTP" field in this mutation.
func (m *AdminLoginMutation) AddedOTP() (r int32, exists bool) {
	v := m.add_OTP
	if v == nil {
		return
	}
	return *v, true
}

// ClearOTP clears the value of the "OTP" field.
func (m *AdminLoginMutation) ClearOTP() {
	m._OTP = nil
	m.add_OTP = nil
	m.clearedFields[adminlogin.FieldOTP] = struct{}{}
}

// OTPCleared returns if the "OTP" field was cleared in this mutation.
func (m *AdminLoginMutation) OTPCleared() bool {
	_, ok := m.clearedFields[adminlogin.FieldOTP]
	return ok
}

// ResetOTP resets all changes to the "OTP" field.
func (m *AdminLoginMutation) ResetOTP() {
	m._OTP = nil
	m.add_OTP = nil
	delete(m.clearedFields, adminlogin.FieldOTP)
}

// SetPassword sets the "Password" field.
func (m *AdminLoginMutation) SetPassword(s string) {
	m._Password = &s
}

// Password returns the value of the "Password" field in the mutation.
func (m *AdminLoginMutation) Password() (r string, exists bool) {
	v := m._Password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "Password" field's value of the AdminLogin entity.
// If the AdminLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "Password" field.
func (m *AdminLoginMutation) ResetPassword() {
	m._Password = nil
}

// SetVerifyRemarks sets the "VerifyRemarks" field.
func (m *AdminLoginMutation) SetVerifyRemarks(s string) {
	m._VerifyRemarks = &s
}

// VerifyRemarks returns the value of the "VerifyRemarks" field in the mutation.
func (m *AdminLoginMutation) VerifyRemarks() (r string, exists bool) {
	v := m._VerifyRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifyRemarks returns the old "VerifyRemarks" field's value of the AdminLogin entity.
// If the AdminLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginMutation) OldVerifyRemarks(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifyRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifyRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifyRemarks: %w", err)
	}
	return oldValue.VerifyRemarks, nil
}

// ClearVerifyRemarks clears the value of the "VerifyRemarks" field.
func (m *AdminLoginMutation) ClearVerifyRemarks() {
	m._VerifyRemarks = nil
	m.clearedFields[adminlogin.FieldVerifyRemarks] = struct{}{}
}

// VerifyRemarksCleared returns if the "VerifyRemarks" field was cleared in this mutation.
func (m *AdminLoginMutation) VerifyRemarksCleared() bool {
	_, ok := m.clearedFields[adminlogin.FieldVerifyRemarks]
	return ok
}

// ResetVerifyRemarks resets all changes to the "VerifyRemarks" field.
func (m *AdminLoginMutation) ResetVerifyRemarks() {
	m._VerifyRemarks = nil
	delete(m.clearedFields, adminlogin.FieldVerifyRemarks)
}

// SetRoleMasterID sets the "role_master" edge to the RoleMaster entity by id.
func (m *AdminLoginMutation) SetRoleMasterID(id int32) {
	m.role_master = &id
}

// ClearRoleMaster clears the "role_master" edge to the RoleMaster entity.
func (m *AdminLoginMutation) ClearRoleMaster() {
	m.clearedrole_master = true
}

// RoleMasterCleared reports if the "role_master" edge to the RoleMaster entity was cleared.
func (m *AdminLoginMutation) RoleMasterCleared() bool {
	return m.RoleUserCodeCleared() || m.clearedrole_master
}

// RoleMasterID returns the "role_master" edge ID in the mutation.
func (m *AdminLoginMutation) RoleMasterID() (id int32, exists bool) {
	if m.role_master != nil {
		return *m.role_master, true
	}
	return
}

// RoleMasterIDs returns the "role_master" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleMasterID instead. It exists only for internal usage by the builders.
func (m *AdminLoginMutation) RoleMasterIDs() (ids []int32) {
	if id := m.role_master; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoleMaster resets all changes to the "role_master" edge.
func (m *AdminLoginMutation) ResetRoleMaster() {
	m.role_master = nil
	m.clearedrole_master = false
}

// Where appends a list predicates to the AdminLoginMutation builder.
func (m *AdminLoginMutation) Where(ps ...predicate.AdminLogin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminLoginMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminLoginMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdminLogin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminLoginMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminLoginMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdminLogin).
func (m *AdminLoginMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminLoginMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.role_master != nil {
		fields = append(fields, adminlogin.FieldRoleUserCode)
	}
	if m._RoleName != nil {
		fields = append(fields, adminlogin.FieldRoleName)
	}
	if m._CreatedDate != nil {
		fields = append(fields, adminlogin.FieldCreatedDate)
	}
	if m._Status != nil {
		fields = append(fields, adminlogin.FieldStatus)
	}
	if m._EmployeedID != nil {
		fields = append(fields, adminlogin.FieldEmployeedID)
	}
	if m._EmployeeName != nil {
		fields = append(fields, adminlogin.FieldEmployeeName)
	}
	if m._Emailid != nil {
		fields = append(fields, adminlogin.FieldEmailid)
	}
	if m._MobileNumber != nil {
		fields = append(fields, adminlogin.FieldMobileNumber)
	}
	if m._Username != nil {
		fields = append(fields, adminlogin.FieldUsername)
	}
	if m._OTP != nil {
		fields = append(fields, adminlogin.FieldOTP)
	}
	if m._Password != nil {
		fields = append(fields, adminlogin.FieldPassword)
	}
	if m._VerifyRemarks != nil {
		fields = append(fields, adminlogin.FieldVerifyRemarks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminLoginMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminlogin.FieldRoleUserCode:
		return m.RoleUserCode()
	case adminlogin.FieldRoleName:
		return m.RoleName()
	case adminlogin.FieldCreatedDate:
		return m.CreatedDate()
	case adminlogin.FieldStatus:
		return m.Status()
	case adminlogin.FieldEmployeedID:
		return m.EmployeedID()
	case adminlogin.FieldEmployeeName:
		return m.EmployeeName()
	case adminlogin.FieldEmailid:
		return m.Emailid()
	case adminlogin.FieldMobileNumber:
		return m.MobileNumber()
	case adminlogin.FieldUsername:
		return m.Username()
	case adminlogin.FieldOTP:
		return m.OTP()
	case adminlogin.FieldPassword:
		return m.Password()
	case adminlogin.FieldVerifyRemarks:
		return m.VerifyRemarks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminLoginMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminlogin.FieldRoleUserCode:
		return m.OldRoleUserCode(ctx)
	case adminlogin.FieldRoleName:
		return m.OldRoleName(ctx)
	case adminlogin.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	case adminlogin.FieldStatus:
		return m.OldStatus(ctx)
	case adminlogin.FieldEmployeedID:
		return m.OldEmployeedID(ctx)
	case adminlogin.FieldEmployeeName:
		return m.OldEmployeeName(ctx)
	case adminlogin.FieldEmailid:
		return m.OldEmailid(ctx)
	case adminlogin.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case adminlogin.FieldUsername:
		return m.OldUsername(ctx)
	case adminlogin.FieldOTP:
		return m.OldOTP(ctx)
	case adminlogin.FieldPassword:
		return m.OldPassword(ctx)
	case adminlogin.FieldVerifyRemarks:
		return m.OldVerifyRemarks(ctx)
	}
	return nil, fmt.Errorf("unknown AdminLogin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminLoginMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminlogin.FieldRoleUserCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleUserCode(v)
		return nil
	case adminlogin.FieldRoleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleName(v)
		return nil
	case adminlogin.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	case adminlogin.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case adminlogin.FieldEmployeedID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeedID(v)
		return nil
	case adminlogin.FieldEmployeeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeName(v)
		return nil
	case adminlogin.FieldEmailid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailid(v)
		return nil
	case adminlogin.FieldMobileNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case adminlogin.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case adminlogin.FieldOTP:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOTP(v)
		return nil
	case adminlogin.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case adminlogin.FieldVerifyRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifyRemarks(v)
		return nil
	}
	return fmt.Errorf("unknown AdminLogin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminLoginMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeedID != nil {
		fields = append(fields, adminlogin.FieldEmployeedID)
	}
	if m.add_MobileNumber != nil {
		fields = append(fields, adminlogin.FieldMobileNumber)
	}
	if m.add_OTP != nil {
		fields = append(fields, adminlogin.FieldOTP)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminLoginMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case adminlogin.FieldEmployeedID:
		return m.AddedEmployeedID()
	case adminlogin.FieldMobileNumber:
		return m.AddedMobileNumber()
	case adminlogin.FieldOTP:
		return m.AddedOTP()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminLoginMutation) AddField(name string, value ent.Value) error {
	switch name {
	case adminlogin.FieldEmployeedID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeedID(v)
		return nil
	case adminlogin.FieldMobileNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMobileNumber(v)
		return nil
	case adminlogin.FieldOTP:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOTP(v)
		return nil
	}
	return fmt.Errorf("unknown AdminLogin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminLoginMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(adminlogin.FieldRoleUserCode) {
		fields = append(fields, adminlogin.FieldRoleUserCode)
	}
	if m.FieldCleared(adminlogin.FieldRoleName) {
		fields = append(fields, adminlogin.FieldRoleName)
	}
	if m.FieldCleared(adminlogin.FieldCreatedDate) {
		fields = append(fields, adminlogin.FieldCreatedDate)
	}
	if m.FieldCleared(adminlogin.FieldStatus) {
		fields = append(fields, adminlogin.FieldStatus)
	}
	if m.FieldCleared(adminlogin.FieldEmployeedID) {
		fields = append(fields, adminlogin.FieldEmployeedID)
	}
	if m.FieldCleared(adminlogin.FieldEmployeeName) {
		fields = append(fields, adminlogin.FieldEmployeeName)
	}
	if m.FieldCleared(adminlogin.FieldEmailid) {
		fields = append(fields, adminlogin.FieldEmailid)
	}
	if m.FieldCleared(adminlogin.FieldMobileNumber) {
		fields = append(fields, adminlogin.FieldMobileNumber)
	}
	if m.FieldCleared(adminlogin.FieldOTP) {
		fields = append(fields, adminlogin.FieldOTP)
	}
	if m.FieldCleared(adminlogin.FieldVerifyRemarks) {
		fields = append(fields, adminlogin.FieldVerifyRemarks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminLoginMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminLoginMutation) ClearField(name string) error {
	switch name {
	case adminlogin.FieldRoleUserCode:
		m.ClearRoleUserCode()
		return nil
	case adminlogin.FieldRoleName:
		m.ClearRoleName()
		return nil
	case adminlogin.FieldCreatedDate:
		m.ClearCreatedDate()
		return nil
	case adminlogin.FieldStatus:
		m.ClearStatus()
		return nil
	case adminlogin.FieldEmployeedID:
		m.ClearEmployeedID()
		return nil
	case adminlogin.FieldEmployeeName:
		m.ClearEmployeeName()
		return nil
	case adminlogin.FieldEmailid:
		m.ClearEmailid()
		return nil
	case adminlogin.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	case adminlogin.FieldOTP:
		m.ClearOTP()
		return nil
	case adminlogin.FieldVerifyRemarks:
		m.ClearVerifyRemarks()
		return nil
	}
	return fmt.Errorf("unknown AdminLogin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminLoginMutation) ResetField(name string) error {
	switch name {
	case adminlogin.FieldRoleUserCode:
		m.ResetRoleUserCode()
		return nil
	case adminlogin.FieldRoleName:
		m.ResetRoleName()
		return nil
	case adminlogin.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	case adminlogin.FieldStatus:
		m.ResetStatus()
		return nil
	case adminlogin.FieldEmployeedID:
		m.ResetEmployeedID()
		return nil
	case adminlogin.FieldEmployeeName:
		m.ResetEmployeeName()
		return nil
	case adminlogin.FieldEmailid:
		m.ResetEmailid()
		return nil
	case adminlogin.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case adminlogin.FieldUsername:
		m.ResetUsername()
		return nil
	case adminlogin.FieldOTP:
		m.ResetOTP()
		return nil
	case adminlogin.FieldPassword:
		m.ResetPassword()
		return nil
	case adminlogin.FieldVerifyRemarks:
		m.ResetVerifyRemarks()
		return nil
	}
	return fmt.Errorf("unknown AdminLogin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminLoginMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.role_master != nil {
		edges = append(edges, adminlogin.EdgeRoleMaster)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminLoginMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adminlogin.EdgeRoleMaster:
		if id := m.role_master; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminLoginMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminLoginMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminLoginMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrole_master {
		edges = append(edges, adminlogin.EdgeRoleMaster)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminLoginMutation) EdgeCleared(name string) bool {
	switch name {
	case adminlogin.EdgeRoleMaster:
		return m.clearedrole_master
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminLoginMutation) ClearEdge(name string) error {
	switch name {
	case adminlogin.EdgeRoleMaster:
		m.ClearRoleMaster()
		return nil
	}
	return fmt.Errorf("unknown AdminLogin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminLoginMutation) ResetEdge(name string) error {
	switch name {
	case adminlogin.EdgeRoleMaster:
		m.ResetRoleMaster()
		return nil
	}
	return fmt.Errorf("unknown AdminLogin edge %s", name)
}

// AgeEligibilityMutation represents an operation that mutates the AgeEligibility nodes in the graph.
type AgeEligibilityMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int32
	_EligibillityCode    *int32
	add_EligibillityCode *int32
	_Age                 *int32
	add_Age              *int32
	_CategoryID          *int32
	add_CategoryID       *int32
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*AgeEligibility, error)
	predicates           []predicate.AgeEligibility
}

var _ ent.Mutation = (*AgeEligibilityMutation)(nil)

// ageeligibilityOption allows management of the mutation configuration using functional options.
type ageeligibilityOption func(*AgeEligibilityMutation)

// newAgeEligibilityMutation creates new mutation for the AgeEligibility entity.
func newAgeEligibilityMutation(c config, op Op, opts ...ageeligibilityOption) *AgeEligibilityMutation {
	m := &AgeEligibilityMutation{
		config:        c,
		op:            op,
		typ:           TypeAgeEligibility,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgeEligibilityID sets the ID field of the mutation.
func withAgeEligibilityID(id int32) ageeligibilityOption {
	return func(m *AgeEligibilityMutation) {
		var (
			err   error
			once  sync.Once
			value *AgeEligibility
		)
		m.oldValue = func(ctx context.Context) (*AgeEligibility, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgeEligibility.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgeEligibility sets the old AgeEligibility of the mutation.
func withAgeEligibility(node *AgeEligibility) ageeligibilityOption {
	return func(m *AgeEligibilityMutation) {
		m.oldValue = func(context.Context) (*AgeEligibility, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgeEligibilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgeEligibilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AgeEligibility entities.
func (m *AgeEligibilityMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgeEligibilityMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgeEligibilityMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AgeEligibility.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEligibillityCode sets the "EligibillityCode" field.
func (m *AgeEligibilityMutation) SetEligibillityCode(i int32) {
	m._EligibillityCode = &i
	m.add_EligibillityCode = nil
}

// EligibillityCode returns the value of the "EligibillityCode" field in the mutation.
func (m *AgeEligibilityMutation) EligibillityCode() (r int32, exists bool) {
	v := m._EligibillityCode
	if v == nil {
		return
	}
	return *v, true
}

// OldEligibillityCode returns the old "EligibillityCode" field's value of the AgeEligibility entity.
// If the AgeEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgeEligibilityMutation) OldEligibillityCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligibillityCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligibillityCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligibillityCode: %w", err)
	}
	return oldValue.EligibillityCode, nil
}

// AddEligibillityCode adds i to the "EligibillityCode" field.
func (m *AgeEligibilityMutation) AddEligibillityCode(i int32) {
	if m.add_EligibillityCode != nil {
		*m.add_EligibillityCode += i
	} else {
		m.add_EligibillityCode = &i
	}
}

// AddedEligibillityCode returns the value that was added to the "EligibillityCode" field in this mutation.
func (m *AgeEligibilityMutation) AddedEligibillityCode() (r int32, exists bool) {
	v := m.add_EligibillityCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearEligibillityCode clears the value of the "EligibillityCode" field.
func (m *AgeEligibilityMutation) ClearEligibillityCode() {
	m._EligibillityCode = nil
	m.add_EligibillityCode = nil
	m.clearedFields[ageeligibility.FieldEligibillityCode] = struct{}{}
}

// EligibillityCodeCleared returns if the "EligibillityCode" field was cleared in this mutation.
func (m *AgeEligibilityMutation) EligibillityCodeCleared() bool {
	_, ok := m.clearedFields[ageeligibility.FieldEligibillityCode]
	return ok
}

// ResetEligibillityCode resets all changes to the "EligibillityCode" field.
func (m *AgeEligibilityMutation) ResetEligibillityCode() {
	m._EligibillityCode = nil
	m.add_EligibillityCode = nil
	delete(m.clearedFields, ageeligibility.FieldEligibillityCode)
}

// SetAge sets the "Age" field.
func (m *AgeEligibilityMutation) SetAge(i int32) {
	m._Age = &i
	m.add_Age = nil
}

// Age returns the value of the "Age" field in the mutation.
func (m *AgeEligibilityMutation) Age() (r int32, exists bool) {
	v := m._Age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "Age" field's value of the AgeEligibility entity.
// If the AgeEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgeEligibilityMutation) OldAge(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "Age" field.
func (m *AgeEligibilityMutation) AddAge(i int32) {
	if m.add_Age != nil {
		*m.add_Age += i
	} else {
		m.add_Age = &i
	}
}

// AddedAge returns the value that was added to the "Age" field in this mutation.
func (m *AgeEligibilityMutation) AddedAge() (r int32, exists bool) {
	v := m.add_Age
	if v == nil {
		return
	}
	return *v, true
}

// ClearAge clears the value of the "Age" field.
func (m *AgeEligibilityMutation) ClearAge() {
	m._Age = nil
	m.add_Age = nil
	m.clearedFields[ageeligibility.FieldAge] = struct{}{}
}

// AgeCleared returns if the "Age" field was cleared in this mutation.
func (m *AgeEligibilityMutation) AgeCleared() bool {
	_, ok := m.clearedFields[ageeligibility.FieldAge]
	return ok
}

// ResetAge resets all changes to the "Age" field.
func (m *AgeEligibilityMutation) ResetAge() {
	m._Age = nil
	m.add_Age = nil
	delete(m.clearedFields, ageeligibility.FieldAge)
}

// SetCategoryID sets the "CategoryID" field.
func (m *AgeEligibilityMutation) SetCategoryID(i int32) {
	m._CategoryID = &i
	m.add_CategoryID = nil
}

// CategoryID returns the value of the "CategoryID" field in the mutation.
func (m *AgeEligibilityMutation) CategoryID() (r int32, exists bool) {
	v := m._CategoryID
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "CategoryID" field's value of the AgeEligibility entity.
// If the AgeEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgeEligibilityMutation) OldCategoryID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "CategoryID" field.
func (m *AgeEligibilityMutation) AddCategoryID(i int32) {
	if m.add_CategoryID != nil {
		*m.add_CategoryID += i
	} else {
		m.add_CategoryID = &i
	}
}

// AddedCategoryID returns the value that was added to the "CategoryID" field in this mutation.
func (m *AgeEligibilityMutation) AddedCategoryID() (r int32, exists bool) {
	v := m.add_CategoryID
	if v == nil {
		return
	}
	return *v, true
}

// ClearCategoryID clears the value of the "CategoryID" field.
func (m *AgeEligibilityMutation) ClearCategoryID() {
	m._CategoryID = nil
	m.add_CategoryID = nil
	m.clearedFields[ageeligibility.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "CategoryID" field was cleared in this mutation.
func (m *AgeEligibilityMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[ageeligibility.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "CategoryID" field.
func (m *AgeEligibilityMutation) ResetCategoryID() {
	m._CategoryID = nil
	m.add_CategoryID = nil
	delete(m.clearedFields, ageeligibility.FieldCategoryID)
}

// Where appends a list predicates to the AgeEligibilityMutation builder.
func (m *AgeEligibilityMutation) Where(ps ...predicate.AgeEligibility) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgeEligibilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgeEligibilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AgeEligibility, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgeEligibilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgeEligibilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AgeEligibility).
func (m *AgeEligibilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgeEligibilityMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._EligibillityCode != nil {
		fields = append(fields, ageeligibility.FieldEligibillityCode)
	}
	if m._Age != nil {
		fields = append(fields, ageeligibility.FieldAge)
	}
	if m._CategoryID != nil {
		fields = append(fields, ageeligibility.FieldCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgeEligibilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ageeligibility.FieldEligibillityCode:
		return m.EligibillityCode()
	case ageeligibility.FieldAge:
		return m.Age()
	case ageeligibility.FieldCategoryID:
		return m.CategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgeEligibilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ageeligibility.FieldEligibillityCode:
		return m.OldEligibillityCode(ctx)
	case ageeligibility.FieldAge:
		return m.OldAge(ctx)
	case ageeligibility.FieldCategoryID:
		return m.OldCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown AgeEligibility field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgeEligibilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ageeligibility.FieldEligibillityCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligibillityCode(v)
		return nil
	case ageeligibility.FieldAge:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case ageeligibility.FieldCategoryID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown AgeEligibility field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgeEligibilityMutation) AddedFields() []string {
	var fields []string
	if m.add_EligibillityCode != nil {
		fields = append(fields, ageeligibility.FieldEligibillityCode)
	}
	if m.add_Age != nil {
		fields = append(fields, ageeligibility.FieldAge)
	}
	if m.add_CategoryID != nil {
		fields = append(fields, ageeligibility.FieldCategoryID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgeEligibilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ageeligibility.FieldEligibillityCode:
		return m.AddedEligibillityCode()
	case ageeligibility.FieldAge:
		return m.AddedAge()
	case ageeligibility.FieldCategoryID:
		return m.AddedCategoryID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgeEligibilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ageeligibility.FieldEligibillityCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEligibillityCode(v)
		return nil
	case ageeligibility.FieldAge:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case ageeligibility.FieldCategoryID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown AgeEligibility numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgeEligibilityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ageeligibility.FieldEligibillityCode) {
		fields = append(fields, ageeligibility.FieldEligibillityCode)
	}
	if m.FieldCleared(ageeligibility.FieldAge) {
		fields = append(fields, ageeligibility.FieldAge)
	}
	if m.FieldCleared(ageeligibility.FieldCategoryID) {
		fields = append(fields, ageeligibility.FieldCategoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgeEligibilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgeEligibilityMutation) ClearField(name string) error {
	switch name {
	case ageeligibility.FieldEligibillityCode:
		m.ClearEligibillityCode()
		return nil
	case ageeligibility.FieldAge:
		m.ClearAge()
		return nil
	case ageeligibility.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	}
	return fmt.Errorf("unknown AgeEligibility nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgeEligibilityMutation) ResetField(name string) error {
	switch name {
	case ageeligibility.FieldEligibillityCode:
		m.ResetEligibillityCode()
		return nil
	case ageeligibility.FieldAge:
		m.ResetAge()
		return nil
	case ageeligibility.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	}
	return fmt.Errorf("unknown AgeEligibility field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgeEligibilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgeEligibilityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgeEligibilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgeEligibilityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgeEligibilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgeEligibilityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgeEligibilityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AgeEligibility unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgeEligibilityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AgeEligibility edge %s", name)
}

// ApplicationMutation represents an operation that mutates the Application nodes in the graph.
type ApplicationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int32
	_EmployeeID         *int32
	add_EmployeeID      *int32
	_HallTicketNumber   *string
	_AppliedStamp       *time.Time
	clearedFields       map[string]struct{}
	center              *int32
	clearedcenter       bool
	notification        *int32
	clearednotification bool
	done                bool
	oldValue            func(context.Context) (*Application, error)
	predicates          []predicate.Application
}

var _ ent.Mutation = (*ApplicationMutation)(nil)

// applicationOption allows management of the mutation configuration using functional options.
type applicationOption func(*ApplicationMutation)

// newApplicationMutation creates new mutation for the Application entity.
func newApplicationMutation(c config, op Op, opts ...applicationOption) *ApplicationMutation {
	m := &ApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationID sets the ID field of the mutation.
func withApplicationID(id int32) applicationOption {
	return func(m *ApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Application
		)
		m.oldValue = func(ctx context.Context) (*Application, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Application.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplication sets the old Application of the mutation.
func withApplication(node *Application) applicationOption {
	return func(m *ApplicationMutation) {
		m.oldValue = func(context.Context) (*Application, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Application entities.
func (m *ApplicationMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicationMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicationMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Application.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *ApplicationMutation) SetEmployeeID(i int32) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *ApplicationMutation) EmployeeID() (r int32, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldEmployeeID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *ApplicationMutation) AddEmployeeID(i int32) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *ApplicationMutation) AddedEmployeeID() (r int32, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *ApplicationMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
}

// SetNotifyCode sets the "NotifyCode" field.
func (m *ApplicationMutation) SetNotifyCode(i int32) {
	m.notification = &i
}

// NotifyCode returns the value of the "NotifyCode" field in the mutation.
func (m *ApplicationMutation) NotifyCode() (r int32, exists bool) {
	v := m.notification
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyCode returns the old "NotifyCode" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldNotifyCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyCode: %w", err)
	}
	return oldValue.NotifyCode, nil
}

// ClearNotifyCode clears the value of the "NotifyCode" field.
func (m *ApplicationMutation) ClearNotifyCode() {
	m.notification = nil
	m.clearedFields[application.FieldNotifyCode] = struct{}{}
}

// NotifyCodeCleared returns if the "NotifyCode" field was cleared in this mutation.
func (m *ApplicationMutation) NotifyCodeCleared() bool {
	_, ok := m.clearedFields[application.FieldNotifyCode]
	return ok
}

// ResetNotifyCode resets all changes to the "NotifyCode" field.
func (m *ApplicationMutation) ResetNotifyCode() {
	m.notification = nil
	delete(m.clearedFields, application.FieldNotifyCode)
}

// SetHallTicketNumber sets the "HallTicketNumber" field.
func (m *ApplicationMutation) SetHallTicketNumber(s string) {
	m._HallTicketNumber = &s
}

// HallTicketNumber returns the value of the "HallTicketNumber" field in the mutation.
func (m *ApplicationMutation) HallTicketNumber() (r string, exists bool) {
	v := m._HallTicketNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldHallTicketNumber returns the old "HallTicketNumber" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldHallTicketNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHallTicketNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHallTicketNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHallTicketNumber: %w", err)
	}
	return oldValue.HallTicketNumber, nil
}

// ClearHallTicketNumber clears the value of the "HallTicketNumber" field.
func (m *ApplicationMutation) ClearHallTicketNumber() {
	m._HallTicketNumber = nil
	m.clearedFields[application.FieldHallTicketNumber] = struct{}{}
}

// HallTicketNumberCleared returns if the "HallTicketNumber" field was cleared in this mutation.
func (m *ApplicationMutation) HallTicketNumberCleared() bool {
	_, ok := m.clearedFields[application.FieldHallTicketNumber]
	return ok
}

// ResetHallTicketNumber resets all changes to the "HallTicketNumber" field.
func (m *ApplicationMutation) ResetHallTicketNumber() {
	m._HallTicketNumber = nil
	delete(m.clearedFields, application.FieldHallTicketNumber)
}

// SetCenterCode sets the "CenterCode" field.
func (m *ApplicationMutation) SetCenterCode(i int32) {
	m.center = &i
}

// CenterCode returns the value of the "CenterCode" field in the mutation.
func (m *ApplicationMutation) CenterCode() (r int32, exists bool) {
	v := m.center
	if v == nil {
		return
	}
	return *v, true
}

// OldCenterCode returns the old "CenterCode" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldCenterCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCenterCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCenterCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCenterCode: %w", err)
	}
	return oldValue.CenterCode, nil
}

// ClearCenterCode clears the value of the "CenterCode" field.
func (m *ApplicationMutation) ClearCenterCode() {
	m.center = nil
	m.clearedFields[application.FieldCenterCode] = struct{}{}
}

// CenterCodeCleared returns if the "CenterCode" field was cleared in this mutation.
func (m *ApplicationMutation) CenterCodeCleared() bool {
	_, ok := m.clearedFields[application.FieldCenterCode]
	return ok
}

// ResetCenterCode resets all changes to the "CenterCode" field.
func (m *ApplicationMutation) ResetCenterCode() {
	m.center = nil
	delete(m.clearedFields, application.FieldCenterCode)
}

// SetAppliedStamp sets the "AppliedStamp" field.
func (m *ApplicationMutation) SetAppliedStamp(t time.Time) {
	m._AppliedStamp = &t
}

// AppliedStamp returns the value of the "AppliedStamp" field in the mutation.
func (m *ApplicationMutation) AppliedStamp() (r time.Time, exists bool) {
	v := m._AppliedStamp
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliedStamp returns the old "AppliedStamp" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldAppliedStamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliedStamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliedStamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliedStamp: %w", err)
	}
	return oldValue.AppliedStamp, nil
}

// ResetAppliedStamp resets all changes to the "AppliedStamp" field.
func (m *ApplicationMutation) ResetAppliedStamp() {
	m._AppliedStamp = nil
}

// SetCenterID sets the "center" edge to the Center entity by id.
func (m *ApplicationMutation) SetCenterID(id int32) {
	m.center = &id
}

// ClearCenter clears the "center" edge to the Center entity.
func (m *ApplicationMutation) ClearCenter() {
	m.clearedcenter = true
}

// CenterCleared reports if the "center" edge to the Center entity was cleared.
func (m *ApplicationMutation) CenterCleared() bool {
	return m.CenterCodeCleared() || m.clearedcenter
}

// CenterID returns the "center" edge ID in the mutation.
func (m *ApplicationMutation) CenterID() (id int32, exists bool) {
	if m.center != nil {
		return *m.center, true
	}
	return
}

// CenterIDs returns the "center" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CenterID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) CenterIDs() (ids []int32) {
	if id := m.center; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCenter resets all changes to the "center" edge.
func (m *ApplicationMutation) ResetCenter() {
	m.center = nil
	m.clearedcenter = false
}

// SetNotificationID sets the "notification" edge to the Notification entity by id.
func (m *ApplicationMutation) SetNotificationID(id int32) {
	m.notification = &id
}

// ClearNotification clears the "notification" edge to the Notification entity.
func (m *ApplicationMutation) ClearNotification() {
	m.clearednotification = true
}

// NotificationCleared reports if the "notification" edge to the Notification entity was cleared.
func (m *ApplicationMutation) NotificationCleared() bool {
	return m.NotifyCodeCleared() || m.clearednotification
}

// NotificationID returns the "notification" edge ID in the mutation.
func (m *ApplicationMutation) NotificationID() (id int32, exists bool) {
	if m.notification != nil {
		return *m.notification, true
	}
	return
}

// NotificationIDs returns the "notification" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotificationID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) NotificationIDs() (ids []int32) {
	if id := m.notification; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotification resets all changes to the "notification" edge.
func (m *ApplicationMutation) ResetNotification() {
	m.notification = nil
	m.clearednotification = false
}

// Where appends a list predicates to the ApplicationMutation builder.
func (m *ApplicationMutation) Where(ps ...predicate.Application) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Application, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Application).
func (m *ApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._EmployeeID != nil {
		fields = append(fields, application.FieldEmployeeID)
	}
	if m.notification != nil {
		fields = append(fields, application.FieldNotifyCode)
	}
	if m._HallTicketNumber != nil {
		fields = append(fields, application.FieldHallTicketNumber)
	}
	if m.center != nil {
		fields = append(fields, application.FieldCenterCode)
	}
	if m._AppliedStamp != nil {
		fields = append(fields, application.FieldAppliedStamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case application.FieldEmployeeID:
		return m.EmployeeID()
	case application.FieldNotifyCode:
		return m.NotifyCode()
	case application.FieldHallTicketNumber:
		return m.HallTicketNumber()
	case application.FieldCenterCode:
		return m.CenterCode()
	case application.FieldAppliedStamp:
		return m.AppliedStamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case application.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case application.FieldNotifyCode:
		return m.OldNotifyCode(ctx)
	case application.FieldHallTicketNumber:
		return m.OldHallTicketNumber(ctx)
	case application.FieldCenterCode:
		return m.OldCenterCode(ctx)
	case application.FieldAppliedStamp:
		return m.OldAppliedStamp(ctx)
	}
	return nil, fmt.Errorf("unknown Application field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case application.FieldEmployeeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case application.FieldNotifyCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyCode(v)
		return nil
	case application.FieldHallTicketNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHallTicketNumber(v)
		return nil
	case application.FieldCenterCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCenterCode(v)
		return nil
	case application.FieldAppliedStamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliedStamp(v)
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicationMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeeID != nil {
		fields = append(fields, application.FieldEmployeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case application.FieldEmployeeID:
		return m.AddedEmployeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case application.FieldEmployeeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown Application numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(application.FieldNotifyCode) {
		fields = append(fields, application.FieldNotifyCode)
	}
	if m.FieldCleared(application.FieldHallTicketNumber) {
		fields = append(fields, application.FieldHallTicketNumber)
	}
	if m.FieldCleared(application.FieldCenterCode) {
		fields = append(fields, application.FieldCenterCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationMutation) ClearField(name string) error {
	switch name {
	case application.FieldNotifyCode:
		m.ClearNotifyCode()
		return nil
	case application.FieldHallTicketNumber:
		m.ClearHallTicketNumber()
		return nil
	case application.FieldCenterCode:
		m.ClearCenterCode()
		return nil
	}
	return fmt.Errorf("unknown Application nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicationMutation) ResetField(name string) error {
	switch name {
	case application.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case application.FieldNotifyCode:
		m.ResetNotifyCode()
		return nil
	case application.FieldHallTicketNumber:
		m.ResetHallTicketNumber()
		return nil
	case application.FieldCenterCode:
		m.ResetCenterCode()
		return nil
	case application.FieldAppliedStamp:
		m.ResetAppliedStamp()
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.center != nil {
		edges = append(edges, application.EdgeCenter)
	}
	if m.notification != nil {
		edges = append(edges, application.EdgeNotification)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeCenter:
		if id := m.center; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeNotification:
		if id := m.notification; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcenter {
		edges = append(edges, application.EdgeCenter)
	}
	if m.clearednotification {
		edges = append(edges, application.EdgeNotification)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case application.EdgeCenter:
		return m.clearedcenter
	case application.EdgeNotification:
		return m.clearednotification
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicationMutation) ClearEdge(name string) error {
	switch name {
	case application.EdgeCenter:
		m.ClearCenter()
		return nil
	case application.EdgeNotification:
		m.ClearNotification()
		return nil
	}
	return fmt.Errorf("unknown Application unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicationMutation) ResetEdge(name string) error {
	switch name {
	case application.EdgeCenter:
		m.ResetCenter()
		return nil
	case application.EdgeNotification:
		m.ResetNotification()
		return nil
	}
	return fmt.Errorf("unknown Application edge %s", name)
}

// CadreChoiceIPMutation represents an operation that mutates the Cadre_Choice_IP nodes in the graph.
type CadreChoiceIPMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int32
	_CadrePrefNo        *string
	_CadrePrefValue     *string
	_EmployeeID         *int64
	add_EmployeeID      *int64
	_UpdatedAt          *time.Time
	_UpdatedBy          *string
	clearedFields       map[string]struct{}
	_ApplnIP_Ref        *int64
	cleared_ApplnIP_Ref bool
	done                bool
	oldValue            func(context.Context) (*Cadre_Choice_IP, error)
	predicates          []predicate.Cadre_Choice_IP
}

var _ ent.Mutation = (*CadreChoiceIPMutation)(nil)

// cadreChoiceIPOption allows management of the mutation configuration using functional options.
type cadreChoiceIPOption func(*CadreChoiceIPMutation)

// newCadreChoiceIPMutation creates new mutation for the Cadre_Choice_IP entity.
func newCadreChoiceIPMutation(c config, op Op, opts ...cadreChoiceIPOption) *CadreChoiceIPMutation {
	m := &CadreChoiceIPMutation{
		config:        c,
		op:            op,
		typ:           TypeCadreChoiceIP,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCadre_Choice_IPID sets the ID field of the mutation.
func withCadre_Choice_IPID(id int32) cadreChoiceIPOption {
	return func(m *CadreChoiceIPMutation) {
		var (
			err   error
			once  sync.Once
			value *Cadre_Choice_IP
		)
		m.oldValue = func(ctx context.Context) (*Cadre_Choice_IP, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cadre_Choice_IP.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCadre_Choice_IP sets the old Cadre_Choice_IP of the mutation.
func withCadre_Choice_IP(node *Cadre_Choice_IP) cadreChoiceIPOption {
	return func(m *CadreChoiceIPMutation) {
		m.oldValue = func(context.Context) (*Cadre_Choice_IP, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CadreChoiceIPMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CadreChoiceIPMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Cadre_Choice_IP entities.
func (m *CadreChoiceIPMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CadreChoiceIPMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CadreChoiceIPMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cadre_Choice_IP.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApplicationID sets the "ApplicationID" field.
func (m *CadreChoiceIPMutation) SetApplicationID(i int64) {
	m._ApplnIP_Ref = &i
}

// ApplicationID returns the value of the "ApplicationID" field in the mutation.
func (m *CadreChoiceIPMutation) ApplicationID() (r int64, exists bool) {
	v := m._ApplnIP_Ref
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationID returns the old "ApplicationID" field's value of the Cadre_Choice_IP entity.
// If the Cadre_Choice_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoiceIPMutation) OldApplicationID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationID: %w", err)
	}
	return oldValue.ApplicationID, nil
}

// ClearApplicationID clears the value of the "ApplicationID" field.
func (m *CadreChoiceIPMutation) ClearApplicationID() {
	m._ApplnIP_Ref = nil
	m.clearedFields[cadre_choice_ip.FieldApplicationID] = struct{}{}
}

// ApplicationIDCleared returns if the "ApplicationID" field was cleared in this mutation.
func (m *CadreChoiceIPMutation) ApplicationIDCleared() bool {
	_, ok := m.clearedFields[cadre_choice_ip.FieldApplicationID]
	return ok
}

// ResetApplicationID resets all changes to the "ApplicationID" field.
func (m *CadreChoiceIPMutation) ResetApplicationID() {
	m._ApplnIP_Ref = nil
	delete(m.clearedFields, cadre_choice_ip.FieldApplicationID)
}

// SetCadrePrefNo sets the "CadrePrefNo" field.
func (m *CadreChoiceIPMutation) SetCadrePrefNo(s string) {
	m._CadrePrefNo = &s
}

// CadrePrefNo returns the value of the "CadrePrefNo" field in the mutation.
func (m *CadreChoiceIPMutation) CadrePrefNo() (r string, exists bool) {
	v := m._CadrePrefNo
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePrefNo returns the old "CadrePrefNo" field's value of the Cadre_Choice_IP entity.
// If the Cadre_Choice_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoiceIPMutation) OldCadrePrefNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePrefNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePrefNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePrefNo: %w", err)
	}
	return oldValue.CadrePrefNo, nil
}

// ClearCadrePrefNo clears the value of the "CadrePrefNo" field.
func (m *CadreChoiceIPMutation) ClearCadrePrefNo() {
	m._CadrePrefNo = nil
	m.clearedFields[cadre_choice_ip.FieldCadrePrefNo] = struct{}{}
}

// CadrePrefNoCleared returns if the "CadrePrefNo" field was cleared in this mutation.
func (m *CadreChoiceIPMutation) CadrePrefNoCleared() bool {
	_, ok := m.clearedFields[cadre_choice_ip.FieldCadrePrefNo]
	return ok
}

// ResetCadrePrefNo resets all changes to the "CadrePrefNo" field.
func (m *CadreChoiceIPMutation) ResetCadrePrefNo() {
	m._CadrePrefNo = nil
	delete(m.clearedFields, cadre_choice_ip.FieldCadrePrefNo)
}

// SetCadrePrefValue sets the "CadrePrefValue" field.
func (m *CadreChoiceIPMutation) SetCadrePrefValue(s string) {
	m._CadrePrefValue = &s
}

// CadrePrefValue returns the value of the "CadrePrefValue" field in the mutation.
func (m *CadreChoiceIPMutation) CadrePrefValue() (r string, exists bool) {
	v := m._CadrePrefValue
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePrefValue returns the old "CadrePrefValue" field's value of the Cadre_Choice_IP entity.
// If the Cadre_Choice_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoiceIPMutation) OldCadrePrefValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePrefValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePrefValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePrefValue: %w", err)
	}
	return oldValue.CadrePrefValue, nil
}

// ClearCadrePrefValue clears the value of the "CadrePrefValue" field.
func (m *CadreChoiceIPMutation) ClearCadrePrefValue() {
	m._CadrePrefValue = nil
	m.clearedFields[cadre_choice_ip.FieldCadrePrefValue] = struct{}{}
}

// CadrePrefValueCleared returns if the "CadrePrefValue" field was cleared in this mutation.
func (m *CadreChoiceIPMutation) CadrePrefValueCleared() bool {
	_, ok := m.clearedFields[cadre_choice_ip.FieldCadrePrefValue]
	return ok
}

// ResetCadrePrefValue resets all changes to the "CadrePrefValue" field.
func (m *CadreChoiceIPMutation) ResetCadrePrefValue() {
	m._CadrePrefValue = nil
	delete(m.clearedFields, cadre_choice_ip.FieldCadrePrefValue)
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *CadreChoiceIPMutation) SetEmployeeID(i int64) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *CadreChoiceIPMutation) EmployeeID() (r int64, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the Cadre_Choice_IP entity.
// If the Cadre_Choice_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoiceIPMutation) OldEmployeeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *CadreChoiceIPMutation) AddEmployeeID(i int64) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *CadreChoiceIPMutation) AddedEmployeeID() (r int64, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeeID clears the value of the "EmployeeID" field.
func (m *CadreChoiceIPMutation) ClearEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	m.clearedFields[cadre_choice_ip.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "EmployeeID" field was cleared in this mutation.
func (m *CadreChoiceIPMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[cadre_choice_ip.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *CadreChoiceIPMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	delete(m.clearedFields, cadre_choice_ip.FieldEmployeeID)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *CadreChoiceIPMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *CadreChoiceIPMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Cadre_Choice_IP entity.
// If the Cadre_Choice_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoiceIPMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *CadreChoiceIPMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[cadre_choice_ip.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *CadreChoiceIPMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[cadre_choice_ip.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *CadreChoiceIPMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, cadre_choice_ip.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *CadreChoiceIPMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *CadreChoiceIPMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the Cadre_Choice_IP entity.
// If the Cadre_Choice_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoiceIPMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *CadreChoiceIPMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[cadre_choice_ip.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *CadreChoiceIPMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[cadre_choice_ip.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *CadreChoiceIPMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, cadre_choice_ip.FieldUpdatedBy)
}

// SetApplnIPRefID sets the "ApplnIP_Ref" edge to the Exam_Applications_IP entity by id.
func (m *CadreChoiceIPMutation) SetApplnIPRefID(id int64) {
	m._ApplnIP_Ref = &id
}

// ClearApplnIPRef clears the "ApplnIP_Ref" edge to the Exam_Applications_IP entity.
func (m *CadreChoiceIPMutation) ClearApplnIPRef() {
	m.cleared_ApplnIP_Ref = true
}

// ApplnIPRefCleared reports if the "ApplnIP_Ref" edge to the Exam_Applications_IP entity was cleared.
func (m *CadreChoiceIPMutation) ApplnIPRefCleared() bool {
	return m.ApplicationIDCleared() || m.cleared_ApplnIP_Ref
}

// ApplnIPRefID returns the "ApplnIP_Ref" edge ID in the mutation.
func (m *CadreChoiceIPMutation) ApplnIPRefID() (id int64, exists bool) {
	if m._ApplnIP_Ref != nil {
		return *m._ApplnIP_Ref, true
	}
	return
}

// ApplnIPRefIDs returns the "ApplnIP_Ref" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplnIPRefID instead. It exists only for internal usage by the builders.
func (m *CadreChoiceIPMutation) ApplnIPRefIDs() (ids []int64) {
	if id := m._ApplnIP_Ref; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplnIPRef resets all changes to the "ApplnIP_Ref" edge.
func (m *CadreChoiceIPMutation) ResetApplnIPRef() {
	m._ApplnIP_Ref = nil
	m.cleared_ApplnIP_Ref = false
}

// Where appends a list predicates to the CadreChoiceIPMutation builder.
func (m *CadreChoiceIPMutation) Where(ps ...predicate.Cadre_Choice_IP) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CadreChoiceIPMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CadreChoiceIPMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Cadre_Choice_IP, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CadreChoiceIPMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CadreChoiceIPMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Cadre_Choice_IP).
func (m *CadreChoiceIPMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CadreChoiceIPMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._ApplnIP_Ref != nil {
		fields = append(fields, cadre_choice_ip.FieldApplicationID)
	}
	if m._CadrePrefNo != nil {
		fields = append(fields, cadre_choice_ip.FieldCadrePrefNo)
	}
	if m._CadrePrefValue != nil {
		fields = append(fields, cadre_choice_ip.FieldCadrePrefValue)
	}
	if m._EmployeeID != nil {
		fields = append(fields, cadre_choice_ip.FieldEmployeeID)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, cadre_choice_ip.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, cadre_choice_ip.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CadreChoiceIPMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cadre_choice_ip.FieldApplicationID:
		return m.ApplicationID()
	case cadre_choice_ip.FieldCadrePrefNo:
		return m.CadrePrefNo()
	case cadre_choice_ip.FieldCadrePrefValue:
		return m.CadrePrefValue()
	case cadre_choice_ip.FieldEmployeeID:
		return m.EmployeeID()
	case cadre_choice_ip.FieldUpdatedAt:
		return m.UpdatedAt()
	case cadre_choice_ip.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CadreChoiceIPMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cadre_choice_ip.FieldApplicationID:
		return m.OldApplicationID(ctx)
	case cadre_choice_ip.FieldCadrePrefNo:
		return m.OldCadrePrefNo(ctx)
	case cadre_choice_ip.FieldCadrePrefValue:
		return m.OldCadrePrefValue(ctx)
	case cadre_choice_ip.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case cadre_choice_ip.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cadre_choice_ip.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Cadre_Choice_IP field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CadreChoiceIPMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cadre_choice_ip.FieldApplicationID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationID(v)
		return nil
	case cadre_choice_ip.FieldCadrePrefNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePrefNo(v)
		return nil
	case cadre_choice_ip.FieldCadrePrefValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePrefValue(v)
		return nil
	case cadre_choice_ip.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case cadre_choice_ip.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cadre_choice_ip.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_IP field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CadreChoiceIPMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeeID != nil {
		fields = append(fields, cadre_choice_ip.FieldEmployeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CadreChoiceIPMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cadre_choice_ip.FieldEmployeeID:
		return m.AddedEmployeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CadreChoiceIPMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cadre_choice_ip.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_IP numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CadreChoiceIPMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cadre_choice_ip.FieldApplicationID) {
		fields = append(fields, cadre_choice_ip.FieldApplicationID)
	}
	if m.FieldCleared(cadre_choice_ip.FieldCadrePrefNo) {
		fields = append(fields, cadre_choice_ip.FieldCadrePrefNo)
	}
	if m.FieldCleared(cadre_choice_ip.FieldCadrePrefValue) {
		fields = append(fields, cadre_choice_ip.FieldCadrePrefValue)
	}
	if m.FieldCleared(cadre_choice_ip.FieldEmployeeID) {
		fields = append(fields, cadre_choice_ip.FieldEmployeeID)
	}
	if m.FieldCleared(cadre_choice_ip.FieldUpdatedAt) {
		fields = append(fields, cadre_choice_ip.FieldUpdatedAt)
	}
	if m.FieldCleared(cadre_choice_ip.FieldUpdatedBy) {
		fields = append(fields, cadre_choice_ip.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CadreChoiceIPMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CadreChoiceIPMutation) ClearField(name string) error {
	switch name {
	case cadre_choice_ip.FieldApplicationID:
		m.ClearApplicationID()
		return nil
	case cadre_choice_ip.FieldCadrePrefNo:
		m.ClearCadrePrefNo()
		return nil
	case cadre_choice_ip.FieldCadrePrefValue:
		m.ClearCadrePrefValue()
		return nil
	case cadre_choice_ip.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case cadre_choice_ip.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case cadre_choice_ip.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_IP nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CadreChoiceIPMutation) ResetField(name string) error {
	switch name {
	case cadre_choice_ip.FieldApplicationID:
		m.ResetApplicationID()
		return nil
	case cadre_choice_ip.FieldCadrePrefNo:
		m.ResetCadrePrefNo()
		return nil
	case cadre_choice_ip.FieldCadrePrefValue:
		m.ResetCadrePrefValue()
		return nil
	case cadre_choice_ip.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case cadre_choice_ip.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cadre_choice_ip.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_IP field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CadreChoiceIPMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._ApplnIP_Ref != nil {
		edges = append(edges, cadre_choice_ip.EdgeApplnIPRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CadreChoiceIPMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cadre_choice_ip.EdgeApplnIPRef:
		if id := m._ApplnIP_Ref; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CadreChoiceIPMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CadreChoiceIPMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CadreChoiceIPMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_ApplnIP_Ref {
		edges = append(edges, cadre_choice_ip.EdgeApplnIPRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CadreChoiceIPMutation) EdgeCleared(name string) bool {
	switch name {
	case cadre_choice_ip.EdgeApplnIPRef:
		return m.cleared_ApplnIP_Ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CadreChoiceIPMutation) ClearEdge(name string) error {
	switch name {
	case cadre_choice_ip.EdgeApplnIPRef:
		m.ClearApplnIPRef()
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_IP unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CadreChoiceIPMutation) ResetEdge(name string) error {
	switch name {
	case cadre_choice_ip.EdgeApplnIPRef:
		m.ResetApplnIPRef()
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_IP edge %s", name)
}

// CadreChoicePAMutation represents an operation that mutates the Cadre_Choice_PA nodes in the graph.
type CadreChoicePAMutation struct {
	config
	op              Op
	typ             string
	id              *int32
	_Application    *string
	_CadrePrefNo    *string
	_CadrePrefValue *string
	_EmployeeID     *int64
	add_EmployeeID  *int64
	_UpdatedAt      *time.Time
	_UpdatedBy      *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Cadre_Choice_PA, error)
	predicates      []predicate.Cadre_Choice_PA
}

var _ ent.Mutation = (*CadreChoicePAMutation)(nil)

// cadreChoicePAOption allows management of the mutation configuration using functional options.
type cadreChoicePAOption func(*CadreChoicePAMutation)

// newCadreChoicePAMutation creates new mutation for the Cadre_Choice_PA entity.
func newCadreChoicePAMutation(c config, op Op, opts ...cadreChoicePAOption) *CadreChoicePAMutation {
	m := &CadreChoicePAMutation{
		config:        c,
		op:            op,
		typ:           TypeCadreChoicePA,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCadre_Choice_PAID sets the ID field of the mutation.
func withCadre_Choice_PAID(id int32) cadreChoicePAOption {
	return func(m *CadreChoicePAMutation) {
		var (
			err   error
			once  sync.Once
			value *Cadre_Choice_PA
		)
		m.oldValue = func(ctx context.Context) (*Cadre_Choice_PA, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cadre_Choice_PA.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCadre_Choice_PA sets the old Cadre_Choice_PA of the mutation.
func withCadre_Choice_PA(node *Cadre_Choice_PA) cadreChoicePAOption {
	return func(m *CadreChoicePAMutation) {
		m.oldValue = func(context.Context) (*Cadre_Choice_PA, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CadreChoicePAMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CadreChoicePAMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Cadre_Choice_PA entities.
func (m *CadreChoicePAMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CadreChoicePAMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CadreChoicePAMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cadre_Choice_PA.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApplication sets the "Application" field.
func (m *CadreChoicePAMutation) SetApplication(s string) {
	m._Application = &s
}

// Application returns the value of the "Application" field in the mutation.
func (m *CadreChoicePAMutation) Application() (r string, exists bool) {
	v := m._Application
	if v == nil {
		return
	}
	return *v, true
}

// OldApplication returns the old "Application" field's value of the Cadre_Choice_PA entity.
// If the Cadre_Choice_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePAMutation) OldApplication(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplication is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplication requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplication: %w", err)
	}
	return oldValue.Application, nil
}

// ClearApplication clears the value of the "Application" field.
func (m *CadreChoicePAMutation) ClearApplication() {
	m._Application = nil
	m.clearedFields[cadre_choice_pa.FieldApplication] = struct{}{}
}

// ApplicationCleared returns if the "Application" field was cleared in this mutation.
func (m *CadreChoicePAMutation) ApplicationCleared() bool {
	_, ok := m.clearedFields[cadre_choice_pa.FieldApplication]
	return ok
}

// ResetApplication resets all changes to the "Application" field.
func (m *CadreChoicePAMutation) ResetApplication() {
	m._Application = nil
	delete(m.clearedFields, cadre_choice_pa.FieldApplication)
}

// SetCadrePrefNo sets the "CadrePrefNo" field.
func (m *CadreChoicePAMutation) SetCadrePrefNo(s string) {
	m._CadrePrefNo = &s
}

// CadrePrefNo returns the value of the "CadrePrefNo" field in the mutation.
func (m *CadreChoicePAMutation) CadrePrefNo() (r string, exists bool) {
	v := m._CadrePrefNo
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePrefNo returns the old "CadrePrefNo" field's value of the Cadre_Choice_PA entity.
// If the Cadre_Choice_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePAMutation) OldCadrePrefNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePrefNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePrefNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePrefNo: %w", err)
	}
	return oldValue.CadrePrefNo, nil
}

// ResetCadrePrefNo resets all changes to the "CadrePrefNo" field.
func (m *CadreChoicePAMutation) ResetCadrePrefNo() {
	m._CadrePrefNo = nil
}

// SetCadrePrefValue sets the "CadrePrefValue" field.
func (m *CadreChoicePAMutation) SetCadrePrefValue(s string) {
	m._CadrePrefValue = &s
}

// CadrePrefValue returns the value of the "CadrePrefValue" field in the mutation.
func (m *CadreChoicePAMutation) CadrePrefValue() (r string, exists bool) {
	v := m._CadrePrefValue
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePrefValue returns the old "CadrePrefValue" field's value of the Cadre_Choice_PA entity.
// If the Cadre_Choice_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePAMutation) OldCadrePrefValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePrefValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePrefValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePrefValue: %w", err)
	}
	return oldValue.CadrePrefValue, nil
}

// ResetCadrePrefValue resets all changes to the "CadrePrefValue" field.
func (m *CadreChoicePAMutation) ResetCadrePrefValue() {
	m._CadrePrefValue = nil
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *CadreChoicePAMutation) SetEmployeeID(i int64) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *CadreChoicePAMutation) EmployeeID() (r int64, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the Cadre_Choice_PA entity.
// If the Cadre_Choice_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePAMutation) OldEmployeeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *CadreChoicePAMutation) AddEmployeeID(i int64) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *CadreChoicePAMutation) AddedEmployeeID() (r int64, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeeID clears the value of the "EmployeeID" field.
func (m *CadreChoicePAMutation) ClearEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	m.clearedFields[cadre_choice_pa.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "EmployeeID" field was cleared in this mutation.
func (m *CadreChoicePAMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[cadre_choice_pa.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *CadreChoicePAMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	delete(m.clearedFields, cadre_choice_pa.FieldEmployeeID)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *CadreChoicePAMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *CadreChoicePAMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Cadre_Choice_PA entity.
// If the Cadre_Choice_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePAMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *CadreChoicePAMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[cadre_choice_pa.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *CadreChoicePAMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[cadre_choice_pa.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *CadreChoicePAMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, cadre_choice_pa.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *CadreChoicePAMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *CadreChoicePAMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the Cadre_Choice_PA entity.
// If the Cadre_Choice_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePAMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *CadreChoicePAMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[cadre_choice_pa.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *CadreChoicePAMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[cadre_choice_pa.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *CadreChoicePAMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, cadre_choice_pa.FieldUpdatedBy)
}

// Where appends a list predicates to the CadreChoicePAMutation builder.
func (m *CadreChoicePAMutation) Where(ps ...predicate.Cadre_Choice_PA) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CadreChoicePAMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CadreChoicePAMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Cadre_Choice_PA, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CadreChoicePAMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CadreChoicePAMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Cadre_Choice_PA).
func (m *CadreChoicePAMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CadreChoicePAMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._Application != nil {
		fields = append(fields, cadre_choice_pa.FieldApplication)
	}
	if m._CadrePrefNo != nil {
		fields = append(fields, cadre_choice_pa.FieldCadrePrefNo)
	}
	if m._CadrePrefValue != nil {
		fields = append(fields, cadre_choice_pa.FieldCadrePrefValue)
	}
	if m._EmployeeID != nil {
		fields = append(fields, cadre_choice_pa.FieldEmployeeID)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, cadre_choice_pa.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, cadre_choice_pa.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CadreChoicePAMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cadre_choice_pa.FieldApplication:
		return m.Application()
	case cadre_choice_pa.FieldCadrePrefNo:
		return m.CadrePrefNo()
	case cadre_choice_pa.FieldCadrePrefValue:
		return m.CadrePrefValue()
	case cadre_choice_pa.FieldEmployeeID:
		return m.EmployeeID()
	case cadre_choice_pa.FieldUpdatedAt:
		return m.UpdatedAt()
	case cadre_choice_pa.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CadreChoicePAMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cadre_choice_pa.FieldApplication:
		return m.OldApplication(ctx)
	case cadre_choice_pa.FieldCadrePrefNo:
		return m.OldCadrePrefNo(ctx)
	case cadre_choice_pa.FieldCadrePrefValue:
		return m.OldCadrePrefValue(ctx)
	case cadre_choice_pa.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case cadre_choice_pa.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cadre_choice_pa.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Cadre_Choice_PA field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CadreChoicePAMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cadre_choice_pa.FieldApplication:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplication(v)
		return nil
	case cadre_choice_pa.FieldCadrePrefNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePrefNo(v)
		return nil
	case cadre_choice_pa.FieldCadrePrefValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePrefValue(v)
		return nil
	case cadre_choice_pa.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case cadre_choice_pa.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cadre_choice_pa.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_PA field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CadreChoicePAMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeeID != nil {
		fields = append(fields, cadre_choice_pa.FieldEmployeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CadreChoicePAMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cadre_choice_pa.FieldEmployeeID:
		return m.AddedEmployeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CadreChoicePAMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cadre_choice_pa.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_PA numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CadreChoicePAMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cadre_choice_pa.FieldApplication) {
		fields = append(fields, cadre_choice_pa.FieldApplication)
	}
	if m.FieldCleared(cadre_choice_pa.FieldEmployeeID) {
		fields = append(fields, cadre_choice_pa.FieldEmployeeID)
	}
	if m.FieldCleared(cadre_choice_pa.FieldUpdatedAt) {
		fields = append(fields, cadre_choice_pa.FieldUpdatedAt)
	}
	if m.FieldCleared(cadre_choice_pa.FieldUpdatedBy) {
		fields = append(fields, cadre_choice_pa.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CadreChoicePAMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CadreChoicePAMutation) ClearField(name string) error {
	switch name {
	case cadre_choice_pa.FieldApplication:
		m.ClearApplication()
		return nil
	case cadre_choice_pa.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case cadre_choice_pa.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case cadre_choice_pa.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_PA nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CadreChoicePAMutation) ResetField(name string) error {
	switch name {
	case cadre_choice_pa.FieldApplication:
		m.ResetApplication()
		return nil
	case cadre_choice_pa.FieldCadrePrefNo:
		m.ResetCadrePrefNo()
		return nil
	case cadre_choice_pa.FieldCadrePrefValue:
		m.ResetCadrePrefValue()
		return nil
	case cadre_choice_pa.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case cadre_choice_pa.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cadre_choice_pa.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_PA field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CadreChoicePAMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CadreChoicePAMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CadreChoicePAMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CadreChoicePAMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CadreChoicePAMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CadreChoicePAMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CadreChoicePAMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Cadre_Choice_PA unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CadreChoicePAMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Cadre_Choice_PA edge %s", name)
}

// CadreChoicePMMutation represents an operation that mutates the Cadre_Choice_PM nodes in the graph.
type CadreChoicePMMutation struct {
	config
	op              Op
	typ             string
	id              *int32
	_Application    *string
	_CadrePrefNo    *string
	_CadrePrefValue *string
	_EmployeeID     *int64
	add_EmployeeID  *int64
	_UpdatedAt      *time.Time
	_UpdatedBy      *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Cadre_Choice_PM, error)
	predicates      []predicate.Cadre_Choice_PM
}

var _ ent.Mutation = (*CadreChoicePMMutation)(nil)

// cadreChoicePMOption allows management of the mutation configuration using functional options.
type cadreChoicePMOption func(*CadreChoicePMMutation)

// newCadreChoicePMMutation creates new mutation for the Cadre_Choice_PM entity.
func newCadreChoicePMMutation(c config, op Op, opts ...cadreChoicePMOption) *CadreChoicePMMutation {
	m := &CadreChoicePMMutation{
		config:        c,
		op:            op,
		typ:           TypeCadreChoicePM,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCadre_Choice_PMID sets the ID field of the mutation.
func withCadre_Choice_PMID(id int32) cadreChoicePMOption {
	return func(m *CadreChoicePMMutation) {
		var (
			err   error
			once  sync.Once
			value *Cadre_Choice_PM
		)
		m.oldValue = func(ctx context.Context) (*Cadre_Choice_PM, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cadre_Choice_PM.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCadre_Choice_PM sets the old Cadre_Choice_PM of the mutation.
func withCadre_Choice_PM(node *Cadre_Choice_PM) cadreChoicePMOption {
	return func(m *CadreChoicePMMutation) {
		m.oldValue = func(context.Context) (*Cadre_Choice_PM, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CadreChoicePMMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CadreChoicePMMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Cadre_Choice_PM entities.
func (m *CadreChoicePMMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CadreChoicePMMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CadreChoicePMMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cadre_Choice_PM.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApplication sets the "Application" field.
func (m *CadreChoicePMMutation) SetApplication(s string) {
	m._Application = &s
}

// Application returns the value of the "Application" field in the mutation.
func (m *CadreChoicePMMutation) Application() (r string, exists bool) {
	v := m._Application
	if v == nil {
		return
	}
	return *v, true
}

// OldApplication returns the old "Application" field's value of the Cadre_Choice_PM entity.
// If the Cadre_Choice_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePMMutation) OldApplication(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplication is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplication requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplication: %w", err)
	}
	return oldValue.Application, nil
}

// ClearApplication clears the value of the "Application" field.
func (m *CadreChoicePMMutation) ClearApplication() {
	m._Application = nil
	m.clearedFields[cadre_choice_pm.FieldApplication] = struct{}{}
}

// ApplicationCleared returns if the "Application" field was cleared in this mutation.
func (m *CadreChoicePMMutation) ApplicationCleared() bool {
	_, ok := m.clearedFields[cadre_choice_pm.FieldApplication]
	return ok
}

// ResetApplication resets all changes to the "Application" field.
func (m *CadreChoicePMMutation) ResetApplication() {
	m._Application = nil
	delete(m.clearedFields, cadre_choice_pm.FieldApplication)
}

// SetCadrePrefNo sets the "CadrePrefNo" field.
func (m *CadreChoicePMMutation) SetCadrePrefNo(s string) {
	m._CadrePrefNo = &s
}

// CadrePrefNo returns the value of the "CadrePrefNo" field in the mutation.
func (m *CadreChoicePMMutation) CadrePrefNo() (r string, exists bool) {
	v := m._CadrePrefNo
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePrefNo returns the old "CadrePrefNo" field's value of the Cadre_Choice_PM entity.
// If the Cadre_Choice_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePMMutation) OldCadrePrefNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePrefNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePrefNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePrefNo: %w", err)
	}
	return oldValue.CadrePrefNo, nil
}

// ResetCadrePrefNo resets all changes to the "CadrePrefNo" field.
func (m *CadreChoicePMMutation) ResetCadrePrefNo() {
	m._CadrePrefNo = nil
}

// SetCadrePrefValue sets the "CadrePrefValue" field.
func (m *CadreChoicePMMutation) SetCadrePrefValue(s string) {
	m._CadrePrefValue = &s
}

// CadrePrefValue returns the value of the "CadrePrefValue" field in the mutation.
func (m *CadreChoicePMMutation) CadrePrefValue() (r string, exists bool) {
	v := m._CadrePrefValue
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePrefValue returns the old "CadrePrefValue" field's value of the Cadre_Choice_PM entity.
// If the Cadre_Choice_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePMMutation) OldCadrePrefValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePrefValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePrefValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePrefValue: %w", err)
	}
	return oldValue.CadrePrefValue, nil
}

// ResetCadrePrefValue resets all changes to the "CadrePrefValue" field.
func (m *CadreChoicePMMutation) ResetCadrePrefValue() {
	m._CadrePrefValue = nil
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *CadreChoicePMMutation) SetEmployeeID(i int64) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *CadreChoicePMMutation) EmployeeID() (r int64, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the Cadre_Choice_PM entity.
// If the Cadre_Choice_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePMMutation) OldEmployeeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *CadreChoicePMMutation) AddEmployeeID(i int64) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *CadreChoicePMMutation) AddedEmployeeID() (r int64, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeeID clears the value of the "EmployeeID" field.
func (m *CadreChoicePMMutation) ClearEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	m.clearedFields[cadre_choice_pm.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "EmployeeID" field was cleared in this mutation.
func (m *CadreChoicePMMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[cadre_choice_pm.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *CadreChoicePMMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	delete(m.clearedFields, cadre_choice_pm.FieldEmployeeID)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *CadreChoicePMMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *CadreChoicePMMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Cadre_Choice_PM entity.
// If the Cadre_Choice_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePMMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *CadreChoicePMMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[cadre_choice_pm.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *CadreChoicePMMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[cadre_choice_pm.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *CadreChoicePMMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, cadre_choice_pm.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *CadreChoicePMMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *CadreChoicePMMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the Cadre_Choice_PM entity.
// If the Cadre_Choice_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePMMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *CadreChoicePMMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[cadre_choice_pm.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *CadreChoicePMMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[cadre_choice_pm.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *CadreChoicePMMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, cadre_choice_pm.FieldUpdatedBy)
}

// Where appends a list predicates to the CadreChoicePMMutation builder.
func (m *CadreChoicePMMutation) Where(ps ...predicate.Cadre_Choice_PM) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CadreChoicePMMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CadreChoicePMMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Cadre_Choice_PM, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CadreChoicePMMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CadreChoicePMMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Cadre_Choice_PM).
func (m *CadreChoicePMMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CadreChoicePMMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._Application != nil {
		fields = append(fields, cadre_choice_pm.FieldApplication)
	}
	if m._CadrePrefNo != nil {
		fields = append(fields, cadre_choice_pm.FieldCadrePrefNo)
	}
	if m._CadrePrefValue != nil {
		fields = append(fields, cadre_choice_pm.FieldCadrePrefValue)
	}
	if m._EmployeeID != nil {
		fields = append(fields, cadre_choice_pm.FieldEmployeeID)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, cadre_choice_pm.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, cadre_choice_pm.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CadreChoicePMMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cadre_choice_pm.FieldApplication:
		return m.Application()
	case cadre_choice_pm.FieldCadrePrefNo:
		return m.CadrePrefNo()
	case cadre_choice_pm.FieldCadrePrefValue:
		return m.CadrePrefValue()
	case cadre_choice_pm.FieldEmployeeID:
		return m.EmployeeID()
	case cadre_choice_pm.FieldUpdatedAt:
		return m.UpdatedAt()
	case cadre_choice_pm.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CadreChoicePMMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cadre_choice_pm.FieldApplication:
		return m.OldApplication(ctx)
	case cadre_choice_pm.FieldCadrePrefNo:
		return m.OldCadrePrefNo(ctx)
	case cadre_choice_pm.FieldCadrePrefValue:
		return m.OldCadrePrefValue(ctx)
	case cadre_choice_pm.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case cadre_choice_pm.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cadre_choice_pm.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Cadre_Choice_PM field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CadreChoicePMMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cadre_choice_pm.FieldApplication:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplication(v)
		return nil
	case cadre_choice_pm.FieldCadrePrefNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePrefNo(v)
		return nil
	case cadre_choice_pm.FieldCadrePrefValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePrefValue(v)
		return nil
	case cadre_choice_pm.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case cadre_choice_pm.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cadre_choice_pm.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_PM field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CadreChoicePMMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeeID != nil {
		fields = append(fields, cadre_choice_pm.FieldEmployeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CadreChoicePMMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cadre_choice_pm.FieldEmployeeID:
		return m.AddedEmployeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CadreChoicePMMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cadre_choice_pm.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_PM numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CadreChoicePMMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cadre_choice_pm.FieldApplication) {
		fields = append(fields, cadre_choice_pm.FieldApplication)
	}
	if m.FieldCleared(cadre_choice_pm.FieldEmployeeID) {
		fields = append(fields, cadre_choice_pm.FieldEmployeeID)
	}
	if m.FieldCleared(cadre_choice_pm.FieldUpdatedAt) {
		fields = append(fields, cadre_choice_pm.FieldUpdatedAt)
	}
	if m.FieldCleared(cadre_choice_pm.FieldUpdatedBy) {
		fields = append(fields, cadre_choice_pm.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CadreChoicePMMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CadreChoicePMMutation) ClearField(name string) error {
	switch name {
	case cadre_choice_pm.FieldApplication:
		m.ClearApplication()
		return nil
	case cadre_choice_pm.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case cadre_choice_pm.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case cadre_choice_pm.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_PM nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CadreChoicePMMutation) ResetField(name string) error {
	switch name {
	case cadre_choice_pm.FieldApplication:
		m.ResetApplication()
		return nil
	case cadre_choice_pm.FieldCadrePrefNo:
		m.ResetCadrePrefNo()
		return nil
	case cadre_choice_pm.FieldCadrePrefValue:
		m.ResetCadrePrefValue()
		return nil
	case cadre_choice_pm.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case cadre_choice_pm.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cadre_choice_pm.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_PM field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CadreChoicePMMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CadreChoicePMMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CadreChoicePMMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CadreChoicePMMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CadreChoicePMMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CadreChoicePMMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CadreChoicePMMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Cadre_Choice_PM unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CadreChoicePMMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Cadre_Choice_PM edge %s", name)
}

// CadreChoicePSMutation represents an operation that mutates the Cadre_Choice_PS nodes in the graph.
type CadreChoicePSMutation struct {
	config
	op              Op
	typ             string
	id              *int32
	_Application    *string
	_CadrePrefNo    *string
	_CadrePrefValue *string
	_EmployeeID     *int64
	add_EmployeeID  *int64
	_UpdatedAt      *time.Time
	_UpdatedBy      *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Cadre_Choice_PS, error)
	predicates      []predicate.Cadre_Choice_PS
}

var _ ent.Mutation = (*CadreChoicePSMutation)(nil)

// cadreChoicePSOption allows management of the mutation configuration using functional options.
type cadreChoicePSOption func(*CadreChoicePSMutation)

// newCadreChoicePSMutation creates new mutation for the Cadre_Choice_PS entity.
func newCadreChoicePSMutation(c config, op Op, opts ...cadreChoicePSOption) *CadreChoicePSMutation {
	m := &CadreChoicePSMutation{
		config:        c,
		op:            op,
		typ:           TypeCadreChoicePS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCadre_Choice_PSID sets the ID field of the mutation.
func withCadre_Choice_PSID(id int32) cadreChoicePSOption {
	return func(m *CadreChoicePSMutation) {
		var (
			err   error
			once  sync.Once
			value *Cadre_Choice_PS
		)
		m.oldValue = func(ctx context.Context) (*Cadre_Choice_PS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cadre_Choice_PS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCadre_Choice_PS sets the old Cadre_Choice_PS of the mutation.
func withCadre_Choice_PS(node *Cadre_Choice_PS) cadreChoicePSOption {
	return func(m *CadreChoicePSMutation) {
		m.oldValue = func(context.Context) (*Cadre_Choice_PS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CadreChoicePSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CadreChoicePSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Cadre_Choice_PS entities.
func (m *CadreChoicePSMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CadreChoicePSMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CadreChoicePSMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cadre_Choice_PS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApplication sets the "Application" field.
func (m *CadreChoicePSMutation) SetApplication(s string) {
	m._Application = &s
}

// Application returns the value of the "Application" field in the mutation.
func (m *CadreChoicePSMutation) Application() (r string, exists bool) {
	v := m._Application
	if v == nil {
		return
	}
	return *v, true
}

// OldApplication returns the old "Application" field's value of the Cadre_Choice_PS entity.
// If the Cadre_Choice_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePSMutation) OldApplication(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplication is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplication requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplication: %w", err)
	}
	return oldValue.Application, nil
}

// ClearApplication clears the value of the "Application" field.
func (m *CadreChoicePSMutation) ClearApplication() {
	m._Application = nil
	m.clearedFields[cadre_choice_ps.FieldApplication] = struct{}{}
}

// ApplicationCleared returns if the "Application" field was cleared in this mutation.
func (m *CadreChoicePSMutation) ApplicationCleared() bool {
	_, ok := m.clearedFields[cadre_choice_ps.FieldApplication]
	return ok
}

// ResetApplication resets all changes to the "Application" field.
func (m *CadreChoicePSMutation) ResetApplication() {
	m._Application = nil
	delete(m.clearedFields, cadre_choice_ps.FieldApplication)
}

// SetCadrePrefNo sets the "CadrePrefNo" field.
func (m *CadreChoicePSMutation) SetCadrePrefNo(s string) {
	m._CadrePrefNo = &s
}

// CadrePrefNo returns the value of the "CadrePrefNo" field in the mutation.
func (m *CadreChoicePSMutation) CadrePrefNo() (r string, exists bool) {
	v := m._CadrePrefNo
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePrefNo returns the old "CadrePrefNo" field's value of the Cadre_Choice_PS entity.
// If the Cadre_Choice_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePSMutation) OldCadrePrefNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePrefNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePrefNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePrefNo: %w", err)
	}
	return oldValue.CadrePrefNo, nil
}

// ResetCadrePrefNo resets all changes to the "CadrePrefNo" field.
func (m *CadreChoicePSMutation) ResetCadrePrefNo() {
	m._CadrePrefNo = nil
}

// SetCadrePrefValue sets the "CadrePrefValue" field.
func (m *CadreChoicePSMutation) SetCadrePrefValue(s string) {
	m._CadrePrefValue = &s
}

// CadrePrefValue returns the value of the "CadrePrefValue" field in the mutation.
func (m *CadreChoicePSMutation) CadrePrefValue() (r string, exists bool) {
	v := m._CadrePrefValue
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePrefValue returns the old "CadrePrefValue" field's value of the Cadre_Choice_PS entity.
// If the Cadre_Choice_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePSMutation) OldCadrePrefValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePrefValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePrefValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePrefValue: %w", err)
	}
	return oldValue.CadrePrefValue, nil
}

// ResetCadrePrefValue resets all changes to the "CadrePrefValue" field.
func (m *CadreChoicePSMutation) ResetCadrePrefValue() {
	m._CadrePrefValue = nil
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *CadreChoicePSMutation) SetEmployeeID(i int64) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *CadreChoicePSMutation) EmployeeID() (r int64, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the Cadre_Choice_PS entity.
// If the Cadre_Choice_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePSMutation) OldEmployeeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *CadreChoicePSMutation) AddEmployeeID(i int64) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *CadreChoicePSMutation) AddedEmployeeID() (r int64, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeeID clears the value of the "EmployeeID" field.
func (m *CadreChoicePSMutation) ClearEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	m.clearedFields[cadre_choice_ps.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "EmployeeID" field was cleared in this mutation.
func (m *CadreChoicePSMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[cadre_choice_ps.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *CadreChoicePSMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	delete(m.clearedFields, cadre_choice_ps.FieldEmployeeID)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *CadreChoicePSMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *CadreChoicePSMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Cadre_Choice_PS entity.
// If the Cadre_Choice_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePSMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *CadreChoicePSMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[cadre_choice_ps.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *CadreChoicePSMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[cadre_choice_ps.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *CadreChoicePSMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, cadre_choice_ps.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *CadreChoicePSMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *CadreChoicePSMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the Cadre_Choice_PS entity.
// If the Cadre_Choice_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CadreChoicePSMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *CadreChoicePSMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[cadre_choice_ps.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *CadreChoicePSMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[cadre_choice_ps.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *CadreChoicePSMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, cadre_choice_ps.FieldUpdatedBy)
}

// Where appends a list predicates to the CadreChoicePSMutation builder.
func (m *CadreChoicePSMutation) Where(ps ...predicate.Cadre_Choice_PS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CadreChoicePSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CadreChoicePSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Cadre_Choice_PS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CadreChoicePSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CadreChoicePSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Cadre_Choice_PS).
func (m *CadreChoicePSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CadreChoicePSMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._Application != nil {
		fields = append(fields, cadre_choice_ps.FieldApplication)
	}
	if m._CadrePrefNo != nil {
		fields = append(fields, cadre_choice_ps.FieldCadrePrefNo)
	}
	if m._CadrePrefValue != nil {
		fields = append(fields, cadre_choice_ps.FieldCadrePrefValue)
	}
	if m._EmployeeID != nil {
		fields = append(fields, cadre_choice_ps.FieldEmployeeID)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, cadre_choice_ps.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, cadre_choice_ps.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CadreChoicePSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cadre_choice_ps.FieldApplication:
		return m.Application()
	case cadre_choice_ps.FieldCadrePrefNo:
		return m.CadrePrefNo()
	case cadre_choice_ps.FieldCadrePrefValue:
		return m.CadrePrefValue()
	case cadre_choice_ps.FieldEmployeeID:
		return m.EmployeeID()
	case cadre_choice_ps.FieldUpdatedAt:
		return m.UpdatedAt()
	case cadre_choice_ps.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CadreChoicePSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cadre_choice_ps.FieldApplication:
		return m.OldApplication(ctx)
	case cadre_choice_ps.FieldCadrePrefNo:
		return m.OldCadrePrefNo(ctx)
	case cadre_choice_ps.FieldCadrePrefValue:
		return m.OldCadrePrefValue(ctx)
	case cadre_choice_ps.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case cadre_choice_ps.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cadre_choice_ps.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Cadre_Choice_PS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CadreChoicePSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cadre_choice_ps.FieldApplication:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplication(v)
		return nil
	case cadre_choice_ps.FieldCadrePrefNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePrefNo(v)
		return nil
	case cadre_choice_ps.FieldCadrePrefValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePrefValue(v)
		return nil
	case cadre_choice_ps.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case cadre_choice_ps.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cadre_choice_ps.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_PS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CadreChoicePSMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeeID != nil {
		fields = append(fields, cadre_choice_ps.FieldEmployeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CadreChoicePSMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cadre_choice_ps.FieldEmployeeID:
		return m.AddedEmployeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CadreChoicePSMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cadre_choice_ps.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_PS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CadreChoicePSMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cadre_choice_ps.FieldApplication) {
		fields = append(fields, cadre_choice_ps.FieldApplication)
	}
	if m.FieldCleared(cadre_choice_ps.FieldEmployeeID) {
		fields = append(fields, cadre_choice_ps.FieldEmployeeID)
	}
	if m.FieldCleared(cadre_choice_ps.FieldUpdatedAt) {
		fields = append(fields, cadre_choice_ps.FieldUpdatedAt)
	}
	if m.FieldCleared(cadre_choice_ps.FieldUpdatedBy) {
		fields = append(fields, cadre_choice_ps.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CadreChoicePSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CadreChoicePSMutation) ClearField(name string) error {
	switch name {
	case cadre_choice_ps.FieldApplication:
		m.ClearApplication()
		return nil
	case cadre_choice_ps.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case cadre_choice_ps.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case cadre_choice_ps.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_PS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CadreChoicePSMutation) ResetField(name string) error {
	switch name {
	case cadre_choice_ps.FieldApplication:
		m.ResetApplication()
		return nil
	case cadre_choice_ps.FieldCadrePrefNo:
		m.ResetCadrePrefNo()
		return nil
	case cadre_choice_ps.FieldCadrePrefValue:
		m.ResetCadrePrefValue()
		return nil
	case cadre_choice_ps.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case cadre_choice_ps.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cadre_choice_ps.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Cadre_Choice_PS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CadreChoicePSMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CadreChoicePSMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CadreChoicePSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CadreChoicePSMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CadreChoicePSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CadreChoicePSMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CadreChoicePSMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Cadre_Choice_PS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CadreChoicePSMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Cadre_Choice_PS edge %s", name)
}

// CenterMutation represents an operation that mutates the Center nodes in the graph.
type CenterMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int32
	_CenterName          *string
	clearedFields        map[string]struct{}
	applications         map[int32]struct{}
	removedapplications  map[int32]struct{}
	clearedapplications  bool
	nodal_officer        *int32
	clearednodal_officer bool
	notification         *int32
	clearednotification  bool
	done                 bool
	oldValue             func(context.Context) (*Center, error)
	predicates           []predicate.Center
}

var _ ent.Mutation = (*CenterMutation)(nil)

// centerOption allows management of the mutation configuration using functional options.
type centerOption func(*CenterMutation)

// newCenterMutation creates new mutation for the Center entity.
func newCenterMutation(c config, op Op, opts ...centerOption) *CenterMutation {
	m := &CenterMutation{
		config:        c,
		op:            op,
		typ:           TypeCenter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCenterID sets the ID field of the mutation.
func withCenterID(id int32) centerOption {
	return func(m *CenterMutation) {
		var (
			err   error
			once  sync.Once
			value *Center
		)
		m.oldValue = func(ctx context.Context) (*Center, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Center.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCenter sets the old Center of the mutation.
func withCenter(node *Center) centerOption {
	return func(m *CenterMutation) {
		m.oldValue = func(context.Context) (*Center, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CenterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CenterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Center entities.
func (m *CenterMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CenterMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CenterMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Center.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNotifyCode sets the "NotifyCode" field.
func (m *CenterMutation) SetNotifyCode(i int32) {
	m.notification = &i
}

// NotifyCode returns the value of the "NotifyCode" field in the mutation.
func (m *CenterMutation) NotifyCode() (r int32, exists bool) {
	v := m.notification
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyCode returns the old "NotifyCode" field's value of the Center entity.
// If the Center object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CenterMutation) OldNotifyCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyCode: %w", err)
	}
	return oldValue.NotifyCode, nil
}

// ClearNotifyCode clears the value of the "NotifyCode" field.
func (m *CenterMutation) ClearNotifyCode() {
	m.notification = nil
	m.clearedFields[center.FieldNotifyCode] = struct{}{}
}

// NotifyCodeCleared returns if the "NotifyCode" field was cleared in this mutation.
func (m *CenterMutation) NotifyCodeCleared() bool {
	_, ok := m.clearedFields[center.FieldNotifyCode]
	return ok
}

// ResetNotifyCode resets all changes to the "NotifyCode" field.
func (m *CenterMutation) ResetNotifyCode() {
	m.notification = nil
	delete(m.clearedFields, center.FieldNotifyCode)
}

// SetNodalOfficerCode sets the "NodalOfficerCode" field.
func (m *CenterMutation) SetNodalOfficerCode(i int32) {
	m.nodal_officer = &i
}

// NodalOfficerCode returns the value of the "NodalOfficerCode" field in the mutation.
func (m *CenterMutation) NodalOfficerCode() (r int32, exists bool) {
	v := m.nodal_officer
	if v == nil {
		return
	}
	return *v, true
}

// OldNodalOfficerCode returns the old "NodalOfficerCode" field's value of the Center entity.
// If the Center object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CenterMutation) OldNodalOfficerCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodalOfficerCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodalOfficerCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodalOfficerCode: %w", err)
	}
	return oldValue.NodalOfficerCode, nil
}

// ClearNodalOfficerCode clears the value of the "NodalOfficerCode" field.
func (m *CenterMutation) ClearNodalOfficerCode() {
	m.nodal_officer = nil
	m.clearedFields[center.FieldNodalOfficerCode] = struct{}{}
}

// NodalOfficerCodeCleared returns if the "NodalOfficerCode" field was cleared in this mutation.
func (m *CenterMutation) NodalOfficerCodeCleared() bool {
	_, ok := m.clearedFields[center.FieldNodalOfficerCode]
	return ok
}

// ResetNodalOfficerCode resets all changes to the "NodalOfficerCode" field.
func (m *CenterMutation) ResetNodalOfficerCode() {
	m.nodal_officer = nil
	delete(m.clearedFields, center.FieldNodalOfficerCode)
}

// SetCenterName sets the "CenterName" field.
func (m *CenterMutation) SetCenterName(s string) {
	m._CenterName = &s
}

// CenterName returns the value of the "CenterName" field in the mutation.
func (m *CenterMutation) CenterName() (r string, exists bool) {
	v := m._CenterName
	if v == nil {
		return
	}
	return *v, true
}

// OldCenterName returns the old "CenterName" field's value of the Center entity.
// If the Center object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CenterMutation) OldCenterName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCenterName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCenterName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCenterName: %w", err)
	}
	return oldValue.CenterName, nil
}

// ResetCenterName resets all changes to the "CenterName" field.
func (m *CenterMutation) ResetCenterName() {
	m._CenterName = nil
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *CenterMutation) AddApplicationIDs(ids ...int32) {
	if m.applications == nil {
		m.applications = make(map[int32]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *CenterMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *CenterMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *CenterMutation) RemoveApplicationIDs(ids ...int32) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *CenterMutation) RemovedApplicationsIDs() (ids []int32) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *CenterMutation) ApplicationsIDs() (ids []int32) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *CenterMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// SetNodalOfficerID sets the "nodal_officer" edge to the NodalOfficer entity by id.
func (m *CenterMutation) SetNodalOfficerID(id int32) {
	m.nodal_officer = &id
}

// ClearNodalOfficer clears the "nodal_officer" edge to the NodalOfficer entity.
func (m *CenterMutation) ClearNodalOfficer() {
	m.clearednodal_officer = true
}

// NodalOfficerCleared reports if the "nodal_officer" edge to the NodalOfficer entity was cleared.
func (m *CenterMutation) NodalOfficerCleared() bool {
	return m.NodalOfficerCodeCleared() || m.clearednodal_officer
}

// NodalOfficerID returns the "nodal_officer" edge ID in the mutation.
func (m *CenterMutation) NodalOfficerID() (id int32, exists bool) {
	if m.nodal_officer != nil {
		return *m.nodal_officer, true
	}
	return
}

// NodalOfficerIDs returns the "nodal_officer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodalOfficerID instead. It exists only for internal usage by the builders.
func (m *CenterMutation) NodalOfficerIDs() (ids []int32) {
	if id := m.nodal_officer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNodalOfficer resets all changes to the "nodal_officer" edge.
func (m *CenterMutation) ResetNodalOfficer() {
	m.nodal_officer = nil
	m.clearednodal_officer = false
}

// SetNotificationID sets the "notification" edge to the Notification entity by id.
func (m *CenterMutation) SetNotificationID(id int32) {
	m.notification = &id
}

// ClearNotification clears the "notification" edge to the Notification entity.
func (m *CenterMutation) ClearNotification() {
	m.clearednotification = true
}

// NotificationCleared reports if the "notification" edge to the Notification entity was cleared.
func (m *CenterMutation) NotificationCleared() bool {
	return m.NotifyCodeCleared() || m.clearednotification
}

// NotificationID returns the "notification" edge ID in the mutation.
func (m *CenterMutation) NotificationID() (id int32, exists bool) {
	if m.notification != nil {
		return *m.notification, true
	}
	return
}

// NotificationIDs returns the "notification" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotificationID instead. It exists only for internal usage by the builders.
func (m *CenterMutation) NotificationIDs() (ids []int32) {
	if id := m.notification; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotification resets all changes to the "notification" edge.
func (m *CenterMutation) ResetNotification() {
	m.notification = nil
	m.clearednotification = false
}

// Where appends a list predicates to the CenterMutation builder.
func (m *CenterMutation) Where(ps ...predicate.Center) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CenterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CenterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Center, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CenterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CenterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Center).
func (m *CenterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CenterMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.notification != nil {
		fields = append(fields, center.FieldNotifyCode)
	}
	if m.nodal_officer != nil {
		fields = append(fields, center.FieldNodalOfficerCode)
	}
	if m._CenterName != nil {
		fields = append(fields, center.FieldCenterName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CenterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case center.FieldNotifyCode:
		return m.NotifyCode()
	case center.FieldNodalOfficerCode:
		return m.NodalOfficerCode()
	case center.FieldCenterName:
		return m.CenterName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CenterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case center.FieldNotifyCode:
		return m.OldNotifyCode(ctx)
	case center.FieldNodalOfficerCode:
		return m.OldNodalOfficerCode(ctx)
	case center.FieldCenterName:
		return m.OldCenterName(ctx)
	}
	return nil, fmt.Errorf("unknown Center field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CenterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case center.FieldNotifyCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyCode(v)
		return nil
	case center.FieldNodalOfficerCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodalOfficerCode(v)
		return nil
	case center.FieldCenterName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCenterName(v)
		return nil
	}
	return fmt.Errorf("unknown Center field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CenterMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CenterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CenterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Center numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CenterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(center.FieldNotifyCode) {
		fields = append(fields, center.FieldNotifyCode)
	}
	if m.FieldCleared(center.FieldNodalOfficerCode) {
		fields = append(fields, center.FieldNodalOfficerCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CenterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CenterMutation) ClearField(name string) error {
	switch name {
	case center.FieldNotifyCode:
		m.ClearNotifyCode()
		return nil
	case center.FieldNodalOfficerCode:
		m.ClearNodalOfficerCode()
		return nil
	}
	return fmt.Errorf("unknown Center nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CenterMutation) ResetField(name string) error {
	switch name {
	case center.FieldNotifyCode:
		m.ResetNotifyCode()
		return nil
	case center.FieldNodalOfficerCode:
		m.ResetNodalOfficerCode()
		return nil
	case center.FieldCenterName:
		m.ResetCenterName()
		return nil
	}
	return fmt.Errorf("unknown Center field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CenterMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.applications != nil {
		edges = append(edges, center.EdgeApplications)
	}
	if m.nodal_officer != nil {
		edges = append(edges, center.EdgeNodalOfficer)
	}
	if m.notification != nil {
		edges = append(edges, center.EdgeNotification)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CenterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case center.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	case center.EdgeNodalOfficer:
		if id := m.nodal_officer; id != nil {
			return []ent.Value{*id}
		}
	case center.EdgeNotification:
		if id := m.notification; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CenterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedapplications != nil {
		edges = append(edges, center.EdgeApplications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CenterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case center.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CenterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapplications {
		edges = append(edges, center.EdgeApplications)
	}
	if m.clearednodal_officer {
		edges = append(edges, center.EdgeNodalOfficer)
	}
	if m.clearednotification {
		edges = append(edges, center.EdgeNotification)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CenterMutation) EdgeCleared(name string) bool {
	switch name {
	case center.EdgeApplications:
		return m.clearedapplications
	case center.EdgeNodalOfficer:
		return m.clearednodal_officer
	case center.EdgeNotification:
		return m.clearednotification
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CenterMutation) ClearEdge(name string) error {
	switch name {
	case center.EdgeNodalOfficer:
		m.ClearNodalOfficer()
		return nil
	case center.EdgeNotification:
		m.ClearNotification()
		return nil
	}
	return fmt.Errorf("unknown Center unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CenterMutation) ResetEdge(name string) error {
	switch name {
	case center.EdgeApplications:
		m.ResetApplications()
		return nil
	case center.EdgeNodalOfficer:
		m.ResetNodalOfficer()
		return nil
	case center.EdgeNotification:
		m.ResetNotification()
		return nil
	}
	return fmt.Errorf("unknown Center edge %s", name)
}

// CircleMasterMutation represents an operation that mutates the CircleMaster nodes in the graph.
type CircleMasterMutation struct {
	config
	op                Op
	typ               string
	id                *int32
	_CircleCode       *int32
	add_CircleCode    *int32
	_CircleOfficeId   *string
	_CircleOfficeName *string
	_OfficeType       *string
	_EmailID          *string
	_MobileNumber     *int32
	add_MobileNumber  *int32
	clearedFields     map[string]struct{}
	region_ref        map[int32]struct{}
	removedregion_ref map[int32]struct{}
	clearedregion_ref bool
	circle_ref        map[int32]struct{}
	removedcircle_ref map[int32]struct{}
	clearedcircle_ref bool
	done              bool
	oldValue          func(context.Context) (*CircleMaster, error)
	predicates        []predicate.CircleMaster
}

var _ ent.Mutation = (*CircleMasterMutation)(nil)

// circlemasterOption allows management of the mutation configuration using functional options.
type circlemasterOption func(*CircleMasterMutation)

// newCircleMasterMutation creates new mutation for the CircleMaster entity.
func newCircleMasterMutation(c config, op Op, opts ...circlemasterOption) *CircleMasterMutation {
	m := &CircleMasterMutation{
		config:        c,
		op:            op,
		typ:           TypeCircleMaster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCircleMasterID sets the ID field of the mutation.
func withCircleMasterID(id int32) circlemasterOption {
	return func(m *CircleMasterMutation) {
		var (
			err   error
			once  sync.Once
			value *CircleMaster
		)
		m.oldValue = func(ctx context.Context) (*CircleMaster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CircleMaster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCircleMaster sets the old CircleMaster of the mutation.
func withCircleMaster(node *CircleMaster) circlemasterOption {
	return func(m *CircleMasterMutation) {
		m.oldValue = func(context.Context) (*CircleMaster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CircleMasterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CircleMasterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CircleMaster entities.
func (m *CircleMasterMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CircleMasterMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CircleMasterMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CircleMaster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCircleCode sets the "CircleCode" field.
func (m *CircleMasterMutation) SetCircleCode(i int32) {
	m._CircleCode = &i
	m.add_CircleCode = nil
}

// CircleCode returns the value of the "CircleCode" field in the mutation.
func (m *CircleMasterMutation) CircleCode() (r int32, exists bool) {
	v := m._CircleCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleCode returns the old "CircleCode" field's value of the CircleMaster entity.
// If the CircleMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CircleMasterMutation) OldCircleCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleCode: %w", err)
	}
	return oldValue.CircleCode, nil
}

// AddCircleCode adds i to the "CircleCode" field.
func (m *CircleMasterMutation) AddCircleCode(i int32) {
	if m.add_CircleCode != nil {
		*m.add_CircleCode += i
	} else {
		m.add_CircleCode = &i
	}
}

// AddedCircleCode returns the value that was added to the "CircleCode" field in this mutation.
func (m *CircleMasterMutation) AddedCircleCode() (r int32, exists bool) {
	v := m.add_CircleCode
	if v == nil {
		return
	}
	return *v, true
}

// ResetCircleCode resets all changes to the "CircleCode" field.
func (m *CircleMasterMutation) ResetCircleCode() {
	m._CircleCode = nil
	m.add_CircleCode = nil
}

// SetCircleOfficeId sets the "CircleOfficeId" field.
func (m *CircleMasterMutation) SetCircleOfficeId(s string) {
	m._CircleOfficeId = &s
}

// CircleOfficeId returns the value of the "CircleOfficeId" field in the mutation.
func (m *CircleMasterMutation) CircleOfficeId() (r string, exists bool) {
	v := m._CircleOfficeId
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleOfficeId returns the old "CircleOfficeId" field's value of the CircleMaster entity.
// If the CircleMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CircleMasterMutation) OldCircleOfficeId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleOfficeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleOfficeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleOfficeId: %w", err)
	}
	return oldValue.CircleOfficeId, nil
}

// ResetCircleOfficeId resets all changes to the "CircleOfficeId" field.
func (m *CircleMasterMutation) ResetCircleOfficeId() {
	m._CircleOfficeId = nil
}

// SetCircleOfficeName sets the "CircleOfficeName" field.
func (m *CircleMasterMutation) SetCircleOfficeName(s string) {
	m._CircleOfficeName = &s
}

// CircleOfficeName returns the value of the "CircleOfficeName" field in the mutation.
func (m *CircleMasterMutation) CircleOfficeName() (r string, exists bool) {
	v := m._CircleOfficeName
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleOfficeName returns the old "CircleOfficeName" field's value of the CircleMaster entity.
// If the CircleMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CircleMasterMutation) OldCircleOfficeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleOfficeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleOfficeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleOfficeName: %w", err)
	}
	return oldValue.CircleOfficeName, nil
}

// ResetCircleOfficeName resets all changes to the "CircleOfficeName" field.
func (m *CircleMasterMutation) ResetCircleOfficeName() {
	m._CircleOfficeName = nil
}

// SetOfficeType sets the "OfficeType" field.
func (m *CircleMasterMutation) SetOfficeType(s string) {
	m._OfficeType = &s
}

// OfficeType returns the value of the "OfficeType" field in the mutation.
func (m *CircleMasterMutation) OfficeType() (r string, exists bool) {
	v := m._OfficeType
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeType returns the old "OfficeType" field's value of the CircleMaster entity.
// If the CircleMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CircleMasterMutation) OldOfficeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeType: %w", err)
	}
	return oldValue.OfficeType, nil
}

// ResetOfficeType resets all changes to the "OfficeType" field.
func (m *CircleMasterMutation) ResetOfficeType() {
	m._OfficeType = nil
}

// SetEmailID sets the "EmailID" field.
func (m *CircleMasterMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *CircleMasterMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the CircleMaster entity.
// If the CircleMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CircleMasterMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ClearEmailID clears the value of the "EmailID" field.
func (m *CircleMasterMutation) ClearEmailID() {
	m._EmailID = nil
	m.clearedFields[circlemaster.FieldEmailID] = struct{}{}
}

// EmailIDCleared returns if the "EmailID" field was cleared in this mutation.
func (m *CircleMasterMutation) EmailIDCleared() bool {
	_, ok := m.clearedFields[circlemaster.FieldEmailID]
	return ok
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *CircleMasterMutation) ResetEmailID() {
	m._EmailID = nil
	delete(m.clearedFields, circlemaster.FieldEmailID)
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *CircleMasterMutation) SetMobileNumber(i int32) {
	m._MobileNumber = &i
	m.add_MobileNumber = nil
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *CircleMasterMutation) MobileNumber() (r int32, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the CircleMaster entity.
// If the CircleMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CircleMasterMutation) OldMobileNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// AddMobileNumber adds i to the "MobileNumber" field.
func (m *CircleMasterMutation) AddMobileNumber(i int32) {
	if m.add_MobileNumber != nil {
		*m.add_MobileNumber += i
	} else {
		m.add_MobileNumber = &i
	}
}

// AddedMobileNumber returns the value that was added to the "MobileNumber" field in this mutation.
func (m *CircleMasterMutation) AddedMobileNumber() (r int32, exists bool) {
	v := m.add_MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearMobileNumber clears the value of the "MobileNumber" field.
func (m *CircleMasterMutation) ClearMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	m.clearedFields[circlemaster.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "MobileNumber" field was cleared in this mutation.
func (m *CircleMasterMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[circlemaster.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *CircleMasterMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	delete(m.clearedFields, circlemaster.FieldMobileNumber)
}

// AddRegionRefIDs adds the "region_ref" edge to the RegionMaster entity by ids.
func (m *CircleMasterMutation) AddRegionRefIDs(ids ...int32) {
	if m.region_ref == nil {
		m.region_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.region_ref[ids[i]] = struct{}{}
	}
}

// ClearRegionRef clears the "region_ref" edge to the RegionMaster entity.
func (m *CircleMasterMutation) ClearRegionRef() {
	m.clearedregion_ref = true
}

// RegionRefCleared reports if the "region_ref" edge to the RegionMaster entity was cleared.
func (m *CircleMasterMutation) RegionRefCleared() bool {
	return m.clearedregion_ref
}

// RemoveRegionRefIDs removes the "region_ref" edge to the RegionMaster entity by IDs.
func (m *CircleMasterMutation) RemoveRegionRefIDs(ids ...int32) {
	if m.removedregion_ref == nil {
		m.removedregion_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.region_ref, ids[i])
		m.removedregion_ref[ids[i]] = struct{}{}
	}
}

// RemovedRegionRef returns the removed IDs of the "region_ref" edge to the RegionMaster entity.
func (m *CircleMasterMutation) RemovedRegionRefIDs() (ids []int32) {
	for id := range m.removedregion_ref {
		ids = append(ids, id)
	}
	return
}

// RegionRefIDs returns the "region_ref" edge IDs in the mutation.
func (m *CircleMasterMutation) RegionRefIDs() (ids []int32) {
	for id := range m.region_ref {
		ids = append(ids, id)
	}
	return
}

// ResetRegionRef resets all changes to the "region_ref" edge.
func (m *CircleMasterMutation) ResetRegionRef() {
	m.region_ref = nil
	m.clearedregion_ref = false
	m.removedregion_ref = nil
}

// AddCircleRefIDs adds the "circle_ref" edge to the Facility entity by ids.
func (m *CircleMasterMutation) AddCircleRefIDs(ids ...int32) {
	if m.circle_ref == nil {
		m.circle_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.circle_ref[ids[i]] = struct{}{}
	}
}

// ClearCircleRef clears the "circle_ref" edge to the Facility entity.
func (m *CircleMasterMutation) ClearCircleRef() {
	m.clearedcircle_ref = true
}

// CircleRefCleared reports if the "circle_ref" edge to the Facility entity was cleared.
func (m *CircleMasterMutation) CircleRefCleared() bool {
	return m.clearedcircle_ref
}

// RemoveCircleRefIDs removes the "circle_ref" edge to the Facility entity by IDs.
func (m *CircleMasterMutation) RemoveCircleRefIDs(ids ...int32) {
	if m.removedcircle_ref == nil {
		m.removedcircle_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.circle_ref, ids[i])
		m.removedcircle_ref[ids[i]] = struct{}{}
	}
}

// RemovedCircleRef returns the removed IDs of the "circle_ref" edge to the Facility entity.
func (m *CircleMasterMutation) RemovedCircleRefIDs() (ids []int32) {
	for id := range m.removedcircle_ref {
		ids = append(ids, id)
	}
	return
}

// CircleRefIDs returns the "circle_ref" edge IDs in the mutation.
func (m *CircleMasterMutation) CircleRefIDs() (ids []int32) {
	for id := range m.circle_ref {
		ids = append(ids, id)
	}
	return
}

// ResetCircleRef resets all changes to the "circle_ref" edge.
func (m *CircleMasterMutation) ResetCircleRef() {
	m.circle_ref = nil
	m.clearedcircle_ref = false
	m.removedcircle_ref = nil
}

// Where appends a list predicates to the CircleMasterMutation builder.
func (m *CircleMasterMutation) Where(ps ...predicate.CircleMaster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CircleMasterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CircleMasterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CircleMaster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CircleMasterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CircleMasterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CircleMaster).
func (m *CircleMasterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CircleMasterMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._CircleCode != nil {
		fields = append(fields, circlemaster.FieldCircleCode)
	}
	if m._CircleOfficeId != nil {
		fields = append(fields, circlemaster.FieldCircleOfficeId)
	}
	if m._CircleOfficeName != nil {
		fields = append(fields, circlemaster.FieldCircleOfficeName)
	}
	if m._OfficeType != nil {
		fields = append(fields, circlemaster.FieldOfficeType)
	}
	if m._EmailID != nil {
		fields = append(fields, circlemaster.FieldEmailID)
	}
	if m._MobileNumber != nil {
		fields = append(fields, circlemaster.FieldMobileNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CircleMasterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case circlemaster.FieldCircleCode:
		return m.CircleCode()
	case circlemaster.FieldCircleOfficeId:
		return m.CircleOfficeId()
	case circlemaster.FieldCircleOfficeName:
		return m.CircleOfficeName()
	case circlemaster.FieldOfficeType:
		return m.OfficeType()
	case circlemaster.FieldEmailID:
		return m.EmailID()
	case circlemaster.FieldMobileNumber:
		return m.MobileNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CircleMasterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case circlemaster.FieldCircleCode:
		return m.OldCircleCode(ctx)
	case circlemaster.FieldCircleOfficeId:
		return m.OldCircleOfficeId(ctx)
	case circlemaster.FieldCircleOfficeName:
		return m.OldCircleOfficeName(ctx)
	case circlemaster.FieldOfficeType:
		return m.OldOfficeType(ctx)
	case circlemaster.FieldEmailID:
		return m.OldEmailID(ctx)
	case circlemaster.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	}
	return nil, fmt.Errorf("unknown CircleMaster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CircleMasterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case circlemaster.FieldCircleCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleCode(v)
		return nil
	case circlemaster.FieldCircleOfficeId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleOfficeId(v)
		return nil
	case circlemaster.FieldCircleOfficeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleOfficeName(v)
		return nil
	case circlemaster.FieldOfficeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeType(v)
		return nil
	case circlemaster.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case circlemaster.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	}
	return fmt.Errorf("unknown CircleMaster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CircleMasterMutation) AddedFields() []string {
	var fields []string
	if m.add_CircleCode != nil {
		fields = append(fields, circlemaster.FieldCircleCode)
	}
	if m.add_MobileNumber != nil {
		fields = append(fields, circlemaster.FieldMobileNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CircleMasterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case circlemaster.FieldCircleCode:
		return m.AddedCircleCode()
	case circlemaster.FieldMobileNumber:
		return m.AddedMobileNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CircleMasterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case circlemaster.FieldCircleCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCircleCode(v)
		return nil
	case circlemaster.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMobileNumber(v)
		return nil
	}
	return fmt.Errorf("unknown CircleMaster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CircleMasterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(circlemaster.FieldEmailID) {
		fields = append(fields, circlemaster.FieldEmailID)
	}
	if m.FieldCleared(circlemaster.FieldMobileNumber) {
		fields = append(fields, circlemaster.FieldMobileNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CircleMasterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CircleMasterMutation) ClearField(name string) error {
	switch name {
	case circlemaster.FieldEmailID:
		m.ClearEmailID()
		return nil
	case circlemaster.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	}
	return fmt.Errorf("unknown CircleMaster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CircleMasterMutation) ResetField(name string) error {
	switch name {
	case circlemaster.FieldCircleCode:
		m.ResetCircleCode()
		return nil
	case circlemaster.FieldCircleOfficeId:
		m.ResetCircleOfficeId()
		return nil
	case circlemaster.FieldCircleOfficeName:
		m.ResetCircleOfficeName()
		return nil
	case circlemaster.FieldOfficeType:
		m.ResetOfficeType()
		return nil
	case circlemaster.FieldEmailID:
		m.ResetEmailID()
		return nil
	case circlemaster.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	}
	return fmt.Errorf("unknown CircleMaster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CircleMasterMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.region_ref != nil {
		edges = append(edges, circlemaster.EdgeRegionRef)
	}
	if m.circle_ref != nil {
		edges = append(edges, circlemaster.EdgeCircleRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CircleMasterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case circlemaster.EdgeRegionRef:
		ids := make([]ent.Value, 0, len(m.region_ref))
		for id := range m.region_ref {
			ids = append(ids, id)
		}
		return ids
	case circlemaster.EdgeCircleRef:
		ids := make([]ent.Value, 0, len(m.circle_ref))
		for id := range m.circle_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CircleMasterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedregion_ref != nil {
		edges = append(edges, circlemaster.EdgeRegionRef)
	}
	if m.removedcircle_ref != nil {
		edges = append(edges, circlemaster.EdgeCircleRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CircleMasterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case circlemaster.EdgeRegionRef:
		ids := make([]ent.Value, 0, len(m.removedregion_ref))
		for id := range m.removedregion_ref {
			ids = append(ids, id)
		}
		return ids
	case circlemaster.EdgeCircleRef:
		ids := make([]ent.Value, 0, len(m.removedcircle_ref))
		for id := range m.removedcircle_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CircleMasterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedregion_ref {
		edges = append(edges, circlemaster.EdgeRegionRef)
	}
	if m.clearedcircle_ref {
		edges = append(edges, circlemaster.EdgeCircleRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CircleMasterMutation) EdgeCleared(name string) bool {
	switch name {
	case circlemaster.EdgeRegionRef:
		return m.clearedregion_ref
	case circlemaster.EdgeCircleRef:
		return m.clearedcircle_ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CircleMasterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CircleMaster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CircleMasterMutation) ResetEdge(name string) error {
	switch name {
	case circlemaster.EdgeRegionRef:
		m.ResetRegionRef()
		return nil
	case circlemaster.EdgeCircleRef:
		m.ResetCircleRef()
		return nil
	}
	return fmt.Errorf("unknown CircleMaster edge %s", name)
}

// DirectorateUsersMutation represents an operation that mutates the DirectorateUsers nodes in the graph.
type DirectorateUsersMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int32
	_Role                *string
	_EmployeedID         *int32
	add_EmployeedID      *int32
	_EmployeeName        *string
	_EmailId             *string
	_MobileNumber        *int64
	add_MobileNumber     *int64
	_SequenceNumber      *int32
	add_SequenceNumber   *int32
	_Status              *string
	clearedFields        map[string]struct{}
	employee_user        map[int32]struct{}
	removedemployee_user map[int32]struct{}
	clearedemployee_user bool
	done                 bool
	oldValue             func(context.Context) (*DirectorateUsers, error)
	predicates           []predicate.DirectorateUsers
}

var _ ent.Mutation = (*DirectorateUsersMutation)(nil)

// directorateusersOption allows management of the mutation configuration using functional options.
type directorateusersOption func(*DirectorateUsersMutation)

// newDirectorateUsersMutation creates new mutation for the DirectorateUsers entity.
func newDirectorateUsersMutation(c config, op Op, opts ...directorateusersOption) *DirectorateUsersMutation {
	m := &DirectorateUsersMutation{
		config:        c,
		op:            op,
		typ:           TypeDirectorateUsers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDirectorateUsersID sets the ID field of the mutation.
func withDirectorateUsersID(id int32) directorateusersOption {
	return func(m *DirectorateUsersMutation) {
		var (
			err   error
			once  sync.Once
			value *DirectorateUsers
		)
		m.oldValue = func(ctx context.Context) (*DirectorateUsers, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DirectorateUsers.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDirectorateUsers sets the old DirectorateUsers of the mutation.
func withDirectorateUsers(node *DirectorateUsers) directorateusersOption {
	return func(m *DirectorateUsersMutation) {
		m.oldValue = func(context.Context) (*DirectorateUsers, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DirectorateUsersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DirectorateUsersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DirectorateUsers entities.
func (m *DirectorateUsersMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DirectorateUsersMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DirectorateUsersMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DirectorateUsers.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRole sets the "Role" field.
func (m *DirectorateUsersMutation) SetRole(s string) {
	m._Role = &s
}

// Role returns the value of the "Role" field in the mutation.
func (m *DirectorateUsersMutation) Role() (r string, exists bool) {
	v := m._Role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "Role" field's value of the DirectorateUsers entity.
// If the DirectorateUsers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectorateUsersMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "Role" field.
func (m *DirectorateUsersMutation) ResetRole() {
	m._Role = nil
}

// SetEmployeedID sets the "EmployeedID" field.
func (m *DirectorateUsersMutation) SetEmployeedID(i int32) {
	m._EmployeedID = &i
	m.add_EmployeedID = nil
}

// EmployeedID returns the value of the "EmployeedID" field in the mutation.
func (m *DirectorateUsersMutation) EmployeedID() (r int32, exists bool) {
	v := m._EmployeedID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeedID returns the old "EmployeedID" field's value of the DirectorateUsers entity.
// If the DirectorateUsers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectorateUsersMutation) OldEmployeedID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeedID: %w", err)
	}
	return oldValue.EmployeedID, nil
}

// AddEmployeedID adds i to the "EmployeedID" field.
func (m *DirectorateUsersMutation) AddEmployeedID(i int32) {
	if m.add_EmployeedID != nil {
		*m.add_EmployeedID += i
	} else {
		m.add_EmployeedID = &i
	}
}

// AddedEmployeedID returns the value that was added to the "EmployeedID" field in this mutation.
func (m *DirectorateUsersMutation) AddedEmployeedID() (r int32, exists bool) {
	v := m.add_EmployeedID
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmployeedID resets all changes to the "EmployeedID" field.
func (m *DirectorateUsersMutation) ResetEmployeedID() {
	m._EmployeedID = nil
	m.add_EmployeedID = nil
}

// SetEmployeeName sets the "EmployeeName" field.
func (m *DirectorateUsersMutation) SetEmployeeName(s string) {
	m._EmployeeName = &s
}

// EmployeeName returns the value of the "EmployeeName" field in the mutation.
func (m *DirectorateUsersMutation) EmployeeName() (r string, exists bool) {
	v := m._EmployeeName
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeName returns the old "EmployeeName" field's value of the DirectorateUsers entity.
// If the DirectorateUsers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectorateUsersMutation) OldEmployeeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeName: %w", err)
	}
	return oldValue.EmployeeName, nil
}

// ResetEmployeeName resets all changes to the "EmployeeName" field.
func (m *DirectorateUsersMutation) ResetEmployeeName() {
	m._EmployeeName = nil
}

// SetEmailId sets the "EmailId" field.
func (m *DirectorateUsersMutation) SetEmailId(s string) {
	m._EmailId = &s
}

// EmailId returns the value of the "EmailId" field in the mutation.
func (m *DirectorateUsersMutation) EmailId() (r string, exists bool) {
	v := m._EmailId
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailId returns the old "EmailId" field's value of the DirectorateUsers entity.
// If the DirectorateUsers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectorateUsersMutation) OldEmailId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailId: %w", err)
	}
	return oldValue.EmailId, nil
}

// ResetEmailId resets all changes to the "EmailId" field.
func (m *DirectorateUsersMutation) ResetEmailId() {
	m._EmailId = nil
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *DirectorateUsersMutation) SetMobileNumber(i int64) {
	m._MobileNumber = &i
	m.add_MobileNumber = nil
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *DirectorateUsersMutation) MobileNumber() (r int64, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the DirectorateUsers entity.
// If the DirectorateUsers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectorateUsersMutation) OldMobileNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// AddMobileNumber adds i to the "MobileNumber" field.
func (m *DirectorateUsersMutation) AddMobileNumber(i int64) {
	if m.add_MobileNumber != nil {
		*m.add_MobileNumber += i
	} else {
		m.add_MobileNumber = &i
	}
}

// AddedMobileNumber returns the value that was added to the "MobileNumber" field in this mutation.
func (m *DirectorateUsersMutation) AddedMobileNumber() (r int64, exists bool) {
	v := m.add_MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *DirectorateUsersMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
}

// SetSequenceNumber sets the "SequenceNumber" field.
func (m *DirectorateUsersMutation) SetSequenceNumber(i int32) {
	m._SequenceNumber = &i
	m.add_SequenceNumber = nil
}

// SequenceNumber returns the value of the "SequenceNumber" field in the mutation.
func (m *DirectorateUsersMutation) SequenceNumber() (r int32, exists bool) {
	v := m._SequenceNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceNumber returns the old "SequenceNumber" field's value of the DirectorateUsers entity.
// If the DirectorateUsers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectorateUsersMutation) OldSequenceNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequenceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequenceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceNumber: %w", err)
	}
	return oldValue.SequenceNumber, nil
}

// AddSequenceNumber adds i to the "SequenceNumber" field.
func (m *DirectorateUsersMutation) AddSequenceNumber(i int32) {
	if m.add_SequenceNumber != nil {
		*m.add_SequenceNumber += i
	} else {
		m.add_SequenceNumber = &i
	}
}

// AddedSequenceNumber returns the value that was added to the "SequenceNumber" field in this mutation.
func (m *DirectorateUsersMutation) AddedSequenceNumber() (r int32, exists bool) {
	v := m.add_SequenceNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearSequenceNumber clears the value of the "SequenceNumber" field.
func (m *DirectorateUsersMutation) ClearSequenceNumber() {
	m._SequenceNumber = nil
	m.add_SequenceNumber = nil
	m.clearedFields[directorateusers.FieldSequenceNumber] = struct{}{}
}

// SequenceNumberCleared returns if the "SequenceNumber" field was cleared in this mutation.
func (m *DirectorateUsersMutation) SequenceNumberCleared() bool {
	_, ok := m.clearedFields[directorateusers.FieldSequenceNumber]
	return ok
}

// ResetSequenceNumber resets all changes to the "SequenceNumber" field.
func (m *DirectorateUsersMutation) ResetSequenceNumber() {
	m._SequenceNumber = nil
	m.add_SequenceNumber = nil
	delete(m.clearedFields, directorateusers.FieldSequenceNumber)
}

// SetStatus sets the "Status" field.
func (m *DirectorateUsersMutation) SetStatus(s string) {
	m._Status = &s
}

// Status returns the value of the "Status" field in the mutation.
func (m *DirectorateUsersMutation) Status() (r string, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the DirectorateUsers entity.
// If the DirectorateUsers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectorateUsersMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "Status" field.
func (m *DirectorateUsersMutation) ClearStatus() {
	m._Status = nil
	m.clearedFields[directorateusers.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "Status" field was cleared in this mutation.
func (m *DirectorateUsersMutation) StatusCleared() bool {
	_, ok := m.clearedFields[directorateusers.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "Status" field.
func (m *DirectorateUsersMutation) ResetStatus() {
	m._Status = nil
	delete(m.clearedFields, directorateusers.FieldStatus)
}

// AddEmployeeUserIDs adds the "employee_user" edge to the Employees entity by ids.
func (m *DirectorateUsersMutation) AddEmployeeUserIDs(ids ...int32) {
	if m.employee_user == nil {
		m.employee_user = make(map[int32]struct{})
	}
	for i := range ids {
		m.employee_user[ids[i]] = struct{}{}
	}
}

// ClearEmployeeUser clears the "employee_user" edge to the Employees entity.
func (m *DirectorateUsersMutation) ClearEmployeeUser() {
	m.clearedemployee_user = true
}

// EmployeeUserCleared reports if the "employee_user" edge to the Employees entity was cleared.
func (m *DirectorateUsersMutation) EmployeeUserCleared() bool {
	return m.clearedemployee_user
}

// RemoveEmployeeUserIDs removes the "employee_user" edge to the Employees entity by IDs.
func (m *DirectorateUsersMutation) RemoveEmployeeUserIDs(ids ...int32) {
	if m.removedemployee_user == nil {
		m.removedemployee_user = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.employee_user, ids[i])
		m.removedemployee_user[ids[i]] = struct{}{}
	}
}

// RemovedEmployeeUser returns the removed IDs of the "employee_user" edge to the Employees entity.
func (m *DirectorateUsersMutation) RemovedEmployeeUserIDs() (ids []int32) {
	for id := range m.removedemployee_user {
		ids = append(ids, id)
	}
	return
}

// EmployeeUserIDs returns the "employee_user" edge IDs in the mutation.
func (m *DirectorateUsersMutation) EmployeeUserIDs() (ids []int32) {
	for id := range m.employee_user {
		ids = append(ids, id)
	}
	return
}

// ResetEmployeeUser resets all changes to the "employee_user" edge.
func (m *DirectorateUsersMutation) ResetEmployeeUser() {
	m.employee_user = nil
	m.clearedemployee_user = false
	m.removedemployee_user = nil
}

// Where appends a list predicates to the DirectorateUsersMutation builder.
func (m *DirectorateUsersMutation) Where(ps ...predicate.DirectorateUsers) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DirectorateUsersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DirectorateUsersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DirectorateUsers, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DirectorateUsersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DirectorateUsersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DirectorateUsers).
func (m *DirectorateUsersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DirectorateUsersMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._Role != nil {
		fields = append(fields, directorateusers.FieldRole)
	}
	if m._EmployeedID != nil {
		fields = append(fields, directorateusers.FieldEmployeedID)
	}
	if m._EmployeeName != nil {
		fields = append(fields, directorateusers.FieldEmployeeName)
	}
	if m._EmailId != nil {
		fields = append(fields, directorateusers.FieldEmailId)
	}
	if m._MobileNumber != nil {
		fields = append(fields, directorateusers.FieldMobileNumber)
	}
	if m._SequenceNumber != nil {
		fields = append(fields, directorateusers.FieldSequenceNumber)
	}
	if m._Status != nil {
		fields = append(fields, directorateusers.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DirectorateUsersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case directorateusers.FieldRole:
		return m.Role()
	case directorateusers.FieldEmployeedID:
		return m.EmployeedID()
	case directorateusers.FieldEmployeeName:
		return m.EmployeeName()
	case directorateusers.FieldEmailId:
		return m.EmailId()
	case directorateusers.FieldMobileNumber:
		return m.MobileNumber()
	case directorateusers.FieldSequenceNumber:
		return m.SequenceNumber()
	case directorateusers.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DirectorateUsersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case directorateusers.FieldRole:
		return m.OldRole(ctx)
	case directorateusers.FieldEmployeedID:
		return m.OldEmployeedID(ctx)
	case directorateusers.FieldEmployeeName:
		return m.OldEmployeeName(ctx)
	case directorateusers.FieldEmailId:
		return m.OldEmailId(ctx)
	case directorateusers.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case directorateusers.FieldSequenceNumber:
		return m.OldSequenceNumber(ctx)
	case directorateusers.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown DirectorateUsers field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DirectorateUsersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case directorateusers.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case directorateusers.FieldEmployeedID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeedID(v)
		return nil
	case directorateusers.FieldEmployeeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeName(v)
		return nil
	case directorateusers.FieldEmailId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailId(v)
		return nil
	case directorateusers.FieldMobileNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case directorateusers.FieldSequenceNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceNumber(v)
		return nil
	case directorateusers.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown DirectorateUsers field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DirectorateUsersMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeedID != nil {
		fields = append(fields, directorateusers.FieldEmployeedID)
	}
	if m.add_MobileNumber != nil {
		fields = append(fields, directorateusers.FieldMobileNumber)
	}
	if m.add_SequenceNumber != nil {
		fields = append(fields, directorateusers.FieldSequenceNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DirectorateUsersMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case directorateusers.FieldEmployeedID:
		return m.AddedEmployeedID()
	case directorateusers.FieldMobileNumber:
		return m.AddedMobileNumber()
	case directorateusers.FieldSequenceNumber:
		return m.AddedSequenceNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DirectorateUsersMutation) AddField(name string, value ent.Value) error {
	switch name {
	case directorateusers.FieldEmployeedID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeedID(v)
		return nil
	case directorateusers.FieldMobileNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMobileNumber(v)
		return nil
	case directorateusers.FieldSequenceNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequenceNumber(v)
		return nil
	}
	return fmt.Errorf("unknown DirectorateUsers numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DirectorateUsersMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(directorateusers.FieldSequenceNumber) {
		fields = append(fields, directorateusers.FieldSequenceNumber)
	}
	if m.FieldCleared(directorateusers.FieldStatus) {
		fields = append(fields, directorateusers.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DirectorateUsersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DirectorateUsersMutation) ClearField(name string) error {
	switch name {
	case directorateusers.FieldSequenceNumber:
		m.ClearSequenceNumber()
		return nil
	case directorateusers.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown DirectorateUsers nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DirectorateUsersMutation) ResetField(name string) error {
	switch name {
	case directorateusers.FieldRole:
		m.ResetRole()
		return nil
	case directorateusers.FieldEmployeedID:
		m.ResetEmployeedID()
		return nil
	case directorateusers.FieldEmployeeName:
		m.ResetEmployeeName()
		return nil
	case directorateusers.FieldEmailId:
		m.ResetEmailId()
		return nil
	case directorateusers.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case directorateusers.FieldSequenceNumber:
		m.ResetSequenceNumber()
		return nil
	case directorateusers.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown DirectorateUsers field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DirectorateUsersMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employee_user != nil {
		edges = append(edges, directorateusers.EdgeEmployeeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DirectorateUsersMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case directorateusers.EdgeEmployeeUser:
		ids := make([]ent.Value, 0, len(m.employee_user))
		for id := range m.employee_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DirectorateUsersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedemployee_user != nil {
		edges = append(edges, directorateusers.EdgeEmployeeUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DirectorateUsersMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case directorateusers.EdgeEmployeeUser:
		ids := make([]ent.Value, 0, len(m.removedemployee_user))
		for id := range m.removedemployee_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DirectorateUsersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedemployee_user {
		edges = append(edges, directorateusers.EdgeEmployeeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DirectorateUsersMutation) EdgeCleared(name string) bool {
	switch name {
	case directorateusers.EdgeEmployeeUser:
		return m.clearedemployee_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DirectorateUsersMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DirectorateUsers unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DirectorateUsersMutation) ResetEdge(name string) error {
	switch name {
	case directorateusers.EdgeEmployeeUser:
		m.ResetEmployeeUser()
		return nil
	}
	return fmt.Errorf("unknown DirectorateUsers edge %s", name)
}

// DisabilityMutation represents an operation that mutates the Disability nodes in the graph.
type DisabilityMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int32
	_DisabilityTypeCode        *string
	_DisabilityTypeDescription *string
	_DisabilityPercentage      *int32
	add_DisabilityPercentage   *int32
	_DisabilityFlag            *disability.DisabilityFlag
	clearedFields              map[string]struct{}
	dis_ref                    map[int32]struct{}
	removeddis_ref             map[int32]struct{}
	cleareddis_ref             bool
	done                       bool
	oldValue                   func(context.Context) (*Disability, error)
	predicates                 []predicate.Disability
}

var _ ent.Mutation = (*DisabilityMutation)(nil)

// disabilityOption allows management of the mutation configuration using functional options.
type disabilityOption func(*DisabilityMutation)

// newDisabilityMutation creates new mutation for the Disability entity.
func newDisabilityMutation(c config, op Op, opts ...disabilityOption) *DisabilityMutation {
	m := &DisabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeDisability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDisabilityID sets the ID field of the mutation.
func withDisabilityID(id int32) disabilityOption {
	return func(m *DisabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *Disability
		)
		m.oldValue = func(ctx context.Context) (*Disability, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Disability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDisability sets the old Disability of the mutation.
func withDisability(node *Disability) disabilityOption {
	return func(m *DisabilityMutation) {
		m.oldValue = func(context.Context) (*Disability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DisabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DisabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Disability entities.
func (m *DisabilityMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DisabilityMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DisabilityMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Disability.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDisabilityTypeCode sets the "DisabilityTypeCode" field.
func (m *DisabilityMutation) SetDisabilityTypeCode(s string) {
	m._DisabilityTypeCode = &s
}

// DisabilityTypeCode returns the value of the "DisabilityTypeCode" field in the mutation.
func (m *DisabilityMutation) DisabilityTypeCode() (r string, exists bool) {
	v := m._DisabilityTypeCode
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityTypeCode returns the old "DisabilityTypeCode" field's value of the Disability entity.
// If the Disability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DisabilityMutation) OldDisabilityTypeCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityTypeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityTypeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityTypeCode: %w", err)
	}
	return oldValue.DisabilityTypeCode, nil
}

// ResetDisabilityTypeCode resets all changes to the "DisabilityTypeCode" field.
func (m *DisabilityMutation) ResetDisabilityTypeCode() {
	m._DisabilityTypeCode = nil
}

// SetDisabilityTypeDescription sets the "DisabilityTypeDescription" field.
func (m *DisabilityMutation) SetDisabilityTypeDescription(s string) {
	m._DisabilityTypeDescription = &s
}

// DisabilityTypeDescription returns the value of the "DisabilityTypeDescription" field in the mutation.
func (m *DisabilityMutation) DisabilityTypeDescription() (r string, exists bool) {
	v := m._DisabilityTypeDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityTypeDescription returns the old "DisabilityTypeDescription" field's value of the Disability entity.
// If the Disability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DisabilityMutation) OldDisabilityTypeDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityTypeDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityTypeDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityTypeDescription: %w", err)
	}
	return oldValue.DisabilityTypeDescription, nil
}

// ResetDisabilityTypeDescription resets all changes to the "DisabilityTypeDescription" field.
func (m *DisabilityMutation) ResetDisabilityTypeDescription() {
	m._DisabilityTypeDescription = nil
}

// SetDisabilityPercentage sets the "DisabilityPercentage" field.
func (m *DisabilityMutation) SetDisabilityPercentage(i int32) {
	m._DisabilityPercentage = &i
	m.add_DisabilityPercentage = nil
}

// DisabilityPercentage returns the value of the "DisabilityPercentage" field in the mutation.
func (m *DisabilityMutation) DisabilityPercentage() (r int32, exists bool) {
	v := m._DisabilityPercentage
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityPercentage returns the old "DisabilityPercentage" field's value of the Disability entity.
// If the Disability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DisabilityMutation) OldDisabilityPercentage(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityPercentage: %w", err)
	}
	return oldValue.DisabilityPercentage, nil
}

// AddDisabilityPercentage adds i to the "DisabilityPercentage" field.
func (m *DisabilityMutation) AddDisabilityPercentage(i int32) {
	if m.add_DisabilityPercentage != nil {
		*m.add_DisabilityPercentage += i
	} else {
		m.add_DisabilityPercentage = &i
	}
}

// AddedDisabilityPercentage returns the value that was added to the "DisabilityPercentage" field in this mutation.
func (m *DisabilityMutation) AddedDisabilityPercentage() (r int32, exists bool) {
	v := m.add_DisabilityPercentage
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisabilityPercentage resets all changes to the "DisabilityPercentage" field.
func (m *DisabilityMutation) ResetDisabilityPercentage() {
	m._DisabilityPercentage = nil
	m.add_DisabilityPercentage = nil
}

// SetDisabilityFlag sets the "DisabilityFlag" field.
func (m *DisabilityMutation) SetDisabilityFlag(df disability.DisabilityFlag) {
	m._DisabilityFlag = &df
}

// DisabilityFlag returns the value of the "DisabilityFlag" field in the mutation.
func (m *DisabilityMutation) DisabilityFlag() (r disability.DisabilityFlag, exists bool) {
	v := m._DisabilityFlag
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityFlag returns the old "DisabilityFlag" field's value of the Disability entity.
// If the Disability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DisabilityMutation) OldDisabilityFlag(ctx context.Context) (v disability.DisabilityFlag, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityFlag: %w", err)
	}
	return oldValue.DisabilityFlag, nil
}

// ResetDisabilityFlag resets all changes to the "DisabilityFlag" field.
func (m *DisabilityMutation) ResetDisabilityFlag() {
	m._DisabilityFlag = nil
}

// AddDisRefIDs adds the "dis_ref" edge to the ExamPapers entity by ids.
func (m *DisabilityMutation) AddDisRefIDs(ids ...int32) {
	if m.dis_ref == nil {
		m.dis_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.dis_ref[ids[i]] = struct{}{}
	}
}

// ClearDisRef clears the "dis_ref" edge to the ExamPapers entity.
func (m *DisabilityMutation) ClearDisRef() {
	m.cleareddis_ref = true
}

// DisRefCleared reports if the "dis_ref" edge to the ExamPapers entity was cleared.
func (m *DisabilityMutation) DisRefCleared() bool {
	return m.cleareddis_ref
}

// RemoveDisRefIDs removes the "dis_ref" edge to the ExamPapers entity by IDs.
func (m *DisabilityMutation) RemoveDisRefIDs(ids ...int32) {
	if m.removeddis_ref == nil {
		m.removeddis_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.dis_ref, ids[i])
		m.removeddis_ref[ids[i]] = struct{}{}
	}
}

// RemovedDisRef returns the removed IDs of the "dis_ref" edge to the ExamPapers entity.
func (m *DisabilityMutation) RemovedDisRefIDs() (ids []int32) {
	for id := range m.removeddis_ref {
		ids = append(ids, id)
	}
	return
}

// DisRefIDs returns the "dis_ref" edge IDs in the mutation.
func (m *DisabilityMutation) DisRefIDs() (ids []int32) {
	for id := range m.dis_ref {
		ids = append(ids, id)
	}
	return
}

// ResetDisRef resets all changes to the "dis_ref" edge.
func (m *DisabilityMutation) ResetDisRef() {
	m.dis_ref = nil
	m.cleareddis_ref = false
	m.removeddis_ref = nil
}

// Where appends a list predicates to the DisabilityMutation builder.
func (m *DisabilityMutation) Where(ps ...predicate.Disability) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DisabilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DisabilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Disability, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DisabilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DisabilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Disability).
func (m *DisabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DisabilityMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._DisabilityTypeCode != nil {
		fields = append(fields, disability.FieldDisabilityTypeCode)
	}
	if m._DisabilityTypeDescription != nil {
		fields = append(fields, disability.FieldDisabilityTypeDescription)
	}
	if m._DisabilityPercentage != nil {
		fields = append(fields, disability.FieldDisabilityPercentage)
	}
	if m._DisabilityFlag != nil {
		fields = append(fields, disability.FieldDisabilityFlag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DisabilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case disability.FieldDisabilityTypeCode:
		return m.DisabilityTypeCode()
	case disability.FieldDisabilityTypeDescription:
		return m.DisabilityTypeDescription()
	case disability.FieldDisabilityPercentage:
		return m.DisabilityPercentage()
	case disability.FieldDisabilityFlag:
		return m.DisabilityFlag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DisabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case disability.FieldDisabilityTypeCode:
		return m.OldDisabilityTypeCode(ctx)
	case disability.FieldDisabilityTypeDescription:
		return m.OldDisabilityTypeDescription(ctx)
	case disability.FieldDisabilityPercentage:
		return m.OldDisabilityPercentage(ctx)
	case disability.FieldDisabilityFlag:
		return m.OldDisabilityFlag(ctx)
	}
	return nil, fmt.Errorf("unknown Disability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DisabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case disability.FieldDisabilityTypeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityTypeCode(v)
		return nil
	case disability.FieldDisabilityTypeDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityTypeDescription(v)
		return nil
	case disability.FieldDisabilityPercentage:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityPercentage(v)
		return nil
	case disability.FieldDisabilityFlag:
		v, ok := value.(disability.DisabilityFlag)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityFlag(v)
		return nil
	}
	return fmt.Errorf("unknown Disability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DisabilityMutation) AddedFields() []string {
	var fields []string
	if m.add_DisabilityPercentage != nil {
		fields = append(fields, disability.FieldDisabilityPercentage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DisabilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case disability.FieldDisabilityPercentage:
		return m.AddedDisabilityPercentage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DisabilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case disability.FieldDisabilityPercentage:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisabilityPercentage(v)
		return nil
	}
	return fmt.Errorf("unknown Disability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DisabilityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DisabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DisabilityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Disability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DisabilityMutation) ResetField(name string) error {
	switch name {
	case disability.FieldDisabilityTypeCode:
		m.ResetDisabilityTypeCode()
		return nil
	case disability.FieldDisabilityTypeDescription:
		m.ResetDisabilityTypeDescription()
		return nil
	case disability.FieldDisabilityPercentage:
		m.ResetDisabilityPercentage()
		return nil
	case disability.FieldDisabilityFlag:
		m.ResetDisabilityFlag()
		return nil
	}
	return fmt.Errorf("unknown Disability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DisabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dis_ref != nil {
		edges = append(edges, disability.EdgeDisRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DisabilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case disability.EdgeDisRef:
		ids := make([]ent.Value, 0, len(m.dis_ref))
		for id := range m.dis_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DisabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddis_ref != nil {
		edges = append(edges, disability.EdgeDisRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DisabilityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case disability.EdgeDisRef:
		ids := make([]ent.Value, 0, len(m.removeddis_ref))
		for id := range m.removeddis_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DisabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddis_ref {
		edges = append(edges, disability.EdgeDisRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DisabilityMutation) EdgeCleared(name string) bool {
	switch name {
	case disability.EdgeDisRef:
		return m.cleareddis_ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DisabilityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Disability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DisabilityMutation) ResetEdge(name string) error {
	switch name {
	case disability.EdgeDisRef:
		m.ResetDisRef()
		return nil
	}
	return fmt.Errorf("unknown Disability edge %s", name)
}

// DivisionMasterMutation represents an operation that mutates the DivisionMaster nodes in the graph.
type DivisionMasterMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int32
	_DivisionCode        *int32
	add_DivisionCode     *int32
	_OfficeType          *string
	_DivisionOfficeID    *string
	_DivisionOfficeName  *string
	_ReportingOfficeType *string
	_ReportingOfficeCode *string
	_EmailID             *string
	_MobileNumber        *int32
	add_MobileNumber     *int32
	_RegionCode          *int32
	add_RegionCode       *int32
	clearedFields        map[string]struct{}
	regions              map[int32]struct{}
	removedregions       map[int32]struct{}
	clearedregions       bool
	divisions_ref        map[int32]struct{}
	removeddivisions_ref map[int32]struct{}
	cleareddivisions_ref bool
	done                 bool
	oldValue             func(context.Context) (*DivisionMaster, error)
	predicates           []predicate.DivisionMaster
}

var _ ent.Mutation = (*DivisionMasterMutation)(nil)

// divisionmasterOption allows management of the mutation configuration using functional options.
type divisionmasterOption func(*DivisionMasterMutation)

// newDivisionMasterMutation creates new mutation for the DivisionMaster entity.
func newDivisionMasterMutation(c config, op Op, opts ...divisionmasterOption) *DivisionMasterMutation {
	m := &DivisionMasterMutation{
		config:        c,
		op:            op,
		typ:           TypeDivisionMaster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDivisionMasterID sets the ID field of the mutation.
func withDivisionMasterID(id int32) divisionmasterOption {
	return func(m *DivisionMasterMutation) {
		var (
			err   error
			once  sync.Once
			value *DivisionMaster
		)
		m.oldValue = func(ctx context.Context) (*DivisionMaster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DivisionMaster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDivisionMaster sets the old DivisionMaster of the mutation.
func withDivisionMaster(node *DivisionMaster) divisionmasterOption {
	return func(m *DivisionMasterMutation) {
		m.oldValue = func(context.Context) (*DivisionMaster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DivisionMasterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DivisionMasterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DivisionMaster entities.
func (m *DivisionMasterMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DivisionMasterMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DivisionMasterMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DivisionMaster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDivisionCode sets the "DivisionCode" field.
func (m *DivisionMasterMutation) SetDivisionCode(i int32) {
	m._DivisionCode = &i
	m.add_DivisionCode = nil
}

// DivisionCode returns the value of the "DivisionCode" field in the mutation.
func (m *DivisionMasterMutation) DivisionCode() (r int32, exists bool) {
	v := m._DivisionCode
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionCode returns the old "DivisionCode" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldDivisionCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionCode: %w", err)
	}
	return oldValue.DivisionCode, nil
}

// AddDivisionCode adds i to the "DivisionCode" field.
func (m *DivisionMasterMutation) AddDivisionCode(i int32) {
	if m.add_DivisionCode != nil {
		*m.add_DivisionCode += i
	} else {
		m.add_DivisionCode = &i
	}
}

// AddedDivisionCode returns the value that was added to the "DivisionCode" field in this mutation.
func (m *DivisionMasterMutation) AddedDivisionCode() (r int32, exists bool) {
	v := m.add_DivisionCode
	if v == nil {
		return
	}
	return *v, true
}

// ResetDivisionCode resets all changes to the "DivisionCode" field.
func (m *DivisionMasterMutation) ResetDivisionCode() {
	m._DivisionCode = nil
	m.add_DivisionCode = nil
}

// SetOfficeType sets the "OfficeType" field.
func (m *DivisionMasterMutation) SetOfficeType(s string) {
	m._OfficeType = &s
}

// OfficeType returns the value of the "OfficeType" field in the mutation.
func (m *DivisionMasterMutation) OfficeType() (r string, exists bool) {
	v := m._OfficeType
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeType returns the old "OfficeType" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldOfficeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeType: %w", err)
	}
	return oldValue.OfficeType, nil
}

// ResetOfficeType resets all changes to the "OfficeType" field.
func (m *DivisionMasterMutation) ResetOfficeType() {
	m._OfficeType = nil
}

// SetDivisionOfficeID sets the "DivisionOfficeID" field.
func (m *DivisionMasterMutation) SetDivisionOfficeID(s string) {
	m._DivisionOfficeID = &s
}

// DivisionOfficeID returns the value of the "DivisionOfficeID" field in the mutation.
func (m *DivisionMasterMutation) DivisionOfficeID() (r string, exists bool) {
	v := m._DivisionOfficeID
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionOfficeID returns the old "DivisionOfficeID" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldDivisionOfficeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionOfficeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionOfficeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionOfficeID: %w", err)
	}
	return oldValue.DivisionOfficeID, nil
}

// ResetDivisionOfficeID resets all changes to the "DivisionOfficeID" field.
func (m *DivisionMasterMutation) ResetDivisionOfficeID() {
	m._DivisionOfficeID = nil
}

// SetDivisionOfficeName sets the "DivisionOfficeName" field.
func (m *DivisionMasterMutation) SetDivisionOfficeName(s string) {
	m._DivisionOfficeName = &s
}

// DivisionOfficeName returns the value of the "DivisionOfficeName" field in the mutation.
func (m *DivisionMasterMutation) DivisionOfficeName() (r string, exists bool) {
	v := m._DivisionOfficeName
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionOfficeName returns the old "DivisionOfficeName" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldDivisionOfficeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionOfficeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionOfficeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionOfficeName: %w", err)
	}
	return oldValue.DivisionOfficeName, nil
}

// ResetDivisionOfficeName resets all changes to the "DivisionOfficeName" field.
func (m *DivisionMasterMutation) ResetDivisionOfficeName() {
	m._DivisionOfficeName = nil
}

// SetReportingOfficeType sets the "ReportingOfficeType" field.
func (m *DivisionMasterMutation) SetReportingOfficeType(s string) {
	m._ReportingOfficeType = &s
}

// ReportingOfficeType returns the value of the "ReportingOfficeType" field in the mutation.
func (m *DivisionMasterMutation) ReportingOfficeType() (r string, exists bool) {
	v := m._ReportingOfficeType
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingOfficeType returns the old "ReportingOfficeType" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldReportingOfficeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingOfficeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingOfficeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingOfficeType: %w", err)
	}
	return oldValue.ReportingOfficeType, nil
}

// ClearReportingOfficeType clears the value of the "ReportingOfficeType" field.
func (m *DivisionMasterMutation) ClearReportingOfficeType() {
	m._ReportingOfficeType = nil
	m.clearedFields[divisionmaster.FieldReportingOfficeType] = struct{}{}
}

// ReportingOfficeTypeCleared returns if the "ReportingOfficeType" field was cleared in this mutation.
func (m *DivisionMasterMutation) ReportingOfficeTypeCleared() bool {
	_, ok := m.clearedFields[divisionmaster.FieldReportingOfficeType]
	return ok
}

// ResetReportingOfficeType resets all changes to the "ReportingOfficeType" field.
func (m *DivisionMasterMutation) ResetReportingOfficeType() {
	m._ReportingOfficeType = nil
	delete(m.clearedFields, divisionmaster.FieldReportingOfficeType)
}

// SetReportingOfficeCode sets the "ReportingOfficeCode" field.
func (m *DivisionMasterMutation) SetReportingOfficeCode(s string) {
	m._ReportingOfficeCode = &s
}

// ReportingOfficeCode returns the value of the "ReportingOfficeCode" field in the mutation.
func (m *DivisionMasterMutation) ReportingOfficeCode() (r string, exists bool) {
	v := m._ReportingOfficeCode
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingOfficeCode returns the old "ReportingOfficeCode" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldReportingOfficeCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingOfficeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingOfficeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingOfficeCode: %w", err)
	}
	return oldValue.ReportingOfficeCode, nil
}

// ClearReportingOfficeCode clears the value of the "ReportingOfficeCode" field.
func (m *DivisionMasterMutation) ClearReportingOfficeCode() {
	m._ReportingOfficeCode = nil
	m.clearedFields[divisionmaster.FieldReportingOfficeCode] = struct{}{}
}

// ReportingOfficeCodeCleared returns if the "ReportingOfficeCode" field was cleared in this mutation.
func (m *DivisionMasterMutation) ReportingOfficeCodeCleared() bool {
	_, ok := m.clearedFields[divisionmaster.FieldReportingOfficeCode]
	return ok
}

// ResetReportingOfficeCode resets all changes to the "ReportingOfficeCode" field.
func (m *DivisionMasterMutation) ResetReportingOfficeCode() {
	m._ReportingOfficeCode = nil
	delete(m.clearedFields, divisionmaster.FieldReportingOfficeCode)
}

// SetEmailID sets the "EmailID" field.
func (m *DivisionMasterMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *DivisionMasterMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ClearEmailID clears the value of the "EmailID" field.
func (m *DivisionMasterMutation) ClearEmailID() {
	m._EmailID = nil
	m.clearedFields[divisionmaster.FieldEmailID] = struct{}{}
}

// EmailIDCleared returns if the "EmailID" field was cleared in this mutation.
func (m *DivisionMasterMutation) EmailIDCleared() bool {
	_, ok := m.clearedFields[divisionmaster.FieldEmailID]
	return ok
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *DivisionMasterMutation) ResetEmailID() {
	m._EmailID = nil
	delete(m.clearedFields, divisionmaster.FieldEmailID)
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *DivisionMasterMutation) SetMobileNumber(i int32) {
	m._MobileNumber = &i
	m.add_MobileNumber = nil
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *DivisionMasterMutation) MobileNumber() (r int32, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldMobileNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// AddMobileNumber adds i to the "MobileNumber" field.
func (m *DivisionMasterMutation) AddMobileNumber(i int32) {
	if m.add_MobileNumber != nil {
		*m.add_MobileNumber += i
	} else {
		m.add_MobileNumber = &i
	}
}

// AddedMobileNumber returns the value that was added to the "MobileNumber" field in this mutation.
func (m *DivisionMasterMutation) AddedMobileNumber() (r int32, exists bool) {
	v := m.add_MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearMobileNumber clears the value of the "MobileNumber" field.
func (m *DivisionMasterMutation) ClearMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	m.clearedFields[divisionmaster.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "MobileNumber" field was cleared in this mutation.
func (m *DivisionMasterMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[divisionmaster.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *DivisionMasterMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	delete(m.clearedFields, divisionmaster.FieldMobileNumber)
}

// SetRegionCode sets the "RegionCode" field.
func (m *DivisionMasterMutation) SetRegionCode(i int32) {
	m._RegionCode = &i
	m.add_RegionCode = nil
}

// RegionCode returns the value of the "RegionCode" field in the mutation.
func (m *DivisionMasterMutation) RegionCode() (r int32, exists bool) {
	v := m._RegionCode
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionCode returns the old "RegionCode" field's value of the DivisionMaster entity.
// If the DivisionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionMasterMutation) OldRegionCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionCode: %w", err)
	}
	return oldValue.RegionCode, nil
}

// AddRegionCode adds i to the "RegionCode" field.
func (m *DivisionMasterMutation) AddRegionCode(i int32) {
	if m.add_RegionCode != nil {
		*m.add_RegionCode += i
	} else {
		m.add_RegionCode = &i
	}
}

// AddedRegionCode returns the value that was added to the "RegionCode" field in this mutation.
func (m *DivisionMasterMutation) AddedRegionCode() (r int32, exists bool) {
	v := m.add_RegionCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearRegionCode clears the value of the "RegionCode" field.
func (m *DivisionMasterMutation) ClearRegionCode() {
	m._RegionCode = nil
	m.add_RegionCode = nil
	m.clearedFields[divisionmaster.FieldRegionCode] = struct{}{}
}

// RegionCodeCleared returns if the "RegionCode" field was cleared in this mutation.
func (m *DivisionMasterMutation) RegionCodeCleared() bool {
	_, ok := m.clearedFields[divisionmaster.FieldRegionCode]
	return ok
}

// ResetRegionCode resets all changes to the "RegionCode" field.
func (m *DivisionMasterMutation) ResetRegionCode() {
	m._RegionCode = nil
	m.add_RegionCode = nil
	delete(m.clearedFields, divisionmaster.FieldRegionCode)
}

// AddRegionIDs adds the "regions" edge to the RegionMaster entity by ids.
func (m *DivisionMasterMutation) AddRegionIDs(ids ...int32) {
	if m.regions == nil {
		m.regions = make(map[int32]struct{})
	}
	for i := range ids {
		m.regions[ids[i]] = struct{}{}
	}
}

// ClearRegions clears the "regions" edge to the RegionMaster entity.
func (m *DivisionMasterMutation) ClearRegions() {
	m.clearedregions = true
}

// RegionsCleared reports if the "regions" edge to the RegionMaster entity was cleared.
func (m *DivisionMasterMutation) RegionsCleared() bool {
	return m.clearedregions
}

// RemoveRegionIDs removes the "regions" edge to the RegionMaster entity by IDs.
func (m *DivisionMasterMutation) RemoveRegionIDs(ids ...int32) {
	if m.removedregions == nil {
		m.removedregions = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.regions, ids[i])
		m.removedregions[ids[i]] = struct{}{}
	}
}

// RemovedRegions returns the removed IDs of the "regions" edge to the RegionMaster entity.
func (m *DivisionMasterMutation) RemovedRegionsIDs() (ids []int32) {
	for id := range m.removedregions {
		ids = append(ids, id)
	}
	return
}

// RegionsIDs returns the "regions" edge IDs in the mutation.
func (m *DivisionMasterMutation) RegionsIDs() (ids []int32) {
	for id := range m.regions {
		ids = append(ids, id)
	}
	return
}

// ResetRegions resets all changes to the "regions" edge.
func (m *DivisionMasterMutation) ResetRegions() {
	m.regions = nil
	m.clearedregions = false
	m.removedregions = nil
}

// AddDivisionsRefIDs adds the "divisions_ref" edge to the Facility entity by ids.
func (m *DivisionMasterMutation) AddDivisionsRefIDs(ids ...int32) {
	if m.divisions_ref == nil {
		m.divisions_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.divisions_ref[ids[i]] = struct{}{}
	}
}

// ClearDivisionsRef clears the "divisions_ref" edge to the Facility entity.
func (m *DivisionMasterMutation) ClearDivisionsRef() {
	m.cleareddivisions_ref = true
}

// DivisionsRefCleared reports if the "divisions_ref" edge to the Facility entity was cleared.
func (m *DivisionMasterMutation) DivisionsRefCleared() bool {
	return m.cleareddivisions_ref
}

// RemoveDivisionsRefIDs removes the "divisions_ref" edge to the Facility entity by IDs.
func (m *DivisionMasterMutation) RemoveDivisionsRefIDs(ids ...int32) {
	if m.removeddivisions_ref == nil {
		m.removeddivisions_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.divisions_ref, ids[i])
		m.removeddivisions_ref[ids[i]] = struct{}{}
	}
}

// RemovedDivisionsRef returns the removed IDs of the "divisions_ref" edge to the Facility entity.
func (m *DivisionMasterMutation) RemovedDivisionsRefIDs() (ids []int32) {
	for id := range m.removeddivisions_ref {
		ids = append(ids, id)
	}
	return
}

// DivisionsRefIDs returns the "divisions_ref" edge IDs in the mutation.
func (m *DivisionMasterMutation) DivisionsRefIDs() (ids []int32) {
	for id := range m.divisions_ref {
		ids = append(ids, id)
	}
	return
}

// ResetDivisionsRef resets all changes to the "divisions_ref" edge.
func (m *DivisionMasterMutation) ResetDivisionsRef() {
	m.divisions_ref = nil
	m.cleareddivisions_ref = false
	m.removeddivisions_ref = nil
}

// Where appends a list predicates to the DivisionMasterMutation builder.
func (m *DivisionMasterMutation) Where(ps ...predicate.DivisionMaster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DivisionMasterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DivisionMasterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DivisionMaster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DivisionMasterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DivisionMasterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DivisionMaster).
func (m *DivisionMasterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DivisionMasterMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._DivisionCode != nil {
		fields = append(fields, divisionmaster.FieldDivisionCode)
	}
	if m._OfficeType != nil {
		fields = append(fields, divisionmaster.FieldOfficeType)
	}
	if m._DivisionOfficeID != nil {
		fields = append(fields, divisionmaster.FieldDivisionOfficeID)
	}
	if m._DivisionOfficeName != nil {
		fields = append(fields, divisionmaster.FieldDivisionOfficeName)
	}
	if m._ReportingOfficeType != nil {
		fields = append(fields, divisionmaster.FieldReportingOfficeType)
	}
	if m._ReportingOfficeCode != nil {
		fields = append(fields, divisionmaster.FieldReportingOfficeCode)
	}
	if m._EmailID != nil {
		fields = append(fields, divisionmaster.FieldEmailID)
	}
	if m._MobileNumber != nil {
		fields = append(fields, divisionmaster.FieldMobileNumber)
	}
	if m._RegionCode != nil {
		fields = append(fields, divisionmaster.FieldRegionCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DivisionMasterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case divisionmaster.FieldDivisionCode:
		return m.DivisionCode()
	case divisionmaster.FieldOfficeType:
		return m.OfficeType()
	case divisionmaster.FieldDivisionOfficeID:
		return m.DivisionOfficeID()
	case divisionmaster.FieldDivisionOfficeName:
		return m.DivisionOfficeName()
	case divisionmaster.FieldReportingOfficeType:
		return m.ReportingOfficeType()
	case divisionmaster.FieldReportingOfficeCode:
		return m.ReportingOfficeCode()
	case divisionmaster.FieldEmailID:
		return m.EmailID()
	case divisionmaster.FieldMobileNumber:
		return m.MobileNumber()
	case divisionmaster.FieldRegionCode:
		return m.RegionCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DivisionMasterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case divisionmaster.FieldDivisionCode:
		return m.OldDivisionCode(ctx)
	case divisionmaster.FieldOfficeType:
		return m.OldOfficeType(ctx)
	case divisionmaster.FieldDivisionOfficeID:
		return m.OldDivisionOfficeID(ctx)
	case divisionmaster.FieldDivisionOfficeName:
		return m.OldDivisionOfficeName(ctx)
	case divisionmaster.FieldReportingOfficeType:
		return m.OldReportingOfficeType(ctx)
	case divisionmaster.FieldReportingOfficeCode:
		return m.OldReportingOfficeCode(ctx)
	case divisionmaster.FieldEmailID:
		return m.OldEmailID(ctx)
	case divisionmaster.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case divisionmaster.FieldRegionCode:
		return m.OldRegionCode(ctx)
	}
	return nil, fmt.Errorf("unknown DivisionMaster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivisionMasterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case divisionmaster.FieldDivisionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionCode(v)
		return nil
	case divisionmaster.FieldOfficeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeType(v)
		return nil
	case divisionmaster.FieldDivisionOfficeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionOfficeID(v)
		return nil
	case divisionmaster.FieldDivisionOfficeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionOfficeName(v)
		return nil
	case divisionmaster.FieldReportingOfficeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingOfficeType(v)
		return nil
	case divisionmaster.FieldReportingOfficeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingOfficeCode(v)
		return nil
	case divisionmaster.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case divisionmaster.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case divisionmaster.FieldRegionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionCode(v)
		return nil
	}
	return fmt.Errorf("unknown DivisionMaster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DivisionMasterMutation) AddedFields() []string {
	var fields []string
	if m.add_DivisionCode != nil {
		fields = append(fields, divisionmaster.FieldDivisionCode)
	}
	if m.add_MobileNumber != nil {
		fields = append(fields, divisionmaster.FieldMobileNumber)
	}
	if m.add_RegionCode != nil {
		fields = append(fields, divisionmaster.FieldRegionCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DivisionMasterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case divisionmaster.FieldDivisionCode:
		return m.AddedDivisionCode()
	case divisionmaster.FieldMobileNumber:
		return m.AddedMobileNumber()
	case divisionmaster.FieldRegionCode:
		return m.AddedRegionCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivisionMasterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case divisionmaster.FieldDivisionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDivisionCode(v)
		return nil
	case divisionmaster.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMobileNumber(v)
		return nil
	case divisionmaster.FieldRegionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegionCode(v)
		return nil
	}
	return fmt.Errorf("unknown DivisionMaster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DivisionMasterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(divisionmaster.FieldReportingOfficeType) {
		fields = append(fields, divisionmaster.FieldReportingOfficeType)
	}
	if m.FieldCleared(divisionmaster.FieldReportingOfficeCode) {
		fields = append(fields, divisionmaster.FieldReportingOfficeCode)
	}
	if m.FieldCleared(divisionmaster.FieldEmailID) {
		fields = append(fields, divisionmaster.FieldEmailID)
	}
	if m.FieldCleared(divisionmaster.FieldMobileNumber) {
		fields = append(fields, divisionmaster.FieldMobileNumber)
	}
	if m.FieldCleared(divisionmaster.FieldRegionCode) {
		fields = append(fields, divisionmaster.FieldRegionCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DivisionMasterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DivisionMasterMutation) ClearField(name string) error {
	switch name {
	case divisionmaster.FieldReportingOfficeType:
		m.ClearReportingOfficeType()
		return nil
	case divisionmaster.FieldReportingOfficeCode:
		m.ClearReportingOfficeCode()
		return nil
	case divisionmaster.FieldEmailID:
		m.ClearEmailID()
		return nil
	case divisionmaster.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	case divisionmaster.FieldRegionCode:
		m.ClearRegionCode()
		return nil
	}
	return fmt.Errorf("unknown DivisionMaster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DivisionMasterMutation) ResetField(name string) error {
	switch name {
	case divisionmaster.FieldDivisionCode:
		m.ResetDivisionCode()
		return nil
	case divisionmaster.FieldOfficeType:
		m.ResetOfficeType()
		return nil
	case divisionmaster.FieldDivisionOfficeID:
		m.ResetDivisionOfficeID()
		return nil
	case divisionmaster.FieldDivisionOfficeName:
		m.ResetDivisionOfficeName()
		return nil
	case divisionmaster.FieldReportingOfficeType:
		m.ResetReportingOfficeType()
		return nil
	case divisionmaster.FieldReportingOfficeCode:
		m.ResetReportingOfficeCode()
		return nil
	case divisionmaster.FieldEmailID:
		m.ResetEmailID()
		return nil
	case divisionmaster.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case divisionmaster.FieldRegionCode:
		m.ResetRegionCode()
		return nil
	}
	return fmt.Errorf("unknown DivisionMaster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DivisionMasterMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.regions != nil {
		edges = append(edges, divisionmaster.EdgeRegions)
	}
	if m.divisions_ref != nil {
		edges = append(edges, divisionmaster.EdgeDivisionsRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DivisionMasterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case divisionmaster.EdgeRegions:
		ids := make([]ent.Value, 0, len(m.regions))
		for id := range m.regions {
			ids = append(ids, id)
		}
		return ids
	case divisionmaster.EdgeDivisionsRef:
		ids := make([]ent.Value, 0, len(m.divisions_ref))
		for id := range m.divisions_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DivisionMasterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedregions != nil {
		edges = append(edges, divisionmaster.EdgeRegions)
	}
	if m.removeddivisions_ref != nil {
		edges = append(edges, divisionmaster.EdgeDivisionsRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DivisionMasterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case divisionmaster.EdgeRegions:
		ids := make([]ent.Value, 0, len(m.removedregions))
		for id := range m.removedregions {
			ids = append(ids, id)
		}
		return ids
	case divisionmaster.EdgeDivisionsRef:
		ids := make([]ent.Value, 0, len(m.removeddivisions_ref))
		for id := range m.removeddivisions_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DivisionMasterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedregions {
		edges = append(edges, divisionmaster.EdgeRegions)
	}
	if m.cleareddivisions_ref {
		edges = append(edges, divisionmaster.EdgeDivisionsRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DivisionMasterMutation) EdgeCleared(name string) bool {
	switch name {
	case divisionmaster.EdgeRegions:
		return m.clearedregions
	case divisionmaster.EdgeDivisionsRef:
		return m.cleareddivisions_ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DivisionMasterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DivisionMaster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DivisionMasterMutation) ResetEdge(name string) error {
	switch name {
	case divisionmaster.EdgeRegions:
		m.ResetRegions()
		return nil
	case divisionmaster.EdgeDivisionsRef:
		m.ResetDivisionsRef()
		return nil
	}
	return fmt.Errorf("unknown DivisionMaster edge %s", name)
}

// DivisionChoicePAMutation represents an operation that mutates the Division_Choice_PA nodes in the graph.
type DivisionChoicePAMutation struct {
	config
	op              Op
	typ             string
	id              *int32
	_Application    *string
	_CadrePrefNo    *string
	_CadrePrefValue *string
	_EmployeeID     *int64
	add_EmployeeID  *int64
	_UpdatedAt      *time.Time
	_UpdatedBy      *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Division_Choice_PA, error)
	predicates      []predicate.Division_Choice_PA
}

var _ ent.Mutation = (*DivisionChoicePAMutation)(nil)

// divisionChoicePAOption allows management of the mutation configuration using functional options.
type divisionChoicePAOption func(*DivisionChoicePAMutation)

// newDivisionChoicePAMutation creates new mutation for the Division_Choice_PA entity.
func newDivisionChoicePAMutation(c config, op Op, opts ...divisionChoicePAOption) *DivisionChoicePAMutation {
	m := &DivisionChoicePAMutation{
		config:        c,
		op:            op,
		typ:           TypeDivisionChoicePA,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDivision_Choice_PAID sets the ID field of the mutation.
func withDivision_Choice_PAID(id int32) divisionChoicePAOption {
	return func(m *DivisionChoicePAMutation) {
		var (
			err   error
			once  sync.Once
			value *Division_Choice_PA
		)
		m.oldValue = func(ctx context.Context) (*Division_Choice_PA, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Division_Choice_PA.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDivision_Choice_PA sets the old Division_Choice_PA of the mutation.
func withDivision_Choice_PA(node *Division_Choice_PA) divisionChoicePAOption {
	return func(m *DivisionChoicePAMutation) {
		m.oldValue = func(context.Context) (*Division_Choice_PA, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DivisionChoicePAMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DivisionChoicePAMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Division_Choice_PA entities.
func (m *DivisionChoicePAMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DivisionChoicePAMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DivisionChoicePAMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Division_Choice_PA.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApplication sets the "Application" field.
func (m *DivisionChoicePAMutation) SetApplication(s string) {
	m._Application = &s
}

// Application returns the value of the "Application" field in the mutation.
func (m *DivisionChoicePAMutation) Application() (r string, exists bool) {
	v := m._Application
	if v == nil {
		return
	}
	return *v, true
}

// OldApplication returns the old "Application" field's value of the Division_Choice_PA entity.
// If the Division_Choice_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePAMutation) OldApplication(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplication is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplication requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplication: %w", err)
	}
	return oldValue.Application, nil
}

// ClearApplication clears the value of the "Application" field.
func (m *DivisionChoicePAMutation) ClearApplication() {
	m._Application = nil
	m.clearedFields[division_choice_pa.FieldApplication] = struct{}{}
}

// ApplicationCleared returns if the "Application" field was cleared in this mutation.
func (m *DivisionChoicePAMutation) ApplicationCleared() bool {
	_, ok := m.clearedFields[division_choice_pa.FieldApplication]
	return ok
}

// ResetApplication resets all changes to the "Application" field.
func (m *DivisionChoicePAMutation) ResetApplication() {
	m._Application = nil
	delete(m.clearedFields, division_choice_pa.FieldApplication)
}

// SetCadrePrefNo sets the "CadrePrefNo" field.
func (m *DivisionChoicePAMutation) SetCadrePrefNo(s string) {
	m._CadrePrefNo = &s
}

// CadrePrefNo returns the value of the "CadrePrefNo" field in the mutation.
func (m *DivisionChoicePAMutation) CadrePrefNo() (r string, exists bool) {
	v := m._CadrePrefNo
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePrefNo returns the old "CadrePrefNo" field's value of the Division_Choice_PA entity.
// If the Division_Choice_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePAMutation) OldCadrePrefNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePrefNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePrefNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePrefNo: %w", err)
	}
	return oldValue.CadrePrefNo, nil
}

// ResetCadrePrefNo resets all changes to the "CadrePrefNo" field.
func (m *DivisionChoicePAMutation) ResetCadrePrefNo() {
	m._CadrePrefNo = nil
}

// SetCadrePrefValue sets the "CadrePrefValue" field.
func (m *DivisionChoicePAMutation) SetCadrePrefValue(s string) {
	m._CadrePrefValue = &s
}

// CadrePrefValue returns the value of the "CadrePrefValue" field in the mutation.
func (m *DivisionChoicePAMutation) CadrePrefValue() (r string, exists bool) {
	v := m._CadrePrefValue
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePrefValue returns the old "CadrePrefValue" field's value of the Division_Choice_PA entity.
// If the Division_Choice_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePAMutation) OldCadrePrefValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePrefValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePrefValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePrefValue: %w", err)
	}
	return oldValue.CadrePrefValue, nil
}

// ResetCadrePrefValue resets all changes to the "CadrePrefValue" field.
func (m *DivisionChoicePAMutation) ResetCadrePrefValue() {
	m._CadrePrefValue = nil
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *DivisionChoicePAMutation) SetEmployeeID(i int64) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *DivisionChoicePAMutation) EmployeeID() (r int64, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the Division_Choice_PA entity.
// If the Division_Choice_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePAMutation) OldEmployeeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *DivisionChoicePAMutation) AddEmployeeID(i int64) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *DivisionChoicePAMutation) AddedEmployeeID() (r int64, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeeID clears the value of the "EmployeeID" field.
func (m *DivisionChoicePAMutation) ClearEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	m.clearedFields[division_choice_pa.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "EmployeeID" field was cleared in this mutation.
func (m *DivisionChoicePAMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[division_choice_pa.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *DivisionChoicePAMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	delete(m.clearedFields, division_choice_pa.FieldEmployeeID)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *DivisionChoicePAMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *DivisionChoicePAMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Division_Choice_PA entity.
// If the Division_Choice_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePAMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *DivisionChoicePAMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[division_choice_pa.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *DivisionChoicePAMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[division_choice_pa.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *DivisionChoicePAMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, division_choice_pa.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *DivisionChoicePAMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *DivisionChoicePAMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the Division_Choice_PA entity.
// If the Division_Choice_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePAMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *DivisionChoicePAMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[division_choice_pa.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *DivisionChoicePAMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[division_choice_pa.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *DivisionChoicePAMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, division_choice_pa.FieldUpdatedBy)
}

// Where appends a list predicates to the DivisionChoicePAMutation builder.
func (m *DivisionChoicePAMutation) Where(ps ...predicate.Division_Choice_PA) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DivisionChoicePAMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DivisionChoicePAMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Division_Choice_PA, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DivisionChoicePAMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DivisionChoicePAMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Division_Choice_PA).
func (m *DivisionChoicePAMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DivisionChoicePAMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._Application != nil {
		fields = append(fields, division_choice_pa.FieldApplication)
	}
	if m._CadrePrefNo != nil {
		fields = append(fields, division_choice_pa.FieldCadrePrefNo)
	}
	if m._CadrePrefValue != nil {
		fields = append(fields, division_choice_pa.FieldCadrePrefValue)
	}
	if m._EmployeeID != nil {
		fields = append(fields, division_choice_pa.FieldEmployeeID)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, division_choice_pa.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, division_choice_pa.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DivisionChoicePAMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case division_choice_pa.FieldApplication:
		return m.Application()
	case division_choice_pa.FieldCadrePrefNo:
		return m.CadrePrefNo()
	case division_choice_pa.FieldCadrePrefValue:
		return m.CadrePrefValue()
	case division_choice_pa.FieldEmployeeID:
		return m.EmployeeID()
	case division_choice_pa.FieldUpdatedAt:
		return m.UpdatedAt()
	case division_choice_pa.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DivisionChoicePAMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case division_choice_pa.FieldApplication:
		return m.OldApplication(ctx)
	case division_choice_pa.FieldCadrePrefNo:
		return m.OldCadrePrefNo(ctx)
	case division_choice_pa.FieldCadrePrefValue:
		return m.OldCadrePrefValue(ctx)
	case division_choice_pa.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case division_choice_pa.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case division_choice_pa.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Division_Choice_PA field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivisionChoicePAMutation) SetField(name string, value ent.Value) error {
	switch name {
	case division_choice_pa.FieldApplication:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplication(v)
		return nil
	case division_choice_pa.FieldCadrePrefNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePrefNo(v)
		return nil
	case division_choice_pa.FieldCadrePrefValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePrefValue(v)
		return nil
	case division_choice_pa.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case division_choice_pa.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case division_choice_pa.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Division_Choice_PA field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DivisionChoicePAMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeeID != nil {
		fields = append(fields, division_choice_pa.FieldEmployeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DivisionChoicePAMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case division_choice_pa.FieldEmployeeID:
		return m.AddedEmployeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivisionChoicePAMutation) AddField(name string, value ent.Value) error {
	switch name {
	case division_choice_pa.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown Division_Choice_PA numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DivisionChoicePAMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(division_choice_pa.FieldApplication) {
		fields = append(fields, division_choice_pa.FieldApplication)
	}
	if m.FieldCleared(division_choice_pa.FieldEmployeeID) {
		fields = append(fields, division_choice_pa.FieldEmployeeID)
	}
	if m.FieldCleared(division_choice_pa.FieldUpdatedAt) {
		fields = append(fields, division_choice_pa.FieldUpdatedAt)
	}
	if m.FieldCleared(division_choice_pa.FieldUpdatedBy) {
		fields = append(fields, division_choice_pa.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DivisionChoicePAMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DivisionChoicePAMutation) ClearField(name string) error {
	switch name {
	case division_choice_pa.FieldApplication:
		m.ClearApplication()
		return nil
	case division_choice_pa.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case division_choice_pa.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case division_choice_pa.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Division_Choice_PA nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DivisionChoicePAMutation) ResetField(name string) error {
	switch name {
	case division_choice_pa.FieldApplication:
		m.ResetApplication()
		return nil
	case division_choice_pa.FieldCadrePrefNo:
		m.ResetCadrePrefNo()
		return nil
	case division_choice_pa.FieldCadrePrefValue:
		m.ResetCadrePrefValue()
		return nil
	case division_choice_pa.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case division_choice_pa.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case division_choice_pa.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Division_Choice_PA field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DivisionChoicePAMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DivisionChoicePAMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DivisionChoicePAMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DivisionChoicePAMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DivisionChoicePAMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DivisionChoicePAMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DivisionChoicePAMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Division_Choice_PA unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DivisionChoicePAMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Division_Choice_PA edge %s", name)
}

// DivisionChoicePMMutation represents an operation that mutates the Division_Choice_PM nodes in the graph.
type DivisionChoicePMMutation struct {
	config
	op              Op
	typ             string
	id              *int32
	_Application    *string
	_CadrePrefNo    *string
	_CadrePrefValue *string
	_EmployeeID     *int64
	add_EmployeeID  *int64
	_UpdatedAt      *time.Time
	_UpdatedBy      *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Division_Choice_PM, error)
	predicates      []predicate.Division_Choice_PM
}

var _ ent.Mutation = (*DivisionChoicePMMutation)(nil)

// divisionChoicePMOption allows management of the mutation configuration using functional options.
type divisionChoicePMOption func(*DivisionChoicePMMutation)

// newDivisionChoicePMMutation creates new mutation for the Division_Choice_PM entity.
func newDivisionChoicePMMutation(c config, op Op, opts ...divisionChoicePMOption) *DivisionChoicePMMutation {
	m := &DivisionChoicePMMutation{
		config:        c,
		op:            op,
		typ:           TypeDivisionChoicePM,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDivision_Choice_PMID sets the ID field of the mutation.
func withDivision_Choice_PMID(id int32) divisionChoicePMOption {
	return func(m *DivisionChoicePMMutation) {
		var (
			err   error
			once  sync.Once
			value *Division_Choice_PM
		)
		m.oldValue = func(ctx context.Context) (*Division_Choice_PM, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Division_Choice_PM.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDivision_Choice_PM sets the old Division_Choice_PM of the mutation.
func withDivision_Choice_PM(node *Division_Choice_PM) divisionChoicePMOption {
	return func(m *DivisionChoicePMMutation) {
		m.oldValue = func(context.Context) (*Division_Choice_PM, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DivisionChoicePMMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DivisionChoicePMMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Division_Choice_PM entities.
func (m *DivisionChoicePMMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DivisionChoicePMMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DivisionChoicePMMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Division_Choice_PM.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApplication sets the "Application" field.
func (m *DivisionChoicePMMutation) SetApplication(s string) {
	m._Application = &s
}

// Application returns the value of the "Application" field in the mutation.
func (m *DivisionChoicePMMutation) Application() (r string, exists bool) {
	v := m._Application
	if v == nil {
		return
	}
	return *v, true
}

// OldApplication returns the old "Application" field's value of the Division_Choice_PM entity.
// If the Division_Choice_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePMMutation) OldApplication(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplication is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplication requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplication: %w", err)
	}
	return oldValue.Application, nil
}

// ClearApplication clears the value of the "Application" field.
func (m *DivisionChoicePMMutation) ClearApplication() {
	m._Application = nil
	m.clearedFields[division_choice_pm.FieldApplication] = struct{}{}
}

// ApplicationCleared returns if the "Application" field was cleared in this mutation.
func (m *DivisionChoicePMMutation) ApplicationCleared() bool {
	_, ok := m.clearedFields[division_choice_pm.FieldApplication]
	return ok
}

// ResetApplication resets all changes to the "Application" field.
func (m *DivisionChoicePMMutation) ResetApplication() {
	m._Application = nil
	delete(m.clearedFields, division_choice_pm.FieldApplication)
}

// SetCadrePrefNo sets the "CadrePrefNo" field.
func (m *DivisionChoicePMMutation) SetCadrePrefNo(s string) {
	m._CadrePrefNo = &s
}

// CadrePrefNo returns the value of the "CadrePrefNo" field in the mutation.
func (m *DivisionChoicePMMutation) CadrePrefNo() (r string, exists bool) {
	v := m._CadrePrefNo
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePrefNo returns the old "CadrePrefNo" field's value of the Division_Choice_PM entity.
// If the Division_Choice_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePMMutation) OldCadrePrefNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePrefNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePrefNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePrefNo: %w", err)
	}
	return oldValue.CadrePrefNo, nil
}

// ResetCadrePrefNo resets all changes to the "CadrePrefNo" field.
func (m *DivisionChoicePMMutation) ResetCadrePrefNo() {
	m._CadrePrefNo = nil
}

// SetCadrePrefValue sets the "CadrePrefValue" field.
func (m *DivisionChoicePMMutation) SetCadrePrefValue(s string) {
	m._CadrePrefValue = &s
}

// CadrePrefValue returns the value of the "CadrePrefValue" field in the mutation.
func (m *DivisionChoicePMMutation) CadrePrefValue() (r string, exists bool) {
	v := m._CadrePrefValue
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePrefValue returns the old "CadrePrefValue" field's value of the Division_Choice_PM entity.
// If the Division_Choice_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePMMutation) OldCadrePrefValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePrefValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePrefValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePrefValue: %w", err)
	}
	return oldValue.CadrePrefValue, nil
}

// ResetCadrePrefValue resets all changes to the "CadrePrefValue" field.
func (m *DivisionChoicePMMutation) ResetCadrePrefValue() {
	m._CadrePrefValue = nil
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *DivisionChoicePMMutation) SetEmployeeID(i int64) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *DivisionChoicePMMutation) EmployeeID() (r int64, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the Division_Choice_PM entity.
// If the Division_Choice_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePMMutation) OldEmployeeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *DivisionChoicePMMutation) AddEmployeeID(i int64) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *DivisionChoicePMMutation) AddedEmployeeID() (r int64, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeeID clears the value of the "EmployeeID" field.
func (m *DivisionChoicePMMutation) ClearEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	m.clearedFields[division_choice_pm.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "EmployeeID" field was cleared in this mutation.
func (m *DivisionChoicePMMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[division_choice_pm.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *DivisionChoicePMMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	delete(m.clearedFields, division_choice_pm.FieldEmployeeID)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *DivisionChoicePMMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *DivisionChoicePMMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Division_Choice_PM entity.
// If the Division_Choice_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePMMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *DivisionChoicePMMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[division_choice_pm.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *DivisionChoicePMMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[division_choice_pm.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *DivisionChoicePMMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, division_choice_pm.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *DivisionChoicePMMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *DivisionChoicePMMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the Division_Choice_PM entity.
// If the Division_Choice_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePMMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *DivisionChoicePMMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[division_choice_pm.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *DivisionChoicePMMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[division_choice_pm.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *DivisionChoicePMMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, division_choice_pm.FieldUpdatedBy)
}

// Where appends a list predicates to the DivisionChoicePMMutation builder.
func (m *DivisionChoicePMMutation) Where(ps ...predicate.Division_Choice_PM) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DivisionChoicePMMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DivisionChoicePMMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Division_Choice_PM, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DivisionChoicePMMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DivisionChoicePMMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Division_Choice_PM).
func (m *DivisionChoicePMMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DivisionChoicePMMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._Application != nil {
		fields = append(fields, division_choice_pm.FieldApplication)
	}
	if m._CadrePrefNo != nil {
		fields = append(fields, division_choice_pm.FieldCadrePrefNo)
	}
	if m._CadrePrefValue != nil {
		fields = append(fields, division_choice_pm.FieldCadrePrefValue)
	}
	if m._EmployeeID != nil {
		fields = append(fields, division_choice_pm.FieldEmployeeID)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, division_choice_pm.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, division_choice_pm.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DivisionChoicePMMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case division_choice_pm.FieldApplication:
		return m.Application()
	case division_choice_pm.FieldCadrePrefNo:
		return m.CadrePrefNo()
	case division_choice_pm.FieldCadrePrefValue:
		return m.CadrePrefValue()
	case division_choice_pm.FieldEmployeeID:
		return m.EmployeeID()
	case division_choice_pm.FieldUpdatedAt:
		return m.UpdatedAt()
	case division_choice_pm.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DivisionChoicePMMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case division_choice_pm.FieldApplication:
		return m.OldApplication(ctx)
	case division_choice_pm.FieldCadrePrefNo:
		return m.OldCadrePrefNo(ctx)
	case division_choice_pm.FieldCadrePrefValue:
		return m.OldCadrePrefValue(ctx)
	case division_choice_pm.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case division_choice_pm.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case division_choice_pm.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Division_Choice_PM field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivisionChoicePMMutation) SetField(name string, value ent.Value) error {
	switch name {
	case division_choice_pm.FieldApplication:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplication(v)
		return nil
	case division_choice_pm.FieldCadrePrefNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePrefNo(v)
		return nil
	case division_choice_pm.FieldCadrePrefValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePrefValue(v)
		return nil
	case division_choice_pm.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case division_choice_pm.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case division_choice_pm.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Division_Choice_PM field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DivisionChoicePMMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeeID != nil {
		fields = append(fields, division_choice_pm.FieldEmployeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DivisionChoicePMMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case division_choice_pm.FieldEmployeeID:
		return m.AddedEmployeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivisionChoicePMMutation) AddField(name string, value ent.Value) error {
	switch name {
	case division_choice_pm.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown Division_Choice_PM numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DivisionChoicePMMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(division_choice_pm.FieldApplication) {
		fields = append(fields, division_choice_pm.FieldApplication)
	}
	if m.FieldCleared(division_choice_pm.FieldEmployeeID) {
		fields = append(fields, division_choice_pm.FieldEmployeeID)
	}
	if m.FieldCleared(division_choice_pm.FieldUpdatedAt) {
		fields = append(fields, division_choice_pm.FieldUpdatedAt)
	}
	if m.FieldCleared(division_choice_pm.FieldUpdatedBy) {
		fields = append(fields, division_choice_pm.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DivisionChoicePMMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DivisionChoicePMMutation) ClearField(name string) error {
	switch name {
	case division_choice_pm.FieldApplication:
		m.ClearApplication()
		return nil
	case division_choice_pm.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case division_choice_pm.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case division_choice_pm.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Division_Choice_PM nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DivisionChoicePMMutation) ResetField(name string) error {
	switch name {
	case division_choice_pm.FieldApplication:
		m.ResetApplication()
		return nil
	case division_choice_pm.FieldCadrePrefNo:
		m.ResetCadrePrefNo()
		return nil
	case division_choice_pm.FieldCadrePrefValue:
		m.ResetCadrePrefValue()
		return nil
	case division_choice_pm.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case division_choice_pm.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case division_choice_pm.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Division_Choice_PM field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DivisionChoicePMMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DivisionChoicePMMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DivisionChoicePMMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DivisionChoicePMMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DivisionChoicePMMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DivisionChoicePMMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DivisionChoicePMMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Division_Choice_PM unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DivisionChoicePMMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Division_Choice_PM edge %s", name)
}

// DivisionChoicePSMutation represents an operation that mutates the Division_Choice_PS nodes in the graph.
type DivisionChoicePSMutation struct {
	config
	op              Op
	typ             string
	id              *int32
	_Application    *string
	_CadrePrefNo    *string
	_CadrePrefValue *string
	_EmployeeID     *int64
	add_EmployeeID  *int64
	_UpdatedAt      *time.Time
	_UpdatedBy      *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Division_Choice_PS, error)
	predicates      []predicate.Division_Choice_PS
}

var _ ent.Mutation = (*DivisionChoicePSMutation)(nil)

// divisionChoicePSOption allows management of the mutation configuration using functional options.
type divisionChoicePSOption func(*DivisionChoicePSMutation)

// newDivisionChoicePSMutation creates new mutation for the Division_Choice_PS entity.
func newDivisionChoicePSMutation(c config, op Op, opts ...divisionChoicePSOption) *DivisionChoicePSMutation {
	m := &DivisionChoicePSMutation{
		config:        c,
		op:            op,
		typ:           TypeDivisionChoicePS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDivision_Choice_PSID sets the ID field of the mutation.
func withDivision_Choice_PSID(id int32) divisionChoicePSOption {
	return func(m *DivisionChoicePSMutation) {
		var (
			err   error
			once  sync.Once
			value *Division_Choice_PS
		)
		m.oldValue = func(ctx context.Context) (*Division_Choice_PS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Division_Choice_PS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDivision_Choice_PS sets the old Division_Choice_PS of the mutation.
func withDivision_Choice_PS(node *Division_Choice_PS) divisionChoicePSOption {
	return func(m *DivisionChoicePSMutation) {
		m.oldValue = func(context.Context) (*Division_Choice_PS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DivisionChoicePSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DivisionChoicePSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Division_Choice_PS entities.
func (m *DivisionChoicePSMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DivisionChoicePSMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DivisionChoicePSMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Division_Choice_PS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApplication sets the "Application" field.
func (m *DivisionChoicePSMutation) SetApplication(s string) {
	m._Application = &s
}

// Application returns the value of the "Application" field in the mutation.
func (m *DivisionChoicePSMutation) Application() (r string, exists bool) {
	v := m._Application
	if v == nil {
		return
	}
	return *v, true
}

// OldApplication returns the old "Application" field's value of the Division_Choice_PS entity.
// If the Division_Choice_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePSMutation) OldApplication(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplication is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplication requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplication: %w", err)
	}
	return oldValue.Application, nil
}

// ClearApplication clears the value of the "Application" field.
func (m *DivisionChoicePSMutation) ClearApplication() {
	m._Application = nil
	m.clearedFields[division_choice_ps.FieldApplication] = struct{}{}
}

// ApplicationCleared returns if the "Application" field was cleared in this mutation.
func (m *DivisionChoicePSMutation) ApplicationCleared() bool {
	_, ok := m.clearedFields[division_choice_ps.FieldApplication]
	return ok
}

// ResetApplication resets all changes to the "Application" field.
func (m *DivisionChoicePSMutation) ResetApplication() {
	m._Application = nil
	delete(m.clearedFields, division_choice_ps.FieldApplication)
}

// SetCadrePrefNo sets the "CadrePrefNo" field.
func (m *DivisionChoicePSMutation) SetCadrePrefNo(s string) {
	m._CadrePrefNo = &s
}

// CadrePrefNo returns the value of the "CadrePrefNo" field in the mutation.
func (m *DivisionChoicePSMutation) CadrePrefNo() (r string, exists bool) {
	v := m._CadrePrefNo
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePrefNo returns the old "CadrePrefNo" field's value of the Division_Choice_PS entity.
// If the Division_Choice_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePSMutation) OldCadrePrefNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePrefNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePrefNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePrefNo: %w", err)
	}
	return oldValue.CadrePrefNo, nil
}

// ResetCadrePrefNo resets all changes to the "CadrePrefNo" field.
func (m *DivisionChoicePSMutation) ResetCadrePrefNo() {
	m._CadrePrefNo = nil
}

// SetCadrePrefValue sets the "CadrePrefValue" field.
func (m *DivisionChoicePSMutation) SetCadrePrefValue(s string) {
	m._CadrePrefValue = &s
}

// CadrePrefValue returns the value of the "CadrePrefValue" field in the mutation.
func (m *DivisionChoicePSMutation) CadrePrefValue() (r string, exists bool) {
	v := m._CadrePrefValue
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePrefValue returns the old "CadrePrefValue" field's value of the Division_Choice_PS entity.
// If the Division_Choice_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePSMutation) OldCadrePrefValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePrefValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePrefValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePrefValue: %w", err)
	}
	return oldValue.CadrePrefValue, nil
}

// ResetCadrePrefValue resets all changes to the "CadrePrefValue" field.
func (m *DivisionChoicePSMutation) ResetCadrePrefValue() {
	m._CadrePrefValue = nil
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *DivisionChoicePSMutation) SetEmployeeID(i int64) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *DivisionChoicePSMutation) EmployeeID() (r int64, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the Division_Choice_PS entity.
// If the Division_Choice_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePSMutation) OldEmployeeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *DivisionChoicePSMutation) AddEmployeeID(i int64) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *DivisionChoicePSMutation) AddedEmployeeID() (r int64, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeeID clears the value of the "EmployeeID" field.
func (m *DivisionChoicePSMutation) ClearEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	m.clearedFields[division_choice_ps.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "EmployeeID" field was cleared in this mutation.
func (m *DivisionChoicePSMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[division_choice_ps.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *DivisionChoicePSMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	delete(m.clearedFields, division_choice_ps.FieldEmployeeID)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *DivisionChoicePSMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *DivisionChoicePSMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Division_Choice_PS entity.
// If the Division_Choice_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePSMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *DivisionChoicePSMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[division_choice_ps.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *DivisionChoicePSMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[division_choice_ps.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *DivisionChoicePSMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, division_choice_ps.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *DivisionChoicePSMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *DivisionChoicePSMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the Division_Choice_PS entity.
// If the Division_Choice_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionChoicePSMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *DivisionChoicePSMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[division_choice_ps.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *DivisionChoicePSMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[division_choice_ps.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *DivisionChoicePSMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, division_choice_ps.FieldUpdatedBy)
}

// Where appends a list predicates to the DivisionChoicePSMutation builder.
func (m *DivisionChoicePSMutation) Where(ps ...predicate.Division_Choice_PS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DivisionChoicePSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DivisionChoicePSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Division_Choice_PS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DivisionChoicePSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DivisionChoicePSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Division_Choice_PS).
func (m *DivisionChoicePSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DivisionChoicePSMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._Application != nil {
		fields = append(fields, division_choice_ps.FieldApplication)
	}
	if m._CadrePrefNo != nil {
		fields = append(fields, division_choice_ps.FieldCadrePrefNo)
	}
	if m._CadrePrefValue != nil {
		fields = append(fields, division_choice_ps.FieldCadrePrefValue)
	}
	if m._EmployeeID != nil {
		fields = append(fields, division_choice_ps.FieldEmployeeID)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, division_choice_ps.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, division_choice_ps.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DivisionChoicePSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case division_choice_ps.FieldApplication:
		return m.Application()
	case division_choice_ps.FieldCadrePrefNo:
		return m.CadrePrefNo()
	case division_choice_ps.FieldCadrePrefValue:
		return m.CadrePrefValue()
	case division_choice_ps.FieldEmployeeID:
		return m.EmployeeID()
	case division_choice_ps.FieldUpdatedAt:
		return m.UpdatedAt()
	case division_choice_ps.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DivisionChoicePSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case division_choice_ps.FieldApplication:
		return m.OldApplication(ctx)
	case division_choice_ps.FieldCadrePrefNo:
		return m.OldCadrePrefNo(ctx)
	case division_choice_ps.FieldCadrePrefValue:
		return m.OldCadrePrefValue(ctx)
	case division_choice_ps.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case division_choice_ps.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case division_choice_ps.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Division_Choice_PS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivisionChoicePSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case division_choice_ps.FieldApplication:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplication(v)
		return nil
	case division_choice_ps.FieldCadrePrefNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePrefNo(v)
		return nil
	case division_choice_ps.FieldCadrePrefValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePrefValue(v)
		return nil
	case division_choice_ps.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case division_choice_ps.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case division_choice_ps.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Division_Choice_PS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DivisionChoicePSMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeeID != nil {
		fields = append(fields, division_choice_ps.FieldEmployeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DivisionChoicePSMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case division_choice_ps.FieldEmployeeID:
		return m.AddedEmployeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivisionChoicePSMutation) AddField(name string, value ent.Value) error {
	switch name {
	case division_choice_ps.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown Division_Choice_PS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DivisionChoicePSMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(division_choice_ps.FieldApplication) {
		fields = append(fields, division_choice_ps.FieldApplication)
	}
	if m.FieldCleared(division_choice_ps.FieldEmployeeID) {
		fields = append(fields, division_choice_ps.FieldEmployeeID)
	}
	if m.FieldCleared(division_choice_ps.FieldUpdatedAt) {
		fields = append(fields, division_choice_ps.FieldUpdatedAt)
	}
	if m.FieldCleared(division_choice_ps.FieldUpdatedBy) {
		fields = append(fields, division_choice_ps.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DivisionChoicePSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DivisionChoicePSMutation) ClearField(name string) error {
	switch name {
	case division_choice_ps.FieldApplication:
		m.ClearApplication()
		return nil
	case division_choice_ps.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case division_choice_ps.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case division_choice_ps.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Division_Choice_PS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DivisionChoicePSMutation) ResetField(name string) error {
	switch name {
	case division_choice_ps.FieldApplication:
		m.ResetApplication()
		return nil
	case division_choice_ps.FieldCadrePrefNo:
		m.ResetCadrePrefNo()
		return nil
	case division_choice_ps.FieldCadrePrefValue:
		m.ResetCadrePrefValue()
		return nil
	case division_choice_ps.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case division_choice_ps.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case division_choice_ps.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Division_Choice_PS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DivisionChoicePSMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DivisionChoicePSMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DivisionChoicePSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DivisionChoicePSMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DivisionChoicePSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DivisionChoicePSMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DivisionChoicePSMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Division_Choice_PS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DivisionChoicePSMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Division_Choice_PS edge %s", name)
}

// EligibilityMasterMutation represents an operation that mutates the EligibilityMaster nodes in the graph.
type EligibilityMasterMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int32
	_ExamName                     *string
	_PostCode                     *string
	gdsService                    *bool
	_AgeCriteria                  *int32
	add_AgeCriteria               *int32
	_ServiceCriteria              *int32
	add_ServiceCriteria           *int32
	_DrivingLicenseCriteria       *bool
	_ComputerKnowledge            *bool
	_LevelOfPayMatrixEligibility  *bool
	_Education                    *string
	_NotifyCode                   *int32
	add_NotifyCode                *int32
	_CategoryCode                 *string
	_PaperDescription             *string
	_MinimumMarks                 *int32
	add_MinimumMarks              *int32
	clearedFields                 map[string]struct{}
	_Notifications                map[int32]struct{}
	removed_Notifications         map[int32]struct{}
	cleared_Notifications         bool
	_CategoryEligibility          map[int32]struct{}
	removed_CategoryEligibility   map[int32]struct{}
	cleared_CategoryEligibility   bool
	_PostEligibility              map[int32]struct{}
	removed_PostEligibility       map[int32]struct{}
	cleared_PostEligibility       bool
	_ExamPaper_Eligibility        *int32
	cleared_ExamPaper_Eligibility bool
	_Exam_Eligibility             *int32
	cleared_Exam_Eligibility      bool
	done                          bool
	oldValue                      func(context.Context) (*EligibilityMaster, error)
	predicates                    []predicate.EligibilityMaster
}

var _ ent.Mutation = (*EligibilityMasterMutation)(nil)

// eligibilitymasterOption allows management of the mutation configuration using functional options.
type eligibilitymasterOption func(*EligibilityMasterMutation)

// newEligibilityMasterMutation creates new mutation for the EligibilityMaster entity.
func newEligibilityMasterMutation(c config, op Op, opts ...eligibilitymasterOption) *EligibilityMasterMutation {
	m := &EligibilityMasterMutation{
		config:        c,
		op:            op,
		typ:           TypeEligibilityMaster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEligibilityMasterID sets the ID field of the mutation.
func withEligibilityMasterID(id int32) eligibilitymasterOption {
	return func(m *EligibilityMasterMutation) {
		var (
			err   error
			once  sync.Once
			value *EligibilityMaster
		)
		m.oldValue = func(ctx context.Context) (*EligibilityMaster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EligibilityMaster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEligibilityMaster sets the old EligibilityMaster of the mutation.
func withEligibilityMaster(node *EligibilityMaster) eligibilitymasterOption {
	return func(m *EligibilityMasterMutation) {
		m.oldValue = func(context.Context) (*EligibilityMaster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EligibilityMasterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EligibilityMasterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EligibilityMaster entities.
func (m *EligibilityMasterMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EligibilityMasterMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EligibilityMasterMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EligibilityMaster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExamCode sets the "ExamCode" field.
func (m *EligibilityMasterMutation) SetExamCode(i int32) {
	m._Exam_Eligibility = &i
}

// ExamCode returns the value of the "ExamCode" field in the mutation.
func (m *EligibilityMasterMutation) ExamCode() (r int32, exists bool) {
	v := m._Exam_Eligibility
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCode returns the old "ExamCode" field's value of the EligibilityMaster entity.
// If the EligibilityMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EligibilityMasterMutation) OldExamCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCode: %w", err)
	}
	return oldValue.ExamCode, nil
}

// ClearExamCode clears the value of the "ExamCode" field.
func (m *EligibilityMasterMutation) ClearExamCode() {
	m._Exam_Eligibility = nil
	m.clearedFields[eligibilitymaster.FieldExamCode] = struct{}{}
}

// ExamCodeCleared returns if the "ExamCode" field was cleared in this mutation.
func (m *EligibilityMasterMutation) ExamCodeCleared() bool {
	_, ok := m.clearedFields[eligibilitymaster.FieldExamCode]
	return ok
}

// ResetExamCode resets all changes to the "ExamCode" field.
func (m *EligibilityMasterMutation) ResetExamCode() {
	m._Exam_Eligibility = nil
	delete(m.clearedFields, eligibilitymaster.FieldExamCode)
}

// SetExamName sets the "ExamName" field.
func (m *EligibilityMasterMutation) SetExamName(s string) {
	m._ExamName = &s
}

// ExamName returns the value of the "ExamName" field in the mutation.
func (m *EligibilityMasterMutation) ExamName() (r string, exists bool) {
	v := m._ExamName
	if v == nil {
		return
	}
	return *v, true
}

// OldExamName returns the old "ExamName" field's value of the EligibilityMaster entity.
// If the EligibilityMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EligibilityMasterMutation) OldExamName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamName: %w", err)
	}
	return oldValue.ExamName, nil
}

// ResetExamName resets all changes to the "ExamName" field.
func (m *EligibilityMasterMutation) ResetExamName() {
	m._ExamName = nil
}

// SetPostCode sets the "PostCode" field.
func (m *EligibilityMasterMutation) SetPostCode(s string) {
	m._PostCode = &s
}

// PostCode returns the value of the "PostCode" field in the mutation.
func (m *EligibilityMasterMutation) PostCode() (r string, exists bool) {
	v := m._PostCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPostCode returns the old "PostCode" field's value of the EligibilityMaster entity.
// If the EligibilityMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EligibilityMasterMutation) OldPostCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostCode: %w", err)
	}
	return oldValue.PostCode, nil
}

// ClearPostCode clears the value of the "PostCode" field.
func (m *EligibilityMasterMutation) ClearPostCode() {
	m._PostCode = nil
	m.clearedFields[eligibilitymaster.FieldPostCode] = struct{}{}
}

// PostCodeCleared returns if the "PostCode" field was cleared in this mutation.
func (m *EligibilityMasterMutation) PostCodeCleared() bool {
	_, ok := m.clearedFields[eligibilitymaster.FieldPostCode]
	return ok
}

// ResetPostCode resets all changes to the "PostCode" field.
func (m *EligibilityMasterMutation) ResetPostCode() {
	m._PostCode = nil
	delete(m.clearedFields, eligibilitymaster.FieldPostCode)
}

// SetGdsService sets the "gdsService" field.
func (m *EligibilityMasterMutation) SetGdsService(b bool) {
	m.gdsService = &b
}

// GdsService returns the value of the "gdsService" field in the mutation.
func (m *EligibilityMasterMutation) GdsService() (r bool, exists bool) {
	v := m.gdsService
	if v == nil {
		return
	}
	return *v, true
}

// OldGdsService returns the old "gdsService" field's value of the EligibilityMaster entity.
// If the EligibilityMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EligibilityMasterMutation) OldGdsService(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGdsService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGdsService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGdsService: %w", err)
	}
	return oldValue.GdsService, nil
}

// ResetGdsService resets all changes to the "gdsService" field.
func (m *EligibilityMasterMutation) ResetGdsService() {
	m.gdsService = nil
}

// SetAgeCriteria sets the "AgeCriteria" field.
func (m *EligibilityMasterMutation) SetAgeCriteria(i int32) {
	m._AgeCriteria = &i
	m.add_AgeCriteria = nil
}

// AgeCriteria returns the value of the "AgeCriteria" field in the mutation.
func (m *EligibilityMasterMutation) AgeCriteria() (r int32, exists bool) {
	v := m._AgeCriteria
	if v == nil {
		return
	}
	return *v, true
}

// OldAgeCriteria returns the old "AgeCriteria" field's value of the EligibilityMaster entity.
// If the EligibilityMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EligibilityMasterMutation) OldAgeCriteria(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgeCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgeCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgeCriteria: %w", err)
	}
	return oldValue.AgeCriteria, nil
}

// AddAgeCriteria adds i to the "AgeCriteria" field.
func (m *EligibilityMasterMutation) AddAgeCriteria(i int32) {
	if m.add_AgeCriteria != nil {
		*m.add_AgeCriteria += i
	} else {
		m.add_AgeCriteria = &i
	}
}

// AddedAgeCriteria returns the value that was added to the "AgeCriteria" field in this mutation.
func (m *EligibilityMasterMutation) AddedAgeCriteria() (r int32, exists bool) {
	v := m.add_AgeCriteria
	if v == nil {
		return
	}
	return *v, true
}

// ClearAgeCriteria clears the value of the "AgeCriteria" field.
func (m *EligibilityMasterMutation) ClearAgeCriteria() {
	m._AgeCriteria = nil
	m.add_AgeCriteria = nil
	m.clearedFields[eligibilitymaster.FieldAgeCriteria] = struct{}{}
}

// AgeCriteriaCleared returns if the "AgeCriteria" field was cleared in this mutation.
func (m *EligibilityMasterMutation) AgeCriteriaCleared() bool {
	_, ok := m.clearedFields[eligibilitymaster.FieldAgeCriteria]
	return ok
}

// ResetAgeCriteria resets all changes to the "AgeCriteria" field.
func (m *EligibilityMasterMutation) ResetAgeCriteria() {
	m._AgeCriteria = nil
	m.add_AgeCriteria = nil
	delete(m.clearedFields, eligibilitymaster.FieldAgeCriteria)
}

// SetServiceCriteria sets the "ServiceCriteria" field.
func (m *EligibilityMasterMutation) SetServiceCriteria(i int32) {
	m._ServiceCriteria = &i
	m.add_ServiceCriteria = nil
}

// ServiceCriteria returns the value of the "ServiceCriteria" field in the mutation.
func (m *EligibilityMasterMutation) ServiceCriteria() (r int32, exists bool) {
	v := m._ServiceCriteria
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceCriteria returns the old "ServiceCriteria" field's value of the EligibilityMaster entity.
// If the EligibilityMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EligibilityMasterMutation) OldServiceCriteria(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceCriteria: %w", err)
	}
	return oldValue.ServiceCriteria, nil
}

// AddServiceCriteria adds i to the "ServiceCriteria" field.
func (m *EligibilityMasterMutation) AddServiceCriteria(i int32) {
	if m.add_ServiceCriteria != nil {
		*m.add_ServiceCriteria += i
	} else {
		m.add_ServiceCriteria = &i
	}
}

// AddedServiceCriteria returns the value that was added to the "ServiceCriteria" field in this mutation.
func (m *EligibilityMasterMutation) AddedServiceCriteria() (r int32, exists bool) {
	v := m.add_ServiceCriteria
	if v == nil {
		return
	}
	return *v, true
}

// ClearServiceCriteria clears the value of the "ServiceCriteria" field.
func (m *EligibilityMasterMutation) ClearServiceCriteria() {
	m._ServiceCriteria = nil
	m.add_ServiceCriteria = nil
	m.clearedFields[eligibilitymaster.FieldServiceCriteria] = struct{}{}
}

// ServiceCriteriaCleared returns if the "ServiceCriteria" field was cleared in this mutation.
func (m *EligibilityMasterMutation) ServiceCriteriaCleared() bool {
	_, ok := m.clearedFields[eligibilitymaster.FieldServiceCriteria]
	return ok
}

// ResetServiceCriteria resets all changes to the "ServiceCriteria" field.
func (m *EligibilityMasterMutation) ResetServiceCriteria() {
	m._ServiceCriteria = nil
	m.add_ServiceCriteria = nil
	delete(m.clearedFields, eligibilitymaster.FieldServiceCriteria)
}

// SetDrivingLicenseCriteria sets the "DrivingLicenseCriteria" field.
func (m *EligibilityMasterMutation) SetDrivingLicenseCriteria(b bool) {
	m._DrivingLicenseCriteria = &b
}

// DrivingLicenseCriteria returns the value of the "DrivingLicenseCriteria" field in the mutation.
func (m *EligibilityMasterMutation) DrivingLicenseCriteria() (r bool, exists bool) {
	v := m._DrivingLicenseCriteria
	if v == nil {
		return
	}
	return *v, true
}

// OldDrivingLicenseCriteria returns the old "DrivingLicenseCriteria" field's value of the EligibilityMaster entity.
// If the EligibilityMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EligibilityMasterMutation) OldDrivingLicenseCriteria(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrivingLicenseCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrivingLicenseCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrivingLicenseCriteria: %w", err)
	}
	return oldValue.DrivingLicenseCriteria, nil
}

// ResetDrivingLicenseCriteria resets all changes to the "DrivingLicenseCriteria" field.
func (m *EligibilityMasterMutation) ResetDrivingLicenseCriteria() {
	m._DrivingLicenseCriteria = nil
}

// SetComputerKnowledge sets the "ComputerKnowledge" field.
func (m *EligibilityMasterMutation) SetComputerKnowledge(b bool) {
	m._ComputerKnowledge = &b
}

// ComputerKnowledge returns the value of the "ComputerKnowledge" field in the mutation.
func (m *EligibilityMasterMutation) ComputerKnowledge() (r bool, exists bool) {
	v := m._ComputerKnowledge
	if v == nil {
		return
	}
	return *v, true
}

// OldComputerKnowledge returns the old "ComputerKnowledge" field's value of the EligibilityMaster entity.
// If the EligibilityMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EligibilityMasterMutation) OldComputerKnowledge(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComputerKnowledge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComputerKnowledge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComputerKnowledge: %w", err)
	}
	return oldValue.ComputerKnowledge, nil
}

// ResetComputerKnowledge resets all changes to the "ComputerKnowledge" field.
func (m *EligibilityMasterMutation) ResetComputerKnowledge() {
	m._ComputerKnowledge = nil
}

// SetLevelOfPayMatrixEligibility sets the "LevelOfPayMatrixEligibility" field.
func (m *EligibilityMasterMutation) SetLevelOfPayMatrixEligibility(b bool) {
	m._LevelOfPayMatrixEligibility = &b
}

// LevelOfPayMatrixEligibility returns the value of the "LevelOfPayMatrixEligibility" field in the mutation.
func (m *EligibilityMasterMutation) LevelOfPayMatrixEligibility() (r bool, exists bool) {
	v := m._LevelOfPayMatrixEligibility
	if v == nil {
		return
	}
	return *v, true
}

// OldLevelOfPayMatrixEligibility returns the old "LevelOfPayMatrixEligibility" field's value of the EligibilityMaster entity.
// If the EligibilityMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EligibilityMasterMutation) OldLevelOfPayMatrixEligibility(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevelOfPayMatrixEligibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevelOfPayMatrixEligibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevelOfPayMatrixEligibility: %w", err)
	}
	return oldValue.LevelOfPayMatrixEligibility, nil
}

// ResetLevelOfPayMatrixEligibility resets all changes to the "LevelOfPayMatrixEligibility" field.
func (m *EligibilityMasterMutation) ResetLevelOfPayMatrixEligibility() {
	m._LevelOfPayMatrixEligibility = nil
}

// SetEducation sets the "Education" field.
func (m *EligibilityMasterMutation) SetEducation(s string) {
	m._Education = &s
}

// Education returns the value of the "Education" field in the mutation.
func (m *EligibilityMasterMutation) Education() (r string, exists bool) {
	v := m._Education
	if v == nil {
		return
	}
	return *v, true
}

// OldEducation returns the old "Education" field's value of the EligibilityMaster entity.
// If the EligibilityMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EligibilityMasterMutation) OldEducation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducation: %w", err)
	}
	return oldValue.Education, nil
}

// ResetEducation resets all changes to the "Education" field.
func (m *EligibilityMasterMutation) ResetEducation() {
	m._Education = nil
}

// SetNotifyCode sets the "NotifyCode" field.
func (m *EligibilityMasterMutation) SetNotifyCode(i int32) {
	m._NotifyCode = &i
	m.add_NotifyCode = nil
}

// NotifyCode returns the value of the "NotifyCode" field in the mutation.
func (m *EligibilityMasterMutation) NotifyCode() (r int32, exists bool) {
	v := m._NotifyCode
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyCode returns the old "NotifyCode" field's value of the EligibilityMaster entity.
// If the EligibilityMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EligibilityMasterMutation) OldNotifyCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyCode: %w", err)
	}
	return oldValue.NotifyCode, nil
}

// AddNotifyCode adds i to the "NotifyCode" field.
func (m *EligibilityMasterMutation) AddNotifyCode(i int32) {
	if m.add_NotifyCode != nil {
		*m.add_NotifyCode += i
	} else {
		m.add_NotifyCode = &i
	}
}

// AddedNotifyCode returns the value that was added to the "NotifyCode" field in this mutation.
func (m *EligibilityMasterMutation) AddedNotifyCode() (r int32, exists bool) {
	v := m.add_NotifyCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearNotifyCode clears the value of the "NotifyCode" field.
func (m *EligibilityMasterMutation) ClearNotifyCode() {
	m._NotifyCode = nil
	m.add_NotifyCode = nil
	m.clearedFields[eligibilitymaster.FieldNotifyCode] = struct{}{}
}

// NotifyCodeCleared returns if the "NotifyCode" field was cleared in this mutation.
func (m *EligibilityMasterMutation) NotifyCodeCleared() bool {
	_, ok := m.clearedFields[eligibilitymaster.FieldNotifyCode]
	return ok
}

// ResetNotifyCode resets all changes to the "NotifyCode" field.
func (m *EligibilityMasterMutation) ResetNotifyCode() {
	m._NotifyCode = nil
	m.add_NotifyCode = nil
	delete(m.clearedFields, eligibilitymaster.FieldNotifyCode)
}

// SetCategoryCode sets the "CategoryCode" field.
func (m *EligibilityMasterMutation) SetCategoryCode(s string) {
	m._CategoryCode = &s
}

// CategoryCode returns the value of the "CategoryCode" field in the mutation.
func (m *EligibilityMasterMutation) CategoryCode() (r string, exists bool) {
	v := m._CategoryCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryCode returns the old "CategoryCode" field's value of the EligibilityMaster entity.
// If the EligibilityMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EligibilityMasterMutation) OldCategoryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryCode: %w", err)
	}
	return oldValue.CategoryCode, nil
}

// ClearCategoryCode clears the value of the "CategoryCode" field.
func (m *EligibilityMasterMutation) ClearCategoryCode() {
	m._CategoryCode = nil
	m.clearedFields[eligibilitymaster.FieldCategoryCode] = struct{}{}
}

// CategoryCodeCleared returns if the "CategoryCode" field was cleared in this mutation.
func (m *EligibilityMasterMutation) CategoryCodeCleared() bool {
	_, ok := m.clearedFields[eligibilitymaster.FieldCategoryCode]
	return ok
}

// ResetCategoryCode resets all changes to the "CategoryCode" field.
func (m *EligibilityMasterMutation) ResetCategoryCode() {
	m._CategoryCode = nil
	delete(m.clearedFields, eligibilitymaster.FieldCategoryCode)
}

// SetPaperCode sets the "PaperCode" field.
func (m *EligibilityMasterMutation) SetPaperCode(i int32) {
	m._ExamPaper_Eligibility = &i
}

// PaperCode returns the value of the "PaperCode" field in the mutation.
func (m *EligibilityMasterMutation) PaperCode() (r int32, exists bool) {
	v := m._ExamPaper_Eligibility
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperCode returns the old "PaperCode" field's value of the EligibilityMaster entity.
// If the EligibilityMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EligibilityMasterMutation) OldPaperCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperCode: %w", err)
	}
	return oldValue.PaperCode, nil
}

// ClearPaperCode clears the value of the "PaperCode" field.
func (m *EligibilityMasterMutation) ClearPaperCode() {
	m._ExamPaper_Eligibility = nil
	m.clearedFields[eligibilitymaster.FieldPaperCode] = struct{}{}
}

// PaperCodeCleared returns if the "PaperCode" field was cleared in this mutation.
func (m *EligibilityMasterMutation) PaperCodeCleared() bool {
	_, ok := m.clearedFields[eligibilitymaster.FieldPaperCode]
	return ok
}

// ResetPaperCode resets all changes to the "PaperCode" field.
func (m *EligibilityMasterMutation) ResetPaperCode() {
	m._ExamPaper_Eligibility = nil
	delete(m.clearedFields, eligibilitymaster.FieldPaperCode)
}

// SetPaperDescription sets the "PaperDescription" field.
func (m *EligibilityMasterMutation) SetPaperDescription(s string) {
	m._PaperDescription = &s
}

// PaperDescription returns the value of the "PaperDescription" field in the mutation.
func (m *EligibilityMasterMutation) PaperDescription() (r string, exists bool) {
	v := m._PaperDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperDescription returns the old "PaperDescription" field's value of the EligibilityMaster entity.
// If the EligibilityMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EligibilityMasterMutation) OldPaperDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperDescription: %w", err)
	}
	return oldValue.PaperDescription, nil
}

// ResetPaperDescription resets all changes to the "PaperDescription" field.
func (m *EligibilityMasterMutation) ResetPaperDescription() {
	m._PaperDescription = nil
}

// SetMinimumMarks sets the "MinimumMarks" field.
func (m *EligibilityMasterMutation) SetMinimumMarks(i int32) {
	m._MinimumMarks = &i
	m.add_MinimumMarks = nil
}

// MinimumMarks returns the value of the "MinimumMarks" field in the mutation.
func (m *EligibilityMasterMutation) MinimumMarks() (r int32, exists bool) {
	v := m._MinimumMarks
	if v == nil {
		return
	}
	return *v, true
}

// OldMinimumMarks returns the old "MinimumMarks" field's value of the EligibilityMaster entity.
// If the EligibilityMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EligibilityMasterMutation) OldMinimumMarks(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinimumMarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinimumMarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinimumMarks: %w", err)
	}
	return oldValue.MinimumMarks, nil
}

// AddMinimumMarks adds i to the "MinimumMarks" field.
func (m *EligibilityMasterMutation) AddMinimumMarks(i int32) {
	if m.add_MinimumMarks != nil {
		*m.add_MinimumMarks += i
	} else {
		m.add_MinimumMarks = &i
	}
}

// AddedMinimumMarks returns the value that was added to the "MinimumMarks" field in this mutation.
func (m *EligibilityMasterMutation) AddedMinimumMarks() (r int32, exists bool) {
	v := m.add_MinimumMarks
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinimumMarks resets all changes to the "MinimumMarks" field.
func (m *EligibilityMasterMutation) ResetMinimumMarks() {
	m._MinimumMarks = nil
	m.add_MinimumMarks = nil
}

// AddNotificationIDs adds the "Notifications" edge to the Notification entity by ids.
func (m *EligibilityMasterMutation) AddNotificationIDs(ids ...int32) {
	if m._Notifications == nil {
		m._Notifications = make(map[int32]struct{})
	}
	for i := range ids {
		m._Notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "Notifications" edge to the Notification entity.
func (m *EligibilityMasterMutation) ClearNotifications() {
	m.cleared_Notifications = true
}

// NotificationsCleared reports if the "Notifications" edge to the Notification entity was cleared.
func (m *EligibilityMasterMutation) NotificationsCleared() bool {
	return m.cleared_Notifications
}

// RemoveNotificationIDs removes the "Notifications" edge to the Notification entity by IDs.
func (m *EligibilityMasterMutation) RemoveNotificationIDs(ids ...int32) {
	if m.removed_Notifications == nil {
		m.removed_Notifications = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m._Notifications, ids[i])
		m.removed_Notifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "Notifications" edge to the Notification entity.
func (m *EligibilityMasterMutation) RemovedNotificationsIDs() (ids []int32) {
	for id := range m.removed_Notifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "Notifications" edge IDs in the mutation.
func (m *EligibilityMasterMutation) NotificationsIDs() (ids []int32) {
	for id := range m._Notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "Notifications" edge.
func (m *EligibilityMasterMutation) ResetNotifications() {
	m._Notifications = nil
	m.cleared_Notifications = false
	m.removed_Notifications = nil
}

// AddCategoryEligibilityIDs adds the "CategoryEligibility" edge to the EmployeeCategory entity by ids.
func (m *EligibilityMasterMutation) AddCategoryEligibilityIDs(ids ...int32) {
	if m._CategoryEligibility == nil {
		m._CategoryEligibility = make(map[int32]struct{})
	}
	for i := range ids {
		m._CategoryEligibility[ids[i]] = struct{}{}
	}
}

// ClearCategoryEligibility clears the "CategoryEligibility" edge to the EmployeeCategory entity.
func (m *EligibilityMasterMutation) ClearCategoryEligibility() {
	m.cleared_CategoryEligibility = true
}

// CategoryEligibilityCleared reports if the "CategoryEligibility" edge to the EmployeeCategory entity was cleared.
func (m *EligibilityMasterMutation) CategoryEligibilityCleared() bool {
	return m.cleared_CategoryEligibility
}

// RemoveCategoryEligibilityIDs removes the "CategoryEligibility" edge to the EmployeeCategory entity by IDs.
func (m *EligibilityMasterMutation) RemoveCategoryEligibilityIDs(ids ...int32) {
	if m.removed_CategoryEligibility == nil {
		m.removed_CategoryEligibility = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m._CategoryEligibility, ids[i])
		m.removed_CategoryEligibility[ids[i]] = struct{}{}
	}
}

// RemovedCategoryEligibility returns the removed IDs of the "CategoryEligibility" edge to the EmployeeCategory entity.
func (m *EligibilityMasterMutation) RemovedCategoryEligibilityIDs() (ids []int32) {
	for id := range m.removed_CategoryEligibility {
		ids = append(ids, id)
	}
	return
}

// CategoryEligibilityIDs returns the "CategoryEligibility" edge IDs in the mutation.
func (m *EligibilityMasterMutation) CategoryEligibilityIDs() (ids []int32) {
	for id := range m._CategoryEligibility {
		ids = append(ids, id)
	}
	return
}

// ResetCategoryEligibility resets all changes to the "CategoryEligibility" edge.
func (m *EligibilityMasterMutation) ResetCategoryEligibility() {
	m._CategoryEligibility = nil
	m.cleared_CategoryEligibility = false
	m.removed_CategoryEligibility = nil
}

// AddPostEligibilityIDs adds the "PostEligibility" edge to the EmployeePosts entity by ids.
func (m *EligibilityMasterMutation) AddPostEligibilityIDs(ids ...int32) {
	if m._PostEligibility == nil {
		m._PostEligibility = make(map[int32]struct{})
	}
	for i := range ids {
		m._PostEligibility[ids[i]] = struct{}{}
	}
}

// ClearPostEligibility clears the "PostEligibility" edge to the EmployeePosts entity.
func (m *EligibilityMasterMutation) ClearPostEligibility() {
	m.cleared_PostEligibility = true
}

// PostEligibilityCleared reports if the "PostEligibility" edge to the EmployeePosts entity was cleared.
func (m *EligibilityMasterMutation) PostEligibilityCleared() bool {
	return m.cleared_PostEligibility
}

// RemovePostEligibilityIDs removes the "PostEligibility" edge to the EmployeePosts entity by IDs.
func (m *EligibilityMasterMutation) RemovePostEligibilityIDs(ids ...int32) {
	if m.removed_PostEligibility == nil {
		m.removed_PostEligibility = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m._PostEligibility, ids[i])
		m.removed_PostEligibility[ids[i]] = struct{}{}
	}
}

// RemovedPostEligibility returns the removed IDs of the "PostEligibility" edge to the EmployeePosts entity.
func (m *EligibilityMasterMutation) RemovedPostEligibilityIDs() (ids []int32) {
	for id := range m.removed_PostEligibility {
		ids = append(ids, id)
	}
	return
}

// PostEligibilityIDs returns the "PostEligibility" edge IDs in the mutation.
func (m *EligibilityMasterMutation) PostEligibilityIDs() (ids []int32) {
	for id := range m._PostEligibility {
		ids = append(ids, id)
	}
	return
}

// ResetPostEligibility resets all changes to the "PostEligibility" edge.
func (m *EligibilityMasterMutation) ResetPostEligibility() {
	m._PostEligibility = nil
	m.cleared_PostEligibility = false
	m.removed_PostEligibility = nil
}

// SetExamPaperEligibilityID sets the "ExamPaper_Eligibility" edge to the ExamPapers entity by id.
func (m *EligibilityMasterMutation) SetExamPaperEligibilityID(id int32) {
	m._ExamPaper_Eligibility = &id
}

// ClearExamPaperEligibility clears the "ExamPaper_Eligibility" edge to the ExamPapers entity.
func (m *EligibilityMasterMutation) ClearExamPaperEligibility() {
	m.cleared_ExamPaper_Eligibility = true
}

// ExamPaperEligibilityCleared reports if the "ExamPaper_Eligibility" edge to the ExamPapers entity was cleared.
func (m *EligibilityMasterMutation) ExamPaperEligibilityCleared() bool {
	return m.PaperCodeCleared() || m.cleared_ExamPaper_Eligibility
}

// ExamPaperEligibilityID returns the "ExamPaper_Eligibility" edge ID in the mutation.
func (m *EligibilityMasterMutation) ExamPaperEligibilityID() (id int32, exists bool) {
	if m._ExamPaper_Eligibility != nil {
		return *m._ExamPaper_Eligibility, true
	}
	return
}

// ExamPaperEligibilityIDs returns the "ExamPaper_Eligibility" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamPaperEligibilityID instead. It exists only for internal usage by the builders.
func (m *EligibilityMasterMutation) ExamPaperEligibilityIDs() (ids []int32) {
	if id := m._ExamPaper_Eligibility; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExamPaperEligibility resets all changes to the "ExamPaper_Eligibility" edge.
func (m *EligibilityMasterMutation) ResetExamPaperEligibility() {
	m._ExamPaper_Eligibility = nil
	m.cleared_ExamPaper_Eligibility = false
}

// SetExamEligibilityID sets the "Exam_Eligibility" edge to the Exam entity by id.
func (m *EligibilityMasterMutation) SetExamEligibilityID(id int32) {
	m._Exam_Eligibility = &id
}

// ClearExamEligibility clears the "Exam_Eligibility" edge to the Exam entity.
func (m *EligibilityMasterMutation) ClearExamEligibility() {
	m.cleared_Exam_Eligibility = true
}

// ExamEligibilityCleared reports if the "Exam_Eligibility" edge to the Exam entity was cleared.
func (m *EligibilityMasterMutation) ExamEligibilityCleared() bool {
	return m.ExamCodeCleared() || m.cleared_Exam_Eligibility
}

// ExamEligibilityID returns the "Exam_Eligibility" edge ID in the mutation.
func (m *EligibilityMasterMutation) ExamEligibilityID() (id int32, exists bool) {
	if m._Exam_Eligibility != nil {
		return *m._Exam_Eligibility, true
	}
	return
}

// ExamEligibilityIDs returns the "Exam_Eligibility" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamEligibilityID instead. It exists only for internal usage by the builders.
func (m *EligibilityMasterMutation) ExamEligibilityIDs() (ids []int32) {
	if id := m._Exam_Eligibility; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExamEligibility resets all changes to the "Exam_Eligibility" edge.
func (m *EligibilityMasterMutation) ResetExamEligibility() {
	m._Exam_Eligibility = nil
	m.cleared_Exam_Eligibility = false
}

// Where appends a list predicates to the EligibilityMasterMutation builder.
func (m *EligibilityMasterMutation) Where(ps ...predicate.EligibilityMaster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EligibilityMasterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EligibilityMasterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EligibilityMaster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EligibilityMasterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EligibilityMasterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EligibilityMaster).
func (m *EligibilityMasterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EligibilityMasterMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m._Exam_Eligibility != nil {
		fields = append(fields, eligibilitymaster.FieldExamCode)
	}
	if m._ExamName != nil {
		fields = append(fields, eligibilitymaster.FieldExamName)
	}
	if m._PostCode != nil {
		fields = append(fields, eligibilitymaster.FieldPostCode)
	}
	if m.gdsService != nil {
		fields = append(fields, eligibilitymaster.FieldGdsService)
	}
	if m._AgeCriteria != nil {
		fields = append(fields, eligibilitymaster.FieldAgeCriteria)
	}
	if m._ServiceCriteria != nil {
		fields = append(fields, eligibilitymaster.FieldServiceCriteria)
	}
	if m._DrivingLicenseCriteria != nil {
		fields = append(fields, eligibilitymaster.FieldDrivingLicenseCriteria)
	}
	if m._ComputerKnowledge != nil {
		fields = append(fields, eligibilitymaster.FieldComputerKnowledge)
	}
	if m._LevelOfPayMatrixEligibility != nil {
		fields = append(fields, eligibilitymaster.FieldLevelOfPayMatrixEligibility)
	}
	if m._Education != nil {
		fields = append(fields, eligibilitymaster.FieldEducation)
	}
	if m._NotifyCode != nil {
		fields = append(fields, eligibilitymaster.FieldNotifyCode)
	}
	if m._CategoryCode != nil {
		fields = append(fields, eligibilitymaster.FieldCategoryCode)
	}
	if m._ExamPaper_Eligibility != nil {
		fields = append(fields, eligibilitymaster.FieldPaperCode)
	}
	if m._PaperDescription != nil {
		fields = append(fields, eligibilitymaster.FieldPaperDescription)
	}
	if m._MinimumMarks != nil {
		fields = append(fields, eligibilitymaster.FieldMinimumMarks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EligibilityMasterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eligibilitymaster.FieldExamCode:
		return m.ExamCode()
	case eligibilitymaster.FieldExamName:
		return m.ExamName()
	case eligibilitymaster.FieldPostCode:
		return m.PostCode()
	case eligibilitymaster.FieldGdsService:
		return m.GdsService()
	case eligibilitymaster.FieldAgeCriteria:
		return m.AgeCriteria()
	case eligibilitymaster.FieldServiceCriteria:
		return m.ServiceCriteria()
	case eligibilitymaster.FieldDrivingLicenseCriteria:
		return m.DrivingLicenseCriteria()
	case eligibilitymaster.FieldComputerKnowledge:
		return m.ComputerKnowledge()
	case eligibilitymaster.FieldLevelOfPayMatrixEligibility:
		return m.LevelOfPayMatrixEligibility()
	case eligibilitymaster.FieldEducation:
		return m.Education()
	case eligibilitymaster.FieldNotifyCode:
		return m.NotifyCode()
	case eligibilitymaster.FieldCategoryCode:
		return m.CategoryCode()
	case eligibilitymaster.FieldPaperCode:
		return m.PaperCode()
	case eligibilitymaster.FieldPaperDescription:
		return m.PaperDescription()
	case eligibilitymaster.FieldMinimumMarks:
		return m.MinimumMarks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EligibilityMasterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eligibilitymaster.FieldExamCode:
		return m.OldExamCode(ctx)
	case eligibilitymaster.FieldExamName:
		return m.OldExamName(ctx)
	case eligibilitymaster.FieldPostCode:
		return m.OldPostCode(ctx)
	case eligibilitymaster.FieldGdsService:
		return m.OldGdsService(ctx)
	case eligibilitymaster.FieldAgeCriteria:
		return m.OldAgeCriteria(ctx)
	case eligibilitymaster.FieldServiceCriteria:
		return m.OldServiceCriteria(ctx)
	case eligibilitymaster.FieldDrivingLicenseCriteria:
		return m.OldDrivingLicenseCriteria(ctx)
	case eligibilitymaster.FieldComputerKnowledge:
		return m.OldComputerKnowledge(ctx)
	case eligibilitymaster.FieldLevelOfPayMatrixEligibility:
		return m.OldLevelOfPayMatrixEligibility(ctx)
	case eligibilitymaster.FieldEducation:
		return m.OldEducation(ctx)
	case eligibilitymaster.FieldNotifyCode:
		return m.OldNotifyCode(ctx)
	case eligibilitymaster.FieldCategoryCode:
		return m.OldCategoryCode(ctx)
	case eligibilitymaster.FieldPaperCode:
		return m.OldPaperCode(ctx)
	case eligibilitymaster.FieldPaperDescription:
		return m.OldPaperDescription(ctx)
	case eligibilitymaster.FieldMinimumMarks:
		return m.OldMinimumMarks(ctx)
	}
	return nil, fmt.Errorf("unknown EligibilityMaster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EligibilityMasterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eligibilitymaster.FieldExamCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCode(v)
		return nil
	case eligibilitymaster.FieldExamName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamName(v)
		return nil
	case eligibilitymaster.FieldPostCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostCode(v)
		return nil
	case eligibilitymaster.FieldGdsService:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGdsService(v)
		return nil
	case eligibilitymaster.FieldAgeCriteria:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgeCriteria(v)
		return nil
	case eligibilitymaster.FieldServiceCriteria:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceCriteria(v)
		return nil
	case eligibilitymaster.FieldDrivingLicenseCriteria:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrivingLicenseCriteria(v)
		return nil
	case eligibilitymaster.FieldComputerKnowledge:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComputerKnowledge(v)
		return nil
	case eligibilitymaster.FieldLevelOfPayMatrixEligibility:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevelOfPayMatrixEligibility(v)
		return nil
	case eligibilitymaster.FieldEducation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducation(v)
		return nil
	case eligibilitymaster.FieldNotifyCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyCode(v)
		return nil
	case eligibilitymaster.FieldCategoryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryCode(v)
		return nil
	case eligibilitymaster.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperCode(v)
		return nil
	case eligibilitymaster.FieldPaperDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperDescription(v)
		return nil
	case eligibilitymaster.FieldMinimumMarks:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinimumMarks(v)
		return nil
	}
	return fmt.Errorf("unknown EligibilityMaster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EligibilityMasterMutation) AddedFields() []string {
	var fields []string
	if m.add_AgeCriteria != nil {
		fields = append(fields, eligibilitymaster.FieldAgeCriteria)
	}
	if m.add_ServiceCriteria != nil {
		fields = append(fields, eligibilitymaster.FieldServiceCriteria)
	}
	if m.add_NotifyCode != nil {
		fields = append(fields, eligibilitymaster.FieldNotifyCode)
	}
	if m.add_MinimumMarks != nil {
		fields = append(fields, eligibilitymaster.FieldMinimumMarks)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EligibilityMasterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case eligibilitymaster.FieldAgeCriteria:
		return m.AddedAgeCriteria()
	case eligibilitymaster.FieldServiceCriteria:
		return m.AddedServiceCriteria()
	case eligibilitymaster.FieldNotifyCode:
		return m.AddedNotifyCode()
	case eligibilitymaster.FieldMinimumMarks:
		return m.AddedMinimumMarks()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EligibilityMasterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case eligibilitymaster.FieldAgeCriteria:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAgeCriteria(v)
		return nil
	case eligibilitymaster.FieldServiceCriteria:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServiceCriteria(v)
		return nil
	case eligibilitymaster.FieldNotifyCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotifyCode(v)
		return nil
	case eligibilitymaster.FieldMinimumMarks:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinimumMarks(v)
		return nil
	}
	return fmt.Errorf("unknown EligibilityMaster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EligibilityMasterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(eligibilitymaster.FieldExamCode) {
		fields = append(fields, eligibilitymaster.FieldExamCode)
	}
	if m.FieldCleared(eligibilitymaster.FieldPostCode) {
		fields = append(fields, eligibilitymaster.FieldPostCode)
	}
	if m.FieldCleared(eligibilitymaster.FieldAgeCriteria) {
		fields = append(fields, eligibilitymaster.FieldAgeCriteria)
	}
	if m.FieldCleared(eligibilitymaster.FieldServiceCriteria) {
		fields = append(fields, eligibilitymaster.FieldServiceCriteria)
	}
	if m.FieldCleared(eligibilitymaster.FieldNotifyCode) {
		fields = append(fields, eligibilitymaster.FieldNotifyCode)
	}
	if m.FieldCleared(eligibilitymaster.FieldCategoryCode) {
		fields = append(fields, eligibilitymaster.FieldCategoryCode)
	}
	if m.FieldCleared(eligibilitymaster.FieldPaperCode) {
		fields = append(fields, eligibilitymaster.FieldPaperCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EligibilityMasterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EligibilityMasterMutation) ClearField(name string) error {
	switch name {
	case eligibilitymaster.FieldExamCode:
		m.ClearExamCode()
		return nil
	case eligibilitymaster.FieldPostCode:
		m.ClearPostCode()
		return nil
	case eligibilitymaster.FieldAgeCriteria:
		m.ClearAgeCriteria()
		return nil
	case eligibilitymaster.FieldServiceCriteria:
		m.ClearServiceCriteria()
		return nil
	case eligibilitymaster.FieldNotifyCode:
		m.ClearNotifyCode()
		return nil
	case eligibilitymaster.FieldCategoryCode:
		m.ClearCategoryCode()
		return nil
	case eligibilitymaster.FieldPaperCode:
		m.ClearPaperCode()
		return nil
	}
	return fmt.Errorf("unknown EligibilityMaster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EligibilityMasterMutation) ResetField(name string) error {
	switch name {
	case eligibilitymaster.FieldExamCode:
		m.ResetExamCode()
		return nil
	case eligibilitymaster.FieldExamName:
		m.ResetExamName()
		return nil
	case eligibilitymaster.FieldPostCode:
		m.ResetPostCode()
		return nil
	case eligibilitymaster.FieldGdsService:
		m.ResetGdsService()
		return nil
	case eligibilitymaster.FieldAgeCriteria:
		m.ResetAgeCriteria()
		return nil
	case eligibilitymaster.FieldServiceCriteria:
		m.ResetServiceCriteria()
		return nil
	case eligibilitymaster.FieldDrivingLicenseCriteria:
		m.ResetDrivingLicenseCriteria()
		return nil
	case eligibilitymaster.FieldComputerKnowledge:
		m.ResetComputerKnowledge()
		return nil
	case eligibilitymaster.FieldLevelOfPayMatrixEligibility:
		m.ResetLevelOfPayMatrixEligibility()
		return nil
	case eligibilitymaster.FieldEducation:
		m.ResetEducation()
		return nil
	case eligibilitymaster.FieldNotifyCode:
		m.ResetNotifyCode()
		return nil
	case eligibilitymaster.FieldCategoryCode:
		m.ResetCategoryCode()
		return nil
	case eligibilitymaster.FieldPaperCode:
		m.ResetPaperCode()
		return nil
	case eligibilitymaster.FieldPaperDescription:
		m.ResetPaperDescription()
		return nil
	case eligibilitymaster.FieldMinimumMarks:
		m.ResetMinimumMarks()
		return nil
	}
	return fmt.Errorf("unknown EligibilityMaster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EligibilityMasterMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m._Notifications != nil {
		edges = append(edges, eligibilitymaster.EdgeNotifications)
	}
	if m._CategoryEligibility != nil {
		edges = append(edges, eligibilitymaster.EdgeCategoryEligibility)
	}
	if m._PostEligibility != nil {
		edges = append(edges, eligibilitymaster.EdgePostEligibility)
	}
	if m._ExamPaper_Eligibility != nil {
		edges = append(edges, eligibilitymaster.EdgeExamPaperEligibility)
	}
	if m._Exam_Eligibility != nil {
		edges = append(edges, eligibilitymaster.EdgeExamEligibility)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EligibilityMasterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eligibilitymaster.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m._Notifications))
		for id := range m._Notifications {
			ids = append(ids, id)
		}
		return ids
	case eligibilitymaster.EdgeCategoryEligibility:
		ids := make([]ent.Value, 0, len(m._CategoryEligibility))
		for id := range m._CategoryEligibility {
			ids = append(ids, id)
		}
		return ids
	case eligibilitymaster.EdgePostEligibility:
		ids := make([]ent.Value, 0, len(m._PostEligibility))
		for id := range m._PostEligibility {
			ids = append(ids, id)
		}
		return ids
	case eligibilitymaster.EdgeExamPaperEligibility:
		if id := m._ExamPaper_Eligibility; id != nil {
			return []ent.Value{*id}
		}
	case eligibilitymaster.EdgeExamEligibility:
		if id := m._Exam_Eligibility; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EligibilityMasterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removed_Notifications != nil {
		edges = append(edges, eligibilitymaster.EdgeNotifications)
	}
	if m.removed_CategoryEligibility != nil {
		edges = append(edges, eligibilitymaster.EdgeCategoryEligibility)
	}
	if m.removed_PostEligibility != nil {
		edges = append(edges, eligibilitymaster.EdgePostEligibility)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EligibilityMasterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case eligibilitymaster.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removed_Notifications))
		for id := range m.removed_Notifications {
			ids = append(ids, id)
		}
		return ids
	case eligibilitymaster.EdgeCategoryEligibility:
		ids := make([]ent.Value, 0, len(m.removed_CategoryEligibility))
		for id := range m.removed_CategoryEligibility {
			ids = append(ids, id)
		}
		return ids
	case eligibilitymaster.EdgePostEligibility:
		ids := make([]ent.Value, 0, len(m.removed_PostEligibility))
		for id := range m.removed_PostEligibility {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EligibilityMasterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleared_Notifications {
		edges = append(edges, eligibilitymaster.EdgeNotifications)
	}
	if m.cleared_CategoryEligibility {
		edges = append(edges, eligibilitymaster.EdgeCategoryEligibility)
	}
	if m.cleared_PostEligibility {
		edges = append(edges, eligibilitymaster.EdgePostEligibility)
	}
	if m.cleared_ExamPaper_Eligibility {
		edges = append(edges, eligibilitymaster.EdgeExamPaperEligibility)
	}
	if m.cleared_Exam_Eligibility {
		edges = append(edges, eligibilitymaster.EdgeExamEligibility)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EligibilityMasterMutation) EdgeCleared(name string) bool {
	switch name {
	case eligibilitymaster.EdgeNotifications:
		return m.cleared_Notifications
	case eligibilitymaster.EdgeCategoryEligibility:
		return m.cleared_CategoryEligibility
	case eligibilitymaster.EdgePostEligibility:
		return m.cleared_PostEligibility
	case eligibilitymaster.EdgeExamPaperEligibility:
		return m.cleared_ExamPaper_Eligibility
	case eligibilitymaster.EdgeExamEligibility:
		return m.cleared_Exam_Eligibility
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EligibilityMasterMutation) ClearEdge(name string) error {
	switch name {
	case eligibilitymaster.EdgeExamPaperEligibility:
		m.ClearExamPaperEligibility()
		return nil
	case eligibilitymaster.EdgeExamEligibility:
		m.ClearExamEligibility()
		return nil
	}
	return fmt.Errorf("unknown EligibilityMaster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EligibilityMasterMutation) ResetEdge(name string) error {
	switch name {
	case eligibilitymaster.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case eligibilitymaster.EdgeCategoryEligibility:
		m.ResetCategoryEligibility()
		return nil
	case eligibilitymaster.EdgePostEligibility:
		m.ResetPostEligibility()
		return nil
	case eligibilitymaster.EdgeExamPaperEligibility:
		m.ResetExamPaperEligibility()
		return nil
	case eligibilitymaster.EdgeExamEligibility:
		m.ResetExamEligibility()
		return nil
	}
	return fmt.Errorf("unknown EligibilityMaster edge %s", name)
}

// EmployeeCadreMutation represents an operation that mutates the EmployeeCadre nodes in the graph.
type EmployeeCadreMutation struct {
	config
	op               Op
	typ              string
	id               *int32
	cadrecode        *string
	cadredescription *string
	_PayLevel        *string
	_Scale           *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*EmployeeCadre, error)
	predicates       []predicate.EmployeeCadre
}

var _ ent.Mutation = (*EmployeeCadreMutation)(nil)

// employeecadreOption allows management of the mutation configuration using functional options.
type employeecadreOption func(*EmployeeCadreMutation)

// newEmployeeCadreMutation creates new mutation for the EmployeeCadre entity.
func newEmployeeCadreMutation(c config, op Op, opts ...employeecadreOption) *EmployeeCadreMutation {
	m := &EmployeeCadreMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployeeCadre,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeCadreID sets the ID field of the mutation.
func withEmployeeCadreID(id int32) employeecadreOption {
	return func(m *EmployeeCadreMutation) {
		var (
			err   error
			once  sync.Once
			value *EmployeeCadre
		)
		m.oldValue = func(ctx context.Context) (*EmployeeCadre, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmployeeCadre.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployeeCadre sets the old EmployeeCadre of the mutation.
func withEmployeeCadre(node *EmployeeCadre) employeecadreOption {
	return func(m *EmployeeCadreMutation) {
		m.oldValue = func(context.Context) (*EmployeeCadre, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeCadreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeCadreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmployeeCadre entities.
func (m *EmployeeCadreMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeCadreMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeCadreMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmployeeCadre.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCadrecode sets the "cadrecode" field.
func (m *EmployeeCadreMutation) SetCadrecode(s string) {
	m.cadrecode = &s
}

// Cadrecode returns the value of the "cadrecode" field in the mutation.
func (m *EmployeeCadreMutation) Cadrecode() (r string, exists bool) {
	v := m.cadrecode
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrecode returns the old "cadrecode" field's value of the EmployeeCadre entity.
// If the EmployeeCadre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeCadreMutation) OldCadrecode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrecode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrecode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrecode: %w", err)
	}
	return oldValue.Cadrecode, nil
}

// ResetCadrecode resets all changes to the "cadrecode" field.
func (m *EmployeeCadreMutation) ResetCadrecode() {
	m.cadrecode = nil
}

// SetCadredescription sets the "cadredescription" field.
func (m *EmployeeCadreMutation) SetCadredescription(s string) {
	m.cadredescription = &s
}

// Cadredescription returns the value of the "cadredescription" field in the mutation.
func (m *EmployeeCadreMutation) Cadredescription() (r string, exists bool) {
	v := m.cadredescription
	if v == nil {
		return
	}
	return *v, true
}

// OldCadredescription returns the old "cadredescription" field's value of the EmployeeCadre entity.
// If the EmployeeCadre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeCadreMutation) OldCadredescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadredescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadredescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadredescription: %w", err)
	}
	return oldValue.Cadredescription, nil
}

// ResetCadredescription resets all changes to the "cadredescription" field.
func (m *EmployeeCadreMutation) ResetCadredescription() {
	m.cadredescription = nil
}

// SetPayLevel sets the "PayLevel" field.
func (m *EmployeeCadreMutation) SetPayLevel(s string) {
	m._PayLevel = &s
}

// PayLevel returns the value of the "PayLevel" field in the mutation.
func (m *EmployeeCadreMutation) PayLevel() (r string, exists bool) {
	v := m._PayLevel
	if v == nil {
		return
	}
	return *v, true
}

// OldPayLevel returns the old "PayLevel" field's value of the EmployeeCadre entity.
// If the EmployeeCadre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeCadreMutation) OldPayLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayLevel: %w", err)
	}
	return oldValue.PayLevel, nil
}

// ResetPayLevel resets all changes to the "PayLevel" field.
func (m *EmployeeCadreMutation) ResetPayLevel() {
	m._PayLevel = nil
}

// SetScale sets the "Scale" field.
func (m *EmployeeCadreMutation) SetScale(s string) {
	m._Scale = &s
}

// Scale returns the value of the "Scale" field in the mutation.
func (m *EmployeeCadreMutation) Scale() (r string, exists bool) {
	v := m._Scale
	if v == nil {
		return
	}
	return *v, true
}

// OldScale returns the old "Scale" field's value of the EmployeeCadre entity.
// If the EmployeeCadre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeCadreMutation) OldScale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScale: %w", err)
	}
	return oldValue.Scale, nil
}

// ResetScale resets all changes to the "Scale" field.
func (m *EmployeeCadreMutation) ResetScale() {
	m._Scale = nil
}

// Where appends a list predicates to the EmployeeCadreMutation builder.
func (m *EmployeeCadreMutation) Where(ps ...predicate.EmployeeCadre) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeCadreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeCadreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmployeeCadre, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeCadreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeCadreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmployeeCadre).
func (m *EmployeeCadreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeCadreMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.cadrecode != nil {
		fields = append(fields, employeecadre.FieldCadrecode)
	}
	if m.cadredescription != nil {
		fields = append(fields, employeecadre.FieldCadredescription)
	}
	if m._PayLevel != nil {
		fields = append(fields, employeecadre.FieldPayLevel)
	}
	if m._Scale != nil {
		fields = append(fields, employeecadre.FieldScale)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeCadreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employeecadre.FieldCadrecode:
		return m.Cadrecode()
	case employeecadre.FieldCadredescription:
		return m.Cadredescription()
	case employeecadre.FieldPayLevel:
		return m.PayLevel()
	case employeecadre.FieldScale:
		return m.Scale()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeCadreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employeecadre.FieldCadrecode:
		return m.OldCadrecode(ctx)
	case employeecadre.FieldCadredescription:
		return m.OldCadredescription(ctx)
	case employeecadre.FieldPayLevel:
		return m.OldPayLevel(ctx)
	case employeecadre.FieldScale:
		return m.OldScale(ctx)
	}
	return nil, fmt.Errorf("unknown EmployeeCadre field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeCadreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employeecadre.FieldCadrecode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrecode(v)
		return nil
	case employeecadre.FieldCadredescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadredescription(v)
		return nil
	case employeecadre.FieldPayLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayLevel(v)
		return nil
	case employeecadre.FieldScale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScale(v)
		return nil
	}
	return fmt.Errorf("unknown EmployeeCadre field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeCadreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeCadreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeCadreMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmployeeCadre numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeCadreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeCadreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeCadreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EmployeeCadre nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeCadreMutation) ResetField(name string) error {
	switch name {
	case employeecadre.FieldCadrecode:
		m.ResetCadrecode()
		return nil
	case employeecadre.FieldCadredescription:
		m.ResetCadredescription()
		return nil
	case employeecadre.FieldPayLevel:
		m.ResetPayLevel()
		return nil
	case employeecadre.FieldScale:
		m.ResetScale()
		return nil
	}
	return fmt.Errorf("unknown EmployeeCadre field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeCadreMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeCadreMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeCadreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeCadreMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeCadreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeCadreMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeCadreMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EmployeeCadre unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeCadreMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EmployeeCadre edge %s", name)
}

// EmployeeCategoryMutation represents an operation that mutates the EmployeeCategory nodes in the graph.
type EmployeeCategoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int32
	_Categrycode         *string
	_CategoryDescription *string
	_MinimumMarks        *int32
	add_MinimumMarks     *int32
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*EmployeeCategory, error)
	predicates           []predicate.EmployeeCategory
}

var _ ent.Mutation = (*EmployeeCategoryMutation)(nil)

// employeecategoryOption allows management of the mutation configuration using functional options.
type employeecategoryOption func(*EmployeeCategoryMutation)

// newEmployeeCategoryMutation creates new mutation for the EmployeeCategory entity.
func newEmployeeCategoryMutation(c config, op Op, opts ...employeecategoryOption) *EmployeeCategoryMutation {
	m := &EmployeeCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployeeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeCategoryID sets the ID field of the mutation.
func withEmployeeCategoryID(id int32) employeecategoryOption {
	return func(m *EmployeeCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *EmployeeCategory
		)
		m.oldValue = func(ctx context.Context) (*EmployeeCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmployeeCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployeeCategory sets the old EmployeeCategory of the mutation.
func withEmployeeCategory(node *EmployeeCategory) employeecategoryOption {
	return func(m *EmployeeCategoryMutation) {
		m.oldValue = func(context.Context) (*EmployeeCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmployeeCategory entities.
func (m *EmployeeCategoryMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeCategoryMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeCategoryMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmployeeCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCategrycode sets the "Categrycode" field.
func (m *EmployeeCategoryMutation) SetCategrycode(s string) {
	m._Categrycode = &s
}

// Categrycode returns the value of the "Categrycode" field in the mutation.
func (m *EmployeeCategoryMutation) Categrycode() (r string, exists bool) {
	v := m._Categrycode
	if v == nil {
		return
	}
	return *v, true
}

// OldCategrycode returns the old "Categrycode" field's value of the EmployeeCategory entity.
// If the EmployeeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeCategoryMutation) OldCategrycode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategrycode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategrycode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategrycode: %w", err)
	}
	return oldValue.Categrycode, nil
}

// ResetCategrycode resets all changes to the "Categrycode" field.
func (m *EmployeeCategoryMutation) ResetCategrycode() {
	m._Categrycode = nil
}

// SetCategoryDescription sets the "CategoryDescription" field.
func (m *EmployeeCategoryMutation) SetCategoryDescription(s string) {
	m._CategoryDescription = &s
}

// CategoryDescription returns the value of the "CategoryDescription" field in the mutation.
func (m *EmployeeCategoryMutation) CategoryDescription() (r string, exists bool) {
	v := m._CategoryDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryDescription returns the old "CategoryDescription" field's value of the EmployeeCategory entity.
// If the EmployeeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeCategoryMutation) OldCategoryDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryDescription: %w", err)
	}
	return oldValue.CategoryDescription, nil
}

// ResetCategoryDescription resets all changes to the "CategoryDescription" field.
func (m *EmployeeCategoryMutation) ResetCategoryDescription() {
	m._CategoryDescription = nil
}

// SetMinimumMarks sets the "MinimumMarks" field.
func (m *EmployeeCategoryMutation) SetMinimumMarks(i int32) {
	m._MinimumMarks = &i
	m.add_MinimumMarks = nil
}

// MinimumMarks returns the value of the "MinimumMarks" field in the mutation.
func (m *EmployeeCategoryMutation) MinimumMarks() (r int32, exists bool) {
	v := m._MinimumMarks
	if v == nil {
		return
	}
	return *v, true
}

// OldMinimumMarks returns the old "MinimumMarks" field's value of the EmployeeCategory entity.
// If the EmployeeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeCategoryMutation) OldMinimumMarks(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinimumMarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinimumMarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinimumMarks: %w", err)
	}
	return oldValue.MinimumMarks, nil
}

// AddMinimumMarks adds i to the "MinimumMarks" field.
func (m *EmployeeCategoryMutation) AddMinimumMarks(i int32) {
	if m.add_MinimumMarks != nil {
		*m.add_MinimumMarks += i
	} else {
		m.add_MinimumMarks = &i
	}
}

// AddedMinimumMarks returns the value that was added to the "MinimumMarks" field in this mutation.
func (m *EmployeeCategoryMutation) AddedMinimumMarks() (r int32, exists bool) {
	v := m.add_MinimumMarks
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinimumMarks clears the value of the "MinimumMarks" field.
func (m *EmployeeCategoryMutation) ClearMinimumMarks() {
	m._MinimumMarks = nil
	m.add_MinimumMarks = nil
	m.clearedFields[employeecategory.FieldMinimumMarks] = struct{}{}
}

// MinimumMarksCleared returns if the "MinimumMarks" field was cleared in this mutation.
func (m *EmployeeCategoryMutation) MinimumMarksCleared() bool {
	_, ok := m.clearedFields[employeecategory.FieldMinimumMarks]
	return ok
}

// ResetMinimumMarks resets all changes to the "MinimumMarks" field.
func (m *EmployeeCategoryMutation) ResetMinimumMarks() {
	m._MinimumMarks = nil
	m.add_MinimumMarks = nil
	delete(m.clearedFields, employeecategory.FieldMinimumMarks)
}

// Where appends a list predicates to the EmployeeCategoryMutation builder.
func (m *EmployeeCategoryMutation) Where(ps ...predicate.EmployeeCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmployeeCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmployeeCategory).
func (m *EmployeeCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeCategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Categrycode != nil {
		fields = append(fields, employeecategory.FieldCategrycode)
	}
	if m._CategoryDescription != nil {
		fields = append(fields, employeecategory.FieldCategoryDescription)
	}
	if m._MinimumMarks != nil {
		fields = append(fields, employeecategory.FieldMinimumMarks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employeecategory.FieldCategrycode:
		return m.Categrycode()
	case employeecategory.FieldCategoryDescription:
		return m.CategoryDescription()
	case employeecategory.FieldMinimumMarks:
		return m.MinimumMarks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employeecategory.FieldCategrycode:
		return m.OldCategrycode(ctx)
	case employeecategory.FieldCategoryDescription:
		return m.OldCategoryDescription(ctx)
	case employeecategory.FieldMinimumMarks:
		return m.OldMinimumMarks(ctx)
	}
	return nil, fmt.Errorf("unknown EmployeeCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employeecategory.FieldCategrycode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategrycode(v)
		return nil
	case employeecategory.FieldCategoryDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryDescription(v)
		return nil
	case employeecategory.FieldMinimumMarks:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinimumMarks(v)
		return nil
	}
	return fmt.Errorf("unknown EmployeeCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeCategoryMutation) AddedFields() []string {
	var fields []string
	if m.add_MinimumMarks != nil {
		fields = append(fields, employeecategory.FieldMinimumMarks)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case employeecategory.FieldMinimumMarks:
		return m.AddedMinimumMarks()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case employeecategory.FieldMinimumMarks:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinimumMarks(v)
		return nil
	}
	return fmt.Errorf("unknown EmployeeCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employeecategory.FieldMinimumMarks) {
		fields = append(fields, employeecategory.FieldMinimumMarks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeCategoryMutation) ClearField(name string) error {
	switch name {
	case employeecategory.FieldMinimumMarks:
		m.ClearMinimumMarks()
		return nil
	}
	return fmt.Errorf("unknown EmployeeCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeCategoryMutation) ResetField(name string) error {
	switch name {
	case employeecategory.FieldCategrycode:
		m.ResetCategrycode()
		return nil
	case employeecategory.FieldCategoryDescription:
		m.ResetCategoryDescription()
		return nil
	case employeecategory.FieldMinimumMarks:
		m.ResetMinimumMarks()
		return nil
	}
	return fmt.Errorf("unknown EmployeeCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EmployeeCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EmployeeCategory edge %s", name)
}

// EmployeeDesignationMutation represents an operation that mutates the EmployeeDesignation nodes in the graph.
type EmployeeDesignationMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int32
	_DesignationCode        *string
	_DesignationDescription *string
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*EmployeeDesignation, error)
	predicates              []predicate.EmployeeDesignation
}

var _ ent.Mutation = (*EmployeeDesignationMutation)(nil)

// employeedesignationOption allows management of the mutation configuration using functional options.
type employeedesignationOption func(*EmployeeDesignationMutation)

// newEmployeeDesignationMutation creates new mutation for the EmployeeDesignation entity.
func newEmployeeDesignationMutation(c config, op Op, opts ...employeedesignationOption) *EmployeeDesignationMutation {
	m := &EmployeeDesignationMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployeeDesignation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeDesignationID sets the ID field of the mutation.
func withEmployeeDesignationID(id int32) employeedesignationOption {
	return func(m *EmployeeDesignationMutation) {
		var (
			err   error
			once  sync.Once
			value *EmployeeDesignation
		)
		m.oldValue = func(ctx context.Context) (*EmployeeDesignation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmployeeDesignation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployeeDesignation sets the old EmployeeDesignation of the mutation.
func withEmployeeDesignation(node *EmployeeDesignation) employeedesignationOption {
	return func(m *EmployeeDesignationMutation) {
		m.oldValue = func(context.Context) (*EmployeeDesignation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeDesignationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeDesignationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmployeeDesignation entities.
func (m *EmployeeDesignationMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeDesignationMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeDesignationMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmployeeDesignation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDesignationCode sets the "DesignationCode" field.
func (m *EmployeeDesignationMutation) SetDesignationCode(s string) {
	m._DesignationCode = &s
}

// DesignationCode returns the value of the "DesignationCode" field in the mutation.
func (m *EmployeeDesignationMutation) DesignationCode() (r string, exists bool) {
	v := m._DesignationCode
	if v == nil {
		return
	}
	return *v, true
}

// OldDesignationCode returns the old "DesignationCode" field's value of the EmployeeDesignation entity.
// If the EmployeeDesignation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeDesignationMutation) OldDesignationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesignationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesignationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesignationCode: %w", err)
	}
	return oldValue.DesignationCode, nil
}

// ResetDesignationCode resets all changes to the "DesignationCode" field.
func (m *EmployeeDesignationMutation) ResetDesignationCode() {
	m._DesignationCode = nil
}

// SetDesignationDescription sets the "DesignationDescription" field.
func (m *EmployeeDesignationMutation) SetDesignationDescription(s string) {
	m._DesignationDescription = &s
}

// DesignationDescription returns the value of the "DesignationDescription" field in the mutation.
func (m *EmployeeDesignationMutation) DesignationDescription() (r string, exists bool) {
	v := m._DesignationDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldDesignationDescription returns the old "DesignationDescription" field's value of the EmployeeDesignation entity.
// If the EmployeeDesignation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeDesignationMutation) OldDesignationDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesignationDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesignationDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesignationDescription: %w", err)
	}
	return oldValue.DesignationDescription, nil
}

// ResetDesignationDescription resets all changes to the "DesignationDescription" field.
func (m *EmployeeDesignationMutation) ResetDesignationDescription() {
	m._DesignationDescription = nil
}

// Where appends a list predicates to the EmployeeDesignationMutation builder.
func (m *EmployeeDesignationMutation) Where(ps ...predicate.EmployeeDesignation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeDesignationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeDesignationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmployeeDesignation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeDesignationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeDesignationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmployeeDesignation).
func (m *EmployeeDesignationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeDesignationMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._DesignationCode != nil {
		fields = append(fields, employeedesignation.FieldDesignationCode)
	}
	if m._DesignationDescription != nil {
		fields = append(fields, employeedesignation.FieldDesignationDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeDesignationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employeedesignation.FieldDesignationCode:
		return m.DesignationCode()
	case employeedesignation.FieldDesignationDescription:
		return m.DesignationDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeDesignationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employeedesignation.FieldDesignationCode:
		return m.OldDesignationCode(ctx)
	case employeedesignation.FieldDesignationDescription:
		return m.OldDesignationDescription(ctx)
	}
	return nil, fmt.Errorf("unknown EmployeeDesignation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeDesignationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employeedesignation.FieldDesignationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesignationCode(v)
		return nil
	case employeedesignation.FieldDesignationDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesignationDescription(v)
		return nil
	}
	return fmt.Errorf("unknown EmployeeDesignation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeDesignationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeDesignationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeDesignationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmployeeDesignation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeDesignationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeDesignationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeDesignationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EmployeeDesignation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeDesignationMutation) ResetField(name string) error {
	switch name {
	case employeedesignation.FieldDesignationCode:
		m.ResetDesignationCode()
		return nil
	case employeedesignation.FieldDesignationDescription:
		m.ResetDesignationDescription()
		return nil
	}
	return fmt.Errorf("unknown EmployeeDesignation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeDesignationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeDesignationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeDesignationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeDesignationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeDesignationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeDesignationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeDesignationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EmployeeDesignation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeDesignationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EmployeeDesignation edge %s", name)
}

// EmployeeMasterMutation represents an operation that mutates the EmployeeMaster nodes in the graph.
type EmployeeMasterMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	_EmployeeID           *int64
	add_EmployeeID        *int64
	_EmployeeName         *string
	_DOB                  *string
	_Gender               *employeemaster.Gender
	_MobileNumber         *string
	_EmailID              *string
	_EmployeeCategoryCode *string
	_EmployeeCategory     *string
	_PostCode             *string
	_EmployeePost         *string
	_FacilityID           *string
	_DCCS                 *string
	_DCInPresentCadre     *string
	_UpdatedAt            *time.Time
	_UpdatedBy            *string
	_Cadre                *string
	clearedFields         map[string]struct{}
	_UsermasterRef        map[int64]struct{}
	removed_UsermasterRef map[int64]struct{}
	cleared_UsermasterRef bool
	_Emp_Ref              map[int64]struct{}
	removed_Emp_Ref       map[int64]struct{}
	cleared_Emp_Ref       bool
	done                  bool
	oldValue              func(context.Context) (*EmployeeMaster, error)
	predicates            []predicate.EmployeeMaster
}

var _ ent.Mutation = (*EmployeeMasterMutation)(nil)

// employeemasterOption allows management of the mutation configuration using functional options.
type employeemasterOption func(*EmployeeMasterMutation)

// newEmployeeMasterMutation creates new mutation for the EmployeeMaster entity.
func newEmployeeMasterMutation(c config, op Op, opts ...employeemasterOption) *EmployeeMasterMutation {
	m := &EmployeeMasterMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployeeMaster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeMasterID sets the ID field of the mutation.
func withEmployeeMasterID(id int64) employeemasterOption {
	return func(m *EmployeeMasterMutation) {
		var (
			err   error
			once  sync.Once
			value *EmployeeMaster
		)
		m.oldValue = func(ctx context.Context) (*EmployeeMaster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmployeeMaster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployeeMaster sets the old EmployeeMaster of the mutation.
func withEmployeeMaster(node *EmployeeMaster) employeemasterOption {
	return func(m *EmployeeMasterMutation) {
		m.oldValue = func(context.Context) (*EmployeeMaster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMasterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMasterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmployeeMaster entities.
func (m *EmployeeMasterMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMasterMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMasterMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmployeeMaster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *EmployeeMasterMutation) SetEmployeeID(i int64) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *EmployeeMasterMutation) EmployeeID() (r int64, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldEmployeeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *EmployeeMasterMutation) AddEmployeeID(i int64) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *EmployeeMasterMutation) AddedEmployeeID() (r int64, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *EmployeeMasterMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
}

// SetEmployeeName sets the "EmployeeName" field.
func (m *EmployeeMasterMutation) SetEmployeeName(s string) {
	m._EmployeeName = &s
}

// EmployeeName returns the value of the "EmployeeName" field in the mutation.
func (m *EmployeeMasterMutation) EmployeeName() (r string, exists bool) {
	v := m._EmployeeName
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeName returns the old "EmployeeName" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldEmployeeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeName: %w", err)
	}
	return oldValue.EmployeeName, nil
}

// ClearEmployeeName clears the value of the "EmployeeName" field.
func (m *EmployeeMasterMutation) ClearEmployeeName() {
	m._EmployeeName = nil
	m.clearedFields[employeemaster.FieldEmployeeName] = struct{}{}
}

// EmployeeNameCleared returns if the "EmployeeName" field was cleared in this mutation.
func (m *EmployeeMasterMutation) EmployeeNameCleared() bool {
	_, ok := m.clearedFields[employeemaster.FieldEmployeeName]
	return ok
}

// ResetEmployeeName resets all changes to the "EmployeeName" field.
func (m *EmployeeMasterMutation) ResetEmployeeName() {
	m._EmployeeName = nil
	delete(m.clearedFields, employeemaster.FieldEmployeeName)
}

// SetDOB sets the "DOB" field.
func (m *EmployeeMasterMutation) SetDOB(s string) {
	m._DOB = &s
}

// DOB returns the value of the "DOB" field in the mutation.
func (m *EmployeeMasterMutation) DOB() (r string, exists bool) {
	v := m._DOB
	if v == nil {
		return
	}
	return *v, true
}

// OldDOB returns the old "DOB" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldDOB(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOB: %w", err)
	}
	return oldValue.DOB, nil
}

// ClearDOB clears the value of the "DOB" field.
func (m *EmployeeMasterMutation) ClearDOB() {
	m._DOB = nil
	m.clearedFields[employeemaster.FieldDOB] = struct{}{}
}

// DOBCleared returns if the "DOB" field was cleared in this mutation.
func (m *EmployeeMasterMutation) DOBCleared() bool {
	_, ok := m.clearedFields[employeemaster.FieldDOB]
	return ok
}

// ResetDOB resets all changes to the "DOB" field.
func (m *EmployeeMasterMutation) ResetDOB() {
	m._DOB = nil
	delete(m.clearedFields, employeemaster.FieldDOB)
}

// SetGender sets the "Gender" field.
func (m *EmployeeMasterMutation) SetGender(e employeemaster.Gender) {
	m._Gender = &e
}

// Gender returns the value of the "Gender" field in the mutation.
func (m *EmployeeMasterMutation) Gender() (r employeemaster.Gender, exists bool) {
	v := m._Gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "Gender" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldGender(ctx context.Context) (v employeemaster.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "Gender" field.
func (m *EmployeeMasterMutation) ResetGender() {
	m._Gender = nil
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *EmployeeMasterMutation) SetMobileNumber(s string) {
	m._MobileNumber = &s
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *EmployeeMasterMutation) MobileNumber() (r string, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldMobileNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// ClearMobileNumber clears the value of the "MobileNumber" field.
func (m *EmployeeMasterMutation) ClearMobileNumber() {
	m._MobileNumber = nil
	m.clearedFields[employeemaster.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "MobileNumber" field was cleared in this mutation.
func (m *EmployeeMasterMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[employeemaster.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *EmployeeMasterMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	delete(m.clearedFields, employeemaster.FieldMobileNumber)
}

// SetEmailID sets the "EmailID" field.
func (m *EmployeeMasterMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *EmployeeMasterMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ClearEmailID clears the value of the "EmailID" field.
func (m *EmployeeMasterMutation) ClearEmailID() {
	m._EmailID = nil
	m.clearedFields[employeemaster.FieldEmailID] = struct{}{}
}

// EmailIDCleared returns if the "EmailID" field was cleared in this mutation.
func (m *EmployeeMasterMutation) EmailIDCleared() bool {
	_, ok := m.clearedFields[employeemaster.FieldEmailID]
	return ok
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *EmployeeMasterMutation) ResetEmailID() {
	m._EmailID = nil
	delete(m.clearedFields, employeemaster.FieldEmailID)
}

// SetEmployeeCategoryCode sets the "EmployeeCategoryCode" field.
func (m *EmployeeMasterMutation) SetEmployeeCategoryCode(s string) {
	m._EmployeeCategoryCode = &s
}

// EmployeeCategoryCode returns the value of the "EmployeeCategoryCode" field in the mutation.
func (m *EmployeeMasterMutation) EmployeeCategoryCode() (r string, exists bool) {
	v := m._EmployeeCategoryCode
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCategoryCode returns the old "EmployeeCategoryCode" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldEmployeeCategoryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCategoryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCategoryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCategoryCode: %w", err)
	}
	return oldValue.EmployeeCategoryCode, nil
}

// ClearEmployeeCategoryCode clears the value of the "EmployeeCategoryCode" field.
func (m *EmployeeMasterMutation) ClearEmployeeCategoryCode() {
	m._EmployeeCategoryCode = nil
	m.clearedFields[employeemaster.FieldEmployeeCategoryCode] = struct{}{}
}

// EmployeeCategoryCodeCleared returns if the "EmployeeCategoryCode" field was cleared in this mutation.
func (m *EmployeeMasterMutation) EmployeeCategoryCodeCleared() bool {
	_, ok := m.clearedFields[employeemaster.FieldEmployeeCategoryCode]
	return ok
}

// ResetEmployeeCategoryCode resets all changes to the "EmployeeCategoryCode" field.
func (m *EmployeeMasterMutation) ResetEmployeeCategoryCode() {
	m._EmployeeCategoryCode = nil
	delete(m.clearedFields, employeemaster.FieldEmployeeCategoryCode)
}

// SetEmployeeCategory sets the "EmployeeCategory" field.
func (m *EmployeeMasterMutation) SetEmployeeCategory(s string) {
	m._EmployeeCategory = &s
}

// EmployeeCategory returns the value of the "EmployeeCategory" field in the mutation.
func (m *EmployeeMasterMutation) EmployeeCategory() (r string, exists bool) {
	v := m._EmployeeCategory
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCategory returns the old "EmployeeCategory" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldEmployeeCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCategory: %w", err)
	}
	return oldValue.EmployeeCategory, nil
}

// ClearEmployeeCategory clears the value of the "EmployeeCategory" field.
func (m *EmployeeMasterMutation) ClearEmployeeCategory() {
	m._EmployeeCategory = nil
	m.clearedFields[employeemaster.FieldEmployeeCategory] = struct{}{}
}

// EmployeeCategoryCleared returns if the "EmployeeCategory" field was cleared in this mutation.
func (m *EmployeeMasterMutation) EmployeeCategoryCleared() bool {
	_, ok := m.clearedFields[employeemaster.FieldEmployeeCategory]
	return ok
}

// ResetEmployeeCategory resets all changes to the "EmployeeCategory" field.
func (m *EmployeeMasterMutation) ResetEmployeeCategory() {
	m._EmployeeCategory = nil
	delete(m.clearedFields, employeemaster.FieldEmployeeCategory)
}

// SetPostCode sets the "PostCode" field.
func (m *EmployeeMasterMutation) SetPostCode(s string) {
	m._PostCode = &s
}

// PostCode returns the value of the "PostCode" field in the mutation.
func (m *EmployeeMasterMutation) PostCode() (r string, exists bool) {
	v := m._PostCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPostCode returns the old "PostCode" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldPostCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostCode: %w", err)
	}
	return oldValue.PostCode, nil
}

// ClearPostCode clears the value of the "PostCode" field.
func (m *EmployeeMasterMutation) ClearPostCode() {
	m._PostCode = nil
	m.clearedFields[employeemaster.FieldPostCode] = struct{}{}
}

// PostCodeCleared returns if the "PostCode" field was cleared in this mutation.
func (m *EmployeeMasterMutation) PostCodeCleared() bool {
	_, ok := m.clearedFields[employeemaster.FieldPostCode]
	return ok
}

// ResetPostCode resets all changes to the "PostCode" field.
func (m *EmployeeMasterMutation) ResetPostCode() {
	m._PostCode = nil
	delete(m.clearedFields, employeemaster.FieldPostCode)
}

// SetEmployeePost sets the "EmployeePost" field.
func (m *EmployeeMasterMutation) SetEmployeePost(s string) {
	m._EmployeePost = &s
}

// EmployeePost returns the value of the "EmployeePost" field in the mutation.
func (m *EmployeeMasterMutation) EmployeePost() (r string, exists bool) {
	v := m._EmployeePost
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeePost returns the old "EmployeePost" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldEmployeePost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeePost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeePost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeePost: %w", err)
	}
	return oldValue.EmployeePost, nil
}

// ClearEmployeePost clears the value of the "EmployeePost" field.
func (m *EmployeeMasterMutation) ClearEmployeePost() {
	m._EmployeePost = nil
	m.clearedFields[employeemaster.FieldEmployeePost] = struct{}{}
}

// EmployeePostCleared returns if the "EmployeePost" field was cleared in this mutation.
func (m *EmployeeMasterMutation) EmployeePostCleared() bool {
	_, ok := m.clearedFields[employeemaster.FieldEmployeePost]
	return ok
}

// ResetEmployeePost resets all changes to the "EmployeePost" field.
func (m *EmployeeMasterMutation) ResetEmployeePost() {
	m._EmployeePost = nil
	delete(m.clearedFields, employeemaster.FieldEmployeePost)
}

// SetFacilityID sets the "FacilityID" field.
func (m *EmployeeMasterMutation) SetFacilityID(s string) {
	m._FacilityID = &s
}

// FacilityID returns the value of the "FacilityID" field in the mutation.
func (m *EmployeeMasterMutation) FacilityID() (r string, exists bool) {
	v := m._FacilityID
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityID returns the old "FacilityID" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldFacilityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityID: %w", err)
	}
	return oldValue.FacilityID, nil
}

// ClearFacilityID clears the value of the "FacilityID" field.
func (m *EmployeeMasterMutation) ClearFacilityID() {
	m._FacilityID = nil
	m.clearedFields[employeemaster.FieldFacilityID] = struct{}{}
}

// FacilityIDCleared returns if the "FacilityID" field was cleared in this mutation.
func (m *EmployeeMasterMutation) FacilityIDCleared() bool {
	_, ok := m.clearedFields[employeemaster.FieldFacilityID]
	return ok
}

// ResetFacilityID resets all changes to the "FacilityID" field.
func (m *EmployeeMasterMutation) ResetFacilityID() {
	m._FacilityID = nil
	delete(m.clearedFields, employeemaster.FieldFacilityID)
}

// SetDCCS sets the "DCCS" field.
func (m *EmployeeMasterMutation) SetDCCS(s string) {
	m._DCCS = &s
}

// DCCS returns the value of the "DCCS" field in the mutation.
func (m *EmployeeMasterMutation) DCCS() (r string, exists bool) {
	v := m._DCCS
	if v == nil {
		return
	}
	return *v, true
}

// OldDCCS returns the old "DCCS" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldDCCS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCCS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCCS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCCS: %w", err)
	}
	return oldValue.DCCS, nil
}

// ClearDCCS clears the value of the "DCCS" field.
func (m *EmployeeMasterMutation) ClearDCCS() {
	m._DCCS = nil
	m.clearedFields[employeemaster.FieldDCCS] = struct{}{}
}

// DCCSCleared returns if the "DCCS" field was cleared in this mutation.
func (m *EmployeeMasterMutation) DCCSCleared() bool {
	_, ok := m.clearedFields[employeemaster.FieldDCCS]
	return ok
}

// ResetDCCS resets all changes to the "DCCS" field.
func (m *EmployeeMasterMutation) ResetDCCS() {
	m._DCCS = nil
	delete(m.clearedFields, employeemaster.FieldDCCS)
}

// SetDCInPresentCadre sets the "DCInPresentCadre" field.
func (m *EmployeeMasterMutation) SetDCInPresentCadre(s string) {
	m._DCInPresentCadre = &s
}

// DCInPresentCadre returns the value of the "DCInPresentCadre" field in the mutation.
func (m *EmployeeMasterMutation) DCInPresentCadre() (r string, exists bool) {
	v := m._DCInPresentCadre
	if v == nil {
		return
	}
	return *v, true
}

// OldDCInPresentCadre returns the old "DCInPresentCadre" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldDCInPresentCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCInPresentCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCInPresentCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCInPresentCadre: %w", err)
	}
	return oldValue.DCInPresentCadre, nil
}

// ClearDCInPresentCadre clears the value of the "DCInPresentCadre" field.
func (m *EmployeeMasterMutation) ClearDCInPresentCadre() {
	m._DCInPresentCadre = nil
	m.clearedFields[employeemaster.FieldDCInPresentCadre] = struct{}{}
}

// DCInPresentCadreCleared returns if the "DCInPresentCadre" field was cleared in this mutation.
func (m *EmployeeMasterMutation) DCInPresentCadreCleared() bool {
	_, ok := m.clearedFields[employeemaster.FieldDCInPresentCadre]
	return ok
}

// ResetDCInPresentCadre resets all changes to the "DCInPresentCadre" field.
func (m *EmployeeMasterMutation) ResetDCInPresentCadre() {
	m._DCInPresentCadre = nil
	delete(m.clearedFields, employeemaster.FieldDCInPresentCadre)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *EmployeeMasterMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *EmployeeMasterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *EmployeeMasterMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[employeemaster.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *EmployeeMasterMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[employeemaster.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *EmployeeMasterMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, employeemaster.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *EmployeeMasterMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *EmployeeMasterMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *EmployeeMasterMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[employeemaster.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *EmployeeMasterMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[employeemaster.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *EmployeeMasterMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, employeemaster.FieldUpdatedBy)
}

// SetCadre sets the "Cadre" field.
func (m *EmployeeMasterMutation) SetCadre(s string) {
	m._Cadre = &s
}

// Cadre returns the value of the "Cadre" field in the mutation.
func (m *EmployeeMasterMutation) Cadre() (r string, exists bool) {
	v := m._Cadre
	if v == nil {
		return
	}
	return *v, true
}

// OldCadre returns the old "Cadre" field's value of the EmployeeMaster entity.
// If the EmployeeMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMasterMutation) OldCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadre: %w", err)
	}
	return oldValue.Cadre, nil
}

// ClearCadre clears the value of the "Cadre" field.
func (m *EmployeeMasterMutation) ClearCadre() {
	m._Cadre = nil
	m.clearedFields[employeemaster.FieldCadre] = struct{}{}
}

// CadreCleared returns if the "Cadre" field was cleared in this mutation.
func (m *EmployeeMasterMutation) CadreCleared() bool {
	_, ok := m.clearedFields[employeemaster.FieldCadre]
	return ok
}

// ResetCadre resets all changes to the "Cadre" field.
func (m *EmployeeMasterMutation) ResetCadre() {
	m._Cadre = nil
	delete(m.clearedFields, employeemaster.FieldCadre)
}

// AddUsermasterRefIDs adds the "UsermasterRef" edge to the UserMaster entity by ids.
func (m *EmployeeMasterMutation) AddUsermasterRefIDs(ids ...int64) {
	if m._UsermasterRef == nil {
		m._UsermasterRef = make(map[int64]struct{})
	}
	for i := range ids {
		m._UsermasterRef[ids[i]] = struct{}{}
	}
}

// ClearUsermasterRef clears the "UsermasterRef" edge to the UserMaster entity.
func (m *EmployeeMasterMutation) ClearUsermasterRef() {
	m.cleared_UsermasterRef = true
}

// UsermasterRefCleared reports if the "UsermasterRef" edge to the UserMaster entity was cleared.
func (m *EmployeeMasterMutation) UsermasterRefCleared() bool {
	return m.cleared_UsermasterRef
}

// RemoveUsermasterRefIDs removes the "UsermasterRef" edge to the UserMaster entity by IDs.
func (m *EmployeeMasterMutation) RemoveUsermasterRefIDs(ids ...int64) {
	if m.removed_UsermasterRef == nil {
		m.removed_UsermasterRef = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._UsermasterRef, ids[i])
		m.removed_UsermasterRef[ids[i]] = struct{}{}
	}
}

// RemovedUsermasterRef returns the removed IDs of the "UsermasterRef" edge to the UserMaster entity.
func (m *EmployeeMasterMutation) RemovedUsermasterRefIDs() (ids []int64) {
	for id := range m.removed_UsermasterRef {
		ids = append(ids, id)
	}
	return
}

// UsermasterRefIDs returns the "UsermasterRef" edge IDs in the mutation.
func (m *EmployeeMasterMutation) UsermasterRefIDs() (ids []int64) {
	for id := range m._UsermasterRef {
		ids = append(ids, id)
	}
	return
}

// ResetUsermasterRef resets all changes to the "UsermasterRef" edge.
func (m *EmployeeMasterMutation) ResetUsermasterRef() {
	m._UsermasterRef = nil
	m.cleared_UsermasterRef = false
	m.removed_UsermasterRef = nil
}

// AddEmpRefIDs adds the "Emp_Ref" edge to the Exam_Applications_PS entity by ids.
func (m *EmployeeMasterMutation) AddEmpRefIDs(ids ...int64) {
	if m._Emp_Ref == nil {
		m._Emp_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		m._Emp_Ref[ids[i]] = struct{}{}
	}
}

// ClearEmpRef clears the "Emp_Ref" edge to the Exam_Applications_PS entity.
func (m *EmployeeMasterMutation) ClearEmpRef() {
	m.cleared_Emp_Ref = true
}

// EmpRefCleared reports if the "Emp_Ref" edge to the Exam_Applications_PS entity was cleared.
func (m *EmployeeMasterMutation) EmpRefCleared() bool {
	return m.cleared_Emp_Ref
}

// RemoveEmpRefIDs removes the "Emp_Ref" edge to the Exam_Applications_PS entity by IDs.
func (m *EmployeeMasterMutation) RemoveEmpRefIDs(ids ...int64) {
	if m.removed_Emp_Ref == nil {
		m.removed_Emp_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._Emp_Ref, ids[i])
		m.removed_Emp_Ref[ids[i]] = struct{}{}
	}
}

// RemovedEmpRef returns the removed IDs of the "Emp_Ref" edge to the Exam_Applications_PS entity.
func (m *EmployeeMasterMutation) RemovedEmpRefIDs() (ids []int64) {
	for id := range m.removed_Emp_Ref {
		ids = append(ids, id)
	}
	return
}

// EmpRefIDs returns the "Emp_Ref" edge IDs in the mutation.
func (m *EmployeeMasterMutation) EmpRefIDs() (ids []int64) {
	for id := range m._Emp_Ref {
		ids = append(ids, id)
	}
	return
}

// ResetEmpRef resets all changes to the "Emp_Ref" edge.
func (m *EmployeeMasterMutation) ResetEmpRef() {
	m._Emp_Ref = nil
	m.cleared_Emp_Ref = false
	m.removed_Emp_Ref = nil
}

// Where appends a list predicates to the EmployeeMasterMutation builder.
func (m *EmployeeMasterMutation) Where(ps ...predicate.EmployeeMaster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeMasterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeMasterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmployeeMaster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeMasterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeMasterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmployeeMaster).
func (m *EmployeeMasterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMasterMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m._EmployeeID != nil {
		fields = append(fields, employeemaster.FieldEmployeeID)
	}
	if m._EmployeeName != nil {
		fields = append(fields, employeemaster.FieldEmployeeName)
	}
	if m._DOB != nil {
		fields = append(fields, employeemaster.FieldDOB)
	}
	if m._Gender != nil {
		fields = append(fields, employeemaster.FieldGender)
	}
	if m._MobileNumber != nil {
		fields = append(fields, employeemaster.FieldMobileNumber)
	}
	if m._EmailID != nil {
		fields = append(fields, employeemaster.FieldEmailID)
	}
	if m._EmployeeCategoryCode != nil {
		fields = append(fields, employeemaster.FieldEmployeeCategoryCode)
	}
	if m._EmployeeCategory != nil {
		fields = append(fields, employeemaster.FieldEmployeeCategory)
	}
	if m._PostCode != nil {
		fields = append(fields, employeemaster.FieldPostCode)
	}
	if m._EmployeePost != nil {
		fields = append(fields, employeemaster.FieldEmployeePost)
	}
	if m._FacilityID != nil {
		fields = append(fields, employeemaster.FieldFacilityID)
	}
	if m._DCCS != nil {
		fields = append(fields, employeemaster.FieldDCCS)
	}
	if m._DCInPresentCadre != nil {
		fields = append(fields, employeemaster.FieldDCInPresentCadre)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, employeemaster.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, employeemaster.FieldUpdatedBy)
	}
	if m._Cadre != nil {
		fields = append(fields, employeemaster.FieldCadre)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMasterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employeemaster.FieldEmployeeID:
		return m.EmployeeID()
	case employeemaster.FieldEmployeeName:
		return m.EmployeeName()
	case employeemaster.FieldDOB:
		return m.DOB()
	case employeemaster.FieldGender:
		return m.Gender()
	case employeemaster.FieldMobileNumber:
		return m.MobileNumber()
	case employeemaster.FieldEmailID:
		return m.EmailID()
	case employeemaster.FieldEmployeeCategoryCode:
		return m.EmployeeCategoryCode()
	case employeemaster.FieldEmployeeCategory:
		return m.EmployeeCategory()
	case employeemaster.FieldPostCode:
		return m.PostCode()
	case employeemaster.FieldEmployeePost:
		return m.EmployeePost()
	case employeemaster.FieldFacilityID:
		return m.FacilityID()
	case employeemaster.FieldDCCS:
		return m.DCCS()
	case employeemaster.FieldDCInPresentCadre:
		return m.DCInPresentCadre()
	case employeemaster.FieldUpdatedAt:
		return m.UpdatedAt()
	case employeemaster.FieldUpdatedBy:
		return m.UpdatedBy()
	case employeemaster.FieldCadre:
		return m.Cadre()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMasterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employeemaster.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case employeemaster.FieldEmployeeName:
		return m.OldEmployeeName(ctx)
	case employeemaster.FieldDOB:
		return m.OldDOB(ctx)
	case employeemaster.FieldGender:
		return m.OldGender(ctx)
	case employeemaster.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case employeemaster.FieldEmailID:
		return m.OldEmailID(ctx)
	case employeemaster.FieldEmployeeCategoryCode:
		return m.OldEmployeeCategoryCode(ctx)
	case employeemaster.FieldEmployeeCategory:
		return m.OldEmployeeCategory(ctx)
	case employeemaster.FieldPostCode:
		return m.OldPostCode(ctx)
	case employeemaster.FieldEmployeePost:
		return m.OldEmployeePost(ctx)
	case employeemaster.FieldFacilityID:
		return m.OldFacilityID(ctx)
	case employeemaster.FieldDCCS:
		return m.OldDCCS(ctx)
	case employeemaster.FieldDCInPresentCadre:
		return m.OldDCInPresentCadre(ctx)
	case employeemaster.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case employeemaster.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case employeemaster.FieldCadre:
		return m.OldCadre(ctx)
	}
	return nil, fmt.Errorf("unknown EmployeeMaster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMasterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employeemaster.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case employeemaster.FieldEmployeeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeName(v)
		return nil
	case employeemaster.FieldDOB:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOB(v)
		return nil
	case employeemaster.FieldGender:
		v, ok := value.(employeemaster.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case employeemaster.FieldMobileNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case employeemaster.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case employeemaster.FieldEmployeeCategoryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCategoryCode(v)
		return nil
	case employeemaster.FieldEmployeeCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCategory(v)
		return nil
	case employeemaster.FieldPostCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostCode(v)
		return nil
	case employeemaster.FieldEmployeePost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeePost(v)
		return nil
	case employeemaster.FieldFacilityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityID(v)
		return nil
	case employeemaster.FieldDCCS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCCS(v)
		return nil
	case employeemaster.FieldDCInPresentCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCInPresentCadre(v)
		return nil
	case employeemaster.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case employeemaster.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case employeemaster.FieldCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadre(v)
		return nil
	}
	return fmt.Errorf("unknown EmployeeMaster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMasterMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeeID != nil {
		fields = append(fields, employeemaster.FieldEmployeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMasterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case employeemaster.FieldEmployeeID:
		return m.AddedEmployeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMasterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case employeemaster.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown EmployeeMaster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMasterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employeemaster.FieldEmployeeName) {
		fields = append(fields, employeemaster.FieldEmployeeName)
	}
	if m.FieldCleared(employeemaster.FieldDOB) {
		fields = append(fields, employeemaster.FieldDOB)
	}
	if m.FieldCleared(employeemaster.FieldMobileNumber) {
		fields = append(fields, employeemaster.FieldMobileNumber)
	}
	if m.FieldCleared(employeemaster.FieldEmailID) {
		fields = append(fields, employeemaster.FieldEmailID)
	}
	if m.FieldCleared(employeemaster.FieldEmployeeCategoryCode) {
		fields = append(fields, employeemaster.FieldEmployeeCategoryCode)
	}
	if m.FieldCleared(employeemaster.FieldEmployeeCategory) {
		fields = append(fields, employeemaster.FieldEmployeeCategory)
	}
	if m.FieldCleared(employeemaster.FieldPostCode) {
		fields = append(fields, employeemaster.FieldPostCode)
	}
	if m.FieldCleared(employeemaster.FieldEmployeePost) {
		fields = append(fields, employeemaster.FieldEmployeePost)
	}
	if m.FieldCleared(employeemaster.FieldFacilityID) {
		fields = append(fields, employeemaster.FieldFacilityID)
	}
	if m.FieldCleared(employeemaster.FieldDCCS) {
		fields = append(fields, employeemaster.FieldDCCS)
	}
	if m.FieldCleared(employeemaster.FieldDCInPresentCadre) {
		fields = append(fields, employeemaster.FieldDCInPresentCadre)
	}
	if m.FieldCleared(employeemaster.FieldUpdatedAt) {
		fields = append(fields, employeemaster.FieldUpdatedAt)
	}
	if m.FieldCleared(employeemaster.FieldUpdatedBy) {
		fields = append(fields, employeemaster.FieldUpdatedBy)
	}
	if m.FieldCleared(employeemaster.FieldCadre) {
		fields = append(fields, employeemaster.FieldCadre)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMasterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMasterMutation) ClearField(name string) error {
	switch name {
	case employeemaster.FieldEmployeeName:
		m.ClearEmployeeName()
		return nil
	case employeemaster.FieldDOB:
		m.ClearDOB()
		return nil
	case employeemaster.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	case employeemaster.FieldEmailID:
		m.ClearEmailID()
		return nil
	case employeemaster.FieldEmployeeCategoryCode:
		m.ClearEmployeeCategoryCode()
		return nil
	case employeemaster.FieldEmployeeCategory:
		m.ClearEmployeeCategory()
		return nil
	case employeemaster.FieldPostCode:
		m.ClearPostCode()
		return nil
	case employeemaster.FieldEmployeePost:
		m.ClearEmployeePost()
		return nil
	case employeemaster.FieldFacilityID:
		m.ClearFacilityID()
		return nil
	case employeemaster.FieldDCCS:
		m.ClearDCCS()
		return nil
	case employeemaster.FieldDCInPresentCadre:
		m.ClearDCInPresentCadre()
		return nil
	case employeemaster.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case employeemaster.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case employeemaster.FieldCadre:
		m.ClearCadre()
		return nil
	}
	return fmt.Errorf("unknown EmployeeMaster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMasterMutation) ResetField(name string) error {
	switch name {
	case employeemaster.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case employeemaster.FieldEmployeeName:
		m.ResetEmployeeName()
		return nil
	case employeemaster.FieldDOB:
		m.ResetDOB()
		return nil
	case employeemaster.FieldGender:
		m.ResetGender()
		return nil
	case employeemaster.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case employeemaster.FieldEmailID:
		m.ResetEmailID()
		return nil
	case employeemaster.FieldEmployeeCategoryCode:
		m.ResetEmployeeCategoryCode()
		return nil
	case employeemaster.FieldEmployeeCategory:
		m.ResetEmployeeCategory()
		return nil
	case employeemaster.FieldPostCode:
		m.ResetPostCode()
		return nil
	case employeemaster.FieldEmployeePost:
		m.ResetEmployeePost()
		return nil
	case employeemaster.FieldFacilityID:
		m.ResetFacilityID()
		return nil
	case employeemaster.FieldDCCS:
		m.ResetDCCS()
		return nil
	case employeemaster.FieldDCInPresentCadre:
		m.ResetDCInPresentCadre()
		return nil
	case employeemaster.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case employeemaster.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case employeemaster.FieldCadre:
		m.ResetCadre()
		return nil
	}
	return fmt.Errorf("unknown EmployeeMaster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMasterMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._UsermasterRef != nil {
		edges = append(edges, employeemaster.EdgeUsermasterRef)
	}
	if m._Emp_Ref != nil {
		edges = append(edges, employeemaster.EdgeEmpRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMasterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employeemaster.EdgeUsermasterRef:
		ids := make([]ent.Value, 0, len(m._UsermasterRef))
		for id := range m._UsermasterRef {
			ids = append(ids, id)
		}
		return ids
	case employeemaster.EdgeEmpRef:
		ids := make([]ent.Value, 0, len(m._Emp_Ref))
		for id := range m._Emp_Ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMasterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_UsermasterRef != nil {
		edges = append(edges, employeemaster.EdgeUsermasterRef)
	}
	if m.removed_Emp_Ref != nil {
		edges = append(edges, employeemaster.EdgeEmpRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMasterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employeemaster.EdgeUsermasterRef:
		ids := make([]ent.Value, 0, len(m.removed_UsermasterRef))
		for id := range m.removed_UsermasterRef {
			ids = append(ids, id)
		}
		return ids
	case employeemaster.EdgeEmpRef:
		ids := make([]ent.Value, 0, len(m.removed_Emp_Ref))
		for id := range m.removed_Emp_Ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMasterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_UsermasterRef {
		edges = append(edges, employeemaster.EdgeUsermasterRef)
	}
	if m.cleared_Emp_Ref {
		edges = append(edges, employeemaster.EdgeEmpRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMasterMutation) EdgeCleared(name string) bool {
	switch name {
	case employeemaster.EdgeUsermasterRef:
		return m.cleared_UsermasterRef
	case employeemaster.EdgeEmpRef:
		return m.cleared_Emp_Ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMasterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown EmployeeMaster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMasterMutation) ResetEdge(name string) error {
	switch name {
	case employeemaster.EdgeUsermasterRef:
		m.ResetUsermasterRef()
		return nil
	case employeemaster.EdgeEmpRef:
		m.ResetEmpRef()
		return nil
	}
	return fmt.Errorf("unknown EmployeeMaster edge %s", name)
}

// EmployeePostsMutation represents an operation that mutates the EmployeePosts nodes in the graph.
type EmployeePostsMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int32
	_PostCode               *string
	_PostDescription        *string
	_Group                  *string
	_PayLevel               *string
	_Scale                  *string
	_BaseCadreFlag          *bool
	clearedFields           map[string]struct{}
	emp_posts               map[int32]struct{}
	removedemp_posts        map[int32]struct{}
	clearedemp_posts        bool
	_PostEligibility        map[int32]struct{}
	removed_PostEligibility map[int32]struct{}
	cleared_PostEligibility bool
	done                    bool
	oldValue                func(context.Context) (*EmployeePosts, error)
	predicates              []predicate.EmployeePosts
}

var _ ent.Mutation = (*EmployeePostsMutation)(nil)

// employeepostsOption allows management of the mutation configuration using functional options.
type employeepostsOption func(*EmployeePostsMutation)

// newEmployeePostsMutation creates new mutation for the EmployeePosts entity.
func newEmployeePostsMutation(c config, op Op, opts ...employeepostsOption) *EmployeePostsMutation {
	m := &EmployeePostsMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployeePosts,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeePostsID sets the ID field of the mutation.
func withEmployeePostsID(id int32) employeepostsOption {
	return func(m *EmployeePostsMutation) {
		var (
			err   error
			once  sync.Once
			value *EmployeePosts
		)
		m.oldValue = func(ctx context.Context) (*EmployeePosts, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmployeePosts.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployeePosts sets the old EmployeePosts of the mutation.
func withEmployeePosts(node *EmployeePosts) employeepostsOption {
	return func(m *EmployeePostsMutation) {
		m.oldValue = func(context.Context) (*EmployeePosts, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeePostsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeePostsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmployeePosts entities.
func (m *EmployeePostsMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeePostsMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeePostsMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmployeePosts.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPostCode sets the "PostCode" field.
func (m *EmployeePostsMutation) SetPostCode(s string) {
	m._PostCode = &s
}

// PostCode returns the value of the "PostCode" field in the mutation.
func (m *EmployeePostsMutation) PostCode() (r string, exists bool) {
	v := m._PostCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPostCode returns the old "PostCode" field's value of the EmployeePosts entity.
// If the EmployeePosts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeePostsMutation) OldPostCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostCode: %w", err)
	}
	return oldValue.PostCode, nil
}

// ResetPostCode resets all changes to the "PostCode" field.
func (m *EmployeePostsMutation) ResetPostCode() {
	m._PostCode = nil
}

// SetPostDescription sets the "PostDescription" field.
func (m *EmployeePostsMutation) SetPostDescription(s string) {
	m._PostDescription = &s
}

// PostDescription returns the value of the "PostDescription" field in the mutation.
func (m *EmployeePostsMutation) PostDescription() (r string, exists bool) {
	v := m._PostDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldPostDescription returns the old "PostDescription" field's value of the EmployeePosts entity.
// If the EmployeePosts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeePostsMutation) OldPostDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostDescription: %w", err)
	}
	return oldValue.PostDescription, nil
}

// ResetPostDescription resets all changes to the "PostDescription" field.
func (m *EmployeePostsMutation) ResetPostDescription() {
	m._PostDescription = nil
}

// SetGroup sets the "Group" field.
func (m *EmployeePostsMutation) SetGroup(s string) {
	m._Group = &s
}

// Group returns the value of the "Group" field in the mutation.
func (m *EmployeePostsMutation) Group() (r string, exists bool) {
	v := m._Group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "Group" field's value of the EmployeePosts entity.
// If the EmployeePosts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeePostsMutation) OldGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// ResetGroup resets all changes to the "Group" field.
func (m *EmployeePostsMutation) ResetGroup() {
	m._Group = nil
}

// SetPayLevel sets the "PayLevel" field.
func (m *EmployeePostsMutation) SetPayLevel(s string) {
	m._PayLevel = &s
}

// PayLevel returns the value of the "PayLevel" field in the mutation.
func (m *EmployeePostsMutation) PayLevel() (r string, exists bool) {
	v := m._PayLevel
	if v == nil {
		return
	}
	return *v, true
}

// OldPayLevel returns the old "PayLevel" field's value of the EmployeePosts entity.
// If the EmployeePosts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeePostsMutation) OldPayLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayLevel: %w", err)
	}
	return oldValue.PayLevel, nil
}

// ResetPayLevel resets all changes to the "PayLevel" field.
func (m *EmployeePostsMutation) ResetPayLevel() {
	m._PayLevel = nil
}

// SetScale sets the "Scale" field.
func (m *EmployeePostsMutation) SetScale(s string) {
	m._Scale = &s
}

// Scale returns the value of the "Scale" field in the mutation.
func (m *EmployeePostsMutation) Scale() (r string, exists bool) {
	v := m._Scale
	if v == nil {
		return
	}
	return *v, true
}

// OldScale returns the old "Scale" field's value of the EmployeePosts entity.
// If the EmployeePosts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeePostsMutation) OldScale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScale: %w", err)
	}
	return oldValue.Scale, nil
}

// ResetScale resets all changes to the "Scale" field.
func (m *EmployeePostsMutation) ResetScale() {
	m._Scale = nil
}

// SetBaseCadreFlag sets the "BaseCadreFlag" field.
func (m *EmployeePostsMutation) SetBaseCadreFlag(b bool) {
	m._BaseCadreFlag = &b
}

// BaseCadreFlag returns the value of the "BaseCadreFlag" field in the mutation.
func (m *EmployeePostsMutation) BaseCadreFlag() (r bool, exists bool) {
	v := m._BaseCadreFlag
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseCadreFlag returns the old "BaseCadreFlag" field's value of the EmployeePosts entity.
// If the EmployeePosts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeePostsMutation) OldBaseCadreFlag(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseCadreFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseCadreFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseCadreFlag: %w", err)
	}
	return oldValue.BaseCadreFlag, nil
}

// ResetBaseCadreFlag resets all changes to the "BaseCadreFlag" field.
func (m *EmployeePostsMutation) ResetBaseCadreFlag() {
	m._BaseCadreFlag = nil
}

// AddEmpPostIDs adds the "emp_posts" edge to the Employees entity by ids.
func (m *EmployeePostsMutation) AddEmpPostIDs(ids ...int32) {
	if m.emp_posts == nil {
		m.emp_posts = make(map[int32]struct{})
	}
	for i := range ids {
		m.emp_posts[ids[i]] = struct{}{}
	}
}

// ClearEmpPosts clears the "emp_posts" edge to the Employees entity.
func (m *EmployeePostsMutation) ClearEmpPosts() {
	m.clearedemp_posts = true
}

// EmpPostsCleared reports if the "emp_posts" edge to the Employees entity was cleared.
func (m *EmployeePostsMutation) EmpPostsCleared() bool {
	return m.clearedemp_posts
}

// RemoveEmpPostIDs removes the "emp_posts" edge to the Employees entity by IDs.
func (m *EmployeePostsMutation) RemoveEmpPostIDs(ids ...int32) {
	if m.removedemp_posts == nil {
		m.removedemp_posts = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.emp_posts, ids[i])
		m.removedemp_posts[ids[i]] = struct{}{}
	}
}

// RemovedEmpPosts returns the removed IDs of the "emp_posts" edge to the Employees entity.
func (m *EmployeePostsMutation) RemovedEmpPostsIDs() (ids []int32) {
	for id := range m.removedemp_posts {
		ids = append(ids, id)
	}
	return
}

// EmpPostsIDs returns the "emp_posts" edge IDs in the mutation.
func (m *EmployeePostsMutation) EmpPostsIDs() (ids []int32) {
	for id := range m.emp_posts {
		ids = append(ids, id)
	}
	return
}

// ResetEmpPosts resets all changes to the "emp_posts" edge.
func (m *EmployeePostsMutation) ResetEmpPosts() {
	m.emp_posts = nil
	m.clearedemp_posts = false
	m.removedemp_posts = nil
}

// AddPostEligibilityIDs adds the "PostEligibility" edge to the EligibilityMaster entity by ids.
func (m *EmployeePostsMutation) AddPostEligibilityIDs(ids ...int32) {
	if m._PostEligibility == nil {
		m._PostEligibility = make(map[int32]struct{})
	}
	for i := range ids {
		m._PostEligibility[ids[i]] = struct{}{}
	}
}

// ClearPostEligibility clears the "PostEligibility" edge to the EligibilityMaster entity.
func (m *EmployeePostsMutation) ClearPostEligibility() {
	m.cleared_PostEligibility = true
}

// PostEligibilityCleared reports if the "PostEligibility" edge to the EligibilityMaster entity was cleared.
func (m *EmployeePostsMutation) PostEligibilityCleared() bool {
	return m.cleared_PostEligibility
}

// RemovePostEligibilityIDs removes the "PostEligibility" edge to the EligibilityMaster entity by IDs.
func (m *EmployeePostsMutation) RemovePostEligibilityIDs(ids ...int32) {
	if m.removed_PostEligibility == nil {
		m.removed_PostEligibility = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m._PostEligibility, ids[i])
		m.removed_PostEligibility[ids[i]] = struct{}{}
	}
}

// RemovedPostEligibility returns the removed IDs of the "PostEligibility" edge to the EligibilityMaster entity.
func (m *EmployeePostsMutation) RemovedPostEligibilityIDs() (ids []int32) {
	for id := range m.removed_PostEligibility {
		ids = append(ids, id)
	}
	return
}

// PostEligibilityIDs returns the "PostEligibility" edge IDs in the mutation.
func (m *EmployeePostsMutation) PostEligibilityIDs() (ids []int32) {
	for id := range m._PostEligibility {
		ids = append(ids, id)
	}
	return
}

// ResetPostEligibility resets all changes to the "PostEligibility" edge.
func (m *EmployeePostsMutation) ResetPostEligibility() {
	m._PostEligibility = nil
	m.cleared_PostEligibility = false
	m.removed_PostEligibility = nil
}

// Where appends a list predicates to the EmployeePostsMutation builder.
func (m *EmployeePostsMutation) Where(ps ...predicate.EmployeePosts) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeePostsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeePostsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmployeePosts, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeePostsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeePostsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmployeePosts).
func (m *EmployeePostsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeePostsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._PostCode != nil {
		fields = append(fields, employeeposts.FieldPostCode)
	}
	if m._PostDescription != nil {
		fields = append(fields, employeeposts.FieldPostDescription)
	}
	if m._Group != nil {
		fields = append(fields, employeeposts.FieldGroup)
	}
	if m._PayLevel != nil {
		fields = append(fields, employeeposts.FieldPayLevel)
	}
	if m._Scale != nil {
		fields = append(fields, employeeposts.FieldScale)
	}
	if m._BaseCadreFlag != nil {
		fields = append(fields, employeeposts.FieldBaseCadreFlag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeePostsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employeeposts.FieldPostCode:
		return m.PostCode()
	case employeeposts.FieldPostDescription:
		return m.PostDescription()
	case employeeposts.FieldGroup:
		return m.Group()
	case employeeposts.FieldPayLevel:
		return m.PayLevel()
	case employeeposts.FieldScale:
		return m.Scale()
	case employeeposts.FieldBaseCadreFlag:
		return m.BaseCadreFlag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeePostsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employeeposts.FieldPostCode:
		return m.OldPostCode(ctx)
	case employeeposts.FieldPostDescription:
		return m.OldPostDescription(ctx)
	case employeeposts.FieldGroup:
		return m.OldGroup(ctx)
	case employeeposts.FieldPayLevel:
		return m.OldPayLevel(ctx)
	case employeeposts.FieldScale:
		return m.OldScale(ctx)
	case employeeposts.FieldBaseCadreFlag:
		return m.OldBaseCadreFlag(ctx)
	}
	return nil, fmt.Errorf("unknown EmployeePosts field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeePostsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employeeposts.FieldPostCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostCode(v)
		return nil
	case employeeposts.FieldPostDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostDescription(v)
		return nil
	case employeeposts.FieldGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case employeeposts.FieldPayLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayLevel(v)
		return nil
	case employeeposts.FieldScale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScale(v)
		return nil
	case employeeposts.FieldBaseCadreFlag:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseCadreFlag(v)
		return nil
	}
	return fmt.Errorf("unknown EmployeePosts field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeePostsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeePostsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeePostsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmployeePosts numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeePostsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeePostsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeePostsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EmployeePosts nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeePostsMutation) ResetField(name string) error {
	switch name {
	case employeeposts.FieldPostCode:
		m.ResetPostCode()
		return nil
	case employeeposts.FieldPostDescription:
		m.ResetPostDescription()
		return nil
	case employeeposts.FieldGroup:
		m.ResetGroup()
		return nil
	case employeeposts.FieldPayLevel:
		m.ResetPayLevel()
		return nil
	case employeeposts.FieldScale:
		m.ResetScale()
		return nil
	case employeeposts.FieldBaseCadreFlag:
		m.ResetBaseCadreFlag()
		return nil
	}
	return fmt.Errorf("unknown EmployeePosts field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeePostsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.emp_posts != nil {
		edges = append(edges, employeeposts.EdgeEmpPosts)
	}
	if m._PostEligibility != nil {
		edges = append(edges, employeeposts.EdgePostEligibility)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeePostsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employeeposts.EdgeEmpPosts:
		ids := make([]ent.Value, 0, len(m.emp_posts))
		for id := range m.emp_posts {
			ids = append(ids, id)
		}
		return ids
	case employeeposts.EdgePostEligibility:
		ids := make([]ent.Value, 0, len(m._PostEligibility))
		for id := range m._PostEligibility {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeePostsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedemp_posts != nil {
		edges = append(edges, employeeposts.EdgeEmpPosts)
	}
	if m.removed_PostEligibility != nil {
		edges = append(edges, employeeposts.EdgePostEligibility)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeePostsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employeeposts.EdgeEmpPosts:
		ids := make([]ent.Value, 0, len(m.removedemp_posts))
		for id := range m.removedemp_posts {
			ids = append(ids, id)
		}
		return ids
	case employeeposts.EdgePostEligibility:
		ids := make([]ent.Value, 0, len(m.removed_PostEligibility))
		for id := range m.removed_PostEligibility {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeePostsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedemp_posts {
		edges = append(edges, employeeposts.EdgeEmpPosts)
	}
	if m.cleared_PostEligibility {
		edges = append(edges, employeeposts.EdgePostEligibility)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeePostsMutation) EdgeCleared(name string) bool {
	switch name {
	case employeeposts.EdgeEmpPosts:
		return m.clearedemp_posts
	case employeeposts.EdgePostEligibility:
		return m.cleared_PostEligibility
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeePostsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown EmployeePosts unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeePostsMutation) ResetEdge(name string) error {
	switch name {
	case employeeposts.EdgeEmpPosts:
		m.ResetEmpPosts()
		return nil
	case employeeposts.EdgePostEligibility:
		m.ResetPostEligibility()
		return nil
	}
	return fmt.Errorf("unknown EmployeePosts edge %s", name)
}

// EmployeesMutation represents an operation that mutates the Employees nodes in the graph.
type EmployeesMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int32
	_EmployeedID                   *int32
	add_EmployeedID                *int32
	_IDVerified                    *bool
	_IDRemStatus                   *bool
	_IDRemarks                     *string
	_EmployeeName                  *string
	nameVerified                   *bool
	nameRemStatus                  *bool
	nameRemarks                    *string
	_EmployeeFathersName           *string
	_FathersNameVerified           *bool
	_FathersNameRemStatus          *bool
	_FathersNameRemarks            *string
	_DOB                           *time.Time
	_DOBVerified                   *bool
	_DOBRemStatus                  *bool
	_DOBRemarks                    *string
	_Gender                        *employees.Gender
	genderVerified                 *bool
	genderRemStatus                *bool
	genderRemarks                  *string
	_MobileNumber                  *int64
	add_MobileNumber               *int64
	_MobileNumberVerified          *bool
	_MobileNumberRemStatus         *bool
	_MobileNumberRemarks           *string
	_EmailID                       *string
	_EmailIDVerified               *bool
	_EmailIDRemStatus              *bool
	_EmailIDRemarks                *string
	_Categoryid                    *int32
	add_Categoryid                 *int32
	_EmployeeCategoryCode          *string
	_EmployeeCategory              *string
	_EmployeeCategoryCodeVerified  *bool
	_EmployeeCategoryCodeRemStatus *bool
	_EmployeeCategoryCodeRemarks   *string
	_WithDisability                *string
	_WithDisabilityVerified        *bool
	_WithDisabilityRemStatus       *bool
	_WithDisabilityRemarks         *bool
	_DisabilityType                *string
	_DisabilityTypeVerified        *bool
	_DisabilityTypeRemStatus       *bool
	_DisabilityTypeRemarks         *string
	_DisabilityPercentage          *int32
	add_DisabilityPercentage       *int32
	_DisabilityPercentageVerified  *bool
	_DisabilityPercentageRemStatus *bool
	_DisabilityPercentageRemarks   *string
	_Signature                     *string
	_SignatureVerified             *bool
	_SignatureRemStatus            *bool
	_SignatureRemarks              *string
	_Photo                         *string
	_PhotoVerified                 *bool
	_PhotoRemStatus                *bool
	_PhotoRemarks                  *string
	_PostID                        *int32
	add_PostID                     *int32
	_PostCode                      *string
	_EmployeePost                  *string
	_EmployeePostVerified          *bool
	_EmployeePostRemStatus         *bool
	_EmployeePostRemarks           *string
	_DesignationID                 *int32
	add_DesignationID              *int32
	_EmployeeDesignation           *string
	_EmployeeDesignationVerified   *bool
	_EmployeeDesignationRemStatus  *bool
	_EmployeeDesignationRemarks    *string
	_CircleID                      *int32
	add_CircleID                   *int32
	_CircleName                    *string
	_CircleVerified                *bool
	_CircleRemStatus               *bool
	_CircleRemarks                 *string
	_RegionID                      *int32
	add_RegionID                   *int32
	_RegionName                    *string
	_RegionVerified                *bool
	_RegionRemStatus               *bool
	_RegionRemarks                 *string
	_DivisionID                    *int32
	add_DivisionID                 *int32
	_DivisionName                  *string
	_DivisionVerified              *bool
	_DivisionRemStatus             *bool
	_DivisionRemarks               *string
	_OfficeID                      *int32
	add_OfficeID                   *int32
	_OfficeName                    *string
	_OfficeVerified                *bool
	_OfficeRemStatus               *bool
	_OfficeRemarks                 *string
	_Role                          *string
	_RoleVerified                  *bool
	_RoleRemStatus                 *bool
	_RoleRemarks                   *string
	_DCCS                          *time.Time
	_DCCSVerified                  *bool
	_DCCSRemStatus                 *bool
	_DCCSRemarks                   *string
	_DCInPresentCadre              *time.Time
	_DCInPresentCadreVerified      *bool
	_DCInPresentCadreRemStatus     *bool
	_DCInPresentCadreRemarks       *string
	_APSWorking                    *bool
	_APSWorkingVerified            *bool
	_APSWorkingRemStatus           *bool
	_APSWorkingRemarks             *string
	profilestatus                  *bool
	_RoleUserCode                  *int32
	add_RoleUserCode               *int32
	clearedFields                  map[string]struct{}
	done                           bool
	oldValue                       func(context.Context) (*Employees, error)
	predicates                     []predicate.Employees
}

var _ ent.Mutation = (*EmployeesMutation)(nil)

// employeesOption allows management of the mutation configuration using functional options.
type employeesOption func(*EmployeesMutation)

// newEmployeesMutation creates new mutation for the Employees entity.
func newEmployeesMutation(c config, op Op, opts ...employeesOption) *EmployeesMutation {
	m := &EmployeesMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployees,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeesID sets the ID field of the mutation.
func withEmployeesID(id int32) employeesOption {
	return func(m *EmployeesMutation) {
		var (
			err   error
			once  sync.Once
			value *Employees
		)
		m.oldValue = func(ctx context.Context) (*Employees, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employees.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployees sets the old Employees of the mutation.
func withEmployees(node *Employees) employeesOption {
	return func(m *EmployeesMutation) {
		m.oldValue = func(context.Context) (*Employees, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Employees entities.
func (m *EmployeesMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeesMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeesMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employees.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeedID sets the "EmployeedID" field.
func (m *EmployeesMutation) SetEmployeedID(i int32) {
	m._EmployeedID = &i
	m.add_EmployeedID = nil
}

// EmployeedID returns the value of the "EmployeedID" field in the mutation.
func (m *EmployeesMutation) EmployeedID() (r int32, exists bool) {
	v := m._EmployeedID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeedID returns the old "EmployeedID" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeedID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeedID: %w", err)
	}
	return oldValue.EmployeedID, nil
}

// AddEmployeedID adds i to the "EmployeedID" field.
func (m *EmployeesMutation) AddEmployeedID(i int32) {
	if m.add_EmployeedID != nil {
		*m.add_EmployeedID += i
	} else {
		m.add_EmployeedID = &i
	}
}

// AddedEmployeedID returns the value that was added to the "EmployeedID" field in this mutation.
func (m *EmployeesMutation) AddedEmployeedID() (r int32, exists bool) {
	v := m.add_EmployeedID
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmployeedID resets all changes to the "EmployeedID" field.
func (m *EmployeesMutation) ResetEmployeedID() {
	m._EmployeedID = nil
	m.add_EmployeedID = nil
}

// SetIDVerified sets the "IDVerified" field.
func (m *EmployeesMutation) SetIDVerified(b bool) {
	m._IDVerified = &b
}

// IDVerified returns the value of the "IDVerified" field in the mutation.
func (m *EmployeesMutation) IDVerified() (r bool, exists bool) {
	v := m._IDVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldIDVerified returns the old "IDVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldIDVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDVerified: %w", err)
	}
	return oldValue.IDVerified, nil
}

// ResetIDVerified resets all changes to the "IDVerified" field.
func (m *EmployeesMutation) ResetIDVerified() {
	m._IDVerified = nil
}

// SetIDRemStatus sets the "IDRemStatus" field.
func (m *EmployeesMutation) SetIDRemStatus(b bool) {
	m._IDRemStatus = &b
}

// IDRemStatus returns the value of the "IDRemStatus" field in the mutation.
func (m *EmployeesMutation) IDRemStatus() (r bool, exists bool) {
	v := m._IDRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldIDRemStatus returns the old "IDRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldIDRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDRemStatus: %w", err)
	}
	return oldValue.IDRemStatus, nil
}

// ResetIDRemStatus resets all changes to the "IDRemStatus" field.
func (m *EmployeesMutation) ResetIDRemStatus() {
	m._IDRemStatus = nil
}

// SetIDRemarks sets the "IDRemarks" field.
func (m *EmployeesMutation) SetIDRemarks(s string) {
	m._IDRemarks = &s
}

// IDRemarks returns the value of the "IDRemarks" field in the mutation.
func (m *EmployeesMutation) IDRemarks() (r string, exists bool) {
	v := m._IDRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldIDRemarks returns the old "IDRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldIDRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDRemarks: %w", err)
	}
	return oldValue.IDRemarks, nil
}

// ClearIDRemarks clears the value of the "IDRemarks" field.
func (m *EmployeesMutation) ClearIDRemarks() {
	m._IDRemarks = nil
	m.clearedFields[employees.FieldIDRemarks] = struct{}{}
}

// IDRemarksCleared returns if the "IDRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) IDRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldIDRemarks]
	return ok
}

// ResetIDRemarks resets all changes to the "IDRemarks" field.
func (m *EmployeesMutation) ResetIDRemarks() {
	m._IDRemarks = nil
	delete(m.clearedFields, employees.FieldIDRemarks)
}

// SetEmployeeName sets the "EmployeeName" field.
func (m *EmployeesMutation) SetEmployeeName(s string) {
	m._EmployeeName = &s
}

// EmployeeName returns the value of the "EmployeeName" field in the mutation.
func (m *EmployeesMutation) EmployeeName() (r string, exists bool) {
	v := m._EmployeeName
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeName returns the old "EmployeeName" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeName: %w", err)
	}
	return oldValue.EmployeeName, nil
}

// ResetEmployeeName resets all changes to the "EmployeeName" field.
func (m *EmployeesMutation) ResetEmployeeName() {
	m._EmployeeName = nil
}

// SetNameVerified sets the "nameVerified" field.
func (m *EmployeesMutation) SetNameVerified(b bool) {
	m.nameVerified = &b
}

// NameVerified returns the value of the "nameVerified" field in the mutation.
func (m *EmployeesMutation) NameVerified() (r bool, exists bool) {
	v := m.nameVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldNameVerified returns the old "nameVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldNameVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameVerified: %w", err)
	}
	return oldValue.NameVerified, nil
}

// ResetNameVerified resets all changes to the "nameVerified" field.
func (m *EmployeesMutation) ResetNameVerified() {
	m.nameVerified = nil
}

// SetNameRemStatus sets the "nameRemStatus" field.
func (m *EmployeesMutation) SetNameRemStatus(b bool) {
	m.nameRemStatus = &b
}

// NameRemStatus returns the value of the "nameRemStatus" field in the mutation.
func (m *EmployeesMutation) NameRemStatus() (r bool, exists bool) {
	v := m.nameRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldNameRemStatus returns the old "nameRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldNameRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameRemStatus: %w", err)
	}
	return oldValue.NameRemStatus, nil
}

// ResetNameRemStatus resets all changes to the "nameRemStatus" field.
func (m *EmployeesMutation) ResetNameRemStatus() {
	m.nameRemStatus = nil
}

// SetNameRemarks sets the "nameRemarks" field.
func (m *EmployeesMutation) SetNameRemarks(s string) {
	m.nameRemarks = &s
}

// NameRemarks returns the value of the "nameRemarks" field in the mutation.
func (m *EmployeesMutation) NameRemarks() (r string, exists bool) {
	v := m.nameRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldNameRemarks returns the old "nameRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldNameRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameRemarks: %w", err)
	}
	return oldValue.NameRemarks, nil
}

// ClearNameRemarks clears the value of the "nameRemarks" field.
func (m *EmployeesMutation) ClearNameRemarks() {
	m.nameRemarks = nil
	m.clearedFields[employees.FieldNameRemarks] = struct{}{}
}

// NameRemarksCleared returns if the "nameRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) NameRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldNameRemarks]
	return ok
}

// ResetNameRemarks resets all changes to the "nameRemarks" field.
func (m *EmployeesMutation) ResetNameRemarks() {
	m.nameRemarks = nil
	delete(m.clearedFields, employees.FieldNameRemarks)
}

// SetEmployeeFathersName sets the "EmployeeFathersName" field.
func (m *EmployeesMutation) SetEmployeeFathersName(s string) {
	m._EmployeeFathersName = &s
}

// EmployeeFathersName returns the value of the "EmployeeFathersName" field in the mutation.
func (m *EmployeesMutation) EmployeeFathersName() (r string, exists bool) {
	v := m._EmployeeFathersName
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeFathersName returns the old "EmployeeFathersName" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeFathersName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeFathersName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeFathersName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeFathersName: %w", err)
	}
	return oldValue.EmployeeFathersName, nil
}

// ResetEmployeeFathersName resets all changes to the "EmployeeFathersName" field.
func (m *EmployeesMutation) ResetEmployeeFathersName() {
	m._EmployeeFathersName = nil
}

// SetFathersNameVerified sets the "FathersNameVerified" field.
func (m *EmployeesMutation) SetFathersNameVerified(b bool) {
	m._FathersNameVerified = &b
}

// FathersNameVerified returns the value of the "FathersNameVerified" field in the mutation.
func (m *EmployeesMutation) FathersNameVerified() (r bool, exists bool) {
	v := m._FathersNameVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldFathersNameVerified returns the old "FathersNameVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldFathersNameVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFathersNameVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFathersNameVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFathersNameVerified: %w", err)
	}
	return oldValue.FathersNameVerified, nil
}

// ResetFathersNameVerified resets all changes to the "FathersNameVerified" field.
func (m *EmployeesMutation) ResetFathersNameVerified() {
	m._FathersNameVerified = nil
}

// SetFathersNameRemStatus sets the "FathersNameRemStatus" field.
func (m *EmployeesMutation) SetFathersNameRemStatus(b bool) {
	m._FathersNameRemStatus = &b
}

// FathersNameRemStatus returns the value of the "FathersNameRemStatus" field in the mutation.
func (m *EmployeesMutation) FathersNameRemStatus() (r bool, exists bool) {
	v := m._FathersNameRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldFathersNameRemStatus returns the old "FathersNameRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldFathersNameRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFathersNameRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFathersNameRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFathersNameRemStatus: %w", err)
	}
	return oldValue.FathersNameRemStatus, nil
}

// ResetFathersNameRemStatus resets all changes to the "FathersNameRemStatus" field.
func (m *EmployeesMutation) ResetFathersNameRemStatus() {
	m._FathersNameRemStatus = nil
}

// SetFathersNameRemarks sets the "FathersNameRemarks" field.
func (m *EmployeesMutation) SetFathersNameRemarks(s string) {
	m._FathersNameRemarks = &s
}

// FathersNameRemarks returns the value of the "FathersNameRemarks" field in the mutation.
func (m *EmployeesMutation) FathersNameRemarks() (r string, exists bool) {
	v := m._FathersNameRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldFathersNameRemarks returns the old "FathersNameRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldFathersNameRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFathersNameRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFathersNameRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFathersNameRemarks: %w", err)
	}
	return oldValue.FathersNameRemarks, nil
}

// ClearFathersNameRemarks clears the value of the "FathersNameRemarks" field.
func (m *EmployeesMutation) ClearFathersNameRemarks() {
	m._FathersNameRemarks = nil
	m.clearedFields[employees.FieldFathersNameRemarks] = struct{}{}
}

// FathersNameRemarksCleared returns if the "FathersNameRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) FathersNameRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldFathersNameRemarks]
	return ok
}

// ResetFathersNameRemarks resets all changes to the "FathersNameRemarks" field.
func (m *EmployeesMutation) ResetFathersNameRemarks() {
	m._FathersNameRemarks = nil
	delete(m.clearedFields, employees.FieldFathersNameRemarks)
}

// SetDOB sets the "DOB" field.
func (m *EmployeesMutation) SetDOB(t time.Time) {
	m._DOB = &t
}

// DOB returns the value of the "DOB" field in the mutation.
func (m *EmployeesMutation) DOB() (r time.Time, exists bool) {
	v := m._DOB
	if v == nil {
		return
	}
	return *v, true
}

// OldDOB returns the old "DOB" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDOB(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOB: %w", err)
	}
	return oldValue.DOB, nil
}

// ResetDOB resets all changes to the "DOB" field.
func (m *EmployeesMutation) ResetDOB() {
	m._DOB = nil
}

// SetDOBVerified sets the "DOBVerified" field.
func (m *EmployeesMutation) SetDOBVerified(b bool) {
	m._DOBVerified = &b
}

// DOBVerified returns the value of the "DOBVerified" field in the mutation.
func (m *EmployeesMutation) DOBVerified() (r bool, exists bool) {
	v := m._DOBVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldDOBVerified returns the old "DOBVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDOBVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOBVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOBVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOBVerified: %w", err)
	}
	return oldValue.DOBVerified, nil
}

// ResetDOBVerified resets all changes to the "DOBVerified" field.
func (m *EmployeesMutation) ResetDOBVerified() {
	m._DOBVerified = nil
}

// SetDOBRemStatus sets the "DOBRemStatus" field.
func (m *EmployeesMutation) SetDOBRemStatus(b bool) {
	m._DOBRemStatus = &b
}

// DOBRemStatus returns the value of the "DOBRemStatus" field in the mutation.
func (m *EmployeesMutation) DOBRemStatus() (r bool, exists bool) {
	v := m._DOBRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldDOBRemStatus returns the old "DOBRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDOBRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOBRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOBRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOBRemStatus: %w", err)
	}
	return oldValue.DOBRemStatus, nil
}

// ResetDOBRemStatus resets all changes to the "DOBRemStatus" field.
func (m *EmployeesMutation) ResetDOBRemStatus() {
	m._DOBRemStatus = nil
}

// SetDOBRemarks sets the "DOBRemarks" field.
func (m *EmployeesMutation) SetDOBRemarks(s string) {
	m._DOBRemarks = &s
}

// DOBRemarks returns the value of the "DOBRemarks" field in the mutation.
func (m *EmployeesMutation) DOBRemarks() (r string, exists bool) {
	v := m._DOBRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldDOBRemarks returns the old "DOBRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDOBRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOBRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOBRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOBRemarks: %w", err)
	}
	return oldValue.DOBRemarks, nil
}

// ClearDOBRemarks clears the value of the "DOBRemarks" field.
func (m *EmployeesMutation) ClearDOBRemarks() {
	m._DOBRemarks = nil
	m.clearedFields[employees.FieldDOBRemarks] = struct{}{}
}

// DOBRemarksCleared returns if the "DOBRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) DOBRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldDOBRemarks]
	return ok
}

// ResetDOBRemarks resets all changes to the "DOBRemarks" field.
func (m *EmployeesMutation) ResetDOBRemarks() {
	m._DOBRemarks = nil
	delete(m.clearedFields, employees.FieldDOBRemarks)
}

// SetGender sets the "Gender" field.
func (m *EmployeesMutation) SetGender(e employees.Gender) {
	m._Gender = &e
}

// Gender returns the value of the "Gender" field in the mutation.
func (m *EmployeesMutation) Gender() (r employees.Gender, exists bool) {
	v := m._Gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "Gender" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldGender(ctx context.Context) (v employees.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "Gender" field.
func (m *EmployeesMutation) ResetGender() {
	m._Gender = nil
}

// SetGenderVerified sets the "genderVerified" field.
func (m *EmployeesMutation) SetGenderVerified(b bool) {
	m.genderVerified = &b
}

// GenderVerified returns the value of the "genderVerified" field in the mutation.
func (m *EmployeesMutation) GenderVerified() (r bool, exists bool) {
	v := m.genderVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderVerified returns the old "genderVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldGenderVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenderVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenderVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderVerified: %w", err)
	}
	return oldValue.GenderVerified, nil
}

// ResetGenderVerified resets all changes to the "genderVerified" field.
func (m *EmployeesMutation) ResetGenderVerified() {
	m.genderVerified = nil
}

// SetGenderRemStatus sets the "genderRemStatus" field.
func (m *EmployeesMutation) SetGenderRemStatus(b bool) {
	m.genderRemStatus = &b
}

// GenderRemStatus returns the value of the "genderRemStatus" field in the mutation.
func (m *EmployeesMutation) GenderRemStatus() (r bool, exists bool) {
	v := m.genderRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderRemStatus returns the old "genderRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldGenderRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenderRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenderRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderRemStatus: %w", err)
	}
	return oldValue.GenderRemStatus, nil
}

// ResetGenderRemStatus resets all changes to the "genderRemStatus" field.
func (m *EmployeesMutation) ResetGenderRemStatus() {
	m.genderRemStatus = nil
}

// SetGenderRemarks sets the "genderRemarks" field.
func (m *EmployeesMutation) SetGenderRemarks(s string) {
	m.genderRemarks = &s
}

// GenderRemarks returns the value of the "genderRemarks" field in the mutation.
func (m *EmployeesMutation) GenderRemarks() (r string, exists bool) {
	v := m.genderRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderRemarks returns the old "genderRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldGenderRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenderRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenderRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderRemarks: %w", err)
	}
	return oldValue.GenderRemarks, nil
}

// ClearGenderRemarks clears the value of the "genderRemarks" field.
func (m *EmployeesMutation) ClearGenderRemarks() {
	m.genderRemarks = nil
	m.clearedFields[employees.FieldGenderRemarks] = struct{}{}
}

// GenderRemarksCleared returns if the "genderRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) GenderRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldGenderRemarks]
	return ok
}

// ResetGenderRemarks resets all changes to the "genderRemarks" field.
func (m *EmployeesMutation) ResetGenderRemarks() {
	m.genderRemarks = nil
	delete(m.clearedFields, employees.FieldGenderRemarks)
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *EmployeesMutation) SetMobileNumber(i int64) {
	m._MobileNumber = &i
	m.add_MobileNumber = nil
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *EmployeesMutation) MobileNumber() (r int64, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldMobileNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// AddMobileNumber adds i to the "MobileNumber" field.
func (m *EmployeesMutation) AddMobileNumber(i int64) {
	if m.add_MobileNumber != nil {
		*m.add_MobileNumber += i
	} else {
		m.add_MobileNumber = &i
	}
}

// AddedMobileNumber returns the value that was added to the "MobileNumber" field in this mutation.
func (m *EmployeesMutation) AddedMobileNumber() (r int64, exists bool) {
	v := m.add_MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearMobileNumber clears the value of the "MobileNumber" field.
func (m *EmployeesMutation) ClearMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	m.clearedFields[employees.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "MobileNumber" field was cleared in this mutation.
func (m *EmployeesMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[employees.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *EmployeesMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	delete(m.clearedFields, employees.FieldMobileNumber)
}

// SetMobileNumberVerified sets the "MobileNumberVerified" field.
func (m *EmployeesMutation) SetMobileNumberVerified(b bool) {
	m._MobileNumberVerified = &b
}

// MobileNumberVerified returns the value of the "MobileNumberVerified" field in the mutation.
func (m *EmployeesMutation) MobileNumberVerified() (r bool, exists bool) {
	v := m._MobileNumberVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumberVerified returns the old "MobileNumberVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldMobileNumberVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumberVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumberVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumberVerified: %w", err)
	}
	return oldValue.MobileNumberVerified, nil
}

// ResetMobileNumberVerified resets all changes to the "MobileNumberVerified" field.
func (m *EmployeesMutation) ResetMobileNumberVerified() {
	m._MobileNumberVerified = nil
}

// SetMobileNumberRemStatus sets the "MobileNumberRemStatus" field.
func (m *EmployeesMutation) SetMobileNumberRemStatus(b bool) {
	m._MobileNumberRemStatus = &b
}

// MobileNumberRemStatus returns the value of the "MobileNumberRemStatus" field in the mutation.
func (m *EmployeesMutation) MobileNumberRemStatus() (r bool, exists bool) {
	v := m._MobileNumberRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumberRemStatus returns the old "MobileNumberRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldMobileNumberRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumberRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumberRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumberRemStatus: %w", err)
	}
	return oldValue.MobileNumberRemStatus, nil
}

// ResetMobileNumberRemStatus resets all changes to the "MobileNumberRemStatus" field.
func (m *EmployeesMutation) ResetMobileNumberRemStatus() {
	m._MobileNumberRemStatus = nil
}

// SetMobileNumberRemarks sets the "MobileNumberRemarks" field.
func (m *EmployeesMutation) SetMobileNumberRemarks(s string) {
	m._MobileNumberRemarks = &s
}

// MobileNumberRemarks returns the value of the "MobileNumberRemarks" field in the mutation.
func (m *EmployeesMutation) MobileNumberRemarks() (r string, exists bool) {
	v := m._MobileNumberRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumberRemarks returns the old "MobileNumberRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldMobileNumberRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumberRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumberRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumberRemarks: %w", err)
	}
	return oldValue.MobileNumberRemarks, nil
}

// ClearMobileNumberRemarks clears the value of the "MobileNumberRemarks" field.
func (m *EmployeesMutation) ClearMobileNumberRemarks() {
	m._MobileNumberRemarks = nil
	m.clearedFields[employees.FieldMobileNumberRemarks] = struct{}{}
}

// MobileNumberRemarksCleared returns if the "MobileNumberRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) MobileNumberRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldMobileNumberRemarks]
	return ok
}

// ResetMobileNumberRemarks resets all changes to the "MobileNumberRemarks" field.
func (m *EmployeesMutation) ResetMobileNumberRemarks() {
	m._MobileNumberRemarks = nil
	delete(m.clearedFields, employees.FieldMobileNumberRemarks)
}

// SetEmailID sets the "EmailID" field.
func (m *EmployeesMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *EmployeesMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ClearEmailID clears the value of the "EmailID" field.
func (m *EmployeesMutation) ClearEmailID() {
	m._EmailID = nil
	m.clearedFields[employees.FieldEmailID] = struct{}{}
}

// EmailIDCleared returns if the "EmailID" field was cleared in this mutation.
func (m *EmployeesMutation) EmailIDCleared() bool {
	_, ok := m.clearedFields[employees.FieldEmailID]
	return ok
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *EmployeesMutation) ResetEmailID() {
	m._EmailID = nil
	delete(m.clearedFields, employees.FieldEmailID)
}

// SetEmailIDVerified sets the "EmailIDVerified" field.
func (m *EmployeesMutation) SetEmailIDVerified(b bool) {
	m._EmailIDVerified = &b
}

// EmailIDVerified returns the value of the "EmailIDVerified" field in the mutation.
func (m *EmployeesMutation) EmailIDVerified() (r bool, exists bool) {
	v := m._EmailIDVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailIDVerified returns the old "EmailIDVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmailIDVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailIDVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailIDVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailIDVerified: %w", err)
	}
	return oldValue.EmailIDVerified, nil
}

// ResetEmailIDVerified resets all changes to the "EmailIDVerified" field.
func (m *EmployeesMutation) ResetEmailIDVerified() {
	m._EmailIDVerified = nil
}

// SetEmailIDRemStatus sets the "EmailIDRemStatus" field.
func (m *EmployeesMutation) SetEmailIDRemStatus(b bool) {
	m._EmailIDRemStatus = &b
}

// EmailIDRemStatus returns the value of the "EmailIDRemStatus" field in the mutation.
func (m *EmployeesMutation) EmailIDRemStatus() (r bool, exists bool) {
	v := m._EmailIDRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailIDRemStatus returns the old "EmailIDRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmailIDRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailIDRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailIDRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailIDRemStatus: %w", err)
	}
	return oldValue.EmailIDRemStatus, nil
}

// ResetEmailIDRemStatus resets all changes to the "EmailIDRemStatus" field.
func (m *EmployeesMutation) ResetEmailIDRemStatus() {
	m._EmailIDRemStatus = nil
}

// SetEmailIDRemarks sets the "EmailIDRemarks" field.
func (m *EmployeesMutation) SetEmailIDRemarks(s string) {
	m._EmailIDRemarks = &s
}

// EmailIDRemarks returns the value of the "EmailIDRemarks" field in the mutation.
func (m *EmployeesMutation) EmailIDRemarks() (r string, exists bool) {
	v := m._EmailIDRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailIDRemarks returns the old "EmailIDRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmailIDRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailIDRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailIDRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailIDRemarks: %w", err)
	}
	return oldValue.EmailIDRemarks, nil
}

// ClearEmailIDRemarks clears the value of the "EmailIDRemarks" field.
func (m *EmployeesMutation) ClearEmailIDRemarks() {
	m._EmailIDRemarks = nil
	m.clearedFields[employees.FieldEmailIDRemarks] = struct{}{}
}

// EmailIDRemarksCleared returns if the "EmailIDRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) EmailIDRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldEmailIDRemarks]
	return ok
}

// ResetEmailIDRemarks resets all changes to the "EmailIDRemarks" field.
func (m *EmployeesMutation) ResetEmailIDRemarks() {
	m._EmailIDRemarks = nil
	delete(m.clearedFields, employees.FieldEmailIDRemarks)
}

// SetCategoryid sets the "Categoryid" field.
func (m *EmployeesMutation) SetCategoryid(i int32) {
	m._Categoryid = &i
	m.add_Categoryid = nil
}

// Categoryid returns the value of the "Categoryid" field in the mutation.
func (m *EmployeesMutation) Categoryid() (r int32, exists bool) {
	v := m._Categoryid
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryid returns the old "Categoryid" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldCategoryid(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryid: %w", err)
	}
	return oldValue.Categoryid, nil
}

// AddCategoryid adds i to the "Categoryid" field.
func (m *EmployeesMutation) AddCategoryid(i int32) {
	if m.add_Categoryid != nil {
		*m.add_Categoryid += i
	} else {
		m.add_Categoryid = &i
	}
}

// AddedCategoryid returns the value that was added to the "Categoryid" field in this mutation.
func (m *EmployeesMutation) AddedCategoryid() (r int32, exists bool) {
	v := m.add_Categoryid
	if v == nil {
		return
	}
	return *v, true
}

// ClearCategoryid clears the value of the "Categoryid" field.
func (m *EmployeesMutation) ClearCategoryid() {
	m._Categoryid = nil
	m.add_Categoryid = nil
	m.clearedFields[employees.FieldCategoryid] = struct{}{}
}

// CategoryidCleared returns if the "Categoryid" field was cleared in this mutation.
func (m *EmployeesMutation) CategoryidCleared() bool {
	_, ok := m.clearedFields[employees.FieldCategoryid]
	return ok
}

// ResetCategoryid resets all changes to the "Categoryid" field.
func (m *EmployeesMutation) ResetCategoryid() {
	m._Categoryid = nil
	m.add_Categoryid = nil
	delete(m.clearedFields, employees.FieldCategoryid)
}

// SetEmployeeCategoryCode sets the "EmployeeCategoryCode" field.
func (m *EmployeesMutation) SetEmployeeCategoryCode(s string) {
	m._EmployeeCategoryCode = &s
}

// EmployeeCategoryCode returns the value of the "EmployeeCategoryCode" field in the mutation.
func (m *EmployeesMutation) EmployeeCategoryCode() (r string, exists bool) {
	v := m._EmployeeCategoryCode
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCategoryCode returns the old "EmployeeCategoryCode" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeCategoryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCategoryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCategoryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCategoryCode: %w", err)
	}
	return oldValue.EmployeeCategoryCode, nil
}

// ClearEmployeeCategoryCode clears the value of the "EmployeeCategoryCode" field.
func (m *EmployeesMutation) ClearEmployeeCategoryCode() {
	m._EmployeeCategoryCode = nil
	m.clearedFields[employees.FieldEmployeeCategoryCode] = struct{}{}
}

// EmployeeCategoryCodeCleared returns if the "EmployeeCategoryCode" field was cleared in this mutation.
func (m *EmployeesMutation) EmployeeCategoryCodeCleared() bool {
	_, ok := m.clearedFields[employees.FieldEmployeeCategoryCode]
	return ok
}

// ResetEmployeeCategoryCode resets all changes to the "EmployeeCategoryCode" field.
func (m *EmployeesMutation) ResetEmployeeCategoryCode() {
	m._EmployeeCategoryCode = nil
	delete(m.clearedFields, employees.FieldEmployeeCategoryCode)
}

// SetEmployeeCategory sets the "EmployeeCategory" field.
func (m *EmployeesMutation) SetEmployeeCategory(s string) {
	m._EmployeeCategory = &s
}

// EmployeeCategory returns the value of the "EmployeeCategory" field in the mutation.
func (m *EmployeesMutation) EmployeeCategory() (r string, exists bool) {
	v := m._EmployeeCategory
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCategory returns the old "EmployeeCategory" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCategory: %w", err)
	}
	return oldValue.EmployeeCategory, nil
}

// ResetEmployeeCategory resets all changes to the "EmployeeCategory" field.
func (m *EmployeesMutation) ResetEmployeeCategory() {
	m._EmployeeCategory = nil
}

// SetEmployeeCategoryCodeVerified sets the "EmployeeCategoryCodeVerified" field.
func (m *EmployeesMutation) SetEmployeeCategoryCodeVerified(b bool) {
	m._EmployeeCategoryCodeVerified = &b
}

// EmployeeCategoryCodeVerified returns the value of the "EmployeeCategoryCodeVerified" field in the mutation.
func (m *EmployeesMutation) EmployeeCategoryCodeVerified() (r bool, exists bool) {
	v := m._EmployeeCategoryCodeVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCategoryCodeVerified returns the old "EmployeeCategoryCodeVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeCategoryCodeVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCategoryCodeVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCategoryCodeVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCategoryCodeVerified: %w", err)
	}
	return oldValue.EmployeeCategoryCodeVerified, nil
}

// ResetEmployeeCategoryCodeVerified resets all changes to the "EmployeeCategoryCodeVerified" field.
func (m *EmployeesMutation) ResetEmployeeCategoryCodeVerified() {
	m._EmployeeCategoryCodeVerified = nil
}

// SetEmployeeCategoryCodeRemStatus sets the "EmployeeCategoryCodeRemStatus" field.
func (m *EmployeesMutation) SetEmployeeCategoryCodeRemStatus(b bool) {
	m._EmployeeCategoryCodeRemStatus = &b
}

// EmployeeCategoryCodeRemStatus returns the value of the "EmployeeCategoryCodeRemStatus" field in the mutation.
func (m *EmployeesMutation) EmployeeCategoryCodeRemStatus() (r bool, exists bool) {
	v := m._EmployeeCategoryCodeRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCategoryCodeRemStatus returns the old "EmployeeCategoryCodeRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeCategoryCodeRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCategoryCodeRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCategoryCodeRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCategoryCodeRemStatus: %w", err)
	}
	return oldValue.EmployeeCategoryCodeRemStatus, nil
}

// ResetEmployeeCategoryCodeRemStatus resets all changes to the "EmployeeCategoryCodeRemStatus" field.
func (m *EmployeesMutation) ResetEmployeeCategoryCodeRemStatus() {
	m._EmployeeCategoryCodeRemStatus = nil
}

// SetEmployeeCategoryCodeRemarks sets the "EmployeeCategoryCodeRemarks" field.
func (m *EmployeesMutation) SetEmployeeCategoryCodeRemarks(s string) {
	m._EmployeeCategoryCodeRemarks = &s
}

// EmployeeCategoryCodeRemarks returns the value of the "EmployeeCategoryCodeRemarks" field in the mutation.
func (m *EmployeesMutation) EmployeeCategoryCodeRemarks() (r string, exists bool) {
	v := m._EmployeeCategoryCodeRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCategoryCodeRemarks returns the old "EmployeeCategoryCodeRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeCategoryCodeRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCategoryCodeRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCategoryCodeRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCategoryCodeRemarks: %w", err)
	}
	return oldValue.EmployeeCategoryCodeRemarks, nil
}

// ClearEmployeeCategoryCodeRemarks clears the value of the "EmployeeCategoryCodeRemarks" field.
func (m *EmployeesMutation) ClearEmployeeCategoryCodeRemarks() {
	m._EmployeeCategoryCodeRemarks = nil
	m.clearedFields[employees.FieldEmployeeCategoryCodeRemarks] = struct{}{}
}

// EmployeeCategoryCodeRemarksCleared returns if the "EmployeeCategoryCodeRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) EmployeeCategoryCodeRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldEmployeeCategoryCodeRemarks]
	return ok
}

// ResetEmployeeCategoryCodeRemarks resets all changes to the "EmployeeCategoryCodeRemarks" field.
func (m *EmployeesMutation) ResetEmployeeCategoryCodeRemarks() {
	m._EmployeeCategoryCodeRemarks = nil
	delete(m.clearedFields, employees.FieldEmployeeCategoryCodeRemarks)
}

// SetWithDisability sets the "WithDisability" field.
func (m *EmployeesMutation) SetWithDisability(s string) {
	m._WithDisability = &s
}

// WithDisability returns the value of the "WithDisability" field in the mutation.
func (m *EmployeesMutation) WithDisability() (r string, exists bool) {
	v := m._WithDisability
	if v == nil {
		return
	}
	return *v, true
}

// OldWithDisability returns the old "WithDisability" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldWithDisability(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithDisability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithDisability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithDisability: %w", err)
	}
	return oldValue.WithDisability, nil
}

// ResetWithDisability resets all changes to the "WithDisability" field.
func (m *EmployeesMutation) ResetWithDisability() {
	m._WithDisability = nil
}

// SetWithDisabilityVerified sets the "WithDisabilityVerified" field.
func (m *EmployeesMutation) SetWithDisabilityVerified(b bool) {
	m._WithDisabilityVerified = &b
}

// WithDisabilityVerified returns the value of the "WithDisabilityVerified" field in the mutation.
func (m *EmployeesMutation) WithDisabilityVerified() (r bool, exists bool) {
	v := m._WithDisabilityVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldWithDisabilityVerified returns the old "WithDisabilityVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldWithDisabilityVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithDisabilityVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithDisabilityVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithDisabilityVerified: %w", err)
	}
	return oldValue.WithDisabilityVerified, nil
}

// ResetWithDisabilityVerified resets all changes to the "WithDisabilityVerified" field.
func (m *EmployeesMutation) ResetWithDisabilityVerified() {
	m._WithDisabilityVerified = nil
}

// SetWithDisabilityRemStatus sets the "WithDisabilityRemStatus" field.
func (m *EmployeesMutation) SetWithDisabilityRemStatus(b bool) {
	m._WithDisabilityRemStatus = &b
}

// WithDisabilityRemStatus returns the value of the "WithDisabilityRemStatus" field in the mutation.
func (m *EmployeesMutation) WithDisabilityRemStatus() (r bool, exists bool) {
	v := m._WithDisabilityRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldWithDisabilityRemStatus returns the old "WithDisabilityRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldWithDisabilityRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithDisabilityRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithDisabilityRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithDisabilityRemStatus: %w", err)
	}
	return oldValue.WithDisabilityRemStatus, nil
}

// ResetWithDisabilityRemStatus resets all changes to the "WithDisabilityRemStatus" field.
func (m *EmployeesMutation) ResetWithDisabilityRemStatus() {
	m._WithDisabilityRemStatus = nil
}

// SetWithDisabilityRemarks sets the "WithDisabilityRemarks" field.
func (m *EmployeesMutation) SetWithDisabilityRemarks(b bool) {
	m._WithDisabilityRemarks = &b
}

// WithDisabilityRemarks returns the value of the "WithDisabilityRemarks" field in the mutation.
func (m *EmployeesMutation) WithDisabilityRemarks() (r bool, exists bool) {
	v := m._WithDisabilityRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldWithDisabilityRemarks returns the old "WithDisabilityRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldWithDisabilityRemarks(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithDisabilityRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithDisabilityRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithDisabilityRemarks: %w", err)
	}
	return oldValue.WithDisabilityRemarks, nil
}

// ClearWithDisabilityRemarks clears the value of the "WithDisabilityRemarks" field.
func (m *EmployeesMutation) ClearWithDisabilityRemarks() {
	m._WithDisabilityRemarks = nil
	m.clearedFields[employees.FieldWithDisabilityRemarks] = struct{}{}
}

// WithDisabilityRemarksCleared returns if the "WithDisabilityRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) WithDisabilityRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldWithDisabilityRemarks]
	return ok
}

// ResetWithDisabilityRemarks resets all changes to the "WithDisabilityRemarks" field.
func (m *EmployeesMutation) ResetWithDisabilityRemarks() {
	m._WithDisabilityRemarks = nil
	delete(m.clearedFields, employees.FieldWithDisabilityRemarks)
}

// SetDisabilityType sets the "DisabilityType" field.
func (m *EmployeesMutation) SetDisabilityType(s string) {
	m._DisabilityType = &s
}

// DisabilityType returns the value of the "DisabilityType" field in the mutation.
func (m *EmployeesMutation) DisabilityType() (r string, exists bool) {
	v := m._DisabilityType
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityType returns the old "DisabilityType" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityType: %w", err)
	}
	return oldValue.DisabilityType, nil
}

// ClearDisabilityType clears the value of the "DisabilityType" field.
func (m *EmployeesMutation) ClearDisabilityType() {
	m._DisabilityType = nil
	m.clearedFields[employees.FieldDisabilityType] = struct{}{}
}

// DisabilityTypeCleared returns if the "DisabilityType" field was cleared in this mutation.
func (m *EmployeesMutation) DisabilityTypeCleared() bool {
	_, ok := m.clearedFields[employees.FieldDisabilityType]
	return ok
}

// ResetDisabilityType resets all changes to the "DisabilityType" field.
func (m *EmployeesMutation) ResetDisabilityType() {
	m._DisabilityType = nil
	delete(m.clearedFields, employees.FieldDisabilityType)
}

// SetDisabilityTypeVerified sets the "DisabilityTypeVerified" field.
func (m *EmployeesMutation) SetDisabilityTypeVerified(b bool) {
	m._DisabilityTypeVerified = &b
}

// DisabilityTypeVerified returns the value of the "DisabilityTypeVerified" field in the mutation.
func (m *EmployeesMutation) DisabilityTypeVerified() (r bool, exists bool) {
	v := m._DisabilityTypeVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityTypeVerified returns the old "DisabilityTypeVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityTypeVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityTypeVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityTypeVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityTypeVerified: %w", err)
	}
	return oldValue.DisabilityTypeVerified, nil
}

// ResetDisabilityTypeVerified resets all changes to the "DisabilityTypeVerified" field.
func (m *EmployeesMutation) ResetDisabilityTypeVerified() {
	m._DisabilityTypeVerified = nil
}

// SetDisabilityTypeRemStatus sets the "DisabilityTypeRemStatus" field.
func (m *EmployeesMutation) SetDisabilityTypeRemStatus(b bool) {
	m._DisabilityTypeRemStatus = &b
}

// DisabilityTypeRemStatus returns the value of the "DisabilityTypeRemStatus" field in the mutation.
func (m *EmployeesMutation) DisabilityTypeRemStatus() (r bool, exists bool) {
	v := m._DisabilityTypeRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityTypeRemStatus returns the old "DisabilityTypeRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityTypeRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityTypeRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityTypeRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityTypeRemStatus: %w", err)
	}
	return oldValue.DisabilityTypeRemStatus, nil
}

// ResetDisabilityTypeRemStatus resets all changes to the "DisabilityTypeRemStatus" field.
func (m *EmployeesMutation) ResetDisabilityTypeRemStatus() {
	m._DisabilityTypeRemStatus = nil
}

// SetDisabilityTypeRemarks sets the "DisabilityTypeRemarks" field.
func (m *EmployeesMutation) SetDisabilityTypeRemarks(s string) {
	m._DisabilityTypeRemarks = &s
}

// DisabilityTypeRemarks returns the value of the "DisabilityTypeRemarks" field in the mutation.
func (m *EmployeesMutation) DisabilityTypeRemarks() (r string, exists bool) {
	v := m._DisabilityTypeRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityTypeRemarks returns the old "DisabilityTypeRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityTypeRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityTypeRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityTypeRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityTypeRemarks: %w", err)
	}
	return oldValue.DisabilityTypeRemarks, nil
}

// ClearDisabilityTypeRemarks clears the value of the "DisabilityTypeRemarks" field.
func (m *EmployeesMutation) ClearDisabilityTypeRemarks() {
	m._DisabilityTypeRemarks = nil
	m.clearedFields[employees.FieldDisabilityTypeRemarks] = struct{}{}
}

// DisabilityTypeRemarksCleared returns if the "DisabilityTypeRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) DisabilityTypeRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldDisabilityTypeRemarks]
	return ok
}

// ResetDisabilityTypeRemarks resets all changes to the "DisabilityTypeRemarks" field.
func (m *EmployeesMutation) ResetDisabilityTypeRemarks() {
	m._DisabilityTypeRemarks = nil
	delete(m.clearedFields, employees.FieldDisabilityTypeRemarks)
}

// SetDisabilityPercentage sets the "DisabilityPercentage" field.
func (m *EmployeesMutation) SetDisabilityPercentage(i int32) {
	m._DisabilityPercentage = &i
	m.add_DisabilityPercentage = nil
}

// DisabilityPercentage returns the value of the "DisabilityPercentage" field in the mutation.
func (m *EmployeesMutation) DisabilityPercentage() (r int32, exists bool) {
	v := m._DisabilityPercentage
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityPercentage returns the old "DisabilityPercentage" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityPercentage(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityPercentage: %w", err)
	}
	return oldValue.DisabilityPercentage, nil
}

// AddDisabilityPercentage adds i to the "DisabilityPercentage" field.
func (m *EmployeesMutation) AddDisabilityPercentage(i int32) {
	if m.add_DisabilityPercentage != nil {
		*m.add_DisabilityPercentage += i
	} else {
		m.add_DisabilityPercentage = &i
	}
}

// AddedDisabilityPercentage returns the value that was added to the "DisabilityPercentage" field in this mutation.
func (m *EmployeesMutation) AddedDisabilityPercentage() (r int32, exists bool) {
	v := m.add_DisabilityPercentage
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisabilityPercentage clears the value of the "DisabilityPercentage" field.
func (m *EmployeesMutation) ClearDisabilityPercentage() {
	m._DisabilityPercentage = nil
	m.add_DisabilityPercentage = nil
	m.clearedFields[employees.FieldDisabilityPercentage] = struct{}{}
}

// DisabilityPercentageCleared returns if the "DisabilityPercentage" field was cleared in this mutation.
func (m *EmployeesMutation) DisabilityPercentageCleared() bool {
	_, ok := m.clearedFields[employees.FieldDisabilityPercentage]
	return ok
}

// ResetDisabilityPercentage resets all changes to the "DisabilityPercentage" field.
func (m *EmployeesMutation) ResetDisabilityPercentage() {
	m._DisabilityPercentage = nil
	m.add_DisabilityPercentage = nil
	delete(m.clearedFields, employees.FieldDisabilityPercentage)
}

// SetDisabilityPercentageVerified sets the "DisabilityPercentageVerified" field.
func (m *EmployeesMutation) SetDisabilityPercentageVerified(b bool) {
	m._DisabilityPercentageVerified = &b
}

// DisabilityPercentageVerified returns the value of the "DisabilityPercentageVerified" field in the mutation.
func (m *EmployeesMutation) DisabilityPercentageVerified() (r bool, exists bool) {
	v := m._DisabilityPercentageVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityPercentageVerified returns the old "DisabilityPercentageVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityPercentageVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityPercentageVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityPercentageVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityPercentageVerified: %w", err)
	}
	return oldValue.DisabilityPercentageVerified, nil
}

// ResetDisabilityPercentageVerified resets all changes to the "DisabilityPercentageVerified" field.
func (m *EmployeesMutation) ResetDisabilityPercentageVerified() {
	m._DisabilityPercentageVerified = nil
}

// SetDisabilityPercentageRemStatus sets the "DisabilityPercentageRemStatus" field.
func (m *EmployeesMutation) SetDisabilityPercentageRemStatus(b bool) {
	m._DisabilityPercentageRemStatus = &b
}

// DisabilityPercentageRemStatus returns the value of the "DisabilityPercentageRemStatus" field in the mutation.
func (m *EmployeesMutation) DisabilityPercentageRemStatus() (r bool, exists bool) {
	v := m._DisabilityPercentageRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityPercentageRemStatus returns the old "DisabilityPercentageRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityPercentageRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityPercentageRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityPercentageRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityPercentageRemStatus: %w", err)
	}
	return oldValue.DisabilityPercentageRemStatus, nil
}

// ResetDisabilityPercentageRemStatus resets all changes to the "DisabilityPercentageRemStatus" field.
func (m *EmployeesMutation) ResetDisabilityPercentageRemStatus() {
	m._DisabilityPercentageRemStatus = nil
}

// SetDisabilityPercentageRemarks sets the "DisabilityPercentageRemarks" field.
func (m *EmployeesMutation) SetDisabilityPercentageRemarks(s string) {
	m._DisabilityPercentageRemarks = &s
}

// DisabilityPercentageRemarks returns the value of the "DisabilityPercentageRemarks" field in the mutation.
func (m *EmployeesMutation) DisabilityPercentageRemarks() (r string, exists bool) {
	v := m._DisabilityPercentageRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityPercentageRemarks returns the old "DisabilityPercentageRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDisabilityPercentageRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityPercentageRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityPercentageRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityPercentageRemarks: %w", err)
	}
	return oldValue.DisabilityPercentageRemarks, nil
}

// ClearDisabilityPercentageRemarks clears the value of the "DisabilityPercentageRemarks" field.
func (m *EmployeesMutation) ClearDisabilityPercentageRemarks() {
	m._DisabilityPercentageRemarks = nil
	m.clearedFields[employees.FieldDisabilityPercentageRemarks] = struct{}{}
}

// DisabilityPercentageRemarksCleared returns if the "DisabilityPercentageRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) DisabilityPercentageRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldDisabilityPercentageRemarks]
	return ok
}

// ResetDisabilityPercentageRemarks resets all changes to the "DisabilityPercentageRemarks" field.
func (m *EmployeesMutation) ResetDisabilityPercentageRemarks() {
	m._DisabilityPercentageRemarks = nil
	delete(m.clearedFields, employees.FieldDisabilityPercentageRemarks)
}

// SetSignature sets the "Signature" field.
func (m *EmployeesMutation) SetSignature(s string) {
	m._Signature = &s
}

// Signature returns the value of the "Signature" field in the mutation.
func (m *EmployeesMutation) Signature() (r string, exists bool) {
	v := m._Signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "Signature" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ResetSignature resets all changes to the "Signature" field.
func (m *EmployeesMutation) ResetSignature() {
	m._Signature = nil
}

// SetSignatureVerified sets the "SignatureVerified" field.
func (m *EmployeesMutation) SetSignatureVerified(b bool) {
	m._SignatureVerified = &b
}

// SignatureVerified returns the value of the "SignatureVerified" field in the mutation.
func (m *EmployeesMutation) SignatureVerified() (r bool, exists bool) {
	v := m._SignatureVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldSignatureVerified returns the old "SignatureVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldSignatureVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignatureVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignatureVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignatureVerified: %w", err)
	}
	return oldValue.SignatureVerified, nil
}

// ResetSignatureVerified resets all changes to the "SignatureVerified" field.
func (m *EmployeesMutation) ResetSignatureVerified() {
	m._SignatureVerified = nil
}

// SetSignatureRemStatus sets the "SignatureRemStatus" field.
func (m *EmployeesMutation) SetSignatureRemStatus(b bool) {
	m._SignatureRemStatus = &b
}

// SignatureRemStatus returns the value of the "SignatureRemStatus" field in the mutation.
func (m *EmployeesMutation) SignatureRemStatus() (r bool, exists bool) {
	v := m._SignatureRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldSignatureRemStatus returns the old "SignatureRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldSignatureRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignatureRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignatureRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignatureRemStatus: %w", err)
	}
	return oldValue.SignatureRemStatus, nil
}

// ResetSignatureRemStatus resets all changes to the "SignatureRemStatus" field.
func (m *EmployeesMutation) ResetSignatureRemStatus() {
	m._SignatureRemStatus = nil
}

// SetSignatureRemarks sets the "SignatureRemarks" field.
func (m *EmployeesMutation) SetSignatureRemarks(s string) {
	m._SignatureRemarks = &s
}

// SignatureRemarks returns the value of the "SignatureRemarks" field in the mutation.
func (m *EmployeesMutation) SignatureRemarks() (r string, exists bool) {
	v := m._SignatureRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldSignatureRemarks returns the old "SignatureRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldSignatureRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignatureRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignatureRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignatureRemarks: %w", err)
	}
	return oldValue.SignatureRemarks, nil
}

// ClearSignatureRemarks clears the value of the "SignatureRemarks" field.
func (m *EmployeesMutation) ClearSignatureRemarks() {
	m._SignatureRemarks = nil
	m.clearedFields[employees.FieldSignatureRemarks] = struct{}{}
}

// SignatureRemarksCleared returns if the "SignatureRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) SignatureRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldSignatureRemarks]
	return ok
}

// ResetSignatureRemarks resets all changes to the "SignatureRemarks" field.
func (m *EmployeesMutation) ResetSignatureRemarks() {
	m._SignatureRemarks = nil
	delete(m.clearedFields, employees.FieldSignatureRemarks)
}

// SetPhoto sets the "Photo" field.
func (m *EmployeesMutation) SetPhoto(s string) {
	m._Photo = &s
}

// Photo returns the value of the "Photo" field in the mutation.
func (m *EmployeesMutation) Photo() (r string, exists bool) {
	v := m._Photo
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoto returns the old "Photo" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoto: %w", err)
	}
	return oldValue.Photo, nil
}

// ResetPhoto resets all changes to the "Photo" field.
func (m *EmployeesMutation) ResetPhoto() {
	m._Photo = nil
}

// SetPhotoVerified sets the "PhotoVerified" field.
func (m *EmployeesMutation) SetPhotoVerified(b bool) {
	m._PhotoVerified = &b
}

// PhotoVerified returns the value of the "PhotoVerified" field in the mutation.
func (m *EmployeesMutation) PhotoVerified() (r bool, exists bool) {
	v := m._PhotoVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoVerified returns the old "PhotoVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldPhotoVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoVerified: %w", err)
	}
	return oldValue.PhotoVerified, nil
}

// ResetPhotoVerified resets all changes to the "PhotoVerified" field.
func (m *EmployeesMutation) ResetPhotoVerified() {
	m._PhotoVerified = nil
}

// SetPhotoRemStatus sets the "PhotoRemStatus" field.
func (m *EmployeesMutation) SetPhotoRemStatus(b bool) {
	m._PhotoRemStatus = &b
}

// PhotoRemStatus returns the value of the "PhotoRemStatus" field in the mutation.
func (m *EmployeesMutation) PhotoRemStatus() (r bool, exists bool) {
	v := m._PhotoRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoRemStatus returns the old "PhotoRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldPhotoRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoRemStatus: %w", err)
	}
	return oldValue.PhotoRemStatus, nil
}

// ResetPhotoRemStatus resets all changes to the "PhotoRemStatus" field.
func (m *EmployeesMutation) ResetPhotoRemStatus() {
	m._PhotoRemStatus = nil
}

// SetPhotoRemarks sets the "PhotoRemarks" field.
func (m *EmployeesMutation) SetPhotoRemarks(s string) {
	m._PhotoRemarks = &s
}

// PhotoRemarks returns the value of the "PhotoRemarks" field in the mutation.
func (m *EmployeesMutation) PhotoRemarks() (r string, exists bool) {
	v := m._PhotoRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoRemarks returns the old "PhotoRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldPhotoRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoRemarks: %w", err)
	}
	return oldValue.PhotoRemarks, nil
}

// ClearPhotoRemarks clears the value of the "PhotoRemarks" field.
func (m *EmployeesMutation) ClearPhotoRemarks() {
	m._PhotoRemarks = nil
	m.clearedFields[employees.FieldPhotoRemarks] = struct{}{}
}

// PhotoRemarksCleared returns if the "PhotoRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) PhotoRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldPhotoRemarks]
	return ok
}

// ResetPhotoRemarks resets all changes to the "PhotoRemarks" field.
func (m *EmployeesMutation) ResetPhotoRemarks() {
	m._PhotoRemarks = nil
	delete(m.clearedFields, employees.FieldPhotoRemarks)
}

// SetPostID sets the "PostID" field.
func (m *EmployeesMutation) SetPostID(i int32) {
	m._PostID = &i
	m.add_PostID = nil
}

// PostID returns the value of the "PostID" field in the mutation.
func (m *EmployeesMutation) PostID() (r int32, exists bool) {
	v := m._PostID
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "PostID" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldPostID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// AddPostID adds i to the "PostID" field.
func (m *EmployeesMutation) AddPostID(i int32) {
	if m.add_PostID != nil {
		*m.add_PostID += i
	} else {
		m.add_PostID = &i
	}
}

// AddedPostID returns the value that was added to the "PostID" field in this mutation.
func (m *EmployeesMutation) AddedPostID() (r int32, exists bool) {
	v := m.add_PostID
	if v == nil {
		return
	}
	return *v, true
}

// ClearPostID clears the value of the "PostID" field.
func (m *EmployeesMutation) ClearPostID() {
	m._PostID = nil
	m.add_PostID = nil
	m.clearedFields[employees.FieldPostID] = struct{}{}
}

// PostIDCleared returns if the "PostID" field was cleared in this mutation.
func (m *EmployeesMutation) PostIDCleared() bool {
	_, ok := m.clearedFields[employees.FieldPostID]
	return ok
}

// ResetPostID resets all changes to the "PostID" field.
func (m *EmployeesMutation) ResetPostID() {
	m._PostID = nil
	m.add_PostID = nil
	delete(m.clearedFields, employees.FieldPostID)
}

// SetPostCode sets the "PostCode" field.
func (m *EmployeesMutation) SetPostCode(s string) {
	m._PostCode = &s
}

// PostCode returns the value of the "PostCode" field in the mutation.
func (m *EmployeesMutation) PostCode() (r string, exists bool) {
	v := m._PostCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPostCode returns the old "PostCode" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldPostCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostCode: %w", err)
	}
	return oldValue.PostCode, nil
}

// ClearPostCode clears the value of the "PostCode" field.
func (m *EmployeesMutation) ClearPostCode() {
	m._PostCode = nil
	m.clearedFields[employees.FieldPostCode] = struct{}{}
}

// PostCodeCleared returns if the "PostCode" field was cleared in this mutation.
func (m *EmployeesMutation) PostCodeCleared() bool {
	_, ok := m.clearedFields[employees.FieldPostCode]
	return ok
}

// ResetPostCode resets all changes to the "PostCode" field.
func (m *EmployeesMutation) ResetPostCode() {
	m._PostCode = nil
	delete(m.clearedFields, employees.FieldPostCode)
}

// SetEmployeePost sets the "EmployeePost" field.
func (m *EmployeesMutation) SetEmployeePost(s string) {
	m._EmployeePost = &s
}

// EmployeePost returns the value of the "EmployeePost" field in the mutation.
func (m *EmployeesMutation) EmployeePost() (r string, exists bool) {
	v := m._EmployeePost
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeePost returns the old "EmployeePost" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeePost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeePost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeePost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeePost: %w", err)
	}
	return oldValue.EmployeePost, nil
}

// ResetEmployeePost resets all changes to the "EmployeePost" field.
func (m *EmployeesMutation) ResetEmployeePost() {
	m._EmployeePost = nil
}

// SetEmployeePostVerified sets the "EmployeePostVerified" field.
func (m *EmployeesMutation) SetEmployeePostVerified(b bool) {
	m._EmployeePostVerified = &b
}

// EmployeePostVerified returns the value of the "EmployeePostVerified" field in the mutation.
func (m *EmployeesMutation) EmployeePostVerified() (r bool, exists bool) {
	v := m._EmployeePostVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeePostVerified returns the old "EmployeePostVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeePostVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeePostVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeePostVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeePostVerified: %w", err)
	}
	return oldValue.EmployeePostVerified, nil
}

// ResetEmployeePostVerified resets all changes to the "EmployeePostVerified" field.
func (m *EmployeesMutation) ResetEmployeePostVerified() {
	m._EmployeePostVerified = nil
}

// SetEmployeePostRemStatus sets the "EmployeePostRemStatus" field.
func (m *EmployeesMutation) SetEmployeePostRemStatus(b bool) {
	m._EmployeePostRemStatus = &b
}

// EmployeePostRemStatus returns the value of the "EmployeePostRemStatus" field in the mutation.
func (m *EmployeesMutation) EmployeePostRemStatus() (r bool, exists bool) {
	v := m._EmployeePostRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeePostRemStatus returns the old "EmployeePostRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeePostRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeePostRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeePostRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeePostRemStatus: %w", err)
	}
	return oldValue.EmployeePostRemStatus, nil
}

// ResetEmployeePostRemStatus resets all changes to the "EmployeePostRemStatus" field.
func (m *EmployeesMutation) ResetEmployeePostRemStatus() {
	m._EmployeePostRemStatus = nil
}

// SetEmployeePostRemarks sets the "EmployeePostRemarks" field.
func (m *EmployeesMutation) SetEmployeePostRemarks(s string) {
	m._EmployeePostRemarks = &s
}

// EmployeePostRemarks returns the value of the "EmployeePostRemarks" field in the mutation.
func (m *EmployeesMutation) EmployeePostRemarks() (r string, exists bool) {
	v := m._EmployeePostRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeePostRemarks returns the old "EmployeePostRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeePostRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeePostRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeePostRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeePostRemarks: %w", err)
	}
	return oldValue.EmployeePostRemarks, nil
}

// ClearEmployeePostRemarks clears the value of the "EmployeePostRemarks" field.
func (m *EmployeesMutation) ClearEmployeePostRemarks() {
	m._EmployeePostRemarks = nil
	m.clearedFields[employees.FieldEmployeePostRemarks] = struct{}{}
}

// EmployeePostRemarksCleared returns if the "EmployeePostRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) EmployeePostRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldEmployeePostRemarks]
	return ok
}

// ResetEmployeePostRemarks resets all changes to the "EmployeePostRemarks" field.
func (m *EmployeesMutation) ResetEmployeePostRemarks() {
	m._EmployeePostRemarks = nil
	delete(m.clearedFields, employees.FieldEmployeePostRemarks)
}

// SetDesignationID sets the "DesignationID" field.
func (m *EmployeesMutation) SetDesignationID(i int32) {
	m._DesignationID = &i
	m.add_DesignationID = nil
}

// DesignationID returns the value of the "DesignationID" field in the mutation.
func (m *EmployeesMutation) DesignationID() (r int32, exists bool) {
	v := m._DesignationID
	if v == nil {
		return
	}
	return *v, true
}

// OldDesignationID returns the old "DesignationID" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDesignationID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesignationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesignationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesignationID: %w", err)
	}
	return oldValue.DesignationID, nil
}

// AddDesignationID adds i to the "DesignationID" field.
func (m *EmployeesMutation) AddDesignationID(i int32) {
	if m.add_DesignationID != nil {
		*m.add_DesignationID += i
	} else {
		m.add_DesignationID = &i
	}
}

// AddedDesignationID returns the value that was added to the "DesignationID" field in this mutation.
func (m *EmployeesMutation) AddedDesignationID() (r int32, exists bool) {
	v := m.add_DesignationID
	if v == nil {
		return
	}
	return *v, true
}

// ClearDesignationID clears the value of the "DesignationID" field.
func (m *EmployeesMutation) ClearDesignationID() {
	m._DesignationID = nil
	m.add_DesignationID = nil
	m.clearedFields[employees.FieldDesignationID] = struct{}{}
}

// DesignationIDCleared returns if the "DesignationID" field was cleared in this mutation.
func (m *EmployeesMutation) DesignationIDCleared() bool {
	_, ok := m.clearedFields[employees.FieldDesignationID]
	return ok
}

// ResetDesignationID resets all changes to the "DesignationID" field.
func (m *EmployeesMutation) ResetDesignationID() {
	m._DesignationID = nil
	m.add_DesignationID = nil
	delete(m.clearedFields, employees.FieldDesignationID)
}

// SetEmployeeDesignation sets the "EmployeeDesignation" field.
func (m *EmployeesMutation) SetEmployeeDesignation(s string) {
	m._EmployeeDesignation = &s
}

// EmployeeDesignation returns the value of the "EmployeeDesignation" field in the mutation.
func (m *EmployeesMutation) EmployeeDesignation() (r string, exists bool) {
	v := m._EmployeeDesignation
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeDesignation returns the old "EmployeeDesignation" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeDesignation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeDesignation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeDesignation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeDesignation: %w", err)
	}
	return oldValue.EmployeeDesignation, nil
}

// ResetEmployeeDesignation resets all changes to the "EmployeeDesignation" field.
func (m *EmployeesMutation) ResetEmployeeDesignation() {
	m._EmployeeDesignation = nil
}

// SetEmployeeDesignationVerified sets the "EmployeeDesignationVerified" field.
func (m *EmployeesMutation) SetEmployeeDesignationVerified(b bool) {
	m._EmployeeDesignationVerified = &b
}

// EmployeeDesignationVerified returns the value of the "EmployeeDesignationVerified" field in the mutation.
func (m *EmployeesMutation) EmployeeDesignationVerified() (r bool, exists bool) {
	v := m._EmployeeDesignationVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeDesignationVerified returns the old "EmployeeDesignationVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeDesignationVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeDesignationVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeDesignationVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeDesignationVerified: %w", err)
	}
	return oldValue.EmployeeDesignationVerified, nil
}

// ResetEmployeeDesignationVerified resets all changes to the "EmployeeDesignationVerified" field.
func (m *EmployeesMutation) ResetEmployeeDesignationVerified() {
	m._EmployeeDesignationVerified = nil
}

// SetEmployeeDesignationRemStatus sets the "EmployeeDesignationRemStatus" field.
func (m *EmployeesMutation) SetEmployeeDesignationRemStatus(b bool) {
	m._EmployeeDesignationRemStatus = &b
}

// EmployeeDesignationRemStatus returns the value of the "EmployeeDesignationRemStatus" field in the mutation.
func (m *EmployeesMutation) EmployeeDesignationRemStatus() (r bool, exists bool) {
	v := m._EmployeeDesignationRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeDesignationRemStatus returns the old "EmployeeDesignationRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeDesignationRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeDesignationRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeDesignationRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeDesignationRemStatus: %w", err)
	}
	return oldValue.EmployeeDesignationRemStatus, nil
}

// ResetEmployeeDesignationRemStatus resets all changes to the "EmployeeDesignationRemStatus" field.
func (m *EmployeesMutation) ResetEmployeeDesignationRemStatus() {
	m._EmployeeDesignationRemStatus = nil
}

// SetEmployeeDesignationRemarks sets the "EmployeeDesignationRemarks" field.
func (m *EmployeesMutation) SetEmployeeDesignationRemarks(s string) {
	m._EmployeeDesignationRemarks = &s
}

// EmployeeDesignationRemarks returns the value of the "EmployeeDesignationRemarks" field in the mutation.
func (m *EmployeesMutation) EmployeeDesignationRemarks() (r string, exists bool) {
	v := m._EmployeeDesignationRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeDesignationRemarks returns the old "EmployeeDesignationRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldEmployeeDesignationRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeDesignationRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeDesignationRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeDesignationRemarks: %w", err)
	}
	return oldValue.EmployeeDesignationRemarks, nil
}

// ClearEmployeeDesignationRemarks clears the value of the "EmployeeDesignationRemarks" field.
func (m *EmployeesMutation) ClearEmployeeDesignationRemarks() {
	m._EmployeeDesignationRemarks = nil
	m.clearedFields[employees.FieldEmployeeDesignationRemarks] = struct{}{}
}

// EmployeeDesignationRemarksCleared returns if the "EmployeeDesignationRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) EmployeeDesignationRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldEmployeeDesignationRemarks]
	return ok
}

// ResetEmployeeDesignationRemarks resets all changes to the "EmployeeDesignationRemarks" field.
func (m *EmployeesMutation) ResetEmployeeDesignationRemarks() {
	m._EmployeeDesignationRemarks = nil
	delete(m.clearedFields, employees.FieldEmployeeDesignationRemarks)
}

// SetCircleID sets the "CircleID" field.
func (m *EmployeesMutation) SetCircleID(i int32) {
	m._CircleID = &i
	m.add_CircleID = nil
}

// CircleID returns the value of the "CircleID" field in the mutation.
func (m *EmployeesMutation) CircleID() (r int32, exists bool) {
	v := m._CircleID
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleID returns the old "CircleID" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldCircleID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleID: %w", err)
	}
	return oldValue.CircleID, nil
}

// AddCircleID adds i to the "CircleID" field.
func (m *EmployeesMutation) AddCircleID(i int32) {
	if m.add_CircleID != nil {
		*m.add_CircleID += i
	} else {
		m.add_CircleID = &i
	}
}

// AddedCircleID returns the value that was added to the "CircleID" field in this mutation.
func (m *EmployeesMutation) AddedCircleID() (r int32, exists bool) {
	v := m.add_CircleID
	if v == nil {
		return
	}
	return *v, true
}

// ClearCircleID clears the value of the "CircleID" field.
func (m *EmployeesMutation) ClearCircleID() {
	m._CircleID = nil
	m.add_CircleID = nil
	m.clearedFields[employees.FieldCircleID] = struct{}{}
}

// CircleIDCleared returns if the "CircleID" field was cleared in this mutation.
func (m *EmployeesMutation) CircleIDCleared() bool {
	_, ok := m.clearedFields[employees.FieldCircleID]
	return ok
}

// ResetCircleID resets all changes to the "CircleID" field.
func (m *EmployeesMutation) ResetCircleID() {
	m._CircleID = nil
	m.add_CircleID = nil
	delete(m.clearedFields, employees.FieldCircleID)
}

// SetCircleName sets the "CircleName" field.
func (m *EmployeesMutation) SetCircleName(s string) {
	m._CircleName = &s
}

// CircleName returns the value of the "CircleName" field in the mutation.
func (m *EmployeesMutation) CircleName() (r string, exists bool) {
	v := m._CircleName
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleName returns the old "CircleName" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldCircleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleName: %w", err)
	}
	return oldValue.CircleName, nil
}

// ResetCircleName resets all changes to the "CircleName" field.
func (m *EmployeesMutation) ResetCircleName() {
	m._CircleName = nil
}

// SetCircleVerified sets the "CircleVerified" field.
func (m *EmployeesMutation) SetCircleVerified(b bool) {
	m._CircleVerified = &b
}

// CircleVerified returns the value of the "CircleVerified" field in the mutation.
func (m *EmployeesMutation) CircleVerified() (r bool, exists bool) {
	v := m._CircleVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleVerified returns the old "CircleVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldCircleVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleVerified: %w", err)
	}
	return oldValue.CircleVerified, nil
}

// ResetCircleVerified resets all changes to the "CircleVerified" field.
func (m *EmployeesMutation) ResetCircleVerified() {
	m._CircleVerified = nil
}

// SetCircleRemStatus sets the "CircleRemStatus" field.
func (m *EmployeesMutation) SetCircleRemStatus(b bool) {
	m._CircleRemStatus = &b
}

// CircleRemStatus returns the value of the "CircleRemStatus" field in the mutation.
func (m *EmployeesMutation) CircleRemStatus() (r bool, exists bool) {
	v := m._CircleRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleRemStatus returns the old "CircleRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldCircleRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleRemStatus: %w", err)
	}
	return oldValue.CircleRemStatus, nil
}

// ResetCircleRemStatus resets all changes to the "CircleRemStatus" field.
func (m *EmployeesMutation) ResetCircleRemStatus() {
	m._CircleRemStatus = nil
}

// SetCircleRemarks sets the "CircleRemarks" field.
func (m *EmployeesMutation) SetCircleRemarks(s string) {
	m._CircleRemarks = &s
}

// CircleRemarks returns the value of the "CircleRemarks" field in the mutation.
func (m *EmployeesMutation) CircleRemarks() (r string, exists bool) {
	v := m._CircleRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleRemarks returns the old "CircleRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldCircleRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleRemarks: %w", err)
	}
	return oldValue.CircleRemarks, nil
}

// ClearCircleRemarks clears the value of the "CircleRemarks" field.
func (m *EmployeesMutation) ClearCircleRemarks() {
	m._CircleRemarks = nil
	m.clearedFields[employees.FieldCircleRemarks] = struct{}{}
}

// CircleRemarksCleared returns if the "CircleRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) CircleRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldCircleRemarks]
	return ok
}

// ResetCircleRemarks resets all changes to the "CircleRemarks" field.
func (m *EmployeesMutation) ResetCircleRemarks() {
	m._CircleRemarks = nil
	delete(m.clearedFields, employees.FieldCircleRemarks)
}

// SetRegionID sets the "RegionID" field.
func (m *EmployeesMutation) SetRegionID(i int32) {
	m._RegionID = &i
	m.add_RegionID = nil
}

// RegionID returns the value of the "RegionID" field in the mutation.
func (m *EmployeesMutation) RegionID() (r int32, exists bool) {
	v := m._RegionID
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionID returns the old "RegionID" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRegionID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionID: %w", err)
	}
	return oldValue.RegionID, nil
}

// AddRegionID adds i to the "RegionID" field.
func (m *EmployeesMutation) AddRegionID(i int32) {
	if m.add_RegionID != nil {
		*m.add_RegionID += i
	} else {
		m.add_RegionID = &i
	}
}

// AddedRegionID returns the value that was added to the "RegionID" field in this mutation.
func (m *EmployeesMutation) AddedRegionID() (r int32, exists bool) {
	v := m.add_RegionID
	if v == nil {
		return
	}
	return *v, true
}

// ClearRegionID clears the value of the "RegionID" field.
func (m *EmployeesMutation) ClearRegionID() {
	m._RegionID = nil
	m.add_RegionID = nil
	m.clearedFields[employees.FieldRegionID] = struct{}{}
}

// RegionIDCleared returns if the "RegionID" field was cleared in this mutation.
func (m *EmployeesMutation) RegionIDCleared() bool {
	_, ok := m.clearedFields[employees.FieldRegionID]
	return ok
}

// ResetRegionID resets all changes to the "RegionID" field.
func (m *EmployeesMutation) ResetRegionID() {
	m._RegionID = nil
	m.add_RegionID = nil
	delete(m.clearedFields, employees.FieldRegionID)
}

// SetRegionName sets the "RegionName" field.
func (m *EmployeesMutation) SetRegionName(s string) {
	m._RegionName = &s
}

// RegionName returns the value of the "RegionName" field in the mutation.
func (m *EmployeesMutation) RegionName() (r string, exists bool) {
	v := m._RegionName
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionName returns the old "RegionName" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRegionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionName: %w", err)
	}
	return oldValue.RegionName, nil
}

// ClearRegionName clears the value of the "RegionName" field.
func (m *EmployeesMutation) ClearRegionName() {
	m._RegionName = nil
	m.clearedFields[employees.FieldRegionName] = struct{}{}
}

// RegionNameCleared returns if the "RegionName" field was cleared in this mutation.
func (m *EmployeesMutation) RegionNameCleared() bool {
	_, ok := m.clearedFields[employees.FieldRegionName]
	return ok
}

// ResetRegionName resets all changes to the "RegionName" field.
func (m *EmployeesMutation) ResetRegionName() {
	m._RegionName = nil
	delete(m.clearedFields, employees.FieldRegionName)
}

// SetRegionVerified sets the "RegionVerified" field.
func (m *EmployeesMutation) SetRegionVerified(b bool) {
	m._RegionVerified = &b
}

// RegionVerified returns the value of the "RegionVerified" field in the mutation.
func (m *EmployeesMutation) RegionVerified() (r bool, exists bool) {
	v := m._RegionVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionVerified returns the old "RegionVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRegionVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionVerified: %w", err)
	}
	return oldValue.RegionVerified, nil
}

// ResetRegionVerified resets all changes to the "RegionVerified" field.
func (m *EmployeesMutation) ResetRegionVerified() {
	m._RegionVerified = nil
}

// SetRegionRemStatus sets the "RegionRemStatus" field.
func (m *EmployeesMutation) SetRegionRemStatus(b bool) {
	m._RegionRemStatus = &b
}

// RegionRemStatus returns the value of the "RegionRemStatus" field in the mutation.
func (m *EmployeesMutation) RegionRemStatus() (r bool, exists bool) {
	v := m._RegionRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionRemStatus returns the old "RegionRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRegionRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionRemStatus: %w", err)
	}
	return oldValue.RegionRemStatus, nil
}

// ResetRegionRemStatus resets all changes to the "RegionRemStatus" field.
func (m *EmployeesMutation) ResetRegionRemStatus() {
	m._RegionRemStatus = nil
}

// SetRegionRemarks sets the "RegionRemarks" field.
func (m *EmployeesMutation) SetRegionRemarks(s string) {
	m._RegionRemarks = &s
}

// RegionRemarks returns the value of the "RegionRemarks" field in the mutation.
func (m *EmployeesMutation) RegionRemarks() (r string, exists bool) {
	v := m._RegionRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionRemarks returns the old "RegionRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRegionRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionRemarks: %w", err)
	}
	return oldValue.RegionRemarks, nil
}

// ClearRegionRemarks clears the value of the "RegionRemarks" field.
func (m *EmployeesMutation) ClearRegionRemarks() {
	m._RegionRemarks = nil
	m.clearedFields[employees.FieldRegionRemarks] = struct{}{}
}

// RegionRemarksCleared returns if the "RegionRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) RegionRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldRegionRemarks]
	return ok
}

// ResetRegionRemarks resets all changes to the "RegionRemarks" field.
func (m *EmployeesMutation) ResetRegionRemarks() {
	m._RegionRemarks = nil
	delete(m.clearedFields, employees.FieldRegionRemarks)
}

// SetDivisionID sets the "DivisionID" field.
func (m *EmployeesMutation) SetDivisionID(i int32) {
	m._DivisionID = &i
	m.add_DivisionID = nil
}

// DivisionID returns the value of the "DivisionID" field in the mutation.
func (m *EmployeesMutation) DivisionID() (r int32, exists bool) {
	v := m._DivisionID
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionID returns the old "DivisionID" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDivisionID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionID: %w", err)
	}
	return oldValue.DivisionID, nil
}

// AddDivisionID adds i to the "DivisionID" field.
func (m *EmployeesMutation) AddDivisionID(i int32) {
	if m.add_DivisionID != nil {
		*m.add_DivisionID += i
	} else {
		m.add_DivisionID = &i
	}
}

// AddedDivisionID returns the value that was added to the "DivisionID" field in this mutation.
func (m *EmployeesMutation) AddedDivisionID() (r int32, exists bool) {
	v := m.add_DivisionID
	if v == nil {
		return
	}
	return *v, true
}

// ClearDivisionID clears the value of the "DivisionID" field.
func (m *EmployeesMutation) ClearDivisionID() {
	m._DivisionID = nil
	m.add_DivisionID = nil
	m.clearedFields[employees.FieldDivisionID] = struct{}{}
}

// DivisionIDCleared returns if the "DivisionID" field was cleared in this mutation.
func (m *EmployeesMutation) DivisionIDCleared() bool {
	_, ok := m.clearedFields[employees.FieldDivisionID]
	return ok
}

// ResetDivisionID resets all changes to the "DivisionID" field.
func (m *EmployeesMutation) ResetDivisionID() {
	m._DivisionID = nil
	m.add_DivisionID = nil
	delete(m.clearedFields, employees.FieldDivisionID)
}

// SetDivisionName sets the "DivisionName" field.
func (m *EmployeesMutation) SetDivisionName(s string) {
	m._DivisionName = &s
}

// DivisionName returns the value of the "DivisionName" field in the mutation.
func (m *EmployeesMutation) DivisionName() (r string, exists bool) {
	v := m._DivisionName
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionName returns the old "DivisionName" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDivisionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionName: %w", err)
	}
	return oldValue.DivisionName, nil
}

// ClearDivisionName clears the value of the "DivisionName" field.
func (m *EmployeesMutation) ClearDivisionName() {
	m._DivisionName = nil
	m.clearedFields[employees.FieldDivisionName] = struct{}{}
}

// DivisionNameCleared returns if the "DivisionName" field was cleared in this mutation.
func (m *EmployeesMutation) DivisionNameCleared() bool {
	_, ok := m.clearedFields[employees.FieldDivisionName]
	return ok
}

// ResetDivisionName resets all changes to the "DivisionName" field.
func (m *EmployeesMutation) ResetDivisionName() {
	m._DivisionName = nil
	delete(m.clearedFields, employees.FieldDivisionName)
}

// SetDivisionVerified sets the "DivisionVerified" field.
func (m *EmployeesMutation) SetDivisionVerified(b bool) {
	m._DivisionVerified = &b
}

// DivisionVerified returns the value of the "DivisionVerified" field in the mutation.
func (m *EmployeesMutation) DivisionVerified() (r bool, exists bool) {
	v := m._DivisionVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionVerified returns the old "DivisionVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDivisionVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionVerified: %w", err)
	}
	return oldValue.DivisionVerified, nil
}

// ResetDivisionVerified resets all changes to the "DivisionVerified" field.
func (m *EmployeesMutation) ResetDivisionVerified() {
	m._DivisionVerified = nil
}

// SetDivisionRemStatus sets the "DivisionRemStatus" field.
func (m *EmployeesMutation) SetDivisionRemStatus(b bool) {
	m._DivisionRemStatus = &b
}

// DivisionRemStatus returns the value of the "DivisionRemStatus" field in the mutation.
func (m *EmployeesMutation) DivisionRemStatus() (r bool, exists bool) {
	v := m._DivisionRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionRemStatus returns the old "DivisionRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDivisionRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionRemStatus: %w", err)
	}
	return oldValue.DivisionRemStatus, nil
}

// ResetDivisionRemStatus resets all changes to the "DivisionRemStatus" field.
func (m *EmployeesMutation) ResetDivisionRemStatus() {
	m._DivisionRemStatus = nil
}

// SetDivisionRemarks sets the "DivisionRemarks" field.
func (m *EmployeesMutation) SetDivisionRemarks(s string) {
	m._DivisionRemarks = &s
}

// DivisionRemarks returns the value of the "DivisionRemarks" field in the mutation.
func (m *EmployeesMutation) DivisionRemarks() (r string, exists bool) {
	v := m._DivisionRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionRemarks returns the old "DivisionRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDivisionRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionRemarks: %w", err)
	}
	return oldValue.DivisionRemarks, nil
}

// ResetDivisionRemarks resets all changes to the "DivisionRemarks" field.
func (m *EmployeesMutation) ResetDivisionRemarks() {
	m._DivisionRemarks = nil
}

// SetOfficeID sets the "OfficeID" field.
func (m *EmployeesMutation) SetOfficeID(i int32) {
	m._OfficeID = &i
	m.add_OfficeID = nil
}

// OfficeID returns the value of the "OfficeID" field in the mutation.
func (m *EmployeesMutation) OfficeID() (r int32, exists bool) {
	v := m._OfficeID
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeID returns the old "OfficeID" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldOfficeID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeID: %w", err)
	}
	return oldValue.OfficeID, nil
}

// AddOfficeID adds i to the "OfficeID" field.
func (m *EmployeesMutation) AddOfficeID(i int32) {
	if m.add_OfficeID != nil {
		*m.add_OfficeID += i
	} else {
		m.add_OfficeID = &i
	}
}

// AddedOfficeID returns the value that was added to the "OfficeID" field in this mutation.
func (m *EmployeesMutation) AddedOfficeID() (r int32, exists bool) {
	v := m.add_OfficeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearOfficeID clears the value of the "OfficeID" field.
func (m *EmployeesMutation) ClearOfficeID() {
	m._OfficeID = nil
	m.add_OfficeID = nil
	m.clearedFields[employees.FieldOfficeID] = struct{}{}
}

// OfficeIDCleared returns if the "OfficeID" field was cleared in this mutation.
func (m *EmployeesMutation) OfficeIDCleared() bool {
	_, ok := m.clearedFields[employees.FieldOfficeID]
	return ok
}

// ResetOfficeID resets all changes to the "OfficeID" field.
func (m *EmployeesMutation) ResetOfficeID() {
	m._OfficeID = nil
	m.add_OfficeID = nil
	delete(m.clearedFields, employees.FieldOfficeID)
}

// SetOfficeName sets the "OfficeName" field.
func (m *EmployeesMutation) SetOfficeName(s string) {
	m._OfficeName = &s
}

// OfficeName returns the value of the "OfficeName" field in the mutation.
func (m *EmployeesMutation) OfficeName() (r string, exists bool) {
	v := m._OfficeName
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeName returns the old "OfficeName" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldOfficeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeName: %w", err)
	}
	return oldValue.OfficeName, nil
}

// ResetOfficeName resets all changes to the "OfficeName" field.
func (m *EmployeesMutation) ResetOfficeName() {
	m._OfficeName = nil
}

// SetOfficeVerified sets the "OfficeVerified" field.
func (m *EmployeesMutation) SetOfficeVerified(b bool) {
	m._OfficeVerified = &b
}

// OfficeVerified returns the value of the "OfficeVerified" field in the mutation.
func (m *EmployeesMutation) OfficeVerified() (r bool, exists bool) {
	v := m._OfficeVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeVerified returns the old "OfficeVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldOfficeVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeVerified: %w", err)
	}
	return oldValue.OfficeVerified, nil
}

// ResetOfficeVerified resets all changes to the "OfficeVerified" field.
func (m *EmployeesMutation) ResetOfficeVerified() {
	m._OfficeVerified = nil
}

// SetOfficeRemStatus sets the "OfficeRemStatus" field.
func (m *EmployeesMutation) SetOfficeRemStatus(b bool) {
	m._OfficeRemStatus = &b
}

// OfficeRemStatus returns the value of the "OfficeRemStatus" field in the mutation.
func (m *EmployeesMutation) OfficeRemStatus() (r bool, exists bool) {
	v := m._OfficeRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeRemStatus returns the old "OfficeRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldOfficeRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeRemStatus: %w", err)
	}
	return oldValue.OfficeRemStatus, nil
}

// ResetOfficeRemStatus resets all changes to the "OfficeRemStatus" field.
func (m *EmployeesMutation) ResetOfficeRemStatus() {
	m._OfficeRemStatus = nil
}

// SetOfficeRemarks sets the "OfficeRemarks" field.
func (m *EmployeesMutation) SetOfficeRemarks(s string) {
	m._OfficeRemarks = &s
}

// OfficeRemarks returns the value of the "OfficeRemarks" field in the mutation.
func (m *EmployeesMutation) OfficeRemarks() (r string, exists bool) {
	v := m._OfficeRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeRemarks returns the old "OfficeRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldOfficeRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeRemarks: %w", err)
	}
	return oldValue.OfficeRemarks, nil
}

// ClearOfficeRemarks clears the value of the "OfficeRemarks" field.
func (m *EmployeesMutation) ClearOfficeRemarks() {
	m._OfficeRemarks = nil
	m.clearedFields[employees.FieldOfficeRemarks] = struct{}{}
}

// OfficeRemarksCleared returns if the "OfficeRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) OfficeRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldOfficeRemarks]
	return ok
}

// ResetOfficeRemarks resets all changes to the "OfficeRemarks" field.
func (m *EmployeesMutation) ResetOfficeRemarks() {
	m._OfficeRemarks = nil
	delete(m.clearedFields, employees.FieldOfficeRemarks)
}

// SetRole sets the "Role" field.
func (m *EmployeesMutation) SetRole(s string) {
	m._Role = &s
}

// Role returns the value of the "Role" field in the mutation.
func (m *EmployeesMutation) Role() (r string, exists bool) {
	v := m._Role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "Role" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "Role" field.
func (m *EmployeesMutation) ResetRole() {
	m._Role = nil
}

// SetRoleVerified sets the "RoleVerified" field.
func (m *EmployeesMutation) SetRoleVerified(b bool) {
	m._RoleVerified = &b
}

// RoleVerified returns the value of the "RoleVerified" field in the mutation.
func (m *EmployeesMutation) RoleVerified() (r bool, exists bool) {
	v := m._RoleVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleVerified returns the old "RoleVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRoleVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleVerified: %w", err)
	}
	return oldValue.RoleVerified, nil
}

// ResetRoleVerified resets all changes to the "RoleVerified" field.
func (m *EmployeesMutation) ResetRoleVerified() {
	m._RoleVerified = nil
}

// SetRoleRemStatus sets the "RoleRemStatus" field.
func (m *EmployeesMutation) SetRoleRemStatus(b bool) {
	m._RoleRemStatus = &b
}

// RoleRemStatus returns the value of the "RoleRemStatus" field in the mutation.
func (m *EmployeesMutation) RoleRemStatus() (r bool, exists bool) {
	v := m._RoleRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleRemStatus returns the old "RoleRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRoleRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleRemStatus: %w", err)
	}
	return oldValue.RoleRemStatus, nil
}

// ResetRoleRemStatus resets all changes to the "RoleRemStatus" field.
func (m *EmployeesMutation) ResetRoleRemStatus() {
	m._RoleRemStatus = nil
}

// SetRoleRemarks sets the "RoleRemarks" field.
func (m *EmployeesMutation) SetRoleRemarks(s string) {
	m._RoleRemarks = &s
}

// RoleRemarks returns the value of the "RoleRemarks" field in the mutation.
func (m *EmployeesMutation) RoleRemarks() (r string, exists bool) {
	v := m._RoleRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleRemarks returns the old "RoleRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRoleRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleRemarks: %w", err)
	}
	return oldValue.RoleRemarks, nil
}

// ResetRoleRemarks resets all changes to the "RoleRemarks" field.
func (m *EmployeesMutation) ResetRoleRemarks() {
	m._RoleRemarks = nil
}

// SetDCCS sets the "DCCS" field.
func (m *EmployeesMutation) SetDCCS(t time.Time) {
	m._DCCS = &t
}

// DCCS returns the value of the "DCCS" field in the mutation.
func (m *EmployeesMutation) DCCS() (r time.Time, exists bool) {
	v := m._DCCS
	if v == nil {
		return
	}
	return *v, true
}

// OldDCCS returns the old "DCCS" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCCS(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCCS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCCS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCCS: %w", err)
	}
	return oldValue.DCCS, nil
}

// ResetDCCS resets all changes to the "DCCS" field.
func (m *EmployeesMutation) ResetDCCS() {
	m._DCCS = nil
}

// SetDCCSVerified sets the "DCCSVerified" field.
func (m *EmployeesMutation) SetDCCSVerified(b bool) {
	m._DCCSVerified = &b
}

// DCCSVerified returns the value of the "DCCSVerified" field in the mutation.
func (m *EmployeesMutation) DCCSVerified() (r bool, exists bool) {
	v := m._DCCSVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldDCCSVerified returns the old "DCCSVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCCSVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCCSVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCCSVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCCSVerified: %w", err)
	}
	return oldValue.DCCSVerified, nil
}

// ResetDCCSVerified resets all changes to the "DCCSVerified" field.
func (m *EmployeesMutation) ResetDCCSVerified() {
	m._DCCSVerified = nil
}

// SetDCCSRemStatus sets the "DCCSRemStatus" field.
func (m *EmployeesMutation) SetDCCSRemStatus(b bool) {
	m._DCCSRemStatus = &b
}

// DCCSRemStatus returns the value of the "DCCSRemStatus" field in the mutation.
func (m *EmployeesMutation) DCCSRemStatus() (r bool, exists bool) {
	v := m._DCCSRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldDCCSRemStatus returns the old "DCCSRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCCSRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCCSRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCCSRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCCSRemStatus: %w", err)
	}
	return oldValue.DCCSRemStatus, nil
}

// ResetDCCSRemStatus resets all changes to the "DCCSRemStatus" field.
func (m *EmployeesMutation) ResetDCCSRemStatus() {
	m._DCCSRemStatus = nil
}

// SetDCCSRemarks sets the "DCCSRemarks" field.
func (m *EmployeesMutation) SetDCCSRemarks(s string) {
	m._DCCSRemarks = &s
}

// DCCSRemarks returns the value of the "DCCSRemarks" field in the mutation.
func (m *EmployeesMutation) DCCSRemarks() (r string, exists bool) {
	v := m._DCCSRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldDCCSRemarks returns the old "DCCSRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCCSRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCCSRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCCSRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCCSRemarks: %w", err)
	}
	return oldValue.DCCSRemarks, nil
}

// ClearDCCSRemarks clears the value of the "DCCSRemarks" field.
func (m *EmployeesMutation) ClearDCCSRemarks() {
	m._DCCSRemarks = nil
	m.clearedFields[employees.FieldDCCSRemarks] = struct{}{}
}

// DCCSRemarksCleared returns if the "DCCSRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) DCCSRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldDCCSRemarks]
	return ok
}

// ResetDCCSRemarks resets all changes to the "DCCSRemarks" field.
func (m *EmployeesMutation) ResetDCCSRemarks() {
	m._DCCSRemarks = nil
	delete(m.clearedFields, employees.FieldDCCSRemarks)
}

// SetDCInPresentCadre sets the "DCInPresentCadre" field.
func (m *EmployeesMutation) SetDCInPresentCadre(t time.Time) {
	m._DCInPresentCadre = &t
}

// DCInPresentCadre returns the value of the "DCInPresentCadre" field in the mutation.
func (m *EmployeesMutation) DCInPresentCadre() (r time.Time, exists bool) {
	v := m._DCInPresentCadre
	if v == nil {
		return
	}
	return *v, true
}

// OldDCInPresentCadre returns the old "DCInPresentCadre" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCInPresentCadre(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCInPresentCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCInPresentCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCInPresentCadre: %w", err)
	}
	return oldValue.DCInPresentCadre, nil
}

// ResetDCInPresentCadre resets all changes to the "DCInPresentCadre" field.
func (m *EmployeesMutation) ResetDCInPresentCadre() {
	m._DCInPresentCadre = nil
}

// SetDCInPresentCadreVerified sets the "DCInPresentCadreVerified" field.
func (m *EmployeesMutation) SetDCInPresentCadreVerified(b bool) {
	m._DCInPresentCadreVerified = &b
}

// DCInPresentCadreVerified returns the value of the "DCInPresentCadreVerified" field in the mutation.
func (m *EmployeesMutation) DCInPresentCadreVerified() (r bool, exists bool) {
	v := m._DCInPresentCadreVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldDCInPresentCadreVerified returns the old "DCInPresentCadreVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCInPresentCadreVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCInPresentCadreVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCInPresentCadreVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCInPresentCadreVerified: %w", err)
	}
	return oldValue.DCInPresentCadreVerified, nil
}

// ResetDCInPresentCadreVerified resets all changes to the "DCInPresentCadreVerified" field.
func (m *EmployeesMutation) ResetDCInPresentCadreVerified() {
	m._DCInPresentCadreVerified = nil
}

// SetDCInPresentCadreRemStatus sets the "DCInPresentCadreRemStatus" field.
func (m *EmployeesMutation) SetDCInPresentCadreRemStatus(b bool) {
	m._DCInPresentCadreRemStatus = &b
}

// DCInPresentCadreRemStatus returns the value of the "DCInPresentCadreRemStatus" field in the mutation.
func (m *EmployeesMutation) DCInPresentCadreRemStatus() (r bool, exists bool) {
	v := m._DCInPresentCadreRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldDCInPresentCadreRemStatus returns the old "DCInPresentCadreRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCInPresentCadreRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCInPresentCadreRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCInPresentCadreRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCInPresentCadreRemStatus: %w", err)
	}
	return oldValue.DCInPresentCadreRemStatus, nil
}

// ResetDCInPresentCadreRemStatus resets all changes to the "DCInPresentCadreRemStatus" field.
func (m *EmployeesMutation) ResetDCInPresentCadreRemStatus() {
	m._DCInPresentCadreRemStatus = nil
}

// SetDCInPresentCadreRemarks sets the "DCInPresentCadreRemarks" field.
func (m *EmployeesMutation) SetDCInPresentCadreRemarks(s string) {
	m._DCInPresentCadreRemarks = &s
}

// DCInPresentCadreRemarks returns the value of the "DCInPresentCadreRemarks" field in the mutation.
func (m *EmployeesMutation) DCInPresentCadreRemarks() (r string, exists bool) {
	v := m._DCInPresentCadreRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldDCInPresentCadreRemarks returns the old "DCInPresentCadreRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldDCInPresentCadreRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCInPresentCadreRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCInPresentCadreRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCInPresentCadreRemarks: %w", err)
	}
	return oldValue.DCInPresentCadreRemarks, nil
}

// ClearDCInPresentCadreRemarks clears the value of the "DCInPresentCadreRemarks" field.
func (m *EmployeesMutation) ClearDCInPresentCadreRemarks() {
	m._DCInPresentCadreRemarks = nil
	m.clearedFields[employees.FieldDCInPresentCadreRemarks] = struct{}{}
}

// DCInPresentCadreRemarksCleared returns if the "DCInPresentCadreRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) DCInPresentCadreRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldDCInPresentCadreRemarks]
	return ok
}

// ResetDCInPresentCadreRemarks resets all changes to the "DCInPresentCadreRemarks" field.
func (m *EmployeesMutation) ResetDCInPresentCadreRemarks() {
	m._DCInPresentCadreRemarks = nil
	delete(m.clearedFields, employees.FieldDCInPresentCadreRemarks)
}

// SetAPSWorking sets the "APSWorking" field.
func (m *EmployeesMutation) SetAPSWorking(b bool) {
	m._APSWorking = &b
}

// APSWorking returns the value of the "APSWorking" field in the mutation.
func (m *EmployeesMutation) APSWorking() (r bool, exists bool) {
	v := m._APSWorking
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorking returns the old "APSWorking" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldAPSWorking(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorking is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorking requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorking: %w", err)
	}
	return oldValue.APSWorking, nil
}

// ClearAPSWorking clears the value of the "APSWorking" field.
func (m *EmployeesMutation) ClearAPSWorking() {
	m._APSWorking = nil
	m.clearedFields[employees.FieldAPSWorking] = struct{}{}
}

// APSWorkingCleared returns if the "APSWorking" field was cleared in this mutation.
func (m *EmployeesMutation) APSWorkingCleared() bool {
	_, ok := m.clearedFields[employees.FieldAPSWorking]
	return ok
}

// ResetAPSWorking resets all changes to the "APSWorking" field.
func (m *EmployeesMutation) ResetAPSWorking() {
	m._APSWorking = nil
	delete(m.clearedFields, employees.FieldAPSWorking)
}

// SetAPSWorkingVerified sets the "APSWorkingVerified" field.
func (m *EmployeesMutation) SetAPSWorkingVerified(b bool) {
	m._APSWorkingVerified = &b
}

// APSWorkingVerified returns the value of the "APSWorkingVerified" field in the mutation.
func (m *EmployeesMutation) APSWorkingVerified() (r bool, exists bool) {
	v := m._APSWorkingVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorkingVerified returns the old "APSWorkingVerified" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldAPSWorkingVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorkingVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorkingVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorkingVerified: %w", err)
	}
	return oldValue.APSWorkingVerified, nil
}

// ResetAPSWorkingVerified resets all changes to the "APSWorkingVerified" field.
func (m *EmployeesMutation) ResetAPSWorkingVerified() {
	m._APSWorkingVerified = nil
}

// SetAPSWorkingRemStatus sets the "APSWorkingRemStatus" field.
func (m *EmployeesMutation) SetAPSWorkingRemStatus(b bool) {
	m._APSWorkingRemStatus = &b
}

// APSWorkingRemStatus returns the value of the "APSWorkingRemStatus" field in the mutation.
func (m *EmployeesMutation) APSWorkingRemStatus() (r bool, exists bool) {
	v := m._APSWorkingRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorkingRemStatus returns the old "APSWorkingRemStatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldAPSWorkingRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorkingRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorkingRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorkingRemStatus: %w", err)
	}
	return oldValue.APSWorkingRemStatus, nil
}

// ResetAPSWorkingRemStatus resets all changes to the "APSWorkingRemStatus" field.
func (m *EmployeesMutation) ResetAPSWorkingRemStatus() {
	m._APSWorkingRemStatus = nil
}

// SetAPSWorkingRemarks sets the "APSWorkingRemarks" field.
func (m *EmployeesMutation) SetAPSWorkingRemarks(s string) {
	m._APSWorkingRemarks = &s
}

// APSWorkingRemarks returns the value of the "APSWorkingRemarks" field in the mutation.
func (m *EmployeesMutation) APSWorkingRemarks() (r string, exists bool) {
	v := m._APSWorkingRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorkingRemarks returns the old "APSWorkingRemarks" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldAPSWorkingRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorkingRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorkingRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorkingRemarks: %w", err)
	}
	return oldValue.APSWorkingRemarks, nil
}

// ClearAPSWorkingRemarks clears the value of the "APSWorkingRemarks" field.
func (m *EmployeesMutation) ClearAPSWorkingRemarks() {
	m._APSWorkingRemarks = nil
	m.clearedFields[employees.FieldAPSWorkingRemarks] = struct{}{}
}

// APSWorkingRemarksCleared returns if the "APSWorkingRemarks" field was cleared in this mutation.
func (m *EmployeesMutation) APSWorkingRemarksCleared() bool {
	_, ok := m.clearedFields[employees.FieldAPSWorkingRemarks]
	return ok
}

// ResetAPSWorkingRemarks resets all changes to the "APSWorkingRemarks" field.
func (m *EmployeesMutation) ResetAPSWorkingRemarks() {
	m._APSWorkingRemarks = nil
	delete(m.clearedFields, employees.FieldAPSWorkingRemarks)
}

// SetProfilestatus sets the "profilestatus" field.
func (m *EmployeesMutation) SetProfilestatus(b bool) {
	m.profilestatus = &b
}

// Profilestatus returns the value of the "profilestatus" field in the mutation.
func (m *EmployeesMutation) Profilestatus() (r bool, exists bool) {
	v := m.profilestatus
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilestatus returns the old "profilestatus" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldProfilestatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilestatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilestatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilestatus: %w", err)
	}
	return oldValue.Profilestatus, nil
}

// ResetProfilestatus resets all changes to the "profilestatus" field.
func (m *EmployeesMutation) ResetProfilestatus() {
	m.profilestatus = nil
}

// SetRoleUserCode sets the "RoleUserCode" field.
func (m *EmployeesMutation) SetRoleUserCode(i int32) {
	m._RoleUserCode = &i
	m.add_RoleUserCode = nil
}

// RoleUserCode returns the value of the "RoleUserCode" field in the mutation.
func (m *EmployeesMutation) RoleUserCode() (r int32, exists bool) {
	v := m._RoleUserCode
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleUserCode returns the old "RoleUserCode" field's value of the Employees entity.
// If the Employees object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeesMutation) OldRoleUserCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleUserCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleUserCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleUserCode: %w", err)
	}
	return oldValue.RoleUserCode, nil
}

// AddRoleUserCode adds i to the "RoleUserCode" field.
func (m *EmployeesMutation) AddRoleUserCode(i int32) {
	if m.add_RoleUserCode != nil {
		*m.add_RoleUserCode += i
	} else {
		m.add_RoleUserCode = &i
	}
}

// AddedRoleUserCode returns the value that was added to the "RoleUserCode" field in this mutation.
func (m *EmployeesMutation) AddedRoleUserCode() (r int32, exists bool) {
	v := m.add_RoleUserCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoleUserCode clears the value of the "RoleUserCode" field.
func (m *EmployeesMutation) ClearRoleUserCode() {
	m._RoleUserCode = nil
	m.add_RoleUserCode = nil
	m.clearedFields[employees.FieldRoleUserCode] = struct{}{}
}

// RoleUserCodeCleared returns if the "RoleUserCode" field was cleared in this mutation.
func (m *EmployeesMutation) RoleUserCodeCleared() bool {
	_, ok := m.clearedFields[employees.FieldRoleUserCode]
	return ok
}

// ResetRoleUserCode resets all changes to the "RoleUserCode" field.
func (m *EmployeesMutation) ResetRoleUserCode() {
	m._RoleUserCode = nil
	m.add_RoleUserCode = nil
	delete(m.clearedFields, employees.FieldRoleUserCode)
}

// Where appends a list predicates to the EmployeesMutation builder.
func (m *EmployeesMutation) Where(ps ...predicate.Employees) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employees, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employees).
func (m *EmployeesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeesMutation) Fields() []string {
	fields := make([]string, 0, 103)
	if m._EmployeedID != nil {
		fields = append(fields, employees.FieldEmployeedID)
	}
	if m._IDVerified != nil {
		fields = append(fields, employees.FieldIDVerified)
	}
	if m._IDRemStatus != nil {
		fields = append(fields, employees.FieldIDRemStatus)
	}
	if m._IDRemarks != nil {
		fields = append(fields, employees.FieldIDRemarks)
	}
	if m._EmployeeName != nil {
		fields = append(fields, employees.FieldEmployeeName)
	}
	if m.nameVerified != nil {
		fields = append(fields, employees.FieldNameVerified)
	}
	if m.nameRemStatus != nil {
		fields = append(fields, employees.FieldNameRemStatus)
	}
	if m.nameRemarks != nil {
		fields = append(fields, employees.FieldNameRemarks)
	}
	if m._EmployeeFathersName != nil {
		fields = append(fields, employees.FieldEmployeeFathersName)
	}
	if m._FathersNameVerified != nil {
		fields = append(fields, employees.FieldFathersNameVerified)
	}
	if m._FathersNameRemStatus != nil {
		fields = append(fields, employees.FieldFathersNameRemStatus)
	}
	if m._FathersNameRemarks != nil {
		fields = append(fields, employees.FieldFathersNameRemarks)
	}
	if m._DOB != nil {
		fields = append(fields, employees.FieldDOB)
	}
	if m._DOBVerified != nil {
		fields = append(fields, employees.FieldDOBVerified)
	}
	if m._DOBRemStatus != nil {
		fields = append(fields, employees.FieldDOBRemStatus)
	}
	if m._DOBRemarks != nil {
		fields = append(fields, employees.FieldDOBRemarks)
	}
	if m._Gender != nil {
		fields = append(fields, employees.FieldGender)
	}
	if m.genderVerified != nil {
		fields = append(fields, employees.FieldGenderVerified)
	}
	if m.genderRemStatus != nil {
		fields = append(fields, employees.FieldGenderRemStatus)
	}
	if m.genderRemarks != nil {
		fields = append(fields, employees.FieldGenderRemarks)
	}
	if m._MobileNumber != nil {
		fields = append(fields, employees.FieldMobileNumber)
	}
	if m._MobileNumberVerified != nil {
		fields = append(fields, employees.FieldMobileNumberVerified)
	}
	if m._MobileNumberRemStatus != nil {
		fields = append(fields, employees.FieldMobileNumberRemStatus)
	}
	if m._MobileNumberRemarks != nil {
		fields = append(fields, employees.FieldMobileNumberRemarks)
	}
	if m._EmailID != nil {
		fields = append(fields, employees.FieldEmailID)
	}
	if m._EmailIDVerified != nil {
		fields = append(fields, employees.FieldEmailIDVerified)
	}
	if m._EmailIDRemStatus != nil {
		fields = append(fields, employees.FieldEmailIDRemStatus)
	}
	if m._EmailIDRemarks != nil {
		fields = append(fields, employees.FieldEmailIDRemarks)
	}
	if m._Categoryid != nil {
		fields = append(fields, employees.FieldCategoryid)
	}
	if m._EmployeeCategoryCode != nil {
		fields = append(fields, employees.FieldEmployeeCategoryCode)
	}
	if m._EmployeeCategory != nil {
		fields = append(fields, employees.FieldEmployeeCategory)
	}
	if m._EmployeeCategoryCodeVerified != nil {
		fields = append(fields, employees.FieldEmployeeCategoryCodeVerified)
	}
	if m._EmployeeCategoryCodeRemStatus != nil {
		fields = append(fields, employees.FieldEmployeeCategoryCodeRemStatus)
	}
	if m._EmployeeCategoryCodeRemarks != nil {
		fields = append(fields, employees.FieldEmployeeCategoryCodeRemarks)
	}
	if m._WithDisability != nil {
		fields = append(fields, employees.FieldWithDisability)
	}
	if m._WithDisabilityVerified != nil {
		fields = append(fields, employees.FieldWithDisabilityVerified)
	}
	if m._WithDisabilityRemStatus != nil {
		fields = append(fields, employees.FieldWithDisabilityRemStatus)
	}
	if m._WithDisabilityRemarks != nil {
		fields = append(fields, employees.FieldWithDisabilityRemarks)
	}
	if m._DisabilityType != nil {
		fields = append(fields, employees.FieldDisabilityType)
	}
	if m._DisabilityTypeVerified != nil {
		fields = append(fields, employees.FieldDisabilityTypeVerified)
	}
	if m._DisabilityTypeRemStatus != nil {
		fields = append(fields, employees.FieldDisabilityTypeRemStatus)
	}
	if m._DisabilityTypeRemarks != nil {
		fields = append(fields, employees.FieldDisabilityTypeRemarks)
	}
	if m._DisabilityPercentage != nil {
		fields = append(fields, employees.FieldDisabilityPercentage)
	}
	if m._DisabilityPercentageVerified != nil {
		fields = append(fields, employees.FieldDisabilityPercentageVerified)
	}
	if m._DisabilityPercentageRemStatus != nil {
		fields = append(fields, employees.FieldDisabilityPercentageRemStatus)
	}
	if m._DisabilityPercentageRemarks != nil {
		fields = append(fields, employees.FieldDisabilityPercentageRemarks)
	}
	if m._Signature != nil {
		fields = append(fields, employees.FieldSignature)
	}
	if m._SignatureVerified != nil {
		fields = append(fields, employees.FieldSignatureVerified)
	}
	if m._SignatureRemStatus != nil {
		fields = append(fields, employees.FieldSignatureRemStatus)
	}
	if m._SignatureRemarks != nil {
		fields = append(fields, employees.FieldSignatureRemarks)
	}
	if m._Photo != nil {
		fields = append(fields, employees.FieldPhoto)
	}
	if m._PhotoVerified != nil {
		fields = append(fields, employees.FieldPhotoVerified)
	}
	if m._PhotoRemStatus != nil {
		fields = append(fields, employees.FieldPhotoRemStatus)
	}
	if m._PhotoRemarks != nil {
		fields = append(fields, employees.FieldPhotoRemarks)
	}
	if m._PostID != nil {
		fields = append(fields, employees.FieldPostID)
	}
	if m._PostCode != nil {
		fields = append(fields, employees.FieldPostCode)
	}
	if m._EmployeePost != nil {
		fields = append(fields, employees.FieldEmployeePost)
	}
	if m._EmployeePostVerified != nil {
		fields = append(fields, employees.FieldEmployeePostVerified)
	}
	if m._EmployeePostRemStatus != nil {
		fields = append(fields, employees.FieldEmployeePostRemStatus)
	}
	if m._EmployeePostRemarks != nil {
		fields = append(fields, employees.FieldEmployeePostRemarks)
	}
	if m._DesignationID != nil {
		fields = append(fields, employees.FieldDesignationID)
	}
	if m._EmployeeDesignation != nil {
		fields = append(fields, employees.FieldEmployeeDesignation)
	}
	if m._EmployeeDesignationVerified != nil {
		fields = append(fields, employees.FieldEmployeeDesignationVerified)
	}
	if m._EmployeeDesignationRemStatus != nil {
		fields = append(fields, employees.FieldEmployeeDesignationRemStatus)
	}
	if m._EmployeeDesignationRemarks != nil {
		fields = append(fields, employees.FieldEmployeeDesignationRemarks)
	}
	if m._CircleID != nil {
		fields = append(fields, employees.FieldCircleID)
	}
	if m._CircleName != nil {
		fields = append(fields, employees.FieldCircleName)
	}
	if m._CircleVerified != nil {
		fields = append(fields, employees.FieldCircleVerified)
	}
	if m._CircleRemStatus != nil {
		fields = append(fields, employees.FieldCircleRemStatus)
	}
	if m._CircleRemarks != nil {
		fields = append(fields, employees.FieldCircleRemarks)
	}
	if m._RegionID != nil {
		fields = append(fields, employees.FieldRegionID)
	}
	if m._RegionName != nil {
		fields = append(fields, employees.FieldRegionName)
	}
	if m._RegionVerified != nil {
		fields = append(fields, employees.FieldRegionVerified)
	}
	if m._RegionRemStatus != nil {
		fields = append(fields, employees.FieldRegionRemStatus)
	}
	if m._RegionRemarks != nil {
		fields = append(fields, employees.FieldRegionRemarks)
	}
	if m._DivisionID != nil {
		fields = append(fields, employees.FieldDivisionID)
	}
	if m._DivisionName != nil {
		fields = append(fields, employees.FieldDivisionName)
	}
	if m._DivisionVerified != nil {
		fields = append(fields, employees.FieldDivisionVerified)
	}
	if m._DivisionRemStatus != nil {
		fields = append(fields, employees.FieldDivisionRemStatus)
	}
	if m._DivisionRemarks != nil {
		fields = append(fields, employees.FieldDivisionRemarks)
	}
	if m._OfficeID != nil {
		fields = append(fields, employees.FieldOfficeID)
	}
	if m._OfficeName != nil {
		fields = append(fields, employees.FieldOfficeName)
	}
	if m._OfficeVerified != nil {
		fields = append(fields, employees.FieldOfficeVerified)
	}
	if m._OfficeRemStatus != nil {
		fields = append(fields, employees.FieldOfficeRemStatus)
	}
	if m._OfficeRemarks != nil {
		fields = append(fields, employees.FieldOfficeRemarks)
	}
	if m._Role != nil {
		fields = append(fields, employees.FieldRole)
	}
	if m._RoleVerified != nil {
		fields = append(fields, employees.FieldRoleVerified)
	}
	if m._RoleRemStatus != nil {
		fields = append(fields, employees.FieldRoleRemStatus)
	}
	if m._RoleRemarks != nil {
		fields = append(fields, employees.FieldRoleRemarks)
	}
	if m._DCCS != nil {
		fields = append(fields, employees.FieldDCCS)
	}
	if m._DCCSVerified != nil {
		fields = append(fields, employees.FieldDCCSVerified)
	}
	if m._DCCSRemStatus != nil {
		fields = append(fields, employees.FieldDCCSRemStatus)
	}
	if m._DCCSRemarks != nil {
		fields = append(fields, employees.FieldDCCSRemarks)
	}
	if m._DCInPresentCadre != nil {
		fields = append(fields, employees.FieldDCInPresentCadre)
	}
	if m._DCInPresentCadreVerified != nil {
		fields = append(fields, employees.FieldDCInPresentCadreVerified)
	}
	if m._DCInPresentCadreRemStatus != nil {
		fields = append(fields, employees.FieldDCInPresentCadreRemStatus)
	}
	if m._DCInPresentCadreRemarks != nil {
		fields = append(fields, employees.FieldDCInPresentCadreRemarks)
	}
	if m._APSWorking != nil {
		fields = append(fields, employees.FieldAPSWorking)
	}
	if m._APSWorkingVerified != nil {
		fields = append(fields, employees.FieldAPSWorkingVerified)
	}
	if m._APSWorkingRemStatus != nil {
		fields = append(fields, employees.FieldAPSWorkingRemStatus)
	}
	if m._APSWorkingRemarks != nil {
		fields = append(fields, employees.FieldAPSWorkingRemarks)
	}
	if m.profilestatus != nil {
		fields = append(fields, employees.FieldProfilestatus)
	}
	if m._RoleUserCode != nil {
		fields = append(fields, employees.FieldRoleUserCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employees.FieldEmployeedID:
		return m.EmployeedID()
	case employees.FieldIDVerified:
		return m.IDVerified()
	case employees.FieldIDRemStatus:
		return m.IDRemStatus()
	case employees.FieldIDRemarks:
		return m.IDRemarks()
	case employees.FieldEmployeeName:
		return m.EmployeeName()
	case employees.FieldNameVerified:
		return m.NameVerified()
	case employees.FieldNameRemStatus:
		return m.NameRemStatus()
	case employees.FieldNameRemarks:
		return m.NameRemarks()
	case employees.FieldEmployeeFathersName:
		return m.EmployeeFathersName()
	case employees.FieldFathersNameVerified:
		return m.FathersNameVerified()
	case employees.FieldFathersNameRemStatus:
		return m.FathersNameRemStatus()
	case employees.FieldFathersNameRemarks:
		return m.FathersNameRemarks()
	case employees.FieldDOB:
		return m.DOB()
	case employees.FieldDOBVerified:
		return m.DOBVerified()
	case employees.FieldDOBRemStatus:
		return m.DOBRemStatus()
	case employees.FieldDOBRemarks:
		return m.DOBRemarks()
	case employees.FieldGender:
		return m.Gender()
	case employees.FieldGenderVerified:
		return m.GenderVerified()
	case employees.FieldGenderRemStatus:
		return m.GenderRemStatus()
	case employees.FieldGenderRemarks:
		return m.GenderRemarks()
	case employees.FieldMobileNumber:
		return m.MobileNumber()
	case employees.FieldMobileNumberVerified:
		return m.MobileNumberVerified()
	case employees.FieldMobileNumberRemStatus:
		return m.MobileNumberRemStatus()
	case employees.FieldMobileNumberRemarks:
		return m.MobileNumberRemarks()
	case employees.FieldEmailID:
		return m.EmailID()
	case employees.FieldEmailIDVerified:
		return m.EmailIDVerified()
	case employees.FieldEmailIDRemStatus:
		return m.EmailIDRemStatus()
	case employees.FieldEmailIDRemarks:
		return m.EmailIDRemarks()
	case employees.FieldCategoryid:
		return m.Categoryid()
	case employees.FieldEmployeeCategoryCode:
		return m.EmployeeCategoryCode()
	case employees.FieldEmployeeCategory:
		return m.EmployeeCategory()
	case employees.FieldEmployeeCategoryCodeVerified:
		return m.EmployeeCategoryCodeVerified()
	case employees.FieldEmployeeCategoryCodeRemStatus:
		return m.EmployeeCategoryCodeRemStatus()
	case employees.FieldEmployeeCategoryCodeRemarks:
		return m.EmployeeCategoryCodeRemarks()
	case employees.FieldWithDisability:
		return m.WithDisability()
	case employees.FieldWithDisabilityVerified:
		return m.WithDisabilityVerified()
	case employees.FieldWithDisabilityRemStatus:
		return m.WithDisabilityRemStatus()
	case employees.FieldWithDisabilityRemarks:
		return m.WithDisabilityRemarks()
	case employees.FieldDisabilityType:
		return m.DisabilityType()
	case employees.FieldDisabilityTypeVerified:
		return m.DisabilityTypeVerified()
	case employees.FieldDisabilityTypeRemStatus:
		return m.DisabilityTypeRemStatus()
	case employees.FieldDisabilityTypeRemarks:
		return m.DisabilityTypeRemarks()
	case employees.FieldDisabilityPercentage:
		return m.DisabilityPercentage()
	case employees.FieldDisabilityPercentageVerified:
		return m.DisabilityPercentageVerified()
	case employees.FieldDisabilityPercentageRemStatus:
		return m.DisabilityPercentageRemStatus()
	case employees.FieldDisabilityPercentageRemarks:
		return m.DisabilityPercentageRemarks()
	case employees.FieldSignature:
		return m.Signature()
	case employees.FieldSignatureVerified:
		return m.SignatureVerified()
	case employees.FieldSignatureRemStatus:
		return m.SignatureRemStatus()
	case employees.FieldSignatureRemarks:
		return m.SignatureRemarks()
	case employees.FieldPhoto:
		return m.Photo()
	case employees.FieldPhotoVerified:
		return m.PhotoVerified()
	case employees.FieldPhotoRemStatus:
		return m.PhotoRemStatus()
	case employees.FieldPhotoRemarks:
		return m.PhotoRemarks()
	case employees.FieldPostID:
		return m.PostID()
	case employees.FieldPostCode:
		return m.PostCode()
	case employees.FieldEmployeePost:
		return m.EmployeePost()
	case employees.FieldEmployeePostVerified:
		return m.EmployeePostVerified()
	case employees.FieldEmployeePostRemStatus:
		return m.EmployeePostRemStatus()
	case employees.FieldEmployeePostRemarks:
		return m.EmployeePostRemarks()
	case employees.FieldDesignationID:
		return m.DesignationID()
	case employees.FieldEmployeeDesignation:
		return m.EmployeeDesignation()
	case employees.FieldEmployeeDesignationVerified:
		return m.EmployeeDesignationVerified()
	case employees.FieldEmployeeDesignationRemStatus:
		return m.EmployeeDesignationRemStatus()
	case employees.FieldEmployeeDesignationRemarks:
		return m.EmployeeDesignationRemarks()
	case employees.FieldCircleID:
		return m.CircleID()
	case employees.FieldCircleName:
		return m.CircleName()
	case employees.FieldCircleVerified:
		return m.CircleVerified()
	case employees.FieldCircleRemStatus:
		return m.CircleRemStatus()
	case employees.FieldCircleRemarks:
		return m.CircleRemarks()
	case employees.FieldRegionID:
		return m.RegionID()
	case employees.FieldRegionName:
		return m.RegionName()
	case employees.FieldRegionVerified:
		return m.RegionVerified()
	case employees.FieldRegionRemStatus:
		return m.RegionRemStatus()
	case employees.FieldRegionRemarks:
		return m.RegionRemarks()
	case employees.FieldDivisionID:
		return m.DivisionID()
	case employees.FieldDivisionName:
		return m.DivisionName()
	case employees.FieldDivisionVerified:
		return m.DivisionVerified()
	case employees.FieldDivisionRemStatus:
		return m.DivisionRemStatus()
	case employees.FieldDivisionRemarks:
		return m.DivisionRemarks()
	case employees.FieldOfficeID:
		return m.OfficeID()
	case employees.FieldOfficeName:
		return m.OfficeName()
	case employees.FieldOfficeVerified:
		return m.OfficeVerified()
	case employees.FieldOfficeRemStatus:
		return m.OfficeRemStatus()
	case employees.FieldOfficeRemarks:
		return m.OfficeRemarks()
	case employees.FieldRole:
		return m.Role()
	case employees.FieldRoleVerified:
		return m.RoleVerified()
	case employees.FieldRoleRemStatus:
		return m.RoleRemStatus()
	case employees.FieldRoleRemarks:
		return m.RoleRemarks()
	case employees.FieldDCCS:
		return m.DCCS()
	case employees.FieldDCCSVerified:
		return m.DCCSVerified()
	case employees.FieldDCCSRemStatus:
		return m.DCCSRemStatus()
	case employees.FieldDCCSRemarks:
		return m.DCCSRemarks()
	case employees.FieldDCInPresentCadre:
		return m.DCInPresentCadre()
	case employees.FieldDCInPresentCadreVerified:
		return m.DCInPresentCadreVerified()
	case employees.FieldDCInPresentCadreRemStatus:
		return m.DCInPresentCadreRemStatus()
	case employees.FieldDCInPresentCadreRemarks:
		return m.DCInPresentCadreRemarks()
	case employees.FieldAPSWorking:
		return m.APSWorking()
	case employees.FieldAPSWorkingVerified:
		return m.APSWorkingVerified()
	case employees.FieldAPSWorkingRemStatus:
		return m.APSWorkingRemStatus()
	case employees.FieldAPSWorkingRemarks:
		return m.APSWorkingRemarks()
	case employees.FieldProfilestatus:
		return m.Profilestatus()
	case employees.FieldRoleUserCode:
		return m.RoleUserCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employees.FieldEmployeedID:
		return m.OldEmployeedID(ctx)
	case employees.FieldIDVerified:
		return m.OldIDVerified(ctx)
	case employees.FieldIDRemStatus:
		return m.OldIDRemStatus(ctx)
	case employees.FieldIDRemarks:
		return m.OldIDRemarks(ctx)
	case employees.FieldEmployeeName:
		return m.OldEmployeeName(ctx)
	case employees.FieldNameVerified:
		return m.OldNameVerified(ctx)
	case employees.FieldNameRemStatus:
		return m.OldNameRemStatus(ctx)
	case employees.FieldNameRemarks:
		return m.OldNameRemarks(ctx)
	case employees.FieldEmployeeFathersName:
		return m.OldEmployeeFathersName(ctx)
	case employees.FieldFathersNameVerified:
		return m.OldFathersNameVerified(ctx)
	case employees.FieldFathersNameRemStatus:
		return m.OldFathersNameRemStatus(ctx)
	case employees.FieldFathersNameRemarks:
		return m.OldFathersNameRemarks(ctx)
	case employees.FieldDOB:
		return m.OldDOB(ctx)
	case employees.FieldDOBVerified:
		return m.OldDOBVerified(ctx)
	case employees.FieldDOBRemStatus:
		return m.OldDOBRemStatus(ctx)
	case employees.FieldDOBRemarks:
		return m.OldDOBRemarks(ctx)
	case employees.FieldGender:
		return m.OldGender(ctx)
	case employees.FieldGenderVerified:
		return m.OldGenderVerified(ctx)
	case employees.FieldGenderRemStatus:
		return m.OldGenderRemStatus(ctx)
	case employees.FieldGenderRemarks:
		return m.OldGenderRemarks(ctx)
	case employees.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case employees.FieldMobileNumberVerified:
		return m.OldMobileNumberVerified(ctx)
	case employees.FieldMobileNumberRemStatus:
		return m.OldMobileNumberRemStatus(ctx)
	case employees.FieldMobileNumberRemarks:
		return m.OldMobileNumberRemarks(ctx)
	case employees.FieldEmailID:
		return m.OldEmailID(ctx)
	case employees.FieldEmailIDVerified:
		return m.OldEmailIDVerified(ctx)
	case employees.FieldEmailIDRemStatus:
		return m.OldEmailIDRemStatus(ctx)
	case employees.FieldEmailIDRemarks:
		return m.OldEmailIDRemarks(ctx)
	case employees.FieldCategoryid:
		return m.OldCategoryid(ctx)
	case employees.FieldEmployeeCategoryCode:
		return m.OldEmployeeCategoryCode(ctx)
	case employees.FieldEmployeeCategory:
		return m.OldEmployeeCategory(ctx)
	case employees.FieldEmployeeCategoryCodeVerified:
		return m.OldEmployeeCategoryCodeVerified(ctx)
	case employees.FieldEmployeeCategoryCodeRemStatus:
		return m.OldEmployeeCategoryCodeRemStatus(ctx)
	case employees.FieldEmployeeCategoryCodeRemarks:
		return m.OldEmployeeCategoryCodeRemarks(ctx)
	case employees.FieldWithDisability:
		return m.OldWithDisability(ctx)
	case employees.FieldWithDisabilityVerified:
		return m.OldWithDisabilityVerified(ctx)
	case employees.FieldWithDisabilityRemStatus:
		return m.OldWithDisabilityRemStatus(ctx)
	case employees.FieldWithDisabilityRemarks:
		return m.OldWithDisabilityRemarks(ctx)
	case employees.FieldDisabilityType:
		return m.OldDisabilityType(ctx)
	case employees.FieldDisabilityTypeVerified:
		return m.OldDisabilityTypeVerified(ctx)
	case employees.FieldDisabilityTypeRemStatus:
		return m.OldDisabilityTypeRemStatus(ctx)
	case employees.FieldDisabilityTypeRemarks:
		return m.OldDisabilityTypeRemarks(ctx)
	case employees.FieldDisabilityPercentage:
		return m.OldDisabilityPercentage(ctx)
	case employees.FieldDisabilityPercentageVerified:
		return m.OldDisabilityPercentageVerified(ctx)
	case employees.FieldDisabilityPercentageRemStatus:
		return m.OldDisabilityPercentageRemStatus(ctx)
	case employees.FieldDisabilityPercentageRemarks:
		return m.OldDisabilityPercentageRemarks(ctx)
	case employees.FieldSignature:
		return m.OldSignature(ctx)
	case employees.FieldSignatureVerified:
		return m.OldSignatureVerified(ctx)
	case employees.FieldSignatureRemStatus:
		return m.OldSignatureRemStatus(ctx)
	case employees.FieldSignatureRemarks:
		return m.OldSignatureRemarks(ctx)
	case employees.FieldPhoto:
		return m.OldPhoto(ctx)
	case employees.FieldPhotoVerified:
		return m.OldPhotoVerified(ctx)
	case employees.FieldPhotoRemStatus:
		return m.OldPhotoRemStatus(ctx)
	case employees.FieldPhotoRemarks:
		return m.OldPhotoRemarks(ctx)
	case employees.FieldPostID:
		return m.OldPostID(ctx)
	case employees.FieldPostCode:
		return m.OldPostCode(ctx)
	case employees.FieldEmployeePost:
		return m.OldEmployeePost(ctx)
	case employees.FieldEmployeePostVerified:
		return m.OldEmployeePostVerified(ctx)
	case employees.FieldEmployeePostRemStatus:
		return m.OldEmployeePostRemStatus(ctx)
	case employees.FieldEmployeePostRemarks:
		return m.OldEmployeePostRemarks(ctx)
	case employees.FieldDesignationID:
		return m.OldDesignationID(ctx)
	case employees.FieldEmployeeDesignation:
		return m.OldEmployeeDesignation(ctx)
	case employees.FieldEmployeeDesignationVerified:
		return m.OldEmployeeDesignationVerified(ctx)
	case employees.FieldEmployeeDesignationRemStatus:
		return m.OldEmployeeDesignationRemStatus(ctx)
	case employees.FieldEmployeeDesignationRemarks:
		return m.OldEmployeeDesignationRemarks(ctx)
	case employees.FieldCircleID:
		return m.OldCircleID(ctx)
	case employees.FieldCircleName:
		return m.OldCircleName(ctx)
	case employees.FieldCircleVerified:
		return m.OldCircleVerified(ctx)
	case employees.FieldCircleRemStatus:
		return m.OldCircleRemStatus(ctx)
	case employees.FieldCircleRemarks:
		return m.OldCircleRemarks(ctx)
	case employees.FieldRegionID:
		return m.OldRegionID(ctx)
	case employees.FieldRegionName:
		return m.OldRegionName(ctx)
	case employees.FieldRegionVerified:
		return m.OldRegionVerified(ctx)
	case employees.FieldRegionRemStatus:
		return m.OldRegionRemStatus(ctx)
	case employees.FieldRegionRemarks:
		return m.OldRegionRemarks(ctx)
	case employees.FieldDivisionID:
		return m.OldDivisionID(ctx)
	case employees.FieldDivisionName:
		return m.OldDivisionName(ctx)
	case employees.FieldDivisionVerified:
		return m.OldDivisionVerified(ctx)
	case employees.FieldDivisionRemStatus:
		return m.OldDivisionRemStatus(ctx)
	case employees.FieldDivisionRemarks:
		return m.OldDivisionRemarks(ctx)
	case employees.FieldOfficeID:
		return m.OldOfficeID(ctx)
	case employees.FieldOfficeName:
		return m.OldOfficeName(ctx)
	case employees.FieldOfficeVerified:
		return m.OldOfficeVerified(ctx)
	case employees.FieldOfficeRemStatus:
		return m.OldOfficeRemStatus(ctx)
	case employees.FieldOfficeRemarks:
		return m.OldOfficeRemarks(ctx)
	case employees.FieldRole:
		return m.OldRole(ctx)
	case employees.FieldRoleVerified:
		return m.OldRoleVerified(ctx)
	case employees.FieldRoleRemStatus:
		return m.OldRoleRemStatus(ctx)
	case employees.FieldRoleRemarks:
		return m.OldRoleRemarks(ctx)
	case employees.FieldDCCS:
		return m.OldDCCS(ctx)
	case employees.FieldDCCSVerified:
		return m.OldDCCSVerified(ctx)
	case employees.FieldDCCSRemStatus:
		return m.OldDCCSRemStatus(ctx)
	case employees.FieldDCCSRemarks:
		return m.OldDCCSRemarks(ctx)
	case employees.FieldDCInPresentCadre:
		return m.OldDCInPresentCadre(ctx)
	case employees.FieldDCInPresentCadreVerified:
		return m.OldDCInPresentCadreVerified(ctx)
	case employees.FieldDCInPresentCadreRemStatus:
		return m.OldDCInPresentCadreRemStatus(ctx)
	case employees.FieldDCInPresentCadreRemarks:
		return m.OldDCInPresentCadreRemarks(ctx)
	case employees.FieldAPSWorking:
		return m.OldAPSWorking(ctx)
	case employees.FieldAPSWorkingVerified:
		return m.OldAPSWorkingVerified(ctx)
	case employees.FieldAPSWorkingRemStatus:
		return m.OldAPSWorkingRemStatus(ctx)
	case employees.FieldAPSWorkingRemarks:
		return m.OldAPSWorkingRemarks(ctx)
	case employees.FieldProfilestatus:
		return m.OldProfilestatus(ctx)
	case employees.FieldRoleUserCode:
		return m.OldRoleUserCode(ctx)
	}
	return nil, fmt.Errorf("unknown Employees field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employees.FieldEmployeedID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeedID(v)
		return nil
	case employees.FieldIDVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDVerified(v)
		return nil
	case employees.FieldIDRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDRemStatus(v)
		return nil
	case employees.FieldIDRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDRemarks(v)
		return nil
	case employees.FieldEmployeeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeName(v)
		return nil
	case employees.FieldNameVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameVerified(v)
		return nil
	case employees.FieldNameRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameRemStatus(v)
		return nil
	case employees.FieldNameRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameRemarks(v)
		return nil
	case employees.FieldEmployeeFathersName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeFathersName(v)
		return nil
	case employees.FieldFathersNameVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFathersNameVerified(v)
		return nil
	case employees.FieldFathersNameRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFathersNameRemStatus(v)
		return nil
	case employees.FieldFathersNameRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFathersNameRemarks(v)
		return nil
	case employees.FieldDOB:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOB(v)
		return nil
	case employees.FieldDOBVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOBVerified(v)
		return nil
	case employees.FieldDOBRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOBRemStatus(v)
		return nil
	case employees.FieldDOBRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOBRemarks(v)
		return nil
	case employees.FieldGender:
		v, ok := value.(employees.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case employees.FieldGenderVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderVerified(v)
		return nil
	case employees.FieldGenderRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderRemStatus(v)
		return nil
	case employees.FieldGenderRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderRemarks(v)
		return nil
	case employees.FieldMobileNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case employees.FieldMobileNumberVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumberVerified(v)
		return nil
	case employees.FieldMobileNumberRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumberRemStatus(v)
		return nil
	case employees.FieldMobileNumberRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumberRemarks(v)
		return nil
	case employees.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case employees.FieldEmailIDVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailIDVerified(v)
		return nil
	case employees.FieldEmailIDRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailIDRemStatus(v)
		return nil
	case employees.FieldEmailIDRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailIDRemarks(v)
		return nil
	case employees.FieldCategoryid:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryid(v)
		return nil
	case employees.FieldEmployeeCategoryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCategoryCode(v)
		return nil
	case employees.FieldEmployeeCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCategory(v)
		return nil
	case employees.FieldEmployeeCategoryCodeVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCategoryCodeVerified(v)
		return nil
	case employees.FieldEmployeeCategoryCodeRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCategoryCodeRemStatus(v)
		return nil
	case employees.FieldEmployeeCategoryCodeRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCategoryCodeRemarks(v)
		return nil
	case employees.FieldWithDisability:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithDisability(v)
		return nil
	case employees.FieldWithDisabilityVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithDisabilityVerified(v)
		return nil
	case employees.FieldWithDisabilityRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithDisabilityRemStatus(v)
		return nil
	case employees.FieldWithDisabilityRemarks:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithDisabilityRemarks(v)
		return nil
	case employees.FieldDisabilityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityType(v)
		return nil
	case employees.FieldDisabilityTypeVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityTypeVerified(v)
		return nil
	case employees.FieldDisabilityTypeRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityTypeRemStatus(v)
		return nil
	case employees.FieldDisabilityTypeRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityTypeRemarks(v)
		return nil
	case employees.FieldDisabilityPercentage:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityPercentage(v)
		return nil
	case employees.FieldDisabilityPercentageVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityPercentageVerified(v)
		return nil
	case employees.FieldDisabilityPercentageRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityPercentageRemStatus(v)
		return nil
	case employees.FieldDisabilityPercentageRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityPercentageRemarks(v)
		return nil
	case employees.FieldSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case employees.FieldSignatureVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignatureVerified(v)
		return nil
	case employees.FieldSignatureRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignatureRemStatus(v)
		return nil
	case employees.FieldSignatureRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignatureRemarks(v)
		return nil
	case employees.FieldPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoto(v)
		return nil
	case employees.FieldPhotoVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoVerified(v)
		return nil
	case employees.FieldPhotoRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoRemStatus(v)
		return nil
	case employees.FieldPhotoRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoRemarks(v)
		return nil
	case employees.FieldPostID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case employees.FieldPostCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostCode(v)
		return nil
	case employees.FieldEmployeePost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeePost(v)
		return nil
	case employees.FieldEmployeePostVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeePostVerified(v)
		return nil
	case employees.FieldEmployeePostRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeePostRemStatus(v)
		return nil
	case employees.FieldEmployeePostRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeePostRemarks(v)
		return nil
	case employees.FieldDesignationID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesignationID(v)
		return nil
	case employees.FieldEmployeeDesignation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeDesignation(v)
		return nil
	case employees.FieldEmployeeDesignationVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeDesignationVerified(v)
		return nil
	case employees.FieldEmployeeDesignationRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeDesignationRemStatus(v)
		return nil
	case employees.FieldEmployeeDesignationRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeDesignationRemarks(v)
		return nil
	case employees.FieldCircleID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleID(v)
		return nil
	case employees.FieldCircleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleName(v)
		return nil
	case employees.FieldCircleVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleVerified(v)
		return nil
	case employees.FieldCircleRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleRemStatus(v)
		return nil
	case employees.FieldCircleRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleRemarks(v)
		return nil
	case employees.FieldRegionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionID(v)
		return nil
	case employees.FieldRegionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionName(v)
		return nil
	case employees.FieldRegionVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionVerified(v)
		return nil
	case employees.FieldRegionRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionRemStatus(v)
		return nil
	case employees.FieldRegionRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionRemarks(v)
		return nil
	case employees.FieldDivisionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionID(v)
		return nil
	case employees.FieldDivisionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionName(v)
		return nil
	case employees.FieldDivisionVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionVerified(v)
		return nil
	case employees.FieldDivisionRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionRemStatus(v)
		return nil
	case employees.FieldDivisionRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionRemarks(v)
		return nil
	case employees.FieldOfficeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeID(v)
		return nil
	case employees.FieldOfficeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeName(v)
		return nil
	case employees.FieldOfficeVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeVerified(v)
		return nil
	case employees.FieldOfficeRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeRemStatus(v)
		return nil
	case employees.FieldOfficeRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeRemarks(v)
		return nil
	case employees.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case employees.FieldRoleVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleVerified(v)
		return nil
	case employees.FieldRoleRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleRemStatus(v)
		return nil
	case employees.FieldRoleRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleRemarks(v)
		return nil
	case employees.FieldDCCS:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCCS(v)
		return nil
	case employees.FieldDCCSVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCCSVerified(v)
		return nil
	case employees.FieldDCCSRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCCSRemStatus(v)
		return nil
	case employees.FieldDCCSRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCCSRemarks(v)
		return nil
	case employees.FieldDCInPresentCadre:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCInPresentCadre(v)
		return nil
	case employees.FieldDCInPresentCadreVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCInPresentCadreVerified(v)
		return nil
	case employees.FieldDCInPresentCadreRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCInPresentCadreRemStatus(v)
		return nil
	case employees.FieldDCInPresentCadreRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCInPresentCadreRemarks(v)
		return nil
	case employees.FieldAPSWorking:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorking(v)
		return nil
	case employees.FieldAPSWorkingVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorkingVerified(v)
		return nil
	case employees.FieldAPSWorkingRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorkingRemStatus(v)
		return nil
	case employees.FieldAPSWorkingRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorkingRemarks(v)
		return nil
	case employees.FieldProfilestatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilestatus(v)
		return nil
	case employees.FieldRoleUserCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleUserCode(v)
		return nil
	}
	return fmt.Errorf("unknown Employees field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeesMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeedID != nil {
		fields = append(fields, employees.FieldEmployeedID)
	}
	if m.add_MobileNumber != nil {
		fields = append(fields, employees.FieldMobileNumber)
	}
	if m.add_Categoryid != nil {
		fields = append(fields, employees.FieldCategoryid)
	}
	if m.add_DisabilityPercentage != nil {
		fields = append(fields, employees.FieldDisabilityPercentage)
	}
	if m.add_PostID != nil {
		fields = append(fields, employees.FieldPostID)
	}
	if m.add_DesignationID != nil {
		fields = append(fields, employees.FieldDesignationID)
	}
	if m.add_CircleID != nil {
		fields = append(fields, employees.FieldCircleID)
	}
	if m.add_RegionID != nil {
		fields = append(fields, employees.FieldRegionID)
	}
	if m.add_DivisionID != nil {
		fields = append(fields, employees.FieldDivisionID)
	}
	if m.add_OfficeID != nil {
		fields = append(fields, employees.FieldOfficeID)
	}
	if m.add_RoleUserCode != nil {
		fields = append(fields, employees.FieldRoleUserCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case employees.FieldEmployeedID:
		return m.AddedEmployeedID()
	case employees.FieldMobileNumber:
		return m.AddedMobileNumber()
	case employees.FieldCategoryid:
		return m.AddedCategoryid()
	case employees.FieldDisabilityPercentage:
		return m.AddedDisabilityPercentage()
	case employees.FieldPostID:
		return m.AddedPostID()
	case employees.FieldDesignationID:
		return m.AddedDesignationID()
	case employees.FieldCircleID:
		return m.AddedCircleID()
	case employees.FieldRegionID:
		return m.AddedRegionID()
	case employees.FieldDivisionID:
		return m.AddedDivisionID()
	case employees.FieldOfficeID:
		return m.AddedOfficeID()
	case employees.FieldRoleUserCode:
		return m.AddedRoleUserCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case employees.FieldEmployeedID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeedID(v)
		return nil
	case employees.FieldMobileNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMobileNumber(v)
		return nil
	case employees.FieldCategoryid:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryid(v)
		return nil
	case employees.FieldDisabilityPercentage:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisabilityPercentage(v)
		return nil
	case employees.FieldPostID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostID(v)
		return nil
	case employees.FieldDesignationID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDesignationID(v)
		return nil
	case employees.FieldCircleID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCircleID(v)
		return nil
	case employees.FieldRegionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegionID(v)
		return nil
	case employees.FieldDivisionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDivisionID(v)
		return nil
	case employees.FieldOfficeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOfficeID(v)
		return nil
	case employees.FieldRoleUserCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleUserCode(v)
		return nil
	}
	return fmt.Errorf("unknown Employees numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employees.FieldIDRemarks) {
		fields = append(fields, employees.FieldIDRemarks)
	}
	if m.FieldCleared(employees.FieldNameRemarks) {
		fields = append(fields, employees.FieldNameRemarks)
	}
	if m.FieldCleared(employees.FieldFathersNameRemarks) {
		fields = append(fields, employees.FieldFathersNameRemarks)
	}
	if m.FieldCleared(employees.FieldDOBRemarks) {
		fields = append(fields, employees.FieldDOBRemarks)
	}
	if m.FieldCleared(employees.FieldGenderRemarks) {
		fields = append(fields, employees.FieldGenderRemarks)
	}
	if m.FieldCleared(employees.FieldMobileNumber) {
		fields = append(fields, employees.FieldMobileNumber)
	}
	if m.FieldCleared(employees.FieldMobileNumberRemarks) {
		fields = append(fields, employees.FieldMobileNumberRemarks)
	}
	if m.FieldCleared(employees.FieldEmailID) {
		fields = append(fields, employees.FieldEmailID)
	}
	if m.FieldCleared(employees.FieldEmailIDRemarks) {
		fields = append(fields, employees.FieldEmailIDRemarks)
	}
	if m.FieldCleared(employees.FieldCategoryid) {
		fields = append(fields, employees.FieldCategoryid)
	}
	if m.FieldCleared(employees.FieldEmployeeCategoryCode) {
		fields = append(fields, employees.FieldEmployeeCategoryCode)
	}
	if m.FieldCleared(employees.FieldEmployeeCategoryCodeRemarks) {
		fields = append(fields, employees.FieldEmployeeCategoryCodeRemarks)
	}
	if m.FieldCleared(employees.FieldWithDisabilityRemarks) {
		fields = append(fields, employees.FieldWithDisabilityRemarks)
	}
	if m.FieldCleared(employees.FieldDisabilityType) {
		fields = append(fields, employees.FieldDisabilityType)
	}
	if m.FieldCleared(employees.FieldDisabilityTypeRemarks) {
		fields = append(fields, employees.FieldDisabilityTypeRemarks)
	}
	if m.FieldCleared(employees.FieldDisabilityPercentage) {
		fields = append(fields, employees.FieldDisabilityPercentage)
	}
	if m.FieldCleared(employees.FieldDisabilityPercentageRemarks) {
		fields = append(fields, employees.FieldDisabilityPercentageRemarks)
	}
	if m.FieldCleared(employees.FieldSignatureRemarks) {
		fields = append(fields, employees.FieldSignatureRemarks)
	}
	if m.FieldCleared(employees.FieldPhotoRemarks) {
		fields = append(fields, employees.FieldPhotoRemarks)
	}
	if m.FieldCleared(employees.FieldPostID) {
		fields = append(fields, employees.FieldPostID)
	}
	if m.FieldCleared(employees.FieldPostCode) {
		fields = append(fields, employees.FieldPostCode)
	}
	if m.FieldCleared(employees.FieldEmployeePostRemarks) {
		fields = append(fields, employees.FieldEmployeePostRemarks)
	}
	if m.FieldCleared(employees.FieldDesignationID) {
		fields = append(fields, employees.FieldDesignationID)
	}
	if m.FieldCleared(employees.FieldEmployeeDesignationRemarks) {
		fields = append(fields, employees.FieldEmployeeDesignationRemarks)
	}
	if m.FieldCleared(employees.FieldCircleID) {
		fields = append(fields, employees.FieldCircleID)
	}
	if m.FieldCleared(employees.FieldCircleRemarks) {
		fields = append(fields, employees.FieldCircleRemarks)
	}
	if m.FieldCleared(employees.FieldRegionID) {
		fields = append(fields, employees.FieldRegionID)
	}
	if m.FieldCleared(employees.FieldRegionName) {
		fields = append(fields, employees.FieldRegionName)
	}
	if m.FieldCleared(employees.FieldRegionRemarks) {
		fields = append(fields, employees.FieldRegionRemarks)
	}
	if m.FieldCleared(employees.FieldDivisionID) {
		fields = append(fields, employees.FieldDivisionID)
	}
	if m.FieldCleared(employees.FieldDivisionName) {
		fields = append(fields, employees.FieldDivisionName)
	}
	if m.FieldCleared(employees.FieldOfficeID) {
		fields = append(fields, employees.FieldOfficeID)
	}
	if m.FieldCleared(employees.FieldOfficeRemarks) {
		fields = append(fields, employees.FieldOfficeRemarks)
	}
	if m.FieldCleared(employees.FieldDCCSRemarks) {
		fields = append(fields, employees.FieldDCCSRemarks)
	}
	if m.FieldCleared(employees.FieldDCInPresentCadreRemarks) {
		fields = append(fields, employees.FieldDCInPresentCadreRemarks)
	}
	if m.FieldCleared(employees.FieldAPSWorking) {
		fields = append(fields, employees.FieldAPSWorking)
	}
	if m.FieldCleared(employees.FieldAPSWorkingRemarks) {
		fields = append(fields, employees.FieldAPSWorkingRemarks)
	}
	if m.FieldCleared(employees.FieldRoleUserCode) {
		fields = append(fields, employees.FieldRoleUserCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeesMutation) ClearField(name string) error {
	switch name {
	case employees.FieldIDRemarks:
		m.ClearIDRemarks()
		return nil
	case employees.FieldNameRemarks:
		m.ClearNameRemarks()
		return nil
	case employees.FieldFathersNameRemarks:
		m.ClearFathersNameRemarks()
		return nil
	case employees.FieldDOBRemarks:
		m.ClearDOBRemarks()
		return nil
	case employees.FieldGenderRemarks:
		m.ClearGenderRemarks()
		return nil
	case employees.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	case employees.FieldMobileNumberRemarks:
		m.ClearMobileNumberRemarks()
		return nil
	case employees.FieldEmailID:
		m.ClearEmailID()
		return nil
	case employees.FieldEmailIDRemarks:
		m.ClearEmailIDRemarks()
		return nil
	case employees.FieldCategoryid:
		m.ClearCategoryid()
		return nil
	case employees.FieldEmployeeCategoryCode:
		m.ClearEmployeeCategoryCode()
		return nil
	case employees.FieldEmployeeCategoryCodeRemarks:
		m.ClearEmployeeCategoryCodeRemarks()
		return nil
	case employees.FieldWithDisabilityRemarks:
		m.ClearWithDisabilityRemarks()
		return nil
	case employees.FieldDisabilityType:
		m.ClearDisabilityType()
		return nil
	case employees.FieldDisabilityTypeRemarks:
		m.ClearDisabilityTypeRemarks()
		return nil
	case employees.FieldDisabilityPercentage:
		m.ClearDisabilityPercentage()
		return nil
	case employees.FieldDisabilityPercentageRemarks:
		m.ClearDisabilityPercentageRemarks()
		return nil
	case employees.FieldSignatureRemarks:
		m.ClearSignatureRemarks()
		return nil
	case employees.FieldPhotoRemarks:
		m.ClearPhotoRemarks()
		return nil
	case employees.FieldPostID:
		m.ClearPostID()
		return nil
	case employees.FieldPostCode:
		m.ClearPostCode()
		return nil
	case employees.FieldEmployeePostRemarks:
		m.ClearEmployeePostRemarks()
		return nil
	case employees.FieldDesignationID:
		m.ClearDesignationID()
		return nil
	case employees.FieldEmployeeDesignationRemarks:
		m.ClearEmployeeDesignationRemarks()
		return nil
	case employees.FieldCircleID:
		m.ClearCircleID()
		return nil
	case employees.FieldCircleRemarks:
		m.ClearCircleRemarks()
		return nil
	case employees.FieldRegionID:
		m.ClearRegionID()
		return nil
	case employees.FieldRegionName:
		m.ClearRegionName()
		return nil
	case employees.FieldRegionRemarks:
		m.ClearRegionRemarks()
		return nil
	case employees.FieldDivisionID:
		m.ClearDivisionID()
		return nil
	case employees.FieldDivisionName:
		m.ClearDivisionName()
		return nil
	case employees.FieldOfficeID:
		m.ClearOfficeID()
		return nil
	case employees.FieldOfficeRemarks:
		m.ClearOfficeRemarks()
		return nil
	case employees.FieldDCCSRemarks:
		m.ClearDCCSRemarks()
		return nil
	case employees.FieldDCInPresentCadreRemarks:
		m.ClearDCInPresentCadreRemarks()
		return nil
	case employees.FieldAPSWorking:
		m.ClearAPSWorking()
		return nil
	case employees.FieldAPSWorkingRemarks:
		m.ClearAPSWorkingRemarks()
		return nil
	case employees.FieldRoleUserCode:
		m.ClearRoleUserCode()
		return nil
	}
	return fmt.Errorf("unknown Employees nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeesMutation) ResetField(name string) error {
	switch name {
	case employees.FieldEmployeedID:
		m.ResetEmployeedID()
		return nil
	case employees.FieldIDVerified:
		m.ResetIDVerified()
		return nil
	case employees.FieldIDRemStatus:
		m.ResetIDRemStatus()
		return nil
	case employees.FieldIDRemarks:
		m.ResetIDRemarks()
		return nil
	case employees.FieldEmployeeName:
		m.ResetEmployeeName()
		return nil
	case employees.FieldNameVerified:
		m.ResetNameVerified()
		return nil
	case employees.FieldNameRemStatus:
		m.ResetNameRemStatus()
		return nil
	case employees.FieldNameRemarks:
		m.ResetNameRemarks()
		return nil
	case employees.FieldEmployeeFathersName:
		m.ResetEmployeeFathersName()
		return nil
	case employees.FieldFathersNameVerified:
		m.ResetFathersNameVerified()
		return nil
	case employees.FieldFathersNameRemStatus:
		m.ResetFathersNameRemStatus()
		return nil
	case employees.FieldFathersNameRemarks:
		m.ResetFathersNameRemarks()
		return nil
	case employees.FieldDOB:
		m.ResetDOB()
		return nil
	case employees.FieldDOBVerified:
		m.ResetDOBVerified()
		return nil
	case employees.FieldDOBRemStatus:
		m.ResetDOBRemStatus()
		return nil
	case employees.FieldDOBRemarks:
		m.ResetDOBRemarks()
		return nil
	case employees.FieldGender:
		m.ResetGender()
		return nil
	case employees.FieldGenderVerified:
		m.ResetGenderVerified()
		return nil
	case employees.FieldGenderRemStatus:
		m.ResetGenderRemStatus()
		return nil
	case employees.FieldGenderRemarks:
		m.ResetGenderRemarks()
		return nil
	case employees.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case employees.FieldMobileNumberVerified:
		m.ResetMobileNumberVerified()
		return nil
	case employees.FieldMobileNumberRemStatus:
		m.ResetMobileNumberRemStatus()
		return nil
	case employees.FieldMobileNumberRemarks:
		m.ResetMobileNumberRemarks()
		return nil
	case employees.FieldEmailID:
		m.ResetEmailID()
		return nil
	case employees.FieldEmailIDVerified:
		m.ResetEmailIDVerified()
		return nil
	case employees.FieldEmailIDRemStatus:
		m.ResetEmailIDRemStatus()
		return nil
	case employees.FieldEmailIDRemarks:
		m.ResetEmailIDRemarks()
		return nil
	case employees.FieldCategoryid:
		m.ResetCategoryid()
		return nil
	case employees.FieldEmployeeCategoryCode:
		m.ResetEmployeeCategoryCode()
		return nil
	case employees.FieldEmployeeCategory:
		m.ResetEmployeeCategory()
		return nil
	case employees.FieldEmployeeCategoryCodeVerified:
		m.ResetEmployeeCategoryCodeVerified()
		return nil
	case employees.FieldEmployeeCategoryCodeRemStatus:
		m.ResetEmployeeCategoryCodeRemStatus()
		return nil
	case employees.FieldEmployeeCategoryCodeRemarks:
		m.ResetEmployeeCategoryCodeRemarks()
		return nil
	case employees.FieldWithDisability:
		m.ResetWithDisability()
		return nil
	case employees.FieldWithDisabilityVerified:
		m.ResetWithDisabilityVerified()
		return nil
	case employees.FieldWithDisabilityRemStatus:
		m.ResetWithDisabilityRemStatus()
		return nil
	case employees.FieldWithDisabilityRemarks:
		m.ResetWithDisabilityRemarks()
		return nil
	case employees.FieldDisabilityType:
		m.ResetDisabilityType()
		return nil
	case employees.FieldDisabilityTypeVerified:
		m.ResetDisabilityTypeVerified()
		return nil
	case employees.FieldDisabilityTypeRemStatus:
		m.ResetDisabilityTypeRemStatus()
		return nil
	case employees.FieldDisabilityTypeRemarks:
		m.ResetDisabilityTypeRemarks()
		return nil
	case employees.FieldDisabilityPercentage:
		m.ResetDisabilityPercentage()
		return nil
	case employees.FieldDisabilityPercentageVerified:
		m.ResetDisabilityPercentageVerified()
		return nil
	case employees.FieldDisabilityPercentageRemStatus:
		m.ResetDisabilityPercentageRemStatus()
		return nil
	case employees.FieldDisabilityPercentageRemarks:
		m.ResetDisabilityPercentageRemarks()
		return nil
	case employees.FieldSignature:
		m.ResetSignature()
		return nil
	case employees.FieldSignatureVerified:
		m.ResetSignatureVerified()
		return nil
	case employees.FieldSignatureRemStatus:
		m.ResetSignatureRemStatus()
		return nil
	case employees.FieldSignatureRemarks:
		m.ResetSignatureRemarks()
		return nil
	case employees.FieldPhoto:
		m.ResetPhoto()
		return nil
	case employees.FieldPhotoVerified:
		m.ResetPhotoVerified()
		return nil
	case employees.FieldPhotoRemStatus:
		m.ResetPhotoRemStatus()
		return nil
	case employees.FieldPhotoRemarks:
		m.ResetPhotoRemarks()
		return nil
	case employees.FieldPostID:
		m.ResetPostID()
		return nil
	case employees.FieldPostCode:
		m.ResetPostCode()
		return nil
	case employees.FieldEmployeePost:
		m.ResetEmployeePost()
		return nil
	case employees.FieldEmployeePostVerified:
		m.ResetEmployeePostVerified()
		return nil
	case employees.FieldEmployeePostRemStatus:
		m.ResetEmployeePostRemStatus()
		return nil
	case employees.FieldEmployeePostRemarks:
		m.ResetEmployeePostRemarks()
		return nil
	case employees.FieldDesignationID:
		m.ResetDesignationID()
		return nil
	case employees.FieldEmployeeDesignation:
		m.ResetEmployeeDesignation()
		return nil
	case employees.FieldEmployeeDesignationVerified:
		m.ResetEmployeeDesignationVerified()
		return nil
	case employees.FieldEmployeeDesignationRemStatus:
		m.ResetEmployeeDesignationRemStatus()
		return nil
	case employees.FieldEmployeeDesignationRemarks:
		m.ResetEmployeeDesignationRemarks()
		return nil
	case employees.FieldCircleID:
		m.ResetCircleID()
		return nil
	case employees.FieldCircleName:
		m.ResetCircleName()
		return nil
	case employees.FieldCircleVerified:
		m.ResetCircleVerified()
		return nil
	case employees.FieldCircleRemStatus:
		m.ResetCircleRemStatus()
		return nil
	case employees.FieldCircleRemarks:
		m.ResetCircleRemarks()
		return nil
	case employees.FieldRegionID:
		m.ResetRegionID()
		return nil
	case employees.FieldRegionName:
		m.ResetRegionName()
		return nil
	case employees.FieldRegionVerified:
		m.ResetRegionVerified()
		return nil
	case employees.FieldRegionRemStatus:
		m.ResetRegionRemStatus()
		return nil
	case employees.FieldRegionRemarks:
		m.ResetRegionRemarks()
		return nil
	case employees.FieldDivisionID:
		m.ResetDivisionID()
		return nil
	case employees.FieldDivisionName:
		m.ResetDivisionName()
		return nil
	case employees.FieldDivisionVerified:
		m.ResetDivisionVerified()
		return nil
	case employees.FieldDivisionRemStatus:
		m.ResetDivisionRemStatus()
		return nil
	case employees.FieldDivisionRemarks:
		m.ResetDivisionRemarks()
		return nil
	case employees.FieldOfficeID:
		m.ResetOfficeID()
		return nil
	case employees.FieldOfficeName:
		m.ResetOfficeName()
		return nil
	case employees.FieldOfficeVerified:
		m.ResetOfficeVerified()
		return nil
	case employees.FieldOfficeRemStatus:
		m.ResetOfficeRemStatus()
		return nil
	case employees.FieldOfficeRemarks:
		m.ResetOfficeRemarks()
		return nil
	case employees.FieldRole:
		m.ResetRole()
		return nil
	case employees.FieldRoleVerified:
		m.ResetRoleVerified()
		return nil
	case employees.FieldRoleRemStatus:
		m.ResetRoleRemStatus()
		return nil
	case employees.FieldRoleRemarks:
		m.ResetRoleRemarks()
		return nil
	case employees.FieldDCCS:
		m.ResetDCCS()
		return nil
	case employees.FieldDCCSVerified:
		m.ResetDCCSVerified()
		return nil
	case employees.FieldDCCSRemStatus:
		m.ResetDCCSRemStatus()
		return nil
	case employees.FieldDCCSRemarks:
		m.ResetDCCSRemarks()
		return nil
	case employees.FieldDCInPresentCadre:
		m.ResetDCInPresentCadre()
		return nil
	case employees.FieldDCInPresentCadreVerified:
		m.ResetDCInPresentCadreVerified()
		return nil
	case employees.FieldDCInPresentCadreRemStatus:
		m.ResetDCInPresentCadreRemStatus()
		return nil
	case employees.FieldDCInPresentCadreRemarks:
		m.ResetDCInPresentCadreRemarks()
		return nil
	case employees.FieldAPSWorking:
		m.ResetAPSWorking()
		return nil
	case employees.FieldAPSWorkingVerified:
		m.ResetAPSWorkingVerified()
		return nil
	case employees.FieldAPSWorkingRemStatus:
		m.ResetAPSWorkingRemStatus()
		return nil
	case employees.FieldAPSWorkingRemarks:
		m.ResetAPSWorkingRemarks()
		return nil
	case employees.FieldProfilestatus:
		m.ResetProfilestatus()
		return nil
	case employees.FieldRoleUserCode:
		m.ResetRoleUserCode()
		return nil
	}
	return fmt.Errorf("unknown Employees field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Employees unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Employees edge %s", name)
}

// ExamMutation represents an operation that mutates the Exam nodes in the graph.
type ExamMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int32
	_ExamName                           *string
	_NumOfPapers                        *int32
	add_NumOfPapers                     *int32
	_NotificationBy                     *string
	_ConductedBy                        *string
	_NodalOfficerLevel                  *string
	_CalendarCode                       *int32
	add_CalendarCode                    *int32
	_PaperCode                          *int32
	add_PaperCode                       *int32
	_ExamType                           *string
	_TentativeNotificationMandatoryDate *bool
	_LocalLanguage                      *bool
	_OptionForPost                      *bool
	_OptionToWriteExamOtherThanParent   *bool
	_OrderNumber                        *string
	_Status                             *string
	_ExamTypeCode                       *int32
	add_ExamTypeCode                    *int32
	clearedFields                       map[string]struct{}
	nodal_officers                      map[int32]struct{}
	removednodal_officers               map[int32]struct{}
	clearednodal_officers               bool
	notifications                       map[int32]struct{}
	removednotifications                map[int32]struct{}
	clearednotifications                bool
	exams_ref                           map[int32]struct{}
	removedexams_ref                    map[int32]struct{}
	clearedexams_ref                    bool
	papers                              map[int32]struct{}
	removedpapers                       map[int32]struct{}
	clearedpapers                       bool
	_ExamEligibility                    map[int32]struct{}
	removed_ExamEligibility             map[int32]struct{}
	cleared_ExamEligibility             bool
	exams_type                          map[int32]struct{}
	removedexams_type                   map[int32]struct{}
	clearedexams_type                   bool
	done                                bool
	oldValue                            func(context.Context) (*Exam, error)
	predicates                          []predicate.Exam
}

var _ ent.Mutation = (*ExamMutation)(nil)

// examOption allows management of the mutation configuration using functional options.
type examOption func(*ExamMutation)

// newExamMutation creates new mutation for the Exam entity.
func newExamMutation(c config, op Op, opts ...examOption) *ExamMutation {
	m := &ExamMutation{
		config:        c,
		op:            op,
		typ:           TypeExam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExamID sets the ID field of the mutation.
func withExamID(id int32) examOption {
	return func(m *ExamMutation) {
		var (
			err   error
			once  sync.Once
			value *Exam
		)
		m.oldValue = func(ctx context.Context) (*Exam, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exam.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExam sets the old Exam of the mutation.
func withExam(node *Exam) examOption {
	return func(m *ExamMutation) {
		m.oldValue = func(context.Context) (*Exam, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exam entities.
func (m *ExamMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExamMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExamMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exam.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExamName sets the "ExamName" field.
func (m *ExamMutation) SetExamName(s string) {
	m._ExamName = &s
}

// ExamName returns the value of the "ExamName" field in the mutation.
func (m *ExamMutation) ExamName() (r string, exists bool) {
	v := m._ExamName
	if v == nil {
		return
	}
	return *v, true
}

// OldExamName returns the old "ExamName" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldExamName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamName: %w", err)
	}
	return oldValue.ExamName, nil
}

// ResetExamName resets all changes to the "ExamName" field.
func (m *ExamMutation) ResetExamName() {
	m._ExamName = nil
}

// SetNumOfPapers sets the "NumOfPapers" field.
func (m *ExamMutation) SetNumOfPapers(i int32) {
	m._NumOfPapers = &i
	m.add_NumOfPapers = nil
}

// NumOfPapers returns the value of the "NumOfPapers" field in the mutation.
func (m *ExamMutation) NumOfPapers() (r int32, exists bool) {
	v := m._NumOfPapers
	if v == nil {
		return
	}
	return *v, true
}

// OldNumOfPapers returns the old "NumOfPapers" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldNumOfPapers(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumOfPapers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumOfPapers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumOfPapers: %w", err)
	}
	return oldValue.NumOfPapers, nil
}

// AddNumOfPapers adds i to the "NumOfPapers" field.
func (m *ExamMutation) AddNumOfPapers(i int32) {
	if m.add_NumOfPapers != nil {
		*m.add_NumOfPapers += i
	} else {
		m.add_NumOfPapers = &i
	}
}

// AddedNumOfPapers returns the value that was added to the "NumOfPapers" field in this mutation.
func (m *ExamMutation) AddedNumOfPapers() (r int32, exists bool) {
	v := m.add_NumOfPapers
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumOfPapers resets all changes to the "NumOfPapers" field.
func (m *ExamMutation) ResetNumOfPapers() {
	m._NumOfPapers = nil
	m.add_NumOfPapers = nil
}

// SetNotificationBy sets the "NotificationBy" field.
func (m *ExamMutation) SetNotificationBy(s string) {
	m._NotificationBy = &s
}

// NotificationBy returns the value of the "NotificationBy" field in the mutation.
func (m *ExamMutation) NotificationBy() (r string, exists bool) {
	v := m._NotificationBy
	if v == nil {
		return
	}
	return *v, true
}

// OldNotificationBy returns the old "NotificationBy" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldNotificationBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotificationBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotificationBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotificationBy: %w", err)
	}
	return oldValue.NotificationBy, nil
}

// ResetNotificationBy resets all changes to the "NotificationBy" field.
func (m *ExamMutation) ResetNotificationBy() {
	m._NotificationBy = nil
}

// SetConductedBy sets the "ConductedBy" field.
func (m *ExamMutation) SetConductedBy(s string) {
	m._ConductedBy = &s
}

// ConductedBy returns the value of the "ConductedBy" field in the mutation.
func (m *ExamMutation) ConductedBy() (r string, exists bool) {
	v := m._ConductedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldConductedBy returns the old "ConductedBy" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldConductedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConductedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConductedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConductedBy: %w", err)
	}
	return oldValue.ConductedBy, nil
}

// ResetConductedBy resets all changes to the "ConductedBy" field.
func (m *ExamMutation) ResetConductedBy() {
	m._ConductedBy = nil
}

// SetNodalOfficerLevel sets the "NodalOfficerLevel" field.
func (m *ExamMutation) SetNodalOfficerLevel(s string) {
	m._NodalOfficerLevel = &s
}

// NodalOfficerLevel returns the value of the "NodalOfficerLevel" field in the mutation.
func (m *ExamMutation) NodalOfficerLevel() (r string, exists bool) {
	v := m._NodalOfficerLevel
	if v == nil {
		return
	}
	return *v, true
}

// OldNodalOfficerLevel returns the old "NodalOfficerLevel" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldNodalOfficerLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodalOfficerLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodalOfficerLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodalOfficerLevel: %w", err)
	}
	return oldValue.NodalOfficerLevel, nil
}

// ClearNodalOfficerLevel clears the value of the "NodalOfficerLevel" field.
func (m *ExamMutation) ClearNodalOfficerLevel() {
	m._NodalOfficerLevel = nil
	m.clearedFields[exam.FieldNodalOfficerLevel] = struct{}{}
}

// NodalOfficerLevelCleared returns if the "NodalOfficerLevel" field was cleared in this mutation.
func (m *ExamMutation) NodalOfficerLevelCleared() bool {
	_, ok := m.clearedFields[exam.FieldNodalOfficerLevel]
	return ok
}

// ResetNodalOfficerLevel resets all changes to the "NodalOfficerLevel" field.
func (m *ExamMutation) ResetNodalOfficerLevel() {
	m._NodalOfficerLevel = nil
	delete(m.clearedFields, exam.FieldNodalOfficerLevel)
}

// SetCalendarCode sets the "CalendarCode" field.
func (m *ExamMutation) SetCalendarCode(i int32) {
	m._CalendarCode = &i
	m.add_CalendarCode = nil
}

// CalendarCode returns the value of the "CalendarCode" field in the mutation.
func (m *ExamMutation) CalendarCode() (r int32, exists bool) {
	v := m._CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCalendarCode returns the old "CalendarCode" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldCalendarCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalendarCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalendarCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalendarCode: %w", err)
	}
	return oldValue.CalendarCode, nil
}

// AddCalendarCode adds i to the "CalendarCode" field.
func (m *ExamMutation) AddCalendarCode(i int32) {
	if m.add_CalendarCode != nil {
		*m.add_CalendarCode += i
	} else {
		m.add_CalendarCode = &i
	}
}

// AddedCalendarCode returns the value that was added to the "CalendarCode" field in this mutation.
func (m *ExamMutation) AddedCalendarCode() (r int32, exists bool) {
	v := m.add_CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalendarCode clears the value of the "CalendarCode" field.
func (m *ExamMutation) ClearCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	m.clearedFields[exam.FieldCalendarCode] = struct{}{}
}

// CalendarCodeCleared returns if the "CalendarCode" field was cleared in this mutation.
func (m *ExamMutation) CalendarCodeCleared() bool {
	_, ok := m.clearedFields[exam.FieldCalendarCode]
	return ok
}

// ResetCalendarCode resets all changes to the "CalendarCode" field.
func (m *ExamMutation) ResetCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	delete(m.clearedFields, exam.FieldCalendarCode)
}

// SetPaperCode sets the "PaperCode" field.
func (m *ExamMutation) SetPaperCode(i int32) {
	m._PaperCode = &i
	m.add_PaperCode = nil
}

// PaperCode returns the value of the "PaperCode" field in the mutation.
func (m *ExamMutation) PaperCode() (r int32, exists bool) {
	v := m._PaperCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperCode returns the old "PaperCode" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldPaperCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperCode: %w", err)
	}
	return oldValue.PaperCode, nil
}

// AddPaperCode adds i to the "PaperCode" field.
func (m *ExamMutation) AddPaperCode(i int32) {
	if m.add_PaperCode != nil {
		*m.add_PaperCode += i
	} else {
		m.add_PaperCode = &i
	}
}

// AddedPaperCode returns the value that was added to the "PaperCode" field in this mutation.
func (m *ExamMutation) AddedPaperCode() (r int32, exists bool) {
	v := m.add_PaperCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaperCode clears the value of the "PaperCode" field.
func (m *ExamMutation) ClearPaperCode() {
	m._PaperCode = nil
	m.add_PaperCode = nil
	m.clearedFields[exam.FieldPaperCode] = struct{}{}
}

// PaperCodeCleared returns if the "PaperCode" field was cleared in this mutation.
func (m *ExamMutation) PaperCodeCleared() bool {
	_, ok := m.clearedFields[exam.FieldPaperCode]
	return ok
}

// ResetPaperCode resets all changes to the "PaperCode" field.
func (m *ExamMutation) ResetPaperCode() {
	m._PaperCode = nil
	m.add_PaperCode = nil
	delete(m.clearedFields, exam.FieldPaperCode)
}

// SetExamType sets the "ExamType" field.
func (m *ExamMutation) SetExamType(s string) {
	m._ExamType = &s
}

// ExamType returns the value of the "ExamType" field in the mutation.
func (m *ExamMutation) ExamType() (r string, exists bool) {
	v := m._ExamType
	if v == nil {
		return
	}
	return *v, true
}

// OldExamType returns the old "ExamType" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldExamType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamType: %w", err)
	}
	return oldValue.ExamType, nil
}

// ResetExamType resets all changes to the "ExamType" field.
func (m *ExamMutation) ResetExamType() {
	m._ExamType = nil
}

// SetTentativeNotificationMandatoryDate sets the "TentativeNotificationMandatoryDate" field.
func (m *ExamMutation) SetTentativeNotificationMandatoryDate(b bool) {
	m._TentativeNotificationMandatoryDate = &b
}

// TentativeNotificationMandatoryDate returns the value of the "TentativeNotificationMandatoryDate" field in the mutation.
func (m *ExamMutation) TentativeNotificationMandatoryDate() (r bool, exists bool) {
	v := m._TentativeNotificationMandatoryDate
	if v == nil {
		return
	}
	return *v, true
}

// OldTentativeNotificationMandatoryDate returns the old "TentativeNotificationMandatoryDate" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldTentativeNotificationMandatoryDate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTentativeNotificationMandatoryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTentativeNotificationMandatoryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTentativeNotificationMandatoryDate: %w", err)
	}
	return oldValue.TentativeNotificationMandatoryDate, nil
}

// ResetTentativeNotificationMandatoryDate resets all changes to the "TentativeNotificationMandatoryDate" field.
func (m *ExamMutation) ResetTentativeNotificationMandatoryDate() {
	m._TentativeNotificationMandatoryDate = nil
}

// SetLocalLanguage sets the "LocalLanguage" field.
func (m *ExamMutation) SetLocalLanguage(b bool) {
	m._LocalLanguage = &b
}

// LocalLanguage returns the value of the "LocalLanguage" field in the mutation.
func (m *ExamMutation) LocalLanguage() (r bool, exists bool) {
	v := m._LocalLanguage
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalLanguage returns the old "LocalLanguage" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldLocalLanguage(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalLanguage: %w", err)
	}
	return oldValue.LocalLanguage, nil
}

// ResetLocalLanguage resets all changes to the "LocalLanguage" field.
func (m *ExamMutation) ResetLocalLanguage() {
	m._LocalLanguage = nil
}

// SetOptionForPost sets the "OptionForPost" field.
func (m *ExamMutation) SetOptionForPost(b bool) {
	m._OptionForPost = &b
}

// OptionForPost returns the value of the "OptionForPost" field in the mutation.
func (m *ExamMutation) OptionForPost() (r bool, exists bool) {
	v := m._OptionForPost
	if v == nil {
		return
	}
	return *v, true
}

// OldOptionForPost returns the old "OptionForPost" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldOptionForPost(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptionForPost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptionForPost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptionForPost: %w", err)
	}
	return oldValue.OptionForPost, nil
}

// ResetOptionForPost resets all changes to the "OptionForPost" field.
func (m *ExamMutation) ResetOptionForPost() {
	m._OptionForPost = nil
}

// SetOptionToWriteExamOtherThanParent sets the "OptionToWriteExamOtherThanParent" field.
func (m *ExamMutation) SetOptionToWriteExamOtherThanParent(b bool) {
	m._OptionToWriteExamOtherThanParent = &b
}

// OptionToWriteExamOtherThanParent returns the value of the "OptionToWriteExamOtherThanParent" field in the mutation.
func (m *ExamMutation) OptionToWriteExamOtherThanParent() (r bool, exists bool) {
	v := m._OptionToWriteExamOtherThanParent
	if v == nil {
		return
	}
	return *v, true
}

// OldOptionToWriteExamOtherThanParent returns the old "OptionToWriteExamOtherThanParent" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldOptionToWriteExamOtherThanParent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptionToWriteExamOtherThanParent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptionToWriteExamOtherThanParent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptionToWriteExamOtherThanParent: %w", err)
	}
	return oldValue.OptionToWriteExamOtherThanParent, nil
}

// ResetOptionToWriteExamOtherThanParent resets all changes to the "OptionToWriteExamOtherThanParent" field.
func (m *ExamMutation) ResetOptionToWriteExamOtherThanParent() {
	m._OptionToWriteExamOtherThanParent = nil
}

// SetOrderNumber sets the "OrderNumber" field.
func (m *ExamMutation) SetOrderNumber(s string) {
	m._OrderNumber = &s
}

// OrderNumber returns the value of the "OrderNumber" field in the mutation.
func (m *ExamMutation) OrderNumber() (r string, exists bool) {
	v := m._OrderNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNumber returns the old "OrderNumber" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNumber: %w", err)
	}
	return oldValue.OrderNumber, nil
}

// ClearOrderNumber clears the value of the "OrderNumber" field.
func (m *ExamMutation) ClearOrderNumber() {
	m._OrderNumber = nil
	m.clearedFields[exam.FieldOrderNumber] = struct{}{}
}

// OrderNumberCleared returns if the "OrderNumber" field was cleared in this mutation.
func (m *ExamMutation) OrderNumberCleared() bool {
	_, ok := m.clearedFields[exam.FieldOrderNumber]
	return ok
}

// ResetOrderNumber resets all changes to the "OrderNumber" field.
func (m *ExamMutation) ResetOrderNumber() {
	m._OrderNumber = nil
	delete(m.clearedFields, exam.FieldOrderNumber)
}

// SetStatus sets the "Status" field.
func (m *ExamMutation) SetStatus(s string) {
	m._Status = &s
}

// Status returns the value of the "Status" field in the mutation.
func (m *ExamMutation) Status() (r string, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "Status" field.
func (m *ExamMutation) ResetStatus() {
	m._Status = nil
}

// SetExamTypeCode sets the "ExamTypeCode" field.
func (m *ExamMutation) SetExamTypeCode(i int32) {
	m._ExamTypeCode = &i
	m.add_ExamTypeCode = nil
}

// ExamTypeCode returns the value of the "ExamTypeCode" field in the mutation.
func (m *ExamMutation) ExamTypeCode() (r int32, exists bool) {
	v := m._ExamTypeCode
	if v == nil {
		return
	}
	return *v, true
}

// OldExamTypeCode returns the old "ExamTypeCode" field's value of the Exam entity.
// If the Exam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamMutation) OldExamTypeCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamTypeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamTypeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamTypeCode: %w", err)
	}
	return oldValue.ExamTypeCode, nil
}

// AddExamTypeCode adds i to the "ExamTypeCode" field.
func (m *ExamMutation) AddExamTypeCode(i int32) {
	if m.add_ExamTypeCode != nil {
		*m.add_ExamTypeCode += i
	} else {
		m.add_ExamTypeCode = &i
	}
}

// AddedExamTypeCode returns the value that was added to the "ExamTypeCode" field in this mutation.
func (m *ExamMutation) AddedExamTypeCode() (r int32, exists bool) {
	v := m.add_ExamTypeCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearExamTypeCode clears the value of the "ExamTypeCode" field.
func (m *ExamMutation) ClearExamTypeCode() {
	m._ExamTypeCode = nil
	m.add_ExamTypeCode = nil
	m.clearedFields[exam.FieldExamTypeCode] = struct{}{}
}

// ExamTypeCodeCleared returns if the "ExamTypeCode" field was cleared in this mutation.
func (m *ExamMutation) ExamTypeCodeCleared() bool {
	_, ok := m.clearedFields[exam.FieldExamTypeCode]
	return ok
}

// ResetExamTypeCode resets all changes to the "ExamTypeCode" field.
func (m *ExamMutation) ResetExamTypeCode() {
	m._ExamTypeCode = nil
	m.add_ExamTypeCode = nil
	delete(m.clearedFields, exam.FieldExamTypeCode)
}

// AddNodalOfficerIDs adds the "nodal_officers" edge to the NodalOfficer entity by ids.
func (m *ExamMutation) AddNodalOfficerIDs(ids ...int32) {
	if m.nodal_officers == nil {
		m.nodal_officers = make(map[int32]struct{})
	}
	for i := range ids {
		m.nodal_officers[ids[i]] = struct{}{}
	}
}

// ClearNodalOfficers clears the "nodal_officers" edge to the NodalOfficer entity.
func (m *ExamMutation) ClearNodalOfficers() {
	m.clearednodal_officers = true
}

// NodalOfficersCleared reports if the "nodal_officers" edge to the NodalOfficer entity was cleared.
func (m *ExamMutation) NodalOfficersCleared() bool {
	return m.clearednodal_officers
}

// RemoveNodalOfficerIDs removes the "nodal_officers" edge to the NodalOfficer entity by IDs.
func (m *ExamMutation) RemoveNodalOfficerIDs(ids ...int32) {
	if m.removednodal_officers == nil {
		m.removednodal_officers = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.nodal_officers, ids[i])
		m.removednodal_officers[ids[i]] = struct{}{}
	}
}

// RemovedNodalOfficers returns the removed IDs of the "nodal_officers" edge to the NodalOfficer entity.
func (m *ExamMutation) RemovedNodalOfficersIDs() (ids []int32) {
	for id := range m.removednodal_officers {
		ids = append(ids, id)
	}
	return
}

// NodalOfficersIDs returns the "nodal_officers" edge IDs in the mutation.
func (m *ExamMutation) NodalOfficersIDs() (ids []int32) {
	for id := range m.nodal_officers {
		ids = append(ids, id)
	}
	return
}

// ResetNodalOfficers resets all changes to the "nodal_officers" edge.
func (m *ExamMutation) ResetNodalOfficers() {
	m.nodal_officers = nil
	m.clearednodal_officers = false
	m.removednodal_officers = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *ExamMutation) AddNotificationIDs(ids ...int32) {
	if m.notifications == nil {
		m.notifications = make(map[int32]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *ExamMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *ExamMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *ExamMutation) RemoveNotificationIDs(ids ...int32) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *ExamMutation) RemovedNotificationsIDs() (ids []int32) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *ExamMutation) NotificationsIDs() (ids []int32) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *ExamMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// AddExamsRefIDs adds the "exams_ref" edge to the ExamCalendar entity by ids.
func (m *ExamMutation) AddExamsRefIDs(ids ...int32) {
	if m.exams_ref == nil {
		m.exams_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.exams_ref[ids[i]] = struct{}{}
	}
}

// ClearExamsRef clears the "exams_ref" edge to the ExamCalendar entity.
func (m *ExamMutation) ClearExamsRef() {
	m.clearedexams_ref = true
}

// ExamsRefCleared reports if the "exams_ref" edge to the ExamCalendar entity was cleared.
func (m *ExamMutation) ExamsRefCleared() bool {
	return m.clearedexams_ref
}

// RemoveExamsRefIDs removes the "exams_ref" edge to the ExamCalendar entity by IDs.
func (m *ExamMutation) RemoveExamsRefIDs(ids ...int32) {
	if m.removedexams_ref == nil {
		m.removedexams_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.exams_ref, ids[i])
		m.removedexams_ref[ids[i]] = struct{}{}
	}
}

// RemovedExamsRef returns the removed IDs of the "exams_ref" edge to the ExamCalendar entity.
func (m *ExamMutation) RemovedExamsRefIDs() (ids []int32) {
	for id := range m.removedexams_ref {
		ids = append(ids, id)
	}
	return
}

// ExamsRefIDs returns the "exams_ref" edge IDs in the mutation.
func (m *ExamMutation) ExamsRefIDs() (ids []int32) {
	for id := range m.exams_ref {
		ids = append(ids, id)
	}
	return
}

// ResetExamsRef resets all changes to the "exams_ref" edge.
func (m *ExamMutation) ResetExamsRef() {
	m.exams_ref = nil
	m.clearedexams_ref = false
	m.removedexams_ref = nil
}

// AddPaperIDs adds the "papers" edge to the ExamPapers entity by ids.
func (m *ExamMutation) AddPaperIDs(ids ...int32) {
	if m.papers == nil {
		m.papers = make(map[int32]struct{})
	}
	for i := range ids {
		m.papers[ids[i]] = struct{}{}
	}
}

// ClearPapers clears the "papers" edge to the ExamPapers entity.
func (m *ExamMutation) ClearPapers() {
	m.clearedpapers = true
}

// PapersCleared reports if the "papers" edge to the ExamPapers entity was cleared.
func (m *ExamMutation) PapersCleared() bool {
	return m.clearedpapers
}

// RemovePaperIDs removes the "papers" edge to the ExamPapers entity by IDs.
func (m *ExamMutation) RemovePaperIDs(ids ...int32) {
	if m.removedpapers == nil {
		m.removedpapers = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.papers, ids[i])
		m.removedpapers[ids[i]] = struct{}{}
	}
}

// RemovedPapers returns the removed IDs of the "papers" edge to the ExamPapers entity.
func (m *ExamMutation) RemovedPapersIDs() (ids []int32) {
	for id := range m.removedpapers {
		ids = append(ids, id)
	}
	return
}

// PapersIDs returns the "papers" edge IDs in the mutation.
func (m *ExamMutation) PapersIDs() (ids []int32) {
	for id := range m.papers {
		ids = append(ids, id)
	}
	return
}

// ResetPapers resets all changes to the "papers" edge.
func (m *ExamMutation) ResetPapers() {
	m.papers = nil
	m.clearedpapers = false
	m.removedpapers = nil
}

// AddExamEligibilityIDs adds the "ExamEligibility" edge to the EligibilityMaster entity by ids.
func (m *ExamMutation) AddExamEligibilityIDs(ids ...int32) {
	if m._ExamEligibility == nil {
		m._ExamEligibility = make(map[int32]struct{})
	}
	for i := range ids {
		m._ExamEligibility[ids[i]] = struct{}{}
	}
}

// ClearExamEligibility clears the "ExamEligibility" edge to the EligibilityMaster entity.
func (m *ExamMutation) ClearExamEligibility() {
	m.cleared_ExamEligibility = true
}

// ExamEligibilityCleared reports if the "ExamEligibility" edge to the EligibilityMaster entity was cleared.
func (m *ExamMutation) ExamEligibilityCleared() bool {
	return m.cleared_ExamEligibility
}

// RemoveExamEligibilityIDs removes the "ExamEligibility" edge to the EligibilityMaster entity by IDs.
func (m *ExamMutation) RemoveExamEligibilityIDs(ids ...int32) {
	if m.removed_ExamEligibility == nil {
		m.removed_ExamEligibility = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m._ExamEligibility, ids[i])
		m.removed_ExamEligibility[ids[i]] = struct{}{}
	}
}

// RemovedExamEligibility returns the removed IDs of the "ExamEligibility" edge to the EligibilityMaster entity.
func (m *ExamMutation) RemovedExamEligibilityIDs() (ids []int32) {
	for id := range m.removed_ExamEligibility {
		ids = append(ids, id)
	}
	return
}

// ExamEligibilityIDs returns the "ExamEligibility" edge IDs in the mutation.
func (m *ExamMutation) ExamEligibilityIDs() (ids []int32) {
	for id := range m._ExamEligibility {
		ids = append(ids, id)
	}
	return
}

// ResetExamEligibility resets all changes to the "ExamEligibility" edge.
func (m *ExamMutation) ResetExamEligibility() {
	m._ExamEligibility = nil
	m.cleared_ExamEligibility = false
	m.removed_ExamEligibility = nil
}

// AddExamsTypeIDs adds the "exams_type" edge to the ExamType entity by ids.
func (m *ExamMutation) AddExamsTypeIDs(ids ...int32) {
	if m.exams_type == nil {
		m.exams_type = make(map[int32]struct{})
	}
	for i := range ids {
		m.exams_type[ids[i]] = struct{}{}
	}
}

// ClearExamsType clears the "exams_type" edge to the ExamType entity.
func (m *ExamMutation) ClearExamsType() {
	m.clearedexams_type = true
}

// ExamsTypeCleared reports if the "exams_type" edge to the ExamType entity was cleared.
func (m *ExamMutation) ExamsTypeCleared() bool {
	return m.clearedexams_type
}

// RemoveExamsTypeIDs removes the "exams_type" edge to the ExamType entity by IDs.
func (m *ExamMutation) RemoveExamsTypeIDs(ids ...int32) {
	if m.removedexams_type == nil {
		m.removedexams_type = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.exams_type, ids[i])
		m.removedexams_type[ids[i]] = struct{}{}
	}
}

// RemovedExamsType returns the removed IDs of the "exams_type" edge to the ExamType entity.
func (m *ExamMutation) RemovedExamsTypeIDs() (ids []int32) {
	for id := range m.removedexams_type {
		ids = append(ids, id)
	}
	return
}

// ExamsTypeIDs returns the "exams_type" edge IDs in the mutation.
func (m *ExamMutation) ExamsTypeIDs() (ids []int32) {
	for id := range m.exams_type {
		ids = append(ids, id)
	}
	return
}

// ResetExamsType resets all changes to the "exams_type" edge.
func (m *ExamMutation) ResetExamsType() {
	m.exams_type = nil
	m.clearedexams_type = false
	m.removedexams_type = nil
}

// Where appends a list predicates to the ExamMutation builder.
func (m *ExamMutation) Where(ps ...predicate.Exam) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exam, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exam).
func (m *ExamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExamMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m._ExamName != nil {
		fields = append(fields, exam.FieldExamName)
	}
	if m._NumOfPapers != nil {
		fields = append(fields, exam.FieldNumOfPapers)
	}
	if m._NotificationBy != nil {
		fields = append(fields, exam.FieldNotificationBy)
	}
	if m._ConductedBy != nil {
		fields = append(fields, exam.FieldConductedBy)
	}
	if m._NodalOfficerLevel != nil {
		fields = append(fields, exam.FieldNodalOfficerLevel)
	}
	if m._CalendarCode != nil {
		fields = append(fields, exam.FieldCalendarCode)
	}
	if m._PaperCode != nil {
		fields = append(fields, exam.FieldPaperCode)
	}
	if m._ExamType != nil {
		fields = append(fields, exam.FieldExamType)
	}
	if m._TentativeNotificationMandatoryDate != nil {
		fields = append(fields, exam.FieldTentativeNotificationMandatoryDate)
	}
	if m._LocalLanguage != nil {
		fields = append(fields, exam.FieldLocalLanguage)
	}
	if m._OptionForPost != nil {
		fields = append(fields, exam.FieldOptionForPost)
	}
	if m._OptionToWriteExamOtherThanParent != nil {
		fields = append(fields, exam.FieldOptionToWriteExamOtherThanParent)
	}
	if m._OrderNumber != nil {
		fields = append(fields, exam.FieldOrderNumber)
	}
	if m._Status != nil {
		fields = append(fields, exam.FieldStatus)
	}
	if m._ExamTypeCode != nil {
		fields = append(fields, exam.FieldExamTypeCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exam.FieldExamName:
		return m.ExamName()
	case exam.FieldNumOfPapers:
		return m.NumOfPapers()
	case exam.FieldNotificationBy:
		return m.NotificationBy()
	case exam.FieldConductedBy:
		return m.ConductedBy()
	case exam.FieldNodalOfficerLevel:
		return m.NodalOfficerLevel()
	case exam.FieldCalendarCode:
		return m.CalendarCode()
	case exam.FieldPaperCode:
		return m.PaperCode()
	case exam.FieldExamType:
		return m.ExamType()
	case exam.FieldTentativeNotificationMandatoryDate:
		return m.TentativeNotificationMandatoryDate()
	case exam.FieldLocalLanguage:
		return m.LocalLanguage()
	case exam.FieldOptionForPost:
		return m.OptionForPost()
	case exam.FieldOptionToWriteExamOtherThanParent:
		return m.OptionToWriteExamOtherThanParent()
	case exam.FieldOrderNumber:
		return m.OrderNumber()
	case exam.FieldStatus:
		return m.Status()
	case exam.FieldExamTypeCode:
		return m.ExamTypeCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exam.FieldExamName:
		return m.OldExamName(ctx)
	case exam.FieldNumOfPapers:
		return m.OldNumOfPapers(ctx)
	case exam.FieldNotificationBy:
		return m.OldNotificationBy(ctx)
	case exam.FieldConductedBy:
		return m.OldConductedBy(ctx)
	case exam.FieldNodalOfficerLevel:
		return m.OldNodalOfficerLevel(ctx)
	case exam.FieldCalendarCode:
		return m.OldCalendarCode(ctx)
	case exam.FieldPaperCode:
		return m.OldPaperCode(ctx)
	case exam.FieldExamType:
		return m.OldExamType(ctx)
	case exam.FieldTentativeNotificationMandatoryDate:
		return m.OldTentativeNotificationMandatoryDate(ctx)
	case exam.FieldLocalLanguage:
		return m.OldLocalLanguage(ctx)
	case exam.FieldOptionForPost:
		return m.OldOptionForPost(ctx)
	case exam.FieldOptionToWriteExamOtherThanParent:
		return m.OldOptionToWriteExamOtherThanParent(ctx)
	case exam.FieldOrderNumber:
		return m.OldOrderNumber(ctx)
	case exam.FieldStatus:
		return m.OldStatus(ctx)
	case exam.FieldExamTypeCode:
		return m.OldExamTypeCode(ctx)
	}
	return nil, fmt.Errorf("unknown Exam field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exam.FieldExamName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamName(v)
		return nil
	case exam.FieldNumOfPapers:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumOfPapers(v)
		return nil
	case exam.FieldNotificationBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotificationBy(v)
		return nil
	case exam.FieldConductedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConductedBy(v)
		return nil
	case exam.FieldNodalOfficerLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodalOfficerLevel(v)
		return nil
	case exam.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalendarCode(v)
		return nil
	case exam.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperCode(v)
		return nil
	case exam.FieldExamType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamType(v)
		return nil
	case exam.FieldTentativeNotificationMandatoryDate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTentativeNotificationMandatoryDate(v)
		return nil
	case exam.FieldLocalLanguage:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalLanguage(v)
		return nil
	case exam.FieldOptionForPost:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptionForPost(v)
		return nil
	case exam.FieldOptionToWriteExamOtherThanParent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptionToWriteExamOtherThanParent(v)
		return nil
	case exam.FieldOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNumber(v)
		return nil
	case exam.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case exam.FieldExamTypeCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamTypeCode(v)
		return nil
	}
	return fmt.Errorf("unknown Exam field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExamMutation) AddedFields() []string {
	var fields []string
	if m.add_NumOfPapers != nil {
		fields = append(fields, exam.FieldNumOfPapers)
	}
	if m.add_CalendarCode != nil {
		fields = append(fields, exam.FieldCalendarCode)
	}
	if m.add_PaperCode != nil {
		fields = append(fields, exam.FieldPaperCode)
	}
	if m.add_ExamTypeCode != nil {
		fields = append(fields, exam.FieldExamTypeCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exam.FieldNumOfPapers:
		return m.AddedNumOfPapers()
	case exam.FieldCalendarCode:
		return m.AddedCalendarCode()
	case exam.FieldPaperCode:
		return m.AddedPaperCode()
	case exam.FieldExamTypeCode:
		return m.AddedExamTypeCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exam.FieldNumOfPapers:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumOfPapers(v)
		return nil
	case exam.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalendarCode(v)
		return nil
	case exam.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaperCode(v)
		return nil
	case exam.FieldExamTypeCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamTypeCode(v)
		return nil
	}
	return fmt.Errorf("unknown Exam numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exam.FieldNodalOfficerLevel) {
		fields = append(fields, exam.FieldNodalOfficerLevel)
	}
	if m.FieldCleared(exam.FieldCalendarCode) {
		fields = append(fields, exam.FieldCalendarCode)
	}
	if m.FieldCleared(exam.FieldPaperCode) {
		fields = append(fields, exam.FieldPaperCode)
	}
	if m.FieldCleared(exam.FieldOrderNumber) {
		fields = append(fields, exam.FieldOrderNumber)
	}
	if m.FieldCleared(exam.FieldExamTypeCode) {
		fields = append(fields, exam.FieldExamTypeCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExamMutation) ClearField(name string) error {
	switch name {
	case exam.FieldNodalOfficerLevel:
		m.ClearNodalOfficerLevel()
		return nil
	case exam.FieldCalendarCode:
		m.ClearCalendarCode()
		return nil
	case exam.FieldPaperCode:
		m.ClearPaperCode()
		return nil
	case exam.FieldOrderNumber:
		m.ClearOrderNumber()
		return nil
	case exam.FieldExamTypeCode:
		m.ClearExamTypeCode()
		return nil
	}
	return fmt.Errorf("unknown Exam nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExamMutation) ResetField(name string) error {
	switch name {
	case exam.FieldExamName:
		m.ResetExamName()
		return nil
	case exam.FieldNumOfPapers:
		m.ResetNumOfPapers()
		return nil
	case exam.FieldNotificationBy:
		m.ResetNotificationBy()
		return nil
	case exam.FieldConductedBy:
		m.ResetConductedBy()
		return nil
	case exam.FieldNodalOfficerLevel:
		m.ResetNodalOfficerLevel()
		return nil
	case exam.FieldCalendarCode:
		m.ResetCalendarCode()
		return nil
	case exam.FieldPaperCode:
		m.ResetPaperCode()
		return nil
	case exam.FieldExamType:
		m.ResetExamType()
		return nil
	case exam.FieldTentativeNotificationMandatoryDate:
		m.ResetTentativeNotificationMandatoryDate()
		return nil
	case exam.FieldLocalLanguage:
		m.ResetLocalLanguage()
		return nil
	case exam.FieldOptionForPost:
		m.ResetOptionForPost()
		return nil
	case exam.FieldOptionToWriteExamOtherThanParent:
		m.ResetOptionToWriteExamOtherThanParent()
		return nil
	case exam.FieldOrderNumber:
		m.ResetOrderNumber()
		return nil
	case exam.FieldStatus:
		m.ResetStatus()
		return nil
	case exam.FieldExamTypeCode:
		m.ResetExamTypeCode()
		return nil
	}
	return fmt.Errorf("unknown Exam field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExamMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.nodal_officers != nil {
		edges = append(edges, exam.EdgeNodalOfficers)
	}
	if m.notifications != nil {
		edges = append(edges, exam.EdgeNotifications)
	}
	if m.exams_ref != nil {
		edges = append(edges, exam.EdgeExamsRef)
	}
	if m.papers != nil {
		edges = append(edges, exam.EdgePapers)
	}
	if m._ExamEligibility != nil {
		edges = append(edges, exam.EdgeExamEligibility)
	}
	if m.exams_type != nil {
		edges = append(edges, exam.EdgeExamsType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exam.EdgeNodalOfficers:
		ids := make([]ent.Value, 0, len(m.nodal_officers))
		for id := range m.nodal_officers {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgeExamsRef:
		ids := make([]ent.Value, 0, len(m.exams_ref))
		for id := range m.exams_ref {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgePapers:
		ids := make([]ent.Value, 0, len(m.papers))
		for id := range m.papers {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgeExamEligibility:
		ids := make([]ent.Value, 0, len(m._ExamEligibility))
		for id := range m._ExamEligibility {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgeExamsType:
		ids := make([]ent.Value, 0, len(m.exams_type))
		for id := range m.exams_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removednodal_officers != nil {
		edges = append(edges, exam.EdgeNodalOfficers)
	}
	if m.removednotifications != nil {
		edges = append(edges, exam.EdgeNotifications)
	}
	if m.removedexams_ref != nil {
		edges = append(edges, exam.EdgeExamsRef)
	}
	if m.removedpapers != nil {
		edges = append(edges, exam.EdgePapers)
	}
	if m.removed_ExamEligibility != nil {
		edges = append(edges, exam.EdgeExamEligibility)
	}
	if m.removedexams_type != nil {
		edges = append(edges, exam.EdgeExamsType)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exam.EdgeNodalOfficers:
		ids := make([]ent.Value, 0, len(m.removednodal_officers))
		for id := range m.removednodal_officers {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgeExamsRef:
		ids := make([]ent.Value, 0, len(m.removedexams_ref))
		for id := range m.removedexams_ref {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgePapers:
		ids := make([]ent.Value, 0, len(m.removedpapers))
		for id := range m.removedpapers {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgeExamEligibility:
		ids := make([]ent.Value, 0, len(m.removed_ExamEligibility))
		for id := range m.removed_ExamEligibility {
			ids = append(ids, id)
		}
		return ids
	case exam.EdgeExamsType:
		ids := make([]ent.Value, 0, len(m.removedexams_type))
		for id := range m.removedexams_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearednodal_officers {
		edges = append(edges, exam.EdgeNodalOfficers)
	}
	if m.clearednotifications {
		edges = append(edges, exam.EdgeNotifications)
	}
	if m.clearedexams_ref {
		edges = append(edges, exam.EdgeExamsRef)
	}
	if m.clearedpapers {
		edges = append(edges, exam.EdgePapers)
	}
	if m.cleared_ExamEligibility {
		edges = append(edges, exam.EdgeExamEligibility)
	}
	if m.clearedexams_type {
		edges = append(edges, exam.EdgeExamsType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExamMutation) EdgeCleared(name string) bool {
	switch name {
	case exam.EdgeNodalOfficers:
		return m.clearednodal_officers
	case exam.EdgeNotifications:
		return m.clearednotifications
	case exam.EdgeExamsRef:
		return m.clearedexams_ref
	case exam.EdgePapers:
		return m.clearedpapers
	case exam.EdgeExamEligibility:
		return m.cleared_ExamEligibility
	case exam.EdgeExamsType:
		return m.clearedexams_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Exam unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExamMutation) ResetEdge(name string) error {
	switch name {
	case exam.EdgeNodalOfficers:
		m.ResetNodalOfficers()
		return nil
	case exam.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case exam.EdgeExamsRef:
		m.ResetExamsRef()
		return nil
	case exam.EdgePapers:
		m.ResetPapers()
		return nil
	case exam.EdgeExamEligibility:
		m.ResetExamEligibility()
		return nil
	case exam.EdgeExamsType:
		m.ResetExamsType()
		return nil
	}
	return fmt.Errorf("unknown Exam edge %s", name)
}

// ExamCalendarMutation represents an operation that mutates the ExamCalendar nodes in the graph.
type ExamCalendarMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int32
	_ExamYear              *int32
	add_ExamYear           *int32
	_ExamName              *string
	_NotificationDate      *time.Time
	_ModelNotificationDate *time.Time
	_ApplicationEndDate    *time.Time
	_ApprovedOrderDate     *time.Time
	_TentativeResultDate   *time.Time
	_CreatedDate           *time.Time
	_ApprovedOrderNumber   *string
	_VacancyYears          *[]interface{}
	append_VacancyYears    []interface{}
	_ExamPapers            *[]interface{}
	append_ExamPapers      []interface{}
	_ExamCodePS            *int32
	add_ExamCodePS         *int32
	clearedFields          map[string]struct{}
	vcy_years              *int32
	clearedvcy_years       bool
	exams                  *int32
	clearedexams           bool
	papers                 *int32
	clearedpapers          bool
	_Notify_ref            map[int32]struct{}
	removed_Notify_ref     map[int32]struct{}
	cleared_Notify_ref     bool
	examcal_ps_ref         map[int32]struct{}
	removedexamcal_ps_ref  map[int32]struct{}
	clearedexamcal_ps_ref  bool
	examcal_ip_ref         map[int32]struct{}
	removedexamcal_ip_ref  map[int32]struct{}
	clearedexamcal_ip_ref  bool
	done                   bool
	oldValue               func(context.Context) (*ExamCalendar, error)
	predicates             []predicate.ExamCalendar
}

var _ ent.Mutation = (*ExamCalendarMutation)(nil)

// examcalendarOption allows management of the mutation configuration using functional options.
type examcalendarOption func(*ExamCalendarMutation)

// newExamCalendarMutation creates new mutation for the ExamCalendar entity.
func newExamCalendarMutation(c config, op Op, opts ...examcalendarOption) *ExamCalendarMutation {
	m := &ExamCalendarMutation{
		config:        c,
		op:            op,
		typ:           TypeExamCalendar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExamCalendarID sets the ID field of the mutation.
func withExamCalendarID(id int32) examcalendarOption {
	return func(m *ExamCalendarMutation) {
		var (
			err   error
			once  sync.Once
			value *ExamCalendar
		)
		m.oldValue = func(ctx context.Context) (*ExamCalendar, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExamCalendar.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExamCalendar sets the old ExamCalendar of the mutation.
func withExamCalendar(node *ExamCalendar) examcalendarOption {
	return func(m *ExamCalendarMutation) {
		m.oldValue = func(context.Context) (*ExamCalendar, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExamCalendarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExamCalendarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExamCalendar entities.
func (m *ExamCalendarMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExamCalendarMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExamCalendarMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExamCalendar.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExamYear sets the "ExamYear" field.
func (m *ExamCalendarMutation) SetExamYear(i int32) {
	m._ExamYear = &i
	m.add_ExamYear = nil
}

// ExamYear returns the value of the "ExamYear" field in the mutation.
func (m *ExamCalendarMutation) ExamYear() (r int32, exists bool) {
	v := m._ExamYear
	if v == nil {
		return
	}
	return *v, true
}

// OldExamYear returns the old "ExamYear" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldExamYear(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamYear: %w", err)
	}
	return oldValue.ExamYear, nil
}

// AddExamYear adds i to the "ExamYear" field.
func (m *ExamCalendarMutation) AddExamYear(i int32) {
	if m.add_ExamYear != nil {
		*m.add_ExamYear += i
	} else {
		m.add_ExamYear = &i
	}
}

// AddedExamYear returns the value that was added to the "ExamYear" field in this mutation.
func (m *ExamCalendarMutation) AddedExamYear() (r int32, exists bool) {
	v := m.add_ExamYear
	if v == nil {
		return
	}
	return *v, true
}

// ResetExamYear resets all changes to the "ExamYear" field.
func (m *ExamCalendarMutation) ResetExamYear() {
	m._ExamYear = nil
	m.add_ExamYear = nil
}

// SetExamName sets the "ExamName" field.
func (m *ExamCalendarMutation) SetExamName(s string) {
	m._ExamName = &s
}

// ExamName returns the value of the "ExamName" field in the mutation.
func (m *ExamCalendarMutation) ExamName() (r string, exists bool) {
	v := m._ExamName
	if v == nil {
		return
	}
	return *v, true
}

// OldExamName returns the old "ExamName" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldExamName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamName: %w", err)
	}
	return oldValue.ExamName, nil
}

// ResetExamName resets all changes to the "ExamName" field.
func (m *ExamCalendarMutation) ResetExamName() {
	m._ExamName = nil
}

// SetExamCode sets the "ExamCode" field.
func (m *ExamCalendarMutation) SetExamCode(i int32) {
	m.exams = &i
}

// ExamCode returns the value of the "ExamCode" field in the mutation.
func (m *ExamCalendarMutation) ExamCode() (r int32, exists bool) {
	v := m.exams
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCode returns the old "ExamCode" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldExamCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCode: %w", err)
	}
	return oldValue.ExamCode, nil
}

// ClearExamCode clears the value of the "ExamCode" field.
func (m *ExamCalendarMutation) ClearExamCode() {
	m.exams = nil
	m.clearedFields[examcalendar.FieldExamCode] = struct{}{}
}

// ExamCodeCleared returns if the "ExamCode" field was cleared in this mutation.
func (m *ExamCalendarMutation) ExamCodeCleared() bool {
	_, ok := m.clearedFields[examcalendar.FieldExamCode]
	return ok
}

// ResetExamCode resets all changes to the "ExamCode" field.
func (m *ExamCalendarMutation) ResetExamCode() {
	m.exams = nil
	delete(m.clearedFields, examcalendar.FieldExamCode)
}

// SetNotificationDate sets the "NotificationDate" field.
func (m *ExamCalendarMutation) SetNotificationDate(t time.Time) {
	m._NotificationDate = &t
}

// NotificationDate returns the value of the "NotificationDate" field in the mutation.
func (m *ExamCalendarMutation) NotificationDate() (r time.Time, exists bool) {
	v := m._NotificationDate
	if v == nil {
		return
	}
	return *v, true
}

// OldNotificationDate returns the old "NotificationDate" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldNotificationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotificationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotificationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotificationDate: %w", err)
	}
	return oldValue.NotificationDate, nil
}

// ResetNotificationDate resets all changes to the "NotificationDate" field.
func (m *ExamCalendarMutation) ResetNotificationDate() {
	m._NotificationDate = nil
}

// SetModelNotificationDate sets the "ModelNotificationDate" field.
func (m *ExamCalendarMutation) SetModelNotificationDate(t time.Time) {
	m._ModelNotificationDate = &t
}

// ModelNotificationDate returns the value of the "ModelNotificationDate" field in the mutation.
func (m *ExamCalendarMutation) ModelNotificationDate() (r time.Time, exists bool) {
	v := m._ModelNotificationDate
	if v == nil {
		return
	}
	return *v, true
}

// OldModelNotificationDate returns the old "ModelNotificationDate" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldModelNotificationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelNotificationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelNotificationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelNotificationDate: %w", err)
	}
	return oldValue.ModelNotificationDate, nil
}

// ResetModelNotificationDate resets all changes to the "ModelNotificationDate" field.
func (m *ExamCalendarMutation) ResetModelNotificationDate() {
	m._ModelNotificationDate = nil
}

// SetApplicationEndDate sets the "ApplicationEndDate" field.
func (m *ExamCalendarMutation) SetApplicationEndDate(t time.Time) {
	m._ApplicationEndDate = &t
}

// ApplicationEndDate returns the value of the "ApplicationEndDate" field in the mutation.
func (m *ExamCalendarMutation) ApplicationEndDate() (r time.Time, exists bool) {
	v := m._ApplicationEndDate
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationEndDate returns the old "ApplicationEndDate" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldApplicationEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationEndDate: %w", err)
	}
	return oldValue.ApplicationEndDate, nil
}

// ResetApplicationEndDate resets all changes to the "ApplicationEndDate" field.
func (m *ExamCalendarMutation) ResetApplicationEndDate() {
	m._ApplicationEndDate = nil
}

// SetApprovedOrderDate sets the "ApprovedOrderDate" field.
func (m *ExamCalendarMutation) SetApprovedOrderDate(t time.Time) {
	m._ApprovedOrderDate = &t
}

// ApprovedOrderDate returns the value of the "ApprovedOrderDate" field in the mutation.
func (m *ExamCalendarMutation) ApprovedOrderDate() (r time.Time, exists bool) {
	v := m._ApprovedOrderDate
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedOrderDate returns the old "ApprovedOrderDate" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldApprovedOrderDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedOrderDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedOrderDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedOrderDate: %w", err)
	}
	return oldValue.ApprovedOrderDate, nil
}

// ResetApprovedOrderDate resets all changes to the "ApprovedOrderDate" field.
func (m *ExamCalendarMutation) ResetApprovedOrderDate() {
	m._ApprovedOrderDate = nil
}

// SetTentativeResultDate sets the "TentativeResultDate" field.
func (m *ExamCalendarMutation) SetTentativeResultDate(t time.Time) {
	m._TentativeResultDate = &t
}

// TentativeResultDate returns the value of the "TentativeResultDate" field in the mutation.
func (m *ExamCalendarMutation) TentativeResultDate() (r time.Time, exists bool) {
	v := m._TentativeResultDate
	if v == nil {
		return
	}
	return *v, true
}

// OldTentativeResultDate returns the old "TentativeResultDate" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldTentativeResultDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTentativeResultDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTentativeResultDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTentativeResultDate: %w", err)
	}
	return oldValue.TentativeResultDate, nil
}

// ClearTentativeResultDate clears the value of the "TentativeResultDate" field.
func (m *ExamCalendarMutation) ClearTentativeResultDate() {
	m._TentativeResultDate = nil
	m.clearedFields[examcalendar.FieldTentativeResultDate] = struct{}{}
}

// TentativeResultDateCleared returns if the "TentativeResultDate" field was cleared in this mutation.
func (m *ExamCalendarMutation) TentativeResultDateCleared() bool {
	_, ok := m.clearedFields[examcalendar.FieldTentativeResultDate]
	return ok
}

// ResetTentativeResultDate resets all changes to the "TentativeResultDate" field.
func (m *ExamCalendarMutation) ResetTentativeResultDate() {
	m._TentativeResultDate = nil
	delete(m.clearedFields, examcalendar.FieldTentativeResultDate)
}

// SetCreatedDate sets the "CreatedDate" field.
func (m *ExamCalendarMutation) SetCreatedDate(t time.Time) {
	m._CreatedDate = &t
}

// CreatedDate returns the value of the "CreatedDate" field in the mutation.
func (m *ExamCalendarMutation) CreatedDate() (r time.Time, exists bool) {
	v := m._CreatedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "CreatedDate" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ResetCreatedDate resets all changes to the "CreatedDate" field.
func (m *ExamCalendarMutation) ResetCreatedDate() {
	m._CreatedDate = nil
}

// SetApprovedOrderNumber sets the "ApprovedOrderNumber" field.
func (m *ExamCalendarMutation) SetApprovedOrderNumber(s string) {
	m._ApprovedOrderNumber = &s
}

// ApprovedOrderNumber returns the value of the "ApprovedOrderNumber" field in the mutation.
func (m *ExamCalendarMutation) ApprovedOrderNumber() (r string, exists bool) {
	v := m._ApprovedOrderNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedOrderNumber returns the old "ApprovedOrderNumber" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldApprovedOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedOrderNumber: %w", err)
	}
	return oldValue.ApprovedOrderNumber, nil
}

// ResetApprovedOrderNumber resets all changes to the "ApprovedOrderNumber" field.
func (m *ExamCalendarMutation) ResetApprovedOrderNumber() {
	m._ApprovedOrderNumber = nil
}

// SetVacancyYears sets the "VacancyYears" field.
func (m *ExamCalendarMutation) SetVacancyYears(i []interface{}) {
	m._VacancyYears = &i
	m.append_VacancyYears = nil
}

// VacancyYears returns the value of the "VacancyYears" field in the mutation.
func (m *ExamCalendarMutation) VacancyYears() (r []interface{}, exists bool) {
	v := m._VacancyYears
	if v == nil {
		return
	}
	return *v, true
}

// OldVacancyYears returns the old "VacancyYears" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldVacancyYears(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVacancyYears is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVacancyYears requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVacancyYears: %w", err)
	}
	return oldValue.VacancyYears, nil
}

// AppendVacancyYears adds i to the "VacancyYears" field.
func (m *ExamCalendarMutation) AppendVacancyYears(i []interface{}) {
	m.append_VacancyYears = append(m.append_VacancyYears, i...)
}

// AppendedVacancyYears returns the list of values that were appended to the "VacancyYears" field in this mutation.
func (m *ExamCalendarMutation) AppendedVacancyYears() ([]interface{}, bool) {
	if len(m.append_VacancyYears) == 0 {
		return nil, false
	}
	return m.append_VacancyYears, true
}

// ClearVacancyYears clears the value of the "VacancyYears" field.
func (m *ExamCalendarMutation) ClearVacancyYears() {
	m._VacancyYears = nil
	m.append_VacancyYears = nil
	m.clearedFields[examcalendar.FieldVacancyYears] = struct{}{}
}

// VacancyYearsCleared returns if the "VacancyYears" field was cleared in this mutation.
func (m *ExamCalendarMutation) VacancyYearsCleared() bool {
	_, ok := m.clearedFields[examcalendar.FieldVacancyYears]
	return ok
}

// ResetVacancyYears resets all changes to the "VacancyYears" field.
func (m *ExamCalendarMutation) ResetVacancyYears() {
	m._VacancyYears = nil
	m.append_VacancyYears = nil
	delete(m.clearedFields, examcalendar.FieldVacancyYears)
}

// SetExamPapers sets the "ExamPapers" field.
func (m *ExamCalendarMutation) SetExamPapers(i []interface{}) {
	m._ExamPapers = &i
	m.append_ExamPapers = nil
}

// ExamPapers returns the value of the "ExamPapers" field in the mutation.
func (m *ExamCalendarMutation) ExamPapers() (r []interface{}, exists bool) {
	v := m._ExamPapers
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPapers returns the old "ExamPapers" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldExamPapers(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPapers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPapers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPapers: %w", err)
	}
	return oldValue.ExamPapers, nil
}

// AppendExamPapers adds i to the "ExamPapers" field.
func (m *ExamCalendarMutation) AppendExamPapers(i []interface{}) {
	m.append_ExamPapers = append(m.append_ExamPapers, i...)
}

// AppendedExamPapers returns the list of values that were appended to the "ExamPapers" field in this mutation.
func (m *ExamCalendarMutation) AppendedExamPapers() ([]interface{}, bool) {
	if len(m.append_ExamPapers) == 0 {
		return nil, false
	}
	return m.append_ExamPapers, true
}

// ClearExamPapers clears the value of the "ExamPapers" field.
func (m *ExamCalendarMutation) ClearExamPapers() {
	m._ExamPapers = nil
	m.append_ExamPapers = nil
	m.clearedFields[examcalendar.FieldExamPapers] = struct{}{}
}

// ExamPapersCleared returns if the "ExamPapers" field was cleared in this mutation.
func (m *ExamCalendarMutation) ExamPapersCleared() bool {
	_, ok := m.clearedFields[examcalendar.FieldExamPapers]
	return ok
}

// ResetExamPapers resets all changes to the "ExamPapers" field.
func (m *ExamCalendarMutation) ResetExamPapers() {
	m._ExamPapers = nil
	m.append_ExamPapers = nil
	delete(m.clearedFields, examcalendar.FieldExamPapers)
}

// SetVacancyYearCode sets the "VacancyYearCode" field.
func (m *ExamCalendarMutation) SetVacancyYearCode(i int32) {
	m.vcy_years = &i
}

// VacancyYearCode returns the value of the "VacancyYearCode" field in the mutation.
func (m *ExamCalendarMutation) VacancyYearCode() (r int32, exists bool) {
	v := m.vcy_years
	if v == nil {
		return
	}
	return *v, true
}

// OldVacancyYearCode returns the old "VacancyYearCode" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldVacancyYearCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVacancyYearCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVacancyYearCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVacancyYearCode: %w", err)
	}
	return oldValue.VacancyYearCode, nil
}

// ClearVacancyYearCode clears the value of the "VacancyYearCode" field.
func (m *ExamCalendarMutation) ClearVacancyYearCode() {
	m.vcy_years = nil
	m.clearedFields[examcalendar.FieldVacancyYearCode] = struct{}{}
}

// VacancyYearCodeCleared returns if the "VacancyYearCode" field was cleared in this mutation.
func (m *ExamCalendarMutation) VacancyYearCodeCleared() bool {
	_, ok := m.clearedFields[examcalendar.FieldVacancyYearCode]
	return ok
}

// ResetVacancyYearCode resets all changes to the "VacancyYearCode" field.
func (m *ExamCalendarMutation) ResetVacancyYearCode() {
	m.vcy_years = nil
	delete(m.clearedFields, examcalendar.FieldVacancyYearCode)
}

// SetPaperCode sets the "PaperCode" field.
func (m *ExamCalendarMutation) SetPaperCode(i int32) {
	m.papers = &i
}

// PaperCode returns the value of the "PaperCode" field in the mutation.
func (m *ExamCalendarMutation) PaperCode() (r int32, exists bool) {
	v := m.papers
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperCode returns the old "PaperCode" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldPaperCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperCode: %w", err)
	}
	return oldValue.PaperCode, nil
}

// ClearPaperCode clears the value of the "PaperCode" field.
func (m *ExamCalendarMutation) ClearPaperCode() {
	m.papers = nil
	m.clearedFields[examcalendar.FieldPaperCode] = struct{}{}
}

// PaperCodeCleared returns if the "PaperCode" field was cleared in this mutation.
func (m *ExamCalendarMutation) PaperCodeCleared() bool {
	_, ok := m.clearedFields[examcalendar.FieldPaperCode]
	return ok
}

// ResetPaperCode resets all changes to the "PaperCode" field.
func (m *ExamCalendarMutation) ResetPaperCode() {
	m.papers = nil
	delete(m.clearedFields, examcalendar.FieldPaperCode)
}

// SetExamCodePS sets the "ExamCodePS" field.
func (m *ExamCalendarMutation) SetExamCodePS(i int32) {
	m._ExamCodePS = &i
	m.add_ExamCodePS = nil
}

// ExamCodePS returns the value of the "ExamCodePS" field in the mutation.
func (m *ExamCalendarMutation) ExamCodePS() (r int32, exists bool) {
	v := m._ExamCodePS
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCodePS returns the old "ExamCodePS" field's value of the ExamCalendar entity.
// If the ExamCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamCalendarMutation) OldExamCodePS(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCodePS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCodePS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCodePS: %w", err)
	}
	return oldValue.ExamCodePS, nil
}

// AddExamCodePS adds i to the "ExamCodePS" field.
func (m *ExamCalendarMutation) AddExamCodePS(i int32) {
	if m.add_ExamCodePS != nil {
		*m.add_ExamCodePS += i
	} else {
		m.add_ExamCodePS = &i
	}
}

// AddedExamCodePS returns the value that was added to the "ExamCodePS" field in this mutation.
func (m *ExamCalendarMutation) AddedExamCodePS() (r int32, exists bool) {
	v := m.add_ExamCodePS
	if v == nil {
		return
	}
	return *v, true
}

// ClearExamCodePS clears the value of the "ExamCodePS" field.
func (m *ExamCalendarMutation) ClearExamCodePS() {
	m._ExamCodePS = nil
	m.add_ExamCodePS = nil
	m.clearedFields[examcalendar.FieldExamCodePS] = struct{}{}
}

// ExamCodePSCleared returns if the "ExamCodePS" field was cleared in this mutation.
func (m *ExamCalendarMutation) ExamCodePSCleared() bool {
	_, ok := m.clearedFields[examcalendar.FieldExamCodePS]
	return ok
}

// ResetExamCodePS resets all changes to the "ExamCodePS" field.
func (m *ExamCalendarMutation) ResetExamCodePS() {
	m._ExamCodePS = nil
	m.add_ExamCodePS = nil
	delete(m.clearedFields, examcalendar.FieldExamCodePS)
}

// SetVcyYearsID sets the "vcy_years" edge to the VacancyYear entity by id.
func (m *ExamCalendarMutation) SetVcyYearsID(id int32) {
	m.vcy_years = &id
}

// ClearVcyYears clears the "vcy_years" edge to the VacancyYear entity.
func (m *ExamCalendarMutation) ClearVcyYears() {
	m.clearedvcy_years = true
}

// VcyYearsCleared reports if the "vcy_years" edge to the VacancyYear entity was cleared.
func (m *ExamCalendarMutation) VcyYearsCleared() bool {
	return m.VacancyYearCodeCleared() || m.clearedvcy_years
}

// VcyYearsID returns the "vcy_years" edge ID in the mutation.
func (m *ExamCalendarMutation) VcyYearsID() (id int32, exists bool) {
	if m.vcy_years != nil {
		return *m.vcy_years, true
	}
	return
}

// VcyYearsIDs returns the "vcy_years" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VcyYearsID instead. It exists only for internal usage by the builders.
func (m *ExamCalendarMutation) VcyYearsIDs() (ids []int32) {
	if id := m.vcy_years; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVcyYears resets all changes to the "vcy_years" edge.
func (m *ExamCalendarMutation) ResetVcyYears() {
	m.vcy_years = nil
	m.clearedvcy_years = false
}

// SetExamsID sets the "exams" edge to the Exam entity by id.
func (m *ExamCalendarMutation) SetExamsID(id int32) {
	m.exams = &id
}

// ClearExams clears the "exams" edge to the Exam entity.
func (m *ExamCalendarMutation) ClearExams() {
	m.clearedexams = true
}

// ExamsCleared reports if the "exams" edge to the Exam entity was cleared.
func (m *ExamCalendarMutation) ExamsCleared() bool {
	return m.ExamCodeCleared() || m.clearedexams
}

// ExamsID returns the "exams" edge ID in the mutation.
func (m *ExamCalendarMutation) ExamsID() (id int32, exists bool) {
	if m.exams != nil {
		return *m.exams, true
	}
	return
}

// ExamsIDs returns the "exams" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamsID instead. It exists only for internal usage by the builders.
func (m *ExamCalendarMutation) ExamsIDs() (ids []int32) {
	if id := m.exams; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExams resets all changes to the "exams" edge.
func (m *ExamCalendarMutation) ResetExams() {
	m.exams = nil
	m.clearedexams = false
}

// SetPapersID sets the "papers" edge to the ExamPapers entity by id.
func (m *ExamCalendarMutation) SetPapersID(id int32) {
	m.papers = &id
}

// ClearPapers clears the "papers" edge to the ExamPapers entity.
func (m *ExamCalendarMutation) ClearPapers() {
	m.clearedpapers = true
}

// PapersCleared reports if the "papers" edge to the ExamPapers entity was cleared.
func (m *ExamCalendarMutation) PapersCleared() bool {
	return m.PaperCodeCleared() || m.clearedpapers
}

// PapersID returns the "papers" edge ID in the mutation.
func (m *ExamCalendarMutation) PapersID() (id int32, exists bool) {
	if m.papers != nil {
		return *m.papers, true
	}
	return
}

// PapersIDs returns the "papers" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PapersID instead. It exists only for internal usage by the builders.
func (m *ExamCalendarMutation) PapersIDs() (ids []int32) {
	if id := m.papers; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPapers resets all changes to the "papers" edge.
func (m *ExamCalendarMutation) ResetPapers() {
	m.papers = nil
	m.clearedpapers = false
}

// AddNotifyRefIDs adds the "Notify_ref" edge to the Notification entity by ids.
func (m *ExamCalendarMutation) AddNotifyRefIDs(ids ...int32) {
	if m._Notify_ref == nil {
		m._Notify_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m._Notify_ref[ids[i]] = struct{}{}
	}
}

// ClearNotifyRef clears the "Notify_ref" edge to the Notification entity.
func (m *ExamCalendarMutation) ClearNotifyRef() {
	m.cleared_Notify_ref = true
}

// NotifyRefCleared reports if the "Notify_ref" edge to the Notification entity was cleared.
func (m *ExamCalendarMutation) NotifyRefCleared() bool {
	return m.cleared_Notify_ref
}

// RemoveNotifyRefIDs removes the "Notify_ref" edge to the Notification entity by IDs.
func (m *ExamCalendarMutation) RemoveNotifyRefIDs(ids ...int32) {
	if m.removed_Notify_ref == nil {
		m.removed_Notify_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m._Notify_ref, ids[i])
		m.removed_Notify_ref[ids[i]] = struct{}{}
	}
}

// RemovedNotifyRef returns the removed IDs of the "Notify_ref" edge to the Notification entity.
func (m *ExamCalendarMutation) RemovedNotifyRefIDs() (ids []int32) {
	for id := range m.removed_Notify_ref {
		ids = append(ids, id)
	}
	return
}

// NotifyRefIDs returns the "Notify_ref" edge IDs in the mutation.
func (m *ExamCalendarMutation) NotifyRefIDs() (ids []int32) {
	for id := range m._Notify_ref {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyRef resets all changes to the "Notify_ref" edge.
func (m *ExamCalendarMutation) ResetNotifyRef() {
	m._Notify_ref = nil
	m.cleared_Notify_ref = false
	m.removed_Notify_ref = nil
}

// AddExamcalPsRefIDs adds the "examcal_ps_ref" edge to the Exam_PS entity by ids.
func (m *ExamCalendarMutation) AddExamcalPsRefIDs(ids ...int32) {
	if m.examcal_ps_ref == nil {
		m.examcal_ps_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.examcal_ps_ref[ids[i]] = struct{}{}
	}
}

// ClearExamcalPsRef clears the "examcal_ps_ref" edge to the Exam_PS entity.
func (m *ExamCalendarMutation) ClearExamcalPsRef() {
	m.clearedexamcal_ps_ref = true
}

// ExamcalPsRefCleared reports if the "examcal_ps_ref" edge to the Exam_PS entity was cleared.
func (m *ExamCalendarMutation) ExamcalPsRefCleared() bool {
	return m.clearedexamcal_ps_ref
}

// RemoveExamcalPsRefIDs removes the "examcal_ps_ref" edge to the Exam_PS entity by IDs.
func (m *ExamCalendarMutation) RemoveExamcalPsRefIDs(ids ...int32) {
	if m.removedexamcal_ps_ref == nil {
		m.removedexamcal_ps_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.examcal_ps_ref, ids[i])
		m.removedexamcal_ps_ref[ids[i]] = struct{}{}
	}
}

// RemovedExamcalPsRef returns the removed IDs of the "examcal_ps_ref" edge to the Exam_PS entity.
func (m *ExamCalendarMutation) RemovedExamcalPsRefIDs() (ids []int32) {
	for id := range m.removedexamcal_ps_ref {
		ids = append(ids, id)
	}
	return
}

// ExamcalPsRefIDs returns the "examcal_ps_ref" edge IDs in the mutation.
func (m *ExamCalendarMutation) ExamcalPsRefIDs() (ids []int32) {
	for id := range m.examcal_ps_ref {
		ids = append(ids, id)
	}
	return
}

// ResetExamcalPsRef resets all changes to the "examcal_ps_ref" edge.
func (m *ExamCalendarMutation) ResetExamcalPsRef() {
	m.examcal_ps_ref = nil
	m.clearedexamcal_ps_ref = false
	m.removedexamcal_ps_ref = nil
}

// AddExamcalIPRefIDs adds the "examcal_ip_ref" edge to the Exam_IP entity by ids.
func (m *ExamCalendarMutation) AddExamcalIPRefIDs(ids ...int32) {
	if m.examcal_ip_ref == nil {
		m.examcal_ip_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.examcal_ip_ref[ids[i]] = struct{}{}
	}
}

// ClearExamcalIPRef clears the "examcal_ip_ref" edge to the Exam_IP entity.
func (m *ExamCalendarMutation) ClearExamcalIPRef() {
	m.clearedexamcal_ip_ref = true
}

// ExamcalIPRefCleared reports if the "examcal_ip_ref" edge to the Exam_IP entity was cleared.
func (m *ExamCalendarMutation) ExamcalIPRefCleared() bool {
	return m.clearedexamcal_ip_ref
}

// RemoveExamcalIPRefIDs removes the "examcal_ip_ref" edge to the Exam_IP entity by IDs.
func (m *ExamCalendarMutation) RemoveExamcalIPRefIDs(ids ...int32) {
	if m.removedexamcal_ip_ref == nil {
		m.removedexamcal_ip_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.examcal_ip_ref, ids[i])
		m.removedexamcal_ip_ref[ids[i]] = struct{}{}
	}
}

// RemovedExamcalIPRef returns the removed IDs of the "examcal_ip_ref" edge to the Exam_IP entity.
func (m *ExamCalendarMutation) RemovedExamcalIPRefIDs() (ids []int32) {
	for id := range m.removedexamcal_ip_ref {
		ids = append(ids, id)
	}
	return
}

// ExamcalIPRefIDs returns the "examcal_ip_ref" edge IDs in the mutation.
func (m *ExamCalendarMutation) ExamcalIPRefIDs() (ids []int32) {
	for id := range m.examcal_ip_ref {
		ids = append(ids, id)
	}
	return
}

// ResetExamcalIPRef resets all changes to the "examcal_ip_ref" edge.
func (m *ExamCalendarMutation) ResetExamcalIPRef() {
	m.examcal_ip_ref = nil
	m.clearedexamcal_ip_ref = false
	m.removedexamcal_ip_ref = nil
}

// Where appends a list predicates to the ExamCalendarMutation builder.
func (m *ExamCalendarMutation) Where(ps ...predicate.ExamCalendar) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExamCalendarMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExamCalendarMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExamCalendar, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExamCalendarMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExamCalendarMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExamCalendar).
func (m *ExamCalendarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExamCalendarMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m._ExamYear != nil {
		fields = append(fields, examcalendar.FieldExamYear)
	}
	if m._ExamName != nil {
		fields = append(fields, examcalendar.FieldExamName)
	}
	if m.exams != nil {
		fields = append(fields, examcalendar.FieldExamCode)
	}
	if m._NotificationDate != nil {
		fields = append(fields, examcalendar.FieldNotificationDate)
	}
	if m._ModelNotificationDate != nil {
		fields = append(fields, examcalendar.FieldModelNotificationDate)
	}
	if m._ApplicationEndDate != nil {
		fields = append(fields, examcalendar.FieldApplicationEndDate)
	}
	if m._ApprovedOrderDate != nil {
		fields = append(fields, examcalendar.FieldApprovedOrderDate)
	}
	if m._TentativeResultDate != nil {
		fields = append(fields, examcalendar.FieldTentativeResultDate)
	}
	if m._CreatedDate != nil {
		fields = append(fields, examcalendar.FieldCreatedDate)
	}
	if m._ApprovedOrderNumber != nil {
		fields = append(fields, examcalendar.FieldApprovedOrderNumber)
	}
	if m._VacancyYears != nil {
		fields = append(fields, examcalendar.FieldVacancyYears)
	}
	if m._ExamPapers != nil {
		fields = append(fields, examcalendar.FieldExamPapers)
	}
	if m.vcy_years != nil {
		fields = append(fields, examcalendar.FieldVacancyYearCode)
	}
	if m.papers != nil {
		fields = append(fields, examcalendar.FieldPaperCode)
	}
	if m._ExamCodePS != nil {
		fields = append(fields, examcalendar.FieldExamCodePS)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExamCalendarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case examcalendar.FieldExamYear:
		return m.ExamYear()
	case examcalendar.FieldExamName:
		return m.ExamName()
	case examcalendar.FieldExamCode:
		return m.ExamCode()
	case examcalendar.FieldNotificationDate:
		return m.NotificationDate()
	case examcalendar.FieldModelNotificationDate:
		return m.ModelNotificationDate()
	case examcalendar.FieldApplicationEndDate:
		return m.ApplicationEndDate()
	case examcalendar.FieldApprovedOrderDate:
		return m.ApprovedOrderDate()
	case examcalendar.FieldTentativeResultDate:
		return m.TentativeResultDate()
	case examcalendar.FieldCreatedDate:
		return m.CreatedDate()
	case examcalendar.FieldApprovedOrderNumber:
		return m.ApprovedOrderNumber()
	case examcalendar.FieldVacancyYears:
		return m.VacancyYears()
	case examcalendar.FieldExamPapers:
		return m.ExamPapers()
	case examcalendar.FieldVacancyYearCode:
		return m.VacancyYearCode()
	case examcalendar.FieldPaperCode:
		return m.PaperCode()
	case examcalendar.FieldExamCodePS:
		return m.ExamCodePS()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExamCalendarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case examcalendar.FieldExamYear:
		return m.OldExamYear(ctx)
	case examcalendar.FieldExamName:
		return m.OldExamName(ctx)
	case examcalendar.FieldExamCode:
		return m.OldExamCode(ctx)
	case examcalendar.FieldNotificationDate:
		return m.OldNotificationDate(ctx)
	case examcalendar.FieldModelNotificationDate:
		return m.OldModelNotificationDate(ctx)
	case examcalendar.FieldApplicationEndDate:
		return m.OldApplicationEndDate(ctx)
	case examcalendar.FieldApprovedOrderDate:
		return m.OldApprovedOrderDate(ctx)
	case examcalendar.FieldTentativeResultDate:
		return m.OldTentativeResultDate(ctx)
	case examcalendar.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	case examcalendar.FieldApprovedOrderNumber:
		return m.OldApprovedOrderNumber(ctx)
	case examcalendar.FieldVacancyYears:
		return m.OldVacancyYears(ctx)
	case examcalendar.FieldExamPapers:
		return m.OldExamPapers(ctx)
	case examcalendar.FieldVacancyYearCode:
		return m.OldVacancyYearCode(ctx)
	case examcalendar.FieldPaperCode:
		return m.OldPaperCode(ctx)
	case examcalendar.FieldExamCodePS:
		return m.OldExamCodePS(ctx)
	}
	return nil, fmt.Errorf("unknown ExamCalendar field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamCalendarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case examcalendar.FieldExamYear:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamYear(v)
		return nil
	case examcalendar.FieldExamName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamName(v)
		return nil
	case examcalendar.FieldExamCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCode(v)
		return nil
	case examcalendar.FieldNotificationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotificationDate(v)
		return nil
	case examcalendar.FieldModelNotificationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelNotificationDate(v)
		return nil
	case examcalendar.FieldApplicationEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationEndDate(v)
		return nil
	case examcalendar.FieldApprovedOrderDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedOrderDate(v)
		return nil
	case examcalendar.FieldTentativeResultDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTentativeResultDate(v)
		return nil
	case examcalendar.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	case examcalendar.FieldApprovedOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedOrderNumber(v)
		return nil
	case examcalendar.FieldVacancyYears:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVacancyYears(v)
		return nil
	case examcalendar.FieldExamPapers:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPapers(v)
		return nil
	case examcalendar.FieldVacancyYearCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVacancyYearCode(v)
		return nil
	case examcalendar.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperCode(v)
		return nil
	case examcalendar.FieldExamCodePS:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCodePS(v)
		return nil
	}
	return fmt.Errorf("unknown ExamCalendar field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExamCalendarMutation) AddedFields() []string {
	var fields []string
	if m.add_ExamYear != nil {
		fields = append(fields, examcalendar.FieldExamYear)
	}
	if m.add_ExamCodePS != nil {
		fields = append(fields, examcalendar.FieldExamCodePS)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExamCalendarMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case examcalendar.FieldExamYear:
		return m.AddedExamYear()
	case examcalendar.FieldExamCodePS:
		return m.AddedExamCodePS()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamCalendarMutation) AddField(name string, value ent.Value) error {
	switch name {
	case examcalendar.FieldExamYear:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamYear(v)
		return nil
	case examcalendar.FieldExamCodePS:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamCodePS(v)
		return nil
	}
	return fmt.Errorf("unknown ExamCalendar numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExamCalendarMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(examcalendar.FieldExamCode) {
		fields = append(fields, examcalendar.FieldExamCode)
	}
	if m.FieldCleared(examcalendar.FieldTentativeResultDate) {
		fields = append(fields, examcalendar.FieldTentativeResultDate)
	}
	if m.FieldCleared(examcalendar.FieldVacancyYears) {
		fields = append(fields, examcalendar.FieldVacancyYears)
	}
	if m.FieldCleared(examcalendar.FieldExamPapers) {
		fields = append(fields, examcalendar.FieldExamPapers)
	}
	if m.FieldCleared(examcalendar.FieldVacancyYearCode) {
		fields = append(fields, examcalendar.FieldVacancyYearCode)
	}
	if m.FieldCleared(examcalendar.FieldPaperCode) {
		fields = append(fields, examcalendar.FieldPaperCode)
	}
	if m.FieldCleared(examcalendar.FieldExamCodePS) {
		fields = append(fields, examcalendar.FieldExamCodePS)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExamCalendarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExamCalendarMutation) ClearField(name string) error {
	switch name {
	case examcalendar.FieldExamCode:
		m.ClearExamCode()
		return nil
	case examcalendar.FieldTentativeResultDate:
		m.ClearTentativeResultDate()
		return nil
	case examcalendar.FieldVacancyYears:
		m.ClearVacancyYears()
		return nil
	case examcalendar.FieldExamPapers:
		m.ClearExamPapers()
		return nil
	case examcalendar.FieldVacancyYearCode:
		m.ClearVacancyYearCode()
		return nil
	case examcalendar.FieldPaperCode:
		m.ClearPaperCode()
		return nil
	case examcalendar.FieldExamCodePS:
		m.ClearExamCodePS()
		return nil
	}
	return fmt.Errorf("unknown ExamCalendar nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExamCalendarMutation) ResetField(name string) error {
	switch name {
	case examcalendar.FieldExamYear:
		m.ResetExamYear()
		return nil
	case examcalendar.FieldExamName:
		m.ResetExamName()
		return nil
	case examcalendar.FieldExamCode:
		m.ResetExamCode()
		return nil
	case examcalendar.FieldNotificationDate:
		m.ResetNotificationDate()
		return nil
	case examcalendar.FieldModelNotificationDate:
		m.ResetModelNotificationDate()
		return nil
	case examcalendar.FieldApplicationEndDate:
		m.ResetApplicationEndDate()
		return nil
	case examcalendar.FieldApprovedOrderDate:
		m.ResetApprovedOrderDate()
		return nil
	case examcalendar.FieldTentativeResultDate:
		m.ResetTentativeResultDate()
		return nil
	case examcalendar.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	case examcalendar.FieldApprovedOrderNumber:
		m.ResetApprovedOrderNumber()
		return nil
	case examcalendar.FieldVacancyYears:
		m.ResetVacancyYears()
		return nil
	case examcalendar.FieldExamPapers:
		m.ResetExamPapers()
		return nil
	case examcalendar.FieldVacancyYearCode:
		m.ResetVacancyYearCode()
		return nil
	case examcalendar.FieldPaperCode:
		m.ResetPaperCode()
		return nil
	case examcalendar.FieldExamCodePS:
		m.ResetExamCodePS()
		return nil
	}
	return fmt.Errorf("unknown ExamCalendar field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExamCalendarMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.vcy_years != nil {
		edges = append(edges, examcalendar.EdgeVcyYears)
	}
	if m.exams != nil {
		edges = append(edges, examcalendar.EdgeExams)
	}
	if m.papers != nil {
		edges = append(edges, examcalendar.EdgePapers)
	}
	if m._Notify_ref != nil {
		edges = append(edges, examcalendar.EdgeNotifyRef)
	}
	if m.examcal_ps_ref != nil {
		edges = append(edges, examcalendar.EdgeExamcalPsRef)
	}
	if m.examcal_ip_ref != nil {
		edges = append(edges, examcalendar.EdgeExamcalIPRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExamCalendarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case examcalendar.EdgeVcyYears:
		if id := m.vcy_years; id != nil {
			return []ent.Value{*id}
		}
	case examcalendar.EdgeExams:
		if id := m.exams; id != nil {
			return []ent.Value{*id}
		}
	case examcalendar.EdgePapers:
		if id := m.papers; id != nil {
			return []ent.Value{*id}
		}
	case examcalendar.EdgeNotifyRef:
		ids := make([]ent.Value, 0, len(m._Notify_ref))
		for id := range m._Notify_ref {
			ids = append(ids, id)
		}
		return ids
	case examcalendar.EdgeExamcalPsRef:
		ids := make([]ent.Value, 0, len(m.examcal_ps_ref))
		for id := range m.examcal_ps_ref {
			ids = append(ids, id)
		}
		return ids
	case examcalendar.EdgeExamcalIPRef:
		ids := make([]ent.Value, 0, len(m.examcal_ip_ref))
		for id := range m.examcal_ip_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExamCalendarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removed_Notify_ref != nil {
		edges = append(edges, examcalendar.EdgeNotifyRef)
	}
	if m.removedexamcal_ps_ref != nil {
		edges = append(edges, examcalendar.EdgeExamcalPsRef)
	}
	if m.removedexamcal_ip_ref != nil {
		edges = append(edges, examcalendar.EdgeExamcalIPRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExamCalendarMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case examcalendar.EdgeNotifyRef:
		ids := make([]ent.Value, 0, len(m.removed_Notify_ref))
		for id := range m.removed_Notify_ref {
			ids = append(ids, id)
		}
		return ids
	case examcalendar.EdgeExamcalPsRef:
		ids := make([]ent.Value, 0, len(m.removedexamcal_ps_ref))
		for id := range m.removedexamcal_ps_ref {
			ids = append(ids, id)
		}
		return ids
	case examcalendar.EdgeExamcalIPRef:
		ids := make([]ent.Value, 0, len(m.removedexamcal_ip_ref))
		for id := range m.removedexamcal_ip_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExamCalendarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedvcy_years {
		edges = append(edges, examcalendar.EdgeVcyYears)
	}
	if m.clearedexams {
		edges = append(edges, examcalendar.EdgeExams)
	}
	if m.clearedpapers {
		edges = append(edges, examcalendar.EdgePapers)
	}
	if m.cleared_Notify_ref {
		edges = append(edges, examcalendar.EdgeNotifyRef)
	}
	if m.clearedexamcal_ps_ref {
		edges = append(edges, examcalendar.EdgeExamcalPsRef)
	}
	if m.clearedexamcal_ip_ref {
		edges = append(edges, examcalendar.EdgeExamcalIPRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExamCalendarMutation) EdgeCleared(name string) bool {
	switch name {
	case examcalendar.EdgeVcyYears:
		return m.clearedvcy_years
	case examcalendar.EdgeExams:
		return m.clearedexams
	case examcalendar.EdgePapers:
		return m.clearedpapers
	case examcalendar.EdgeNotifyRef:
		return m.cleared_Notify_ref
	case examcalendar.EdgeExamcalPsRef:
		return m.clearedexamcal_ps_ref
	case examcalendar.EdgeExamcalIPRef:
		return m.clearedexamcal_ip_ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExamCalendarMutation) ClearEdge(name string) error {
	switch name {
	case examcalendar.EdgeVcyYears:
		m.ClearVcyYears()
		return nil
	case examcalendar.EdgeExams:
		m.ClearExams()
		return nil
	case examcalendar.EdgePapers:
		m.ClearPapers()
		return nil
	}
	return fmt.Errorf("unknown ExamCalendar unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExamCalendarMutation) ResetEdge(name string) error {
	switch name {
	case examcalendar.EdgeVcyYears:
		m.ResetVcyYears()
		return nil
	case examcalendar.EdgeExams:
		m.ResetExams()
		return nil
	case examcalendar.EdgePapers:
		m.ResetPapers()
		return nil
	case examcalendar.EdgeNotifyRef:
		m.ResetNotifyRef()
		return nil
	case examcalendar.EdgeExamcalPsRef:
		m.ResetExamcalPsRef()
		return nil
	case examcalendar.EdgeExamcalIPRef:
		m.ResetExamcalIPRef()
		return nil
	}
	return fmt.Errorf("unknown ExamCalendar edge %s", name)
}

// ExamPapersMutation represents an operation that mutates the ExamPapers nodes in the graph.
type ExamPapersMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int32
	_PaperDescription                 *string
	_CompetitiveQualifying            *bool
	_ExceptionForDisability           *bool
	_MaximumMarks                     *int
	add_MaximumMarks                  *int
	_Duration                         *int
	add_Duration                      *int
	localLanguageAllowedQuestionPaper *string
	localLanguageAllowedAnswerPaper   *string
	_OrderNumber                      *string
	_PaperStatus                      *string
	_CalendarCode                     *int32
	add_CalendarCode                  *int32
	_CreatedDate                      *time.Time
	_PaperTypeCode                    *int32
	add_PaperTypeCode                 *int32
	_PaperTypeName                    *string
	_DisabilityTypeID                 *int32
	add_DisabilityTypeID              *int32
	_ExamCodePS                       *int32
	add_ExamCodePS                    *int32
	clearedFields                     map[string]struct{}
	centers                           map[int32]struct{}
	removedcenters                    map[int32]struct{}
	clearedcenters                    bool
	exam                              *int32
	clearedexam                       bool
	exampapers_types                  map[int32]struct{}
	removedexampapers_types           map[int32]struct{}
	clearedexampapers_types           bool
	papers_ref                        map[int32]struct{}
	removedpapers_ref                 map[int32]struct{}
	clearedpapers_ref                 bool
	_ExamPaperEligibility             map[int32]struct{}
	removed_ExamPaperEligibility      map[int32]struct{}
	cleared_ExamPaperEligibility      bool
	dis_ref                           map[int32]struct{}
	removeddis_ref                    map[int32]struct{}
	cleareddis_ref                    bool
	papers_ps_ref                     map[int32]struct{}
	removedpapers_ps_ref              map[int32]struct{}
	clearedpapers_ps_ref              bool
	papers_ip_ref                     map[int32]struct{}
	removedpapers_ip_ref              map[int32]struct{}
	clearedpapers_ip_ref              bool
	done                              bool
	oldValue                          func(context.Context) (*ExamPapers, error)
	predicates                        []predicate.ExamPapers
}

var _ ent.Mutation = (*ExamPapersMutation)(nil)

// exampapersOption allows management of the mutation configuration using functional options.
type exampapersOption func(*ExamPapersMutation)

// newExamPapersMutation creates new mutation for the ExamPapers entity.
func newExamPapersMutation(c config, op Op, opts ...exampapersOption) *ExamPapersMutation {
	m := &ExamPapersMutation{
		config:        c,
		op:            op,
		typ:           TypeExamPapers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExamPapersID sets the ID field of the mutation.
func withExamPapersID(id int32) exampapersOption {
	return func(m *ExamPapersMutation) {
		var (
			err   error
			once  sync.Once
			value *ExamPapers
		)
		m.oldValue = func(ctx context.Context) (*ExamPapers, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExamPapers.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExamPapers sets the old ExamPapers of the mutation.
func withExamPapers(node *ExamPapers) exampapersOption {
	return func(m *ExamPapersMutation) {
		m.oldValue = func(context.Context) (*ExamPapers, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExamPapersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExamPapersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExamPapers entities.
func (m *ExamPapersMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExamPapersMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExamPapersMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExamPapers.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPaperDescription sets the "PaperDescription" field.
func (m *ExamPapersMutation) SetPaperDescription(s string) {
	m._PaperDescription = &s
}

// PaperDescription returns the value of the "PaperDescription" field in the mutation.
func (m *ExamPapersMutation) PaperDescription() (r string, exists bool) {
	v := m._PaperDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperDescription returns the old "PaperDescription" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldPaperDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperDescription: %w", err)
	}
	return oldValue.PaperDescription, nil
}

// ResetPaperDescription resets all changes to the "PaperDescription" field.
func (m *ExamPapersMutation) ResetPaperDescription() {
	m._PaperDescription = nil
}

// SetExamCode sets the "ExamCode" field.
func (m *ExamPapersMutation) SetExamCode(i int32) {
	m.exam = &i
}

// ExamCode returns the value of the "ExamCode" field in the mutation.
func (m *ExamPapersMutation) ExamCode() (r int32, exists bool) {
	v := m.exam
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCode returns the old "ExamCode" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldExamCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCode: %w", err)
	}
	return oldValue.ExamCode, nil
}

// ClearExamCode clears the value of the "ExamCode" field.
func (m *ExamPapersMutation) ClearExamCode() {
	m.exam = nil
	m.clearedFields[exampapers.FieldExamCode] = struct{}{}
}

// ExamCodeCleared returns if the "ExamCode" field was cleared in this mutation.
func (m *ExamPapersMutation) ExamCodeCleared() bool {
	_, ok := m.clearedFields[exampapers.FieldExamCode]
	return ok
}

// ResetExamCode resets all changes to the "ExamCode" field.
func (m *ExamPapersMutation) ResetExamCode() {
	m.exam = nil
	delete(m.clearedFields, exampapers.FieldExamCode)
}

// SetCompetitiveQualifying sets the "CompetitiveQualifying" field.
func (m *ExamPapersMutation) SetCompetitiveQualifying(b bool) {
	m._CompetitiveQualifying = &b
}

// CompetitiveQualifying returns the value of the "CompetitiveQualifying" field in the mutation.
func (m *ExamPapersMutation) CompetitiveQualifying() (r bool, exists bool) {
	v := m._CompetitiveQualifying
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitiveQualifying returns the old "CompetitiveQualifying" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldCompetitiveQualifying(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitiveQualifying is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitiveQualifying requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitiveQualifying: %w", err)
	}
	return oldValue.CompetitiveQualifying, nil
}

// ResetCompetitiveQualifying resets all changes to the "CompetitiveQualifying" field.
func (m *ExamPapersMutation) ResetCompetitiveQualifying() {
	m._CompetitiveQualifying = nil
}

// SetExceptionForDisability sets the "ExceptionForDisability" field.
func (m *ExamPapersMutation) SetExceptionForDisability(b bool) {
	m._ExceptionForDisability = &b
}

// ExceptionForDisability returns the value of the "ExceptionForDisability" field in the mutation.
func (m *ExamPapersMutation) ExceptionForDisability() (r bool, exists bool) {
	v := m._ExceptionForDisability
	if v == nil {
		return
	}
	return *v, true
}

// OldExceptionForDisability returns the old "ExceptionForDisability" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldExceptionForDisability(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExceptionForDisability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExceptionForDisability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExceptionForDisability: %w", err)
	}
	return oldValue.ExceptionForDisability, nil
}

// ResetExceptionForDisability resets all changes to the "ExceptionForDisability" field.
func (m *ExamPapersMutation) ResetExceptionForDisability() {
	m._ExceptionForDisability = nil
}

// SetMaximumMarks sets the "MaximumMarks" field.
func (m *ExamPapersMutation) SetMaximumMarks(i int) {
	m._MaximumMarks = &i
	m.add_MaximumMarks = nil
}

// MaximumMarks returns the value of the "MaximumMarks" field in the mutation.
func (m *ExamPapersMutation) MaximumMarks() (r int, exists bool) {
	v := m._MaximumMarks
	if v == nil {
		return
	}
	return *v, true
}

// OldMaximumMarks returns the old "MaximumMarks" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldMaximumMarks(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaximumMarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaximumMarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaximumMarks: %w", err)
	}
	return oldValue.MaximumMarks, nil
}

// AddMaximumMarks adds i to the "MaximumMarks" field.
func (m *ExamPapersMutation) AddMaximumMarks(i int) {
	if m.add_MaximumMarks != nil {
		*m.add_MaximumMarks += i
	} else {
		m.add_MaximumMarks = &i
	}
}

// AddedMaximumMarks returns the value that was added to the "MaximumMarks" field in this mutation.
func (m *ExamPapersMutation) AddedMaximumMarks() (r int, exists bool) {
	v := m.add_MaximumMarks
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaximumMarks resets all changes to the "MaximumMarks" field.
func (m *ExamPapersMutation) ResetMaximumMarks() {
	m._MaximumMarks = nil
	m.add_MaximumMarks = nil
}

// SetDuration sets the "Duration" field.
func (m *ExamPapersMutation) SetDuration(i int) {
	m._Duration = &i
	m.add_Duration = nil
}

// Duration returns the value of the "Duration" field in the mutation.
func (m *ExamPapersMutation) Duration() (r int, exists bool) {
	v := m._Duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "Duration" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "Duration" field.
func (m *ExamPapersMutation) AddDuration(i int) {
	if m.add_Duration != nil {
		*m.add_Duration += i
	} else {
		m.add_Duration = &i
	}
}

// AddedDuration returns the value that was added to the "Duration" field in this mutation.
func (m *ExamPapersMutation) AddedDuration() (r int, exists bool) {
	v := m.add_Duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "Duration" field.
func (m *ExamPapersMutation) ResetDuration() {
	m._Duration = nil
	m.add_Duration = nil
}

// SetLocalLanguageAllowedQuestionPaper sets the "localLanguageAllowedQuestionPaper" field.
func (m *ExamPapersMutation) SetLocalLanguageAllowedQuestionPaper(s string) {
	m.localLanguageAllowedQuestionPaper = &s
}

// LocalLanguageAllowedQuestionPaper returns the value of the "localLanguageAllowedQuestionPaper" field in the mutation.
func (m *ExamPapersMutation) LocalLanguageAllowedQuestionPaper() (r string, exists bool) {
	v := m.localLanguageAllowedQuestionPaper
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalLanguageAllowedQuestionPaper returns the old "localLanguageAllowedQuestionPaper" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldLocalLanguageAllowedQuestionPaper(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalLanguageAllowedQuestionPaper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalLanguageAllowedQuestionPaper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalLanguageAllowedQuestionPaper: %w", err)
	}
	return oldValue.LocalLanguageAllowedQuestionPaper, nil
}

// ResetLocalLanguageAllowedQuestionPaper resets all changes to the "localLanguageAllowedQuestionPaper" field.
func (m *ExamPapersMutation) ResetLocalLanguageAllowedQuestionPaper() {
	m.localLanguageAllowedQuestionPaper = nil
}

// SetLocalLanguageAllowedAnswerPaper sets the "localLanguageAllowedAnswerPaper" field.
func (m *ExamPapersMutation) SetLocalLanguageAllowedAnswerPaper(s string) {
	m.localLanguageAllowedAnswerPaper = &s
}

// LocalLanguageAllowedAnswerPaper returns the value of the "localLanguageAllowedAnswerPaper" field in the mutation.
func (m *ExamPapersMutation) LocalLanguageAllowedAnswerPaper() (r string, exists bool) {
	v := m.localLanguageAllowedAnswerPaper
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalLanguageAllowedAnswerPaper returns the old "localLanguageAllowedAnswerPaper" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldLocalLanguageAllowedAnswerPaper(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalLanguageAllowedAnswerPaper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalLanguageAllowedAnswerPaper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalLanguageAllowedAnswerPaper: %w", err)
	}
	return oldValue.LocalLanguageAllowedAnswerPaper, nil
}

// ResetLocalLanguageAllowedAnswerPaper resets all changes to the "localLanguageAllowedAnswerPaper" field.
func (m *ExamPapersMutation) ResetLocalLanguageAllowedAnswerPaper() {
	m.localLanguageAllowedAnswerPaper = nil
}

// SetOrderNumber sets the "OrderNumber" field.
func (m *ExamPapersMutation) SetOrderNumber(s string) {
	m._OrderNumber = &s
}

// OrderNumber returns the value of the "OrderNumber" field in the mutation.
func (m *ExamPapersMutation) OrderNumber() (r string, exists bool) {
	v := m._OrderNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNumber returns the old "OrderNumber" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNumber: %w", err)
	}
	return oldValue.OrderNumber, nil
}

// ResetOrderNumber resets all changes to the "OrderNumber" field.
func (m *ExamPapersMutation) ResetOrderNumber() {
	m._OrderNumber = nil
}

// SetPaperStatus sets the "PaperStatus" field.
func (m *ExamPapersMutation) SetPaperStatus(s string) {
	m._PaperStatus = &s
}

// PaperStatus returns the value of the "PaperStatus" field in the mutation.
func (m *ExamPapersMutation) PaperStatus() (r string, exists bool) {
	v := m._PaperStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperStatus returns the old "PaperStatus" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldPaperStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperStatus: %w", err)
	}
	return oldValue.PaperStatus, nil
}

// ResetPaperStatus resets all changes to the "PaperStatus" field.
func (m *ExamPapersMutation) ResetPaperStatus() {
	m._PaperStatus = nil
}

// SetCalendarCode sets the "CalendarCode" field.
func (m *ExamPapersMutation) SetCalendarCode(i int32) {
	m._CalendarCode = &i
	m.add_CalendarCode = nil
}

// CalendarCode returns the value of the "CalendarCode" field in the mutation.
func (m *ExamPapersMutation) CalendarCode() (r int32, exists bool) {
	v := m._CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCalendarCode returns the old "CalendarCode" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldCalendarCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalendarCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalendarCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalendarCode: %w", err)
	}
	return oldValue.CalendarCode, nil
}

// AddCalendarCode adds i to the "CalendarCode" field.
func (m *ExamPapersMutation) AddCalendarCode(i int32) {
	if m.add_CalendarCode != nil {
		*m.add_CalendarCode += i
	} else {
		m.add_CalendarCode = &i
	}
}

// AddedCalendarCode returns the value that was added to the "CalendarCode" field in this mutation.
func (m *ExamPapersMutation) AddedCalendarCode() (r int32, exists bool) {
	v := m.add_CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalendarCode clears the value of the "CalendarCode" field.
func (m *ExamPapersMutation) ClearCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	m.clearedFields[exampapers.FieldCalendarCode] = struct{}{}
}

// CalendarCodeCleared returns if the "CalendarCode" field was cleared in this mutation.
func (m *ExamPapersMutation) CalendarCodeCleared() bool {
	_, ok := m.clearedFields[exampapers.FieldCalendarCode]
	return ok
}

// ResetCalendarCode resets all changes to the "CalendarCode" field.
func (m *ExamPapersMutation) ResetCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	delete(m.clearedFields, exampapers.FieldCalendarCode)
}

// SetCreatedDate sets the "CreatedDate" field.
func (m *ExamPapersMutation) SetCreatedDate(t time.Time) {
	m._CreatedDate = &t
}

// CreatedDate returns the value of the "CreatedDate" field in the mutation.
func (m *ExamPapersMutation) CreatedDate() (r time.Time, exists bool) {
	v := m._CreatedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "CreatedDate" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ClearCreatedDate clears the value of the "CreatedDate" field.
func (m *ExamPapersMutation) ClearCreatedDate() {
	m._CreatedDate = nil
	m.clearedFields[exampapers.FieldCreatedDate] = struct{}{}
}

// CreatedDateCleared returns if the "CreatedDate" field was cleared in this mutation.
func (m *ExamPapersMutation) CreatedDateCleared() bool {
	_, ok := m.clearedFields[exampapers.FieldCreatedDate]
	return ok
}

// ResetCreatedDate resets all changes to the "CreatedDate" field.
func (m *ExamPapersMutation) ResetCreatedDate() {
	m._CreatedDate = nil
	delete(m.clearedFields, exampapers.FieldCreatedDate)
}

// SetPaperTypeCode sets the "PaperTypeCode" field.
func (m *ExamPapersMutation) SetPaperTypeCode(i int32) {
	m._PaperTypeCode = &i
	m.add_PaperTypeCode = nil
}

// PaperTypeCode returns the value of the "PaperTypeCode" field in the mutation.
func (m *ExamPapersMutation) PaperTypeCode() (r int32, exists bool) {
	v := m._PaperTypeCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperTypeCode returns the old "PaperTypeCode" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldPaperTypeCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperTypeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperTypeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperTypeCode: %w", err)
	}
	return oldValue.PaperTypeCode, nil
}

// AddPaperTypeCode adds i to the "PaperTypeCode" field.
func (m *ExamPapersMutation) AddPaperTypeCode(i int32) {
	if m.add_PaperTypeCode != nil {
		*m.add_PaperTypeCode += i
	} else {
		m.add_PaperTypeCode = &i
	}
}

// AddedPaperTypeCode returns the value that was added to the "PaperTypeCode" field in this mutation.
func (m *ExamPapersMutation) AddedPaperTypeCode() (r int32, exists bool) {
	v := m.add_PaperTypeCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaperTypeCode clears the value of the "PaperTypeCode" field.
func (m *ExamPapersMutation) ClearPaperTypeCode() {
	m._PaperTypeCode = nil
	m.add_PaperTypeCode = nil
	m.clearedFields[exampapers.FieldPaperTypeCode] = struct{}{}
}

// PaperTypeCodeCleared returns if the "PaperTypeCode" field was cleared in this mutation.
func (m *ExamPapersMutation) PaperTypeCodeCleared() bool {
	_, ok := m.clearedFields[exampapers.FieldPaperTypeCode]
	return ok
}

// ResetPaperTypeCode resets all changes to the "PaperTypeCode" field.
func (m *ExamPapersMutation) ResetPaperTypeCode() {
	m._PaperTypeCode = nil
	m.add_PaperTypeCode = nil
	delete(m.clearedFields, exampapers.FieldPaperTypeCode)
}

// SetPaperTypeName sets the "PaperTypeName" field.
func (m *ExamPapersMutation) SetPaperTypeName(s string) {
	m._PaperTypeName = &s
}

// PaperTypeName returns the value of the "PaperTypeName" field in the mutation.
func (m *ExamPapersMutation) PaperTypeName() (r string, exists bool) {
	v := m._PaperTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperTypeName returns the old "PaperTypeName" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldPaperTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperTypeName: %w", err)
	}
	return oldValue.PaperTypeName, nil
}

// ClearPaperTypeName clears the value of the "PaperTypeName" field.
func (m *ExamPapersMutation) ClearPaperTypeName() {
	m._PaperTypeName = nil
	m.clearedFields[exampapers.FieldPaperTypeName] = struct{}{}
}

// PaperTypeNameCleared returns if the "PaperTypeName" field was cleared in this mutation.
func (m *ExamPapersMutation) PaperTypeNameCleared() bool {
	_, ok := m.clearedFields[exampapers.FieldPaperTypeName]
	return ok
}

// ResetPaperTypeName resets all changes to the "PaperTypeName" field.
func (m *ExamPapersMutation) ResetPaperTypeName() {
	m._PaperTypeName = nil
	delete(m.clearedFields, exampapers.FieldPaperTypeName)
}

// SetDisabilityTypeID sets the "DisabilityTypeID" field.
func (m *ExamPapersMutation) SetDisabilityTypeID(i int32) {
	m._DisabilityTypeID = &i
	m.add_DisabilityTypeID = nil
}

// DisabilityTypeID returns the value of the "DisabilityTypeID" field in the mutation.
func (m *ExamPapersMutation) DisabilityTypeID() (r int32, exists bool) {
	v := m._DisabilityTypeID
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityTypeID returns the old "DisabilityTypeID" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldDisabilityTypeID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityTypeID: %w", err)
	}
	return oldValue.DisabilityTypeID, nil
}

// AddDisabilityTypeID adds i to the "DisabilityTypeID" field.
func (m *ExamPapersMutation) AddDisabilityTypeID(i int32) {
	if m.add_DisabilityTypeID != nil {
		*m.add_DisabilityTypeID += i
	} else {
		m.add_DisabilityTypeID = &i
	}
}

// AddedDisabilityTypeID returns the value that was added to the "DisabilityTypeID" field in this mutation.
func (m *ExamPapersMutation) AddedDisabilityTypeID() (r int32, exists bool) {
	v := m.add_DisabilityTypeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisabilityTypeID clears the value of the "DisabilityTypeID" field.
func (m *ExamPapersMutation) ClearDisabilityTypeID() {
	m._DisabilityTypeID = nil
	m.add_DisabilityTypeID = nil
	m.clearedFields[exampapers.FieldDisabilityTypeID] = struct{}{}
}

// DisabilityTypeIDCleared returns if the "DisabilityTypeID" field was cleared in this mutation.
func (m *ExamPapersMutation) DisabilityTypeIDCleared() bool {
	_, ok := m.clearedFields[exampapers.FieldDisabilityTypeID]
	return ok
}

// ResetDisabilityTypeID resets all changes to the "DisabilityTypeID" field.
func (m *ExamPapersMutation) ResetDisabilityTypeID() {
	m._DisabilityTypeID = nil
	m.add_DisabilityTypeID = nil
	delete(m.clearedFields, exampapers.FieldDisabilityTypeID)
}

// SetExamCodePS sets the "ExamCodePS" field.
func (m *ExamPapersMutation) SetExamCodePS(i int32) {
	m._ExamCodePS = &i
	m.add_ExamCodePS = nil
}

// ExamCodePS returns the value of the "ExamCodePS" field in the mutation.
func (m *ExamPapersMutation) ExamCodePS() (r int32, exists bool) {
	v := m._ExamCodePS
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCodePS returns the old "ExamCodePS" field's value of the ExamPapers entity.
// If the ExamPapers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPapersMutation) OldExamCodePS(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCodePS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCodePS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCodePS: %w", err)
	}
	return oldValue.ExamCodePS, nil
}

// AddExamCodePS adds i to the "ExamCodePS" field.
func (m *ExamPapersMutation) AddExamCodePS(i int32) {
	if m.add_ExamCodePS != nil {
		*m.add_ExamCodePS += i
	} else {
		m.add_ExamCodePS = &i
	}
}

// AddedExamCodePS returns the value that was added to the "ExamCodePS" field in this mutation.
func (m *ExamPapersMutation) AddedExamCodePS() (r int32, exists bool) {
	v := m.add_ExamCodePS
	if v == nil {
		return
	}
	return *v, true
}

// ClearExamCodePS clears the value of the "ExamCodePS" field.
func (m *ExamPapersMutation) ClearExamCodePS() {
	m._ExamCodePS = nil
	m.add_ExamCodePS = nil
	m.clearedFields[exampapers.FieldExamCodePS] = struct{}{}
}

// ExamCodePSCleared returns if the "ExamCodePS" field was cleared in this mutation.
func (m *ExamPapersMutation) ExamCodePSCleared() bool {
	_, ok := m.clearedFields[exampapers.FieldExamCodePS]
	return ok
}

// ResetExamCodePS resets all changes to the "ExamCodePS" field.
func (m *ExamPapersMutation) ResetExamCodePS() {
	m._ExamCodePS = nil
	m.add_ExamCodePS = nil
	delete(m.clearedFields, exampapers.FieldExamCodePS)
}

// AddCenterIDs adds the "centers" edge to the Center entity by ids.
func (m *ExamPapersMutation) AddCenterIDs(ids ...int32) {
	if m.centers == nil {
		m.centers = make(map[int32]struct{})
	}
	for i := range ids {
		m.centers[ids[i]] = struct{}{}
	}
}

// ClearCenters clears the "centers" edge to the Center entity.
func (m *ExamPapersMutation) ClearCenters() {
	m.clearedcenters = true
}

// CentersCleared reports if the "centers" edge to the Center entity was cleared.
func (m *ExamPapersMutation) CentersCleared() bool {
	return m.clearedcenters
}

// RemoveCenterIDs removes the "centers" edge to the Center entity by IDs.
func (m *ExamPapersMutation) RemoveCenterIDs(ids ...int32) {
	if m.removedcenters == nil {
		m.removedcenters = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.centers, ids[i])
		m.removedcenters[ids[i]] = struct{}{}
	}
}

// RemovedCenters returns the removed IDs of the "centers" edge to the Center entity.
func (m *ExamPapersMutation) RemovedCentersIDs() (ids []int32) {
	for id := range m.removedcenters {
		ids = append(ids, id)
	}
	return
}

// CentersIDs returns the "centers" edge IDs in the mutation.
func (m *ExamPapersMutation) CentersIDs() (ids []int32) {
	for id := range m.centers {
		ids = append(ids, id)
	}
	return
}

// ResetCenters resets all changes to the "centers" edge.
func (m *ExamPapersMutation) ResetCenters() {
	m.centers = nil
	m.clearedcenters = false
	m.removedcenters = nil
}

// SetExamID sets the "exam" edge to the Exam entity by id.
func (m *ExamPapersMutation) SetExamID(id int32) {
	m.exam = &id
}

// ClearExam clears the "exam" edge to the Exam entity.
func (m *ExamPapersMutation) ClearExam() {
	m.clearedexam = true
}

// ExamCleared reports if the "exam" edge to the Exam entity was cleared.
func (m *ExamPapersMutation) ExamCleared() bool {
	return m.ExamCodeCleared() || m.clearedexam
}

// ExamID returns the "exam" edge ID in the mutation.
func (m *ExamPapersMutation) ExamID() (id int32, exists bool) {
	if m.exam != nil {
		return *m.exam, true
	}
	return
}

// ExamIDs returns the "exam" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamID instead. It exists only for internal usage by the builders.
func (m *ExamPapersMutation) ExamIDs() (ids []int32) {
	if id := m.exam; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExam resets all changes to the "exam" edge.
func (m *ExamPapersMutation) ResetExam() {
	m.exam = nil
	m.clearedexam = false
}

// AddExampapersTypeIDs adds the "exampapers_types" edge to the PaperTypes entity by ids.
func (m *ExamPapersMutation) AddExampapersTypeIDs(ids ...int32) {
	if m.exampapers_types == nil {
		m.exampapers_types = make(map[int32]struct{})
	}
	for i := range ids {
		m.exampapers_types[ids[i]] = struct{}{}
	}
}

// ClearExampapersTypes clears the "exampapers_types" edge to the PaperTypes entity.
func (m *ExamPapersMutation) ClearExampapersTypes() {
	m.clearedexampapers_types = true
}

// ExampapersTypesCleared reports if the "exampapers_types" edge to the PaperTypes entity was cleared.
func (m *ExamPapersMutation) ExampapersTypesCleared() bool {
	return m.clearedexampapers_types
}

// RemoveExampapersTypeIDs removes the "exampapers_types" edge to the PaperTypes entity by IDs.
func (m *ExamPapersMutation) RemoveExampapersTypeIDs(ids ...int32) {
	if m.removedexampapers_types == nil {
		m.removedexampapers_types = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.exampapers_types, ids[i])
		m.removedexampapers_types[ids[i]] = struct{}{}
	}
}

// RemovedExampapersTypes returns the removed IDs of the "exampapers_types" edge to the PaperTypes entity.
func (m *ExamPapersMutation) RemovedExampapersTypesIDs() (ids []int32) {
	for id := range m.removedexampapers_types {
		ids = append(ids, id)
	}
	return
}

// ExampapersTypesIDs returns the "exampapers_types" edge IDs in the mutation.
func (m *ExamPapersMutation) ExampapersTypesIDs() (ids []int32) {
	for id := range m.exampapers_types {
		ids = append(ids, id)
	}
	return
}

// ResetExampapersTypes resets all changes to the "exampapers_types" edge.
func (m *ExamPapersMutation) ResetExampapersTypes() {
	m.exampapers_types = nil
	m.clearedexampapers_types = false
	m.removedexampapers_types = nil
}

// AddPapersRefIDs adds the "papers_ref" edge to the ExamCalendar entity by ids.
func (m *ExamPapersMutation) AddPapersRefIDs(ids ...int32) {
	if m.papers_ref == nil {
		m.papers_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.papers_ref[ids[i]] = struct{}{}
	}
}

// ClearPapersRef clears the "papers_ref" edge to the ExamCalendar entity.
func (m *ExamPapersMutation) ClearPapersRef() {
	m.clearedpapers_ref = true
}

// PapersRefCleared reports if the "papers_ref" edge to the ExamCalendar entity was cleared.
func (m *ExamPapersMutation) PapersRefCleared() bool {
	return m.clearedpapers_ref
}

// RemovePapersRefIDs removes the "papers_ref" edge to the ExamCalendar entity by IDs.
func (m *ExamPapersMutation) RemovePapersRefIDs(ids ...int32) {
	if m.removedpapers_ref == nil {
		m.removedpapers_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.papers_ref, ids[i])
		m.removedpapers_ref[ids[i]] = struct{}{}
	}
}

// RemovedPapersRef returns the removed IDs of the "papers_ref" edge to the ExamCalendar entity.
func (m *ExamPapersMutation) RemovedPapersRefIDs() (ids []int32) {
	for id := range m.removedpapers_ref {
		ids = append(ids, id)
	}
	return
}

// PapersRefIDs returns the "papers_ref" edge IDs in the mutation.
func (m *ExamPapersMutation) PapersRefIDs() (ids []int32) {
	for id := range m.papers_ref {
		ids = append(ids, id)
	}
	return
}

// ResetPapersRef resets all changes to the "papers_ref" edge.
func (m *ExamPapersMutation) ResetPapersRef() {
	m.papers_ref = nil
	m.clearedpapers_ref = false
	m.removedpapers_ref = nil
}

// AddExamPaperEligibilityIDs adds the "ExamPaperEligibility" edge to the EligibilityMaster entity by ids.
func (m *ExamPapersMutation) AddExamPaperEligibilityIDs(ids ...int32) {
	if m._ExamPaperEligibility == nil {
		m._ExamPaperEligibility = make(map[int32]struct{})
	}
	for i := range ids {
		m._ExamPaperEligibility[ids[i]] = struct{}{}
	}
}

// ClearExamPaperEligibility clears the "ExamPaperEligibility" edge to the EligibilityMaster entity.
func (m *ExamPapersMutation) ClearExamPaperEligibility() {
	m.cleared_ExamPaperEligibility = true
}

// ExamPaperEligibilityCleared reports if the "ExamPaperEligibility" edge to the EligibilityMaster entity was cleared.
func (m *ExamPapersMutation) ExamPaperEligibilityCleared() bool {
	return m.cleared_ExamPaperEligibility
}

// RemoveExamPaperEligibilityIDs removes the "ExamPaperEligibility" edge to the EligibilityMaster entity by IDs.
func (m *ExamPapersMutation) RemoveExamPaperEligibilityIDs(ids ...int32) {
	if m.removed_ExamPaperEligibility == nil {
		m.removed_ExamPaperEligibility = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m._ExamPaperEligibility, ids[i])
		m.removed_ExamPaperEligibility[ids[i]] = struct{}{}
	}
}

// RemovedExamPaperEligibility returns the removed IDs of the "ExamPaperEligibility" edge to the EligibilityMaster entity.
func (m *ExamPapersMutation) RemovedExamPaperEligibilityIDs() (ids []int32) {
	for id := range m.removed_ExamPaperEligibility {
		ids = append(ids, id)
	}
	return
}

// ExamPaperEligibilityIDs returns the "ExamPaperEligibility" edge IDs in the mutation.
func (m *ExamPapersMutation) ExamPaperEligibilityIDs() (ids []int32) {
	for id := range m._ExamPaperEligibility {
		ids = append(ids, id)
	}
	return
}

// ResetExamPaperEligibility resets all changes to the "ExamPaperEligibility" edge.
func (m *ExamPapersMutation) ResetExamPaperEligibility() {
	m._ExamPaperEligibility = nil
	m.cleared_ExamPaperEligibility = false
	m.removed_ExamPaperEligibility = nil
}

// AddDisRefIDs adds the "dis_ref" edge to the Disability entity by ids.
func (m *ExamPapersMutation) AddDisRefIDs(ids ...int32) {
	if m.dis_ref == nil {
		m.dis_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.dis_ref[ids[i]] = struct{}{}
	}
}

// ClearDisRef clears the "dis_ref" edge to the Disability entity.
func (m *ExamPapersMutation) ClearDisRef() {
	m.cleareddis_ref = true
}

// DisRefCleared reports if the "dis_ref" edge to the Disability entity was cleared.
func (m *ExamPapersMutation) DisRefCleared() bool {
	return m.cleareddis_ref
}

// RemoveDisRefIDs removes the "dis_ref" edge to the Disability entity by IDs.
func (m *ExamPapersMutation) RemoveDisRefIDs(ids ...int32) {
	if m.removeddis_ref == nil {
		m.removeddis_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.dis_ref, ids[i])
		m.removeddis_ref[ids[i]] = struct{}{}
	}
}

// RemovedDisRef returns the removed IDs of the "dis_ref" edge to the Disability entity.
func (m *ExamPapersMutation) RemovedDisRefIDs() (ids []int32) {
	for id := range m.removeddis_ref {
		ids = append(ids, id)
	}
	return
}

// DisRefIDs returns the "dis_ref" edge IDs in the mutation.
func (m *ExamPapersMutation) DisRefIDs() (ids []int32) {
	for id := range m.dis_ref {
		ids = append(ids, id)
	}
	return
}

// ResetDisRef resets all changes to the "dis_ref" edge.
func (m *ExamPapersMutation) ResetDisRef() {
	m.dis_ref = nil
	m.cleareddis_ref = false
	m.removeddis_ref = nil
}

// AddPapersPsRefIDs adds the "papers_ps_ref" edge to the Exam_PS entity by ids.
func (m *ExamPapersMutation) AddPapersPsRefIDs(ids ...int32) {
	if m.papers_ps_ref == nil {
		m.papers_ps_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.papers_ps_ref[ids[i]] = struct{}{}
	}
}

// ClearPapersPsRef clears the "papers_ps_ref" edge to the Exam_PS entity.
func (m *ExamPapersMutation) ClearPapersPsRef() {
	m.clearedpapers_ps_ref = true
}

// PapersPsRefCleared reports if the "papers_ps_ref" edge to the Exam_PS entity was cleared.
func (m *ExamPapersMutation) PapersPsRefCleared() bool {
	return m.clearedpapers_ps_ref
}

// RemovePapersPsRefIDs removes the "papers_ps_ref" edge to the Exam_PS entity by IDs.
func (m *ExamPapersMutation) RemovePapersPsRefIDs(ids ...int32) {
	if m.removedpapers_ps_ref == nil {
		m.removedpapers_ps_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.papers_ps_ref, ids[i])
		m.removedpapers_ps_ref[ids[i]] = struct{}{}
	}
}

// RemovedPapersPsRef returns the removed IDs of the "papers_ps_ref" edge to the Exam_PS entity.
func (m *ExamPapersMutation) RemovedPapersPsRefIDs() (ids []int32) {
	for id := range m.removedpapers_ps_ref {
		ids = append(ids, id)
	}
	return
}

// PapersPsRefIDs returns the "papers_ps_ref" edge IDs in the mutation.
func (m *ExamPapersMutation) PapersPsRefIDs() (ids []int32) {
	for id := range m.papers_ps_ref {
		ids = append(ids, id)
	}
	return
}

// ResetPapersPsRef resets all changes to the "papers_ps_ref" edge.
func (m *ExamPapersMutation) ResetPapersPsRef() {
	m.papers_ps_ref = nil
	m.clearedpapers_ps_ref = false
	m.removedpapers_ps_ref = nil
}

// AddPapersIPRefIDs adds the "papers_ip_ref" edge to the Exam_IP entity by ids.
func (m *ExamPapersMutation) AddPapersIPRefIDs(ids ...int32) {
	if m.papers_ip_ref == nil {
		m.papers_ip_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.papers_ip_ref[ids[i]] = struct{}{}
	}
}

// ClearPapersIPRef clears the "papers_ip_ref" edge to the Exam_IP entity.
func (m *ExamPapersMutation) ClearPapersIPRef() {
	m.clearedpapers_ip_ref = true
}

// PapersIPRefCleared reports if the "papers_ip_ref" edge to the Exam_IP entity was cleared.
func (m *ExamPapersMutation) PapersIPRefCleared() bool {
	return m.clearedpapers_ip_ref
}

// RemovePapersIPRefIDs removes the "papers_ip_ref" edge to the Exam_IP entity by IDs.
func (m *ExamPapersMutation) RemovePapersIPRefIDs(ids ...int32) {
	if m.removedpapers_ip_ref == nil {
		m.removedpapers_ip_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.papers_ip_ref, ids[i])
		m.removedpapers_ip_ref[ids[i]] = struct{}{}
	}
}

// RemovedPapersIPRef returns the removed IDs of the "papers_ip_ref" edge to the Exam_IP entity.
func (m *ExamPapersMutation) RemovedPapersIPRefIDs() (ids []int32) {
	for id := range m.removedpapers_ip_ref {
		ids = append(ids, id)
	}
	return
}

// PapersIPRefIDs returns the "papers_ip_ref" edge IDs in the mutation.
func (m *ExamPapersMutation) PapersIPRefIDs() (ids []int32) {
	for id := range m.papers_ip_ref {
		ids = append(ids, id)
	}
	return
}

// ResetPapersIPRef resets all changes to the "papers_ip_ref" edge.
func (m *ExamPapersMutation) ResetPapersIPRef() {
	m.papers_ip_ref = nil
	m.clearedpapers_ip_ref = false
	m.removedpapers_ip_ref = nil
}

// Where appends a list predicates to the ExamPapersMutation builder.
func (m *ExamPapersMutation) Where(ps ...predicate.ExamPapers) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExamPapersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExamPapersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExamPapers, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExamPapersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExamPapersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExamPapers).
func (m *ExamPapersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExamPapersMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m._PaperDescription != nil {
		fields = append(fields, exampapers.FieldPaperDescription)
	}
	if m.exam != nil {
		fields = append(fields, exampapers.FieldExamCode)
	}
	if m._CompetitiveQualifying != nil {
		fields = append(fields, exampapers.FieldCompetitiveQualifying)
	}
	if m._ExceptionForDisability != nil {
		fields = append(fields, exampapers.FieldExceptionForDisability)
	}
	if m._MaximumMarks != nil {
		fields = append(fields, exampapers.FieldMaximumMarks)
	}
	if m._Duration != nil {
		fields = append(fields, exampapers.FieldDuration)
	}
	if m.localLanguageAllowedQuestionPaper != nil {
		fields = append(fields, exampapers.FieldLocalLanguageAllowedQuestionPaper)
	}
	if m.localLanguageAllowedAnswerPaper != nil {
		fields = append(fields, exampapers.FieldLocalLanguageAllowedAnswerPaper)
	}
	if m._OrderNumber != nil {
		fields = append(fields, exampapers.FieldOrderNumber)
	}
	if m._PaperStatus != nil {
		fields = append(fields, exampapers.FieldPaperStatus)
	}
	if m._CalendarCode != nil {
		fields = append(fields, exampapers.FieldCalendarCode)
	}
	if m._CreatedDate != nil {
		fields = append(fields, exampapers.FieldCreatedDate)
	}
	if m._PaperTypeCode != nil {
		fields = append(fields, exampapers.FieldPaperTypeCode)
	}
	if m._PaperTypeName != nil {
		fields = append(fields, exampapers.FieldPaperTypeName)
	}
	if m._DisabilityTypeID != nil {
		fields = append(fields, exampapers.FieldDisabilityTypeID)
	}
	if m._ExamCodePS != nil {
		fields = append(fields, exampapers.FieldExamCodePS)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExamPapersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exampapers.FieldPaperDescription:
		return m.PaperDescription()
	case exampapers.FieldExamCode:
		return m.ExamCode()
	case exampapers.FieldCompetitiveQualifying:
		return m.CompetitiveQualifying()
	case exampapers.FieldExceptionForDisability:
		return m.ExceptionForDisability()
	case exampapers.FieldMaximumMarks:
		return m.MaximumMarks()
	case exampapers.FieldDuration:
		return m.Duration()
	case exampapers.FieldLocalLanguageAllowedQuestionPaper:
		return m.LocalLanguageAllowedQuestionPaper()
	case exampapers.FieldLocalLanguageAllowedAnswerPaper:
		return m.LocalLanguageAllowedAnswerPaper()
	case exampapers.FieldOrderNumber:
		return m.OrderNumber()
	case exampapers.FieldPaperStatus:
		return m.PaperStatus()
	case exampapers.FieldCalendarCode:
		return m.CalendarCode()
	case exampapers.FieldCreatedDate:
		return m.CreatedDate()
	case exampapers.FieldPaperTypeCode:
		return m.PaperTypeCode()
	case exampapers.FieldPaperTypeName:
		return m.PaperTypeName()
	case exampapers.FieldDisabilityTypeID:
		return m.DisabilityTypeID()
	case exampapers.FieldExamCodePS:
		return m.ExamCodePS()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExamPapersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exampapers.FieldPaperDescription:
		return m.OldPaperDescription(ctx)
	case exampapers.FieldExamCode:
		return m.OldExamCode(ctx)
	case exampapers.FieldCompetitiveQualifying:
		return m.OldCompetitiveQualifying(ctx)
	case exampapers.FieldExceptionForDisability:
		return m.OldExceptionForDisability(ctx)
	case exampapers.FieldMaximumMarks:
		return m.OldMaximumMarks(ctx)
	case exampapers.FieldDuration:
		return m.OldDuration(ctx)
	case exampapers.FieldLocalLanguageAllowedQuestionPaper:
		return m.OldLocalLanguageAllowedQuestionPaper(ctx)
	case exampapers.FieldLocalLanguageAllowedAnswerPaper:
		return m.OldLocalLanguageAllowedAnswerPaper(ctx)
	case exampapers.FieldOrderNumber:
		return m.OldOrderNumber(ctx)
	case exampapers.FieldPaperStatus:
		return m.OldPaperStatus(ctx)
	case exampapers.FieldCalendarCode:
		return m.OldCalendarCode(ctx)
	case exampapers.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	case exampapers.FieldPaperTypeCode:
		return m.OldPaperTypeCode(ctx)
	case exampapers.FieldPaperTypeName:
		return m.OldPaperTypeName(ctx)
	case exampapers.FieldDisabilityTypeID:
		return m.OldDisabilityTypeID(ctx)
	case exampapers.FieldExamCodePS:
		return m.OldExamCodePS(ctx)
	}
	return nil, fmt.Errorf("unknown ExamPapers field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamPapersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exampapers.FieldPaperDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperDescription(v)
		return nil
	case exampapers.FieldExamCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCode(v)
		return nil
	case exampapers.FieldCompetitiveQualifying:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitiveQualifying(v)
		return nil
	case exampapers.FieldExceptionForDisability:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExceptionForDisability(v)
		return nil
	case exampapers.FieldMaximumMarks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaximumMarks(v)
		return nil
	case exampapers.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case exampapers.FieldLocalLanguageAllowedQuestionPaper:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalLanguageAllowedQuestionPaper(v)
		return nil
	case exampapers.FieldLocalLanguageAllowedAnswerPaper:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalLanguageAllowedAnswerPaper(v)
		return nil
	case exampapers.FieldOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNumber(v)
		return nil
	case exampapers.FieldPaperStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperStatus(v)
		return nil
	case exampapers.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalendarCode(v)
		return nil
	case exampapers.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	case exampapers.FieldPaperTypeCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperTypeCode(v)
		return nil
	case exampapers.FieldPaperTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperTypeName(v)
		return nil
	case exampapers.FieldDisabilityTypeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityTypeID(v)
		return nil
	case exampapers.FieldExamCodePS:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCodePS(v)
		return nil
	}
	return fmt.Errorf("unknown ExamPapers field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExamPapersMutation) AddedFields() []string {
	var fields []string
	if m.add_MaximumMarks != nil {
		fields = append(fields, exampapers.FieldMaximumMarks)
	}
	if m.add_Duration != nil {
		fields = append(fields, exampapers.FieldDuration)
	}
	if m.add_CalendarCode != nil {
		fields = append(fields, exampapers.FieldCalendarCode)
	}
	if m.add_PaperTypeCode != nil {
		fields = append(fields, exampapers.FieldPaperTypeCode)
	}
	if m.add_DisabilityTypeID != nil {
		fields = append(fields, exampapers.FieldDisabilityTypeID)
	}
	if m.add_ExamCodePS != nil {
		fields = append(fields, exampapers.FieldExamCodePS)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExamPapersMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exampapers.FieldMaximumMarks:
		return m.AddedMaximumMarks()
	case exampapers.FieldDuration:
		return m.AddedDuration()
	case exampapers.FieldCalendarCode:
		return m.AddedCalendarCode()
	case exampapers.FieldPaperTypeCode:
		return m.AddedPaperTypeCode()
	case exampapers.FieldDisabilityTypeID:
		return m.AddedDisabilityTypeID()
	case exampapers.FieldExamCodePS:
		return m.AddedExamCodePS()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamPapersMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exampapers.FieldMaximumMarks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaximumMarks(v)
		return nil
	case exampapers.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case exampapers.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalendarCode(v)
		return nil
	case exampapers.FieldPaperTypeCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaperTypeCode(v)
		return nil
	case exampapers.FieldDisabilityTypeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisabilityTypeID(v)
		return nil
	case exampapers.FieldExamCodePS:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamCodePS(v)
		return nil
	}
	return fmt.Errorf("unknown ExamPapers numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExamPapersMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exampapers.FieldExamCode) {
		fields = append(fields, exampapers.FieldExamCode)
	}
	if m.FieldCleared(exampapers.FieldCalendarCode) {
		fields = append(fields, exampapers.FieldCalendarCode)
	}
	if m.FieldCleared(exampapers.FieldCreatedDate) {
		fields = append(fields, exampapers.FieldCreatedDate)
	}
	if m.FieldCleared(exampapers.FieldPaperTypeCode) {
		fields = append(fields, exampapers.FieldPaperTypeCode)
	}
	if m.FieldCleared(exampapers.FieldPaperTypeName) {
		fields = append(fields, exampapers.FieldPaperTypeName)
	}
	if m.FieldCleared(exampapers.FieldDisabilityTypeID) {
		fields = append(fields, exampapers.FieldDisabilityTypeID)
	}
	if m.FieldCleared(exampapers.FieldExamCodePS) {
		fields = append(fields, exampapers.FieldExamCodePS)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExamPapersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExamPapersMutation) ClearField(name string) error {
	switch name {
	case exampapers.FieldExamCode:
		m.ClearExamCode()
		return nil
	case exampapers.FieldCalendarCode:
		m.ClearCalendarCode()
		return nil
	case exampapers.FieldCreatedDate:
		m.ClearCreatedDate()
		return nil
	case exampapers.FieldPaperTypeCode:
		m.ClearPaperTypeCode()
		return nil
	case exampapers.FieldPaperTypeName:
		m.ClearPaperTypeName()
		return nil
	case exampapers.FieldDisabilityTypeID:
		m.ClearDisabilityTypeID()
		return nil
	case exampapers.FieldExamCodePS:
		m.ClearExamCodePS()
		return nil
	}
	return fmt.Errorf("unknown ExamPapers nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExamPapersMutation) ResetField(name string) error {
	switch name {
	case exampapers.FieldPaperDescription:
		m.ResetPaperDescription()
		return nil
	case exampapers.FieldExamCode:
		m.ResetExamCode()
		return nil
	case exampapers.FieldCompetitiveQualifying:
		m.ResetCompetitiveQualifying()
		return nil
	case exampapers.FieldExceptionForDisability:
		m.ResetExceptionForDisability()
		return nil
	case exampapers.FieldMaximumMarks:
		m.ResetMaximumMarks()
		return nil
	case exampapers.FieldDuration:
		m.ResetDuration()
		return nil
	case exampapers.FieldLocalLanguageAllowedQuestionPaper:
		m.ResetLocalLanguageAllowedQuestionPaper()
		return nil
	case exampapers.FieldLocalLanguageAllowedAnswerPaper:
		m.ResetLocalLanguageAllowedAnswerPaper()
		return nil
	case exampapers.FieldOrderNumber:
		m.ResetOrderNumber()
		return nil
	case exampapers.FieldPaperStatus:
		m.ResetPaperStatus()
		return nil
	case exampapers.FieldCalendarCode:
		m.ResetCalendarCode()
		return nil
	case exampapers.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	case exampapers.FieldPaperTypeCode:
		m.ResetPaperTypeCode()
		return nil
	case exampapers.FieldPaperTypeName:
		m.ResetPaperTypeName()
		return nil
	case exampapers.FieldDisabilityTypeID:
		m.ResetDisabilityTypeID()
		return nil
	case exampapers.FieldExamCodePS:
		m.ResetExamCodePS()
		return nil
	}
	return fmt.Errorf("unknown ExamPapers field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExamPapersMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.centers != nil {
		edges = append(edges, exampapers.EdgeCenters)
	}
	if m.exam != nil {
		edges = append(edges, exampapers.EdgeExam)
	}
	if m.exampapers_types != nil {
		edges = append(edges, exampapers.EdgeExampapersTypes)
	}
	if m.papers_ref != nil {
		edges = append(edges, exampapers.EdgePapersRef)
	}
	if m._ExamPaperEligibility != nil {
		edges = append(edges, exampapers.EdgeExamPaperEligibility)
	}
	if m.dis_ref != nil {
		edges = append(edges, exampapers.EdgeDisRef)
	}
	if m.papers_ps_ref != nil {
		edges = append(edges, exampapers.EdgePapersPsRef)
	}
	if m.papers_ip_ref != nil {
		edges = append(edges, exampapers.EdgePapersIPRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExamPapersMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exampapers.EdgeCenters:
		ids := make([]ent.Value, 0, len(m.centers))
		for id := range m.centers {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgeExam:
		if id := m.exam; id != nil {
			return []ent.Value{*id}
		}
	case exampapers.EdgeExampapersTypes:
		ids := make([]ent.Value, 0, len(m.exampapers_types))
		for id := range m.exampapers_types {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgePapersRef:
		ids := make([]ent.Value, 0, len(m.papers_ref))
		for id := range m.papers_ref {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgeExamPaperEligibility:
		ids := make([]ent.Value, 0, len(m._ExamPaperEligibility))
		for id := range m._ExamPaperEligibility {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgeDisRef:
		ids := make([]ent.Value, 0, len(m.dis_ref))
		for id := range m.dis_ref {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgePapersPsRef:
		ids := make([]ent.Value, 0, len(m.papers_ps_ref))
		for id := range m.papers_ps_ref {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgePapersIPRef:
		ids := make([]ent.Value, 0, len(m.papers_ip_ref))
		for id := range m.papers_ip_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExamPapersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedcenters != nil {
		edges = append(edges, exampapers.EdgeCenters)
	}
	if m.removedexampapers_types != nil {
		edges = append(edges, exampapers.EdgeExampapersTypes)
	}
	if m.removedpapers_ref != nil {
		edges = append(edges, exampapers.EdgePapersRef)
	}
	if m.removed_ExamPaperEligibility != nil {
		edges = append(edges, exampapers.EdgeExamPaperEligibility)
	}
	if m.removeddis_ref != nil {
		edges = append(edges, exampapers.EdgeDisRef)
	}
	if m.removedpapers_ps_ref != nil {
		edges = append(edges, exampapers.EdgePapersPsRef)
	}
	if m.removedpapers_ip_ref != nil {
		edges = append(edges, exampapers.EdgePapersIPRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExamPapersMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exampapers.EdgeCenters:
		ids := make([]ent.Value, 0, len(m.removedcenters))
		for id := range m.removedcenters {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgeExampapersTypes:
		ids := make([]ent.Value, 0, len(m.removedexampapers_types))
		for id := range m.removedexampapers_types {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgePapersRef:
		ids := make([]ent.Value, 0, len(m.removedpapers_ref))
		for id := range m.removedpapers_ref {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgeExamPaperEligibility:
		ids := make([]ent.Value, 0, len(m.removed_ExamPaperEligibility))
		for id := range m.removed_ExamPaperEligibility {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgeDisRef:
		ids := make([]ent.Value, 0, len(m.removeddis_ref))
		for id := range m.removeddis_ref {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgePapersPsRef:
		ids := make([]ent.Value, 0, len(m.removedpapers_ps_ref))
		for id := range m.removedpapers_ps_ref {
			ids = append(ids, id)
		}
		return ids
	case exampapers.EdgePapersIPRef:
		ids := make([]ent.Value, 0, len(m.removedpapers_ip_ref))
		for id := range m.removedpapers_ip_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExamPapersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedcenters {
		edges = append(edges, exampapers.EdgeCenters)
	}
	if m.clearedexam {
		edges = append(edges, exampapers.EdgeExam)
	}
	if m.clearedexampapers_types {
		edges = append(edges, exampapers.EdgeExampapersTypes)
	}
	if m.clearedpapers_ref {
		edges = append(edges, exampapers.EdgePapersRef)
	}
	if m.cleared_ExamPaperEligibility {
		edges = append(edges, exampapers.EdgeExamPaperEligibility)
	}
	if m.cleareddis_ref {
		edges = append(edges, exampapers.EdgeDisRef)
	}
	if m.clearedpapers_ps_ref {
		edges = append(edges, exampapers.EdgePapersPsRef)
	}
	if m.clearedpapers_ip_ref {
		edges = append(edges, exampapers.EdgePapersIPRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExamPapersMutation) EdgeCleared(name string) bool {
	switch name {
	case exampapers.EdgeCenters:
		return m.clearedcenters
	case exampapers.EdgeExam:
		return m.clearedexam
	case exampapers.EdgeExampapersTypes:
		return m.clearedexampapers_types
	case exampapers.EdgePapersRef:
		return m.clearedpapers_ref
	case exampapers.EdgeExamPaperEligibility:
		return m.cleared_ExamPaperEligibility
	case exampapers.EdgeDisRef:
		return m.cleareddis_ref
	case exampapers.EdgePapersPsRef:
		return m.clearedpapers_ps_ref
	case exampapers.EdgePapersIPRef:
		return m.clearedpapers_ip_ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExamPapersMutation) ClearEdge(name string) error {
	switch name {
	case exampapers.EdgeExam:
		m.ClearExam()
		return nil
	}
	return fmt.Errorf("unknown ExamPapers unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExamPapersMutation) ResetEdge(name string) error {
	switch name {
	case exampapers.EdgeCenters:
		m.ResetCenters()
		return nil
	case exampapers.EdgeExam:
		m.ResetExam()
		return nil
	case exampapers.EdgeExampapersTypes:
		m.ResetExampapersTypes()
		return nil
	case exampapers.EdgePapersRef:
		m.ResetPapersRef()
		return nil
	case exampapers.EdgeExamPaperEligibility:
		m.ResetExamPaperEligibility()
		return nil
	case exampapers.EdgeDisRef:
		m.ResetDisRef()
		return nil
	case exampapers.EdgePapersPsRef:
		m.ResetPapersPsRef()
		return nil
	case exampapers.EdgePapersIPRef:
		m.ResetPapersIPRef()
		return nil
	}
	return fmt.Errorf("unknown ExamPapers edge %s", name)
}

// ExamTypeMutation represents an operation that mutates the ExamType nodes in the graph.
type ExamTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	_ExamType     *string
	_Status       *string
	clearedFields map[string]struct{}
	exam          *int32
	clearedexam   bool
	done          bool
	oldValue      func(context.Context) (*ExamType, error)
	predicates    []predicate.ExamType
}

var _ ent.Mutation = (*ExamTypeMutation)(nil)

// examtypeOption allows management of the mutation configuration using functional options.
type examtypeOption func(*ExamTypeMutation)

// newExamTypeMutation creates new mutation for the ExamType entity.
func newExamTypeMutation(c config, op Op, opts ...examtypeOption) *ExamTypeMutation {
	m := &ExamTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeExamType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExamTypeID sets the ID field of the mutation.
func withExamTypeID(id int32) examtypeOption {
	return func(m *ExamTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ExamType
		)
		m.oldValue = func(ctx context.Context) (*ExamType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExamType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExamType sets the old ExamType of the mutation.
func withExamType(node *ExamType) examtypeOption {
	return func(m *ExamTypeMutation) {
		m.oldValue = func(context.Context) (*ExamType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExamTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExamTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExamType entities.
func (m *ExamTypeMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExamTypeMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExamTypeMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExamType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExamType sets the "ExamType" field.
func (m *ExamTypeMutation) SetExamType(s string) {
	m._ExamType = &s
}

// ExamType returns the value of the "ExamType" field in the mutation.
func (m *ExamTypeMutation) ExamType() (r string, exists bool) {
	v := m._ExamType
	if v == nil {
		return
	}
	return *v, true
}

// OldExamType returns the old "ExamType" field's value of the ExamType entity.
// If the ExamType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamTypeMutation) OldExamType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamType: %w", err)
	}
	return oldValue.ExamType, nil
}

// ResetExamType resets all changes to the "ExamType" field.
func (m *ExamTypeMutation) ResetExamType() {
	m._ExamType = nil
}

// SetStatus sets the "Status" field.
func (m *ExamTypeMutation) SetStatus(s string) {
	m._Status = &s
}

// Status returns the value of the "Status" field in the mutation.
func (m *ExamTypeMutation) Status() (r string, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the ExamType entity.
// If the ExamType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamTypeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "Status" field.
func (m *ExamTypeMutation) ResetStatus() {
	m._Status = nil
}

// SetExamCode sets the "ExamCode" field.
func (m *ExamTypeMutation) SetExamCode(i int32) {
	m.exam = &i
}

// ExamCode returns the value of the "ExamCode" field in the mutation.
func (m *ExamTypeMutation) ExamCode() (r int32, exists bool) {
	v := m.exam
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCode returns the old "ExamCode" field's value of the ExamType entity.
// If the ExamType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamTypeMutation) OldExamCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCode: %w", err)
	}
	return oldValue.ExamCode, nil
}

// ClearExamCode clears the value of the "ExamCode" field.
func (m *ExamTypeMutation) ClearExamCode() {
	m.exam = nil
	m.clearedFields[examtype.FieldExamCode] = struct{}{}
}

// ExamCodeCleared returns if the "ExamCode" field was cleared in this mutation.
func (m *ExamTypeMutation) ExamCodeCleared() bool {
	_, ok := m.clearedFields[examtype.FieldExamCode]
	return ok
}

// ResetExamCode resets all changes to the "ExamCode" field.
func (m *ExamTypeMutation) ResetExamCode() {
	m.exam = nil
	delete(m.clearedFields, examtype.FieldExamCode)
}

// SetExamID sets the "exam" edge to the Exam entity by id.
func (m *ExamTypeMutation) SetExamID(id int32) {
	m.exam = &id
}

// ClearExam clears the "exam" edge to the Exam entity.
func (m *ExamTypeMutation) ClearExam() {
	m.clearedexam = true
}

// ExamCleared reports if the "exam" edge to the Exam entity was cleared.
func (m *ExamTypeMutation) ExamCleared() bool {
	return m.ExamCodeCleared() || m.clearedexam
}

// ExamID returns the "exam" edge ID in the mutation.
func (m *ExamTypeMutation) ExamID() (id int32, exists bool) {
	if m.exam != nil {
		return *m.exam, true
	}
	return
}

// ExamIDs returns the "exam" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamID instead. It exists only for internal usage by the builders.
func (m *ExamTypeMutation) ExamIDs() (ids []int32) {
	if id := m.exam; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExam resets all changes to the "exam" edge.
func (m *ExamTypeMutation) ResetExam() {
	m.exam = nil
	m.clearedexam = false
}

// Where appends a list predicates to the ExamTypeMutation builder.
func (m *ExamTypeMutation) Where(ps ...predicate.ExamType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExamTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExamTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExamType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExamTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExamTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExamType).
func (m *ExamTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExamTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._ExamType != nil {
		fields = append(fields, examtype.FieldExamType)
	}
	if m._Status != nil {
		fields = append(fields, examtype.FieldStatus)
	}
	if m.exam != nil {
		fields = append(fields, examtype.FieldExamCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExamTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case examtype.FieldExamType:
		return m.ExamType()
	case examtype.FieldStatus:
		return m.Status()
	case examtype.FieldExamCode:
		return m.ExamCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExamTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case examtype.FieldExamType:
		return m.OldExamType(ctx)
	case examtype.FieldStatus:
		return m.OldStatus(ctx)
	case examtype.FieldExamCode:
		return m.OldExamCode(ctx)
	}
	return nil, fmt.Errorf("unknown ExamType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case examtype.FieldExamType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamType(v)
		return nil
	case examtype.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case examtype.FieldExamCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCode(v)
		return nil
	}
	return fmt.Errorf("unknown ExamType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExamTypeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExamTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ExamType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExamTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(examtype.FieldExamCode) {
		fields = append(fields, examtype.FieldExamCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExamTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExamTypeMutation) ClearField(name string) error {
	switch name {
	case examtype.FieldExamCode:
		m.ClearExamCode()
		return nil
	}
	return fmt.Errorf("unknown ExamType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExamTypeMutation) ResetField(name string) error {
	switch name {
	case examtype.FieldExamType:
		m.ResetExamType()
		return nil
	case examtype.FieldStatus:
		m.ResetStatus()
		return nil
	case examtype.FieldExamCode:
		m.ResetExamCode()
		return nil
	}
	return fmt.Errorf("unknown ExamType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExamTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.exam != nil {
		edges = append(edges, examtype.EdgeExam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExamTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case examtype.EdgeExam:
		if id := m.exam; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExamTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExamTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExamTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedexam {
		edges = append(edges, examtype.EdgeExam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExamTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case examtype.EdgeExam:
		return m.clearedexam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExamTypeMutation) ClearEdge(name string) error {
	switch name {
	case examtype.EdgeExam:
		m.ClearExam()
		return nil
	}
	return fmt.Errorf("unknown ExamType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExamTypeMutation) ResetEdge(name string) error {
	switch name {
	case examtype.EdgeExam:
		m.ResetExam()
		return nil
	}
	return fmt.Errorf("unknown ExamType edge %s", name)
}

// ExamApplicationsIPMutation represents an operation that mutates the Exam_Applications_IP nodes in the graph.
type ExamApplicationsIPMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	_ApplicationNumber         *string
	_EmployeeID                *int64
	add_EmployeeID             *int64
	_EmployeeName              *string
	_DOB                       *string
	_Gender                    *string
	_MobileNumber              *string
	_EmailID                   *string
	_EmployeeCategory          *string
	_Cadre                     *string
	_EmployeePost              *string
	_FacilityID                *string
	_FacilityName              *string
	_DivisionName              *string
	_RegionName                *string
	_ReportingOfficeName       *string
	_CircleName                *string
	_EntryCadre                *string
	_DCCS                      *string
	_DCInPresentCadre          *string
	_DeputationOfficeId        *string
	_DisabilityType            *string
	_DisabilityPercentage      *string
	_Education                 *string
	_ExamNameCode              *string
	_ExamYear                  *string
	_ExamName                  *string
	_PresentCadre              *string
	_PresentDesignation        *string
	_EligibleCadre             *string
	_EligibleCadreDate         *string
	_ServiceLength             *[]interface{}
	append_ServiceLength       []interface{}
	_CentrePreference          *string
	_Signature                 *string
	_Photo                     *string
	_ApplicationStatus         *string
	_ApplnSubmittedDate        *time.Time
	_VA_Remarks                *string
	_VA_UserName               *string
	_VA_Date                   *time.Time
	_CA_Remarks                *string
	_CA_UserName               *string
	_CA_Date                   *time.Time
	_ApplicationWdlDate        *time.Time
	_NA_Remarks                *string
	_NA_UserName               *string
	_NA_Date                   *time.Time
	_AppliactionRemarks        *string
	_CadrePreferences          *[]interface{}
	append_CadrePreferences    []interface{}
	_DivisionPreferences       *[]interface{}
	append_DivisionPreferences []interface{}
	_UpdatedAt                 *time.Time
	_UpdatedBy                 *string
	_CAPreviousRemarks         *string
	clearedFields              map[string]struct{}
	_UsersIPRef                map[int64]struct{}
	removed_UsersIPRef         map[int64]struct{}
	cleared_UsersIPRef         bool
	_ExamAppln_IP_Ref          map[int32]struct{}
	removed_ExamAppln_IP_Ref   map[int32]struct{}
	cleared_ExamAppln_IP_Ref   bool
	_Office_IP_Ref             map[int32]struct{}
	removed_Office_IP_Ref      map[int32]struct{}
	cleared_Office_IP_Ref      bool
	roleusers                  *int32
	clearedroleusers           bool
	_CadrePref_Ref             map[int32]struct{}
	removed_CadrePref_Ref      map[int32]struct{}
	cleared_CadrePref_Ref      bool
	_CirclePrefRef             map[int32]struct{}
	removed_CirclePrefRef      map[int32]struct{}
	cleared_CirclePrefRef      bool
	_IPApplicationsRef         map[int64]struct{}
	removed_IPApplicationsRef  map[int64]struct{}
	cleared_IPApplicationsRef  bool
	done                       bool
	oldValue                   func(context.Context) (*Exam_Applications_IP, error)
	predicates                 []predicate.Exam_Applications_IP
}

var _ ent.Mutation = (*ExamApplicationsIPMutation)(nil)

// examApplicationsIPOption allows management of the mutation configuration using functional options.
type examApplicationsIPOption func(*ExamApplicationsIPMutation)

// newExamApplicationsIPMutation creates new mutation for the Exam_Applications_IP entity.
func newExamApplicationsIPMutation(c config, op Op, opts ...examApplicationsIPOption) *ExamApplicationsIPMutation {
	m := &ExamApplicationsIPMutation{
		config:        c,
		op:            op,
		typ:           TypeExamApplicationsIP,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExam_Applications_IPID sets the ID field of the mutation.
func withExam_Applications_IPID(id int64) examApplicationsIPOption {
	return func(m *ExamApplicationsIPMutation) {
		var (
			err   error
			once  sync.Once
			value *Exam_Applications_IP
		)
		m.oldValue = func(ctx context.Context) (*Exam_Applications_IP, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exam_Applications_IP.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExam_Applications_IP sets the old Exam_Applications_IP of the mutation.
func withExam_Applications_IP(node *Exam_Applications_IP) examApplicationsIPOption {
	return func(m *ExamApplicationsIPMutation) {
		m.oldValue = func(context.Context) (*Exam_Applications_IP, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExamApplicationsIPMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExamApplicationsIPMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exam_Applications_IP entities.
func (m *ExamApplicationsIPMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExamApplicationsIPMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExamApplicationsIPMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exam_Applications_IP.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApplicationNumber sets the "ApplicationNumber" field.
func (m *ExamApplicationsIPMutation) SetApplicationNumber(s string) {
	m._ApplicationNumber = &s
}

// ApplicationNumber returns the value of the "ApplicationNumber" field in the mutation.
func (m *ExamApplicationsIPMutation) ApplicationNumber() (r string, exists bool) {
	v := m._ApplicationNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationNumber returns the old "ApplicationNumber" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldApplicationNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationNumber: %w", err)
	}
	return oldValue.ApplicationNumber, nil
}

// ClearApplicationNumber clears the value of the "ApplicationNumber" field.
func (m *ExamApplicationsIPMutation) ClearApplicationNumber() {
	m._ApplicationNumber = nil
	m.clearedFields[exam_applications_ip.FieldApplicationNumber] = struct{}{}
}

// ApplicationNumberCleared returns if the "ApplicationNumber" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) ApplicationNumberCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldApplicationNumber]
	return ok
}

// ResetApplicationNumber resets all changes to the "ApplicationNumber" field.
func (m *ExamApplicationsIPMutation) ResetApplicationNumber() {
	m._ApplicationNumber = nil
	delete(m.clearedFields, exam_applications_ip.FieldApplicationNumber)
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *ExamApplicationsIPMutation) SetEmployeeID(i int64) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *ExamApplicationsIPMutation) EmployeeID() (r int64, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldEmployeeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *ExamApplicationsIPMutation) AddEmployeeID(i int64) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *ExamApplicationsIPMutation) AddedEmployeeID() (r int64, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeeID clears the value of the "EmployeeID" field.
func (m *ExamApplicationsIPMutation) ClearEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	m.clearedFields[exam_applications_ip.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "EmployeeID" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *ExamApplicationsIPMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	delete(m.clearedFields, exam_applications_ip.FieldEmployeeID)
}

// SetEmployeeName sets the "EmployeeName" field.
func (m *ExamApplicationsIPMutation) SetEmployeeName(s string) {
	m._EmployeeName = &s
}

// EmployeeName returns the value of the "EmployeeName" field in the mutation.
func (m *ExamApplicationsIPMutation) EmployeeName() (r string, exists bool) {
	v := m._EmployeeName
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeName returns the old "EmployeeName" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldEmployeeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeName: %w", err)
	}
	return oldValue.EmployeeName, nil
}

// ClearEmployeeName clears the value of the "EmployeeName" field.
func (m *ExamApplicationsIPMutation) ClearEmployeeName() {
	m._EmployeeName = nil
	m.clearedFields[exam_applications_ip.FieldEmployeeName] = struct{}{}
}

// EmployeeNameCleared returns if the "EmployeeName" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) EmployeeNameCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldEmployeeName]
	return ok
}

// ResetEmployeeName resets all changes to the "EmployeeName" field.
func (m *ExamApplicationsIPMutation) ResetEmployeeName() {
	m._EmployeeName = nil
	delete(m.clearedFields, exam_applications_ip.FieldEmployeeName)
}

// SetDOB sets the "DOB" field.
func (m *ExamApplicationsIPMutation) SetDOB(s string) {
	m._DOB = &s
}

// DOB returns the value of the "DOB" field in the mutation.
func (m *ExamApplicationsIPMutation) DOB() (r string, exists bool) {
	v := m._DOB
	if v == nil {
		return
	}
	return *v, true
}

// OldDOB returns the old "DOB" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldDOB(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOB: %w", err)
	}
	return oldValue.DOB, nil
}

// ClearDOB clears the value of the "DOB" field.
func (m *ExamApplicationsIPMutation) ClearDOB() {
	m._DOB = nil
	m.clearedFields[exam_applications_ip.FieldDOB] = struct{}{}
}

// DOBCleared returns if the "DOB" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) DOBCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldDOB]
	return ok
}

// ResetDOB resets all changes to the "DOB" field.
func (m *ExamApplicationsIPMutation) ResetDOB() {
	m._DOB = nil
	delete(m.clearedFields, exam_applications_ip.FieldDOB)
}

// SetGender sets the "Gender" field.
func (m *ExamApplicationsIPMutation) SetGender(s string) {
	m._Gender = &s
}

// Gender returns the value of the "Gender" field in the mutation.
func (m *ExamApplicationsIPMutation) Gender() (r string, exists bool) {
	v := m._Gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "Gender" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "Gender" field.
func (m *ExamApplicationsIPMutation) ClearGender() {
	m._Gender = nil
	m.clearedFields[exam_applications_ip.FieldGender] = struct{}{}
}

// GenderCleared returns if the "Gender" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) GenderCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldGender]
	return ok
}

// ResetGender resets all changes to the "Gender" field.
func (m *ExamApplicationsIPMutation) ResetGender() {
	m._Gender = nil
	delete(m.clearedFields, exam_applications_ip.FieldGender)
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *ExamApplicationsIPMutation) SetMobileNumber(s string) {
	m._MobileNumber = &s
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *ExamApplicationsIPMutation) MobileNumber() (r string, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldMobileNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// ClearMobileNumber clears the value of the "MobileNumber" field.
func (m *ExamApplicationsIPMutation) ClearMobileNumber() {
	m._MobileNumber = nil
	m.clearedFields[exam_applications_ip.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "MobileNumber" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *ExamApplicationsIPMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	delete(m.clearedFields, exam_applications_ip.FieldMobileNumber)
}

// SetEmailID sets the "EmailID" field.
func (m *ExamApplicationsIPMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *ExamApplicationsIPMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ClearEmailID clears the value of the "EmailID" field.
func (m *ExamApplicationsIPMutation) ClearEmailID() {
	m._EmailID = nil
	m.clearedFields[exam_applications_ip.FieldEmailID] = struct{}{}
}

// EmailIDCleared returns if the "EmailID" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) EmailIDCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldEmailID]
	return ok
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *ExamApplicationsIPMutation) ResetEmailID() {
	m._EmailID = nil
	delete(m.clearedFields, exam_applications_ip.FieldEmailID)
}

// SetEmployeeCategory sets the "EmployeeCategory" field.
func (m *ExamApplicationsIPMutation) SetEmployeeCategory(s string) {
	m._EmployeeCategory = &s
}

// EmployeeCategory returns the value of the "EmployeeCategory" field in the mutation.
func (m *ExamApplicationsIPMutation) EmployeeCategory() (r string, exists bool) {
	v := m._EmployeeCategory
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCategory returns the old "EmployeeCategory" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldEmployeeCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCategory: %w", err)
	}
	return oldValue.EmployeeCategory, nil
}

// ClearEmployeeCategory clears the value of the "EmployeeCategory" field.
func (m *ExamApplicationsIPMutation) ClearEmployeeCategory() {
	m._EmployeeCategory = nil
	m.clearedFields[exam_applications_ip.FieldEmployeeCategory] = struct{}{}
}

// EmployeeCategoryCleared returns if the "EmployeeCategory" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) EmployeeCategoryCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldEmployeeCategory]
	return ok
}

// ResetEmployeeCategory resets all changes to the "EmployeeCategory" field.
func (m *ExamApplicationsIPMutation) ResetEmployeeCategory() {
	m._EmployeeCategory = nil
	delete(m.clearedFields, exam_applications_ip.FieldEmployeeCategory)
}

// SetCadre sets the "Cadre" field.
func (m *ExamApplicationsIPMutation) SetCadre(s string) {
	m._Cadre = &s
}

// Cadre returns the value of the "Cadre" field in the mutation.
func (m *ExamApplicationsIPMutation) Cadre() (r string, exists bool) {
	v := m._Cadre
	if v == nil {
		return
	}
	return *v, true
}

// OldCadre returns the old "Cadre" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadre: %w", err)
	}
	return oldValue.Cadre, nil
}

// ClearCadre clears the value of the "Cadre" field.
func (m *ExamApplicationsIPMutation) ClearCadre() {
	m._Cadre = nil
	m.clearedFields[exam_applications_ip.FieldCadre] = struct{}{}
}

// CadreCleared returns if the "Cadre" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) CadreCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldCadre]
	return ok
}

// ResetCadre resets all changes to the "Cadre" field.
func (m *ExamApplicationsIPMutation) ResetCadre() {
	m._Cadre = nil
	delete(m.clearedFields, exam_applications_ip.FieldCadre)
}

// SetEmployeePost sets the "EmployeePost" field.
func (m *ExamApplicationsIPMutation) SetEmployeePost(s string) {
	m._EmployeePost = &s
}

// EmployeePost returns the value of the "EmployeePost" field in the mutation.
func (m *ExamApplicationsIPMutation) EmployeePost() (r string, exists bool) {
	v := m._EmployeePost
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeePost returns the old "EmployeePost" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldEmployeePost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeePost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeePost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeePost: %w", err)
	}
	return oldValue.EmployeePost, nil
}

// ClearEmployeePost clears the value of the "EmployeePost" field.
func (m *ExamApplicationsIPMutation) ClearEmployeePost() {
	m._EmployeePost = nil
	m.clearedFields[exam_applications_ip.FieldEmployeePost] = struct{}{}
}

// EmployeePostCleared returns if the "EmployeePost" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) EmployeePostCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldEmployeePost]
	return ok
}

// ResetEmployeePost resets all changes to the "EmployeePost" field.
func (m *ExamApplicationsIPMutation) ResetEmployeePost() {
	m._EmployeePost = nil
	delete(m.clearedFields, exam_applications_ip.FieldEmployeePost)
}

// SetFacilityID sets the "FacilityID" field.
func (m *ExamApplicationsIPMutation) SetFacilityID(s string) {
	m._FacilityID = &s
}

// FacilityID returns the value of the "FacilityID" field in the mutation.
func (m *ExamApplicationsIPMutation) FacilityID() (r string, exists bool) {
	v := m._FacilityID
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityID returns the old "FacilityID" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldFacilityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityID: %w", err)
	}
	return oldValue.FacilityID, nil
}

// ClearFacilityID clears the value of the "FacilityID" field.
func (m *ExamApplicationsIPMutation) ClearFacilityID() {
	m._FacilityID = nil
	m.clearedFields[exam_applications_ip.FieldFacilityID] = struct{}{}
}

// FacilityIDCleared returns if the "FacilityID" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) FacilityIDCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldFacilityID]
	return ok
}

// ResetFacilityID resets all changes to the "FacilityID" field.
func (m *ExamApplicationsIPMutation) ResetFacilityID() {
	m._FacilityID = nil
	delete(m.clearedFields, exam_applications_ip.FieldFacilityID)
}

// SetFacilityName sets the "FacilityName" field.
func (m *ExamApplicationsIPMutation) SetFacilityName(s string) {
	m._FacilityName = &s
}

// FacilityName returns the value of the "FacilityName" field in the mutation.
func (m *ExamApplicationsIPMutation) FacilityName() (r string, exists bool) {
	v := m._FacilityName
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityName returns the old "FacilityName" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldFacilityName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacilityName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacilityName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityName: %w", err)
	}
	return oldValue.FacilityName, nil
}

// ClearFacilityName clears the value of the "FacilityName" field.
func (m *ExamApplicationsIPMutation) ClearFacilityName() {
	m._FacilityName = nil
	m.clearedFields[exam_applications_ip.FieldFacilityName] = struct{}{}
}

// FacilityNameCleared returns if the "FacilityName" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) FacilityNameCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldFacilityName]
	return ok
}

// ResetFacilityName resets all changes to the "FacilityName" field.
func (m *ExamApplicationsIPMutation) ResetFacilityName() {
	m._FacilityName = nil
	delete(m.clearedFields, exam_applications_ip.FieldFacilityName)
}

// SetDivisionName sets the "DivisionName" field.
func (m *ExamApplicationsIPMutation) SetDivisionName(s string) {
	m._DivisionName = &s
}

// DivisionName returns the value of the "DivisionName" field in the mutation.
func (m *ExamApplicationsIPMutation) DivisionName() (r string, exists bool) {
	v := m._DivisionName
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionName returns the old "DivisionName" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldDivisionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionName: %w", err)
	}
	return oldValue.DivisionName, nil
}

// ClearDivisionName clears the value of the "DivisionName" field.
func (m *ExamApplicationsIPMutation) ClearDivisionName() {
	m._DivisionName = nil
	m.clearedFields[exam_applications_ip.FieldDivisionName] = struct{}{}
}

// DivisionNameCleared returns if the "DivisionName" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) DivisionNameCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldDivisionName]
	return ok
}

// ResetDivisionName resets all changes to the "DivisionName" field.
func (m *ExamApplicationsIPMutation) ResetDivisionName() {
	m._DivisionName = nil
	delete(m.clearedFields, exam_applications_ip.FieldDivisionName)
}

// SetRegionName sets the "RegionName" field.
func (m *ExamApplicationsIPMutation) SetRegionName(s string) {
	m._RegionName = &s
}

// RegionName returns the value of the "RegionName" field in the mutation.
func (m *ExamApplicationsIPMutation) RegionName() (r string, exists bool) {
	v := m._RegionName
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionName returns the old "RegionName" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldRegionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionName: %w", err)
	}
	return oldValue.RegionName, nil
}

// ClearRegionName clears the value of the "RegionName" field.
func (m *ExamApplicationsIPMutation) ClearRegionName() {
	m._RegionName = nil
	m.clearedFields[exam_applications_ip.FieldRegionName] = struct{}{}
}

// RegionNameCleared returns if the "RegionName" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) RegionNameCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldRegionName]
	return ok
}

// ResetRegionName resets all changes to the "RegionName" field.
func (m *ExamApplicationsIPMutation) ResetRegionName() {
	m._RegionName = nil
	delete(m.clearedFields, exam_applications_ip.FieldRegionName)
}

// SetReportingOfficeName sets the "ReportingOfficeName" field.
func (m *ExamApplicationsIPMutation) SetReportingOfficeName(s string) {
	m._ReportingOfficeName = &s
}

// ReportingOfficeName returns the value of the "ReportingOfficeName" field in the mutation.
func (m *ExamApplicationsIPMutation) ReportingOfficeName() (r string, exists bool) {
	v := m._ReportingOfficeName
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingOfficeName returns the old "ReportingOfficeName" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldReportingOfficeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingOfficeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingOfficeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingOfficeName: %w", err)
	}
	return oldValue.ReportingOfficeName, nil
}

// ClearReportingOfficeName clears the value of the "ReportingOfficeName" field.
func (m *ExamApplicationsIPMutation) ClearReportingOfficeName() {
	m._ReportingOfficeName = nil
	m.clearedFields[exam_applications_ip.FieldReportingOfficeName] = struct{}{}
}

// ReportingOfficeNameCleared returns if the "ReportingOfficeName" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) ReportingOfficeNameCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldReportingOfficeName]
	return ok
}

// ResetReportingOfficeName resets all changes to the "ReportingOfficeName" field.
func (m *ExamApplicationsIPMutation) ResetReportingOfficeName() {
	m._ReportingOfficeName = nil
	delete(m.clearedFields, exam_applications_ip.FieldReportingOfficeName)
}

// SetCircleName sets the "CircleName" field.
func (m *ExamApplicationsIPMutation) SetCircleName(s string) {
	m._CircleName = &s
}

// CircleName returns the value of the "CircleName" field in the mutation.
func (m *ExamApplicationsIPMutation) CircleName() (r string, exists bool) {
	v := m._CircleName
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleName returns the old "CircleName" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldCircleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleName: %w", err)
	}
	return oldValue.CircleName, nil
}

// ClearCircleName clears the value of the "CircleName" field.
func (m *ExamApplicationsIPMutation) ClearCircleName() {
	m._CircleName = nil
	m.clearedFields[exam_applications_ip.FieldCircleName] = struct{}{}
}

// CircleNameCleared returns if the "CircleName" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) CircleNameCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldCircleName]
	return ok
}

// ResetCircleName resets all changes to the "CircleName" field.
func (m *ExamApplicationsIPMutation) ResetCircleName() {
	m._CircleName = nil
	delete(m.clearedFields, exam_applications_ip.FieldCircleName)
}

// SetEntryCadre sets the "EntryCadre" field.
func (m *ExamApplicationsIPMutation) SetEntryCadre(s string) {
	m._EntryCadre = &s
}

// EntryCadre returns the value of the "EntryCadre" field in the mutation.
func (m *ExamApplicationsIPMutation) EntryCadre() (r string, exists bool) {
	v := m._EntryCadre
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryCadre returns the old "EntryCadre" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldEntryCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryCadre: %w", err)
	}
	return oldValue.EntryCadre, nil
}

// ClearEntryCadre clears the value of the "EntryCadre" field.
func (m *ExamApplicationsIPMutation) ClearEntryCadre() {
	m._EntryCadre = nil
	m.clearedFields[exam_applications_ip.FieldEntryCadre] = struct{}{}
}

// EntryCadreCleared returns if the "EntryCadre" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) EntryCadreCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldEntryCadre]
	return ok
}

// ResetEntryCadre resets all changes to the "EntryCadre" field.
func (m *ExamApplicationsIPMutation) ResetEntryCadre() {
	m._EntryCadre = nil
	delete(m.clearedFields, exam_applications_ip.FieldEntryCadre)
}

// SetDCCS sets the "DCCS" field.
func (m *ExamApplicationsIPMutation) SetDCCS(s string) {
	m._DCCS = &s
}

// DCCS returns the value of the "DCCS" field in the mutation.
func (m *ExamApplicationsIPMutation) DCCS() (r string, exists bool) {
	v := m._DCCS
	if v == nil {
		return
	}
	return *v, true
}

// OldDCCS returns the old "DCCS" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldDCCS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCCS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCCS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCCS: %w", err)
	}
	return oldValue.DCCS, nil
}

// ClearDCCS clears the value of the "DCCS" field.
func (m *ExamApplicationsIPMutation) ClearDCCS() {
	m._DCCS = nil
	m.clearedFields[exam_applications_ip.FieldDCCS] = struct{}{}
}

// DCCSCleared returns if the "DCCS" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) DCCSCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldDCCS]
	return ok
}

// ResetDCCS resets all changes to the "DCCS" field.
func (m *ExamApplicationsIPMutation) ResetDCCS() {
	m._DCCS = nil
	delete(m.clearedFields, exam_applications_ip.FieldDCCS)
}

// SetDCInPresentCadre sets the "DCInPresentCadre" field.
func (m *ExamApplicationsIPMutation) SetDCInPresentCadre(s string) {
	m._DCInPresentCadre = &s
}

// DCInPresentCadre returns the value of the "DCInPresentCadre" field in the mutation.
func (m *ExamApplicationsIPMutation) DCInPresentCadre() (r string, exists bool) {
	v := m._DCInPresentCadre
	if v == nil {
		return
	}
	return *v, true
}

// OldDCInPresentCadre returns the old "DCInPresentCadre" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldDCInPresentCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCInPresentCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCInPresentCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCInPresentCadre: %w", err)
	}
	return oldValue.DCInPresentCadre, nil
}

// ClearDCInPresentCadre clears the value of the "DCInPresentCadre" field.
func (m *ExamApplicationsIPMutation) ClearDCInPresentCadre() {
	m._DCInPresentCadre = nil
	m.clearedFields[exam_applications_ip.FieldDCInPresentCadre] = struct{}{}
}

// DCInPresentCadreCleared returns if the "DCInPresentCadre" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) DCInPresentCadreCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldDCInPresentCadre]
	return ok
}

// ResetDCInPresentCadre resets all changes to the "DCInPresentCadre" field.
func (m *ExamApplicationsIPMutation) ResetDCInPresentCadre() {
	m._DCInPresentCadre = nil
	delete(m.clearedFields, exam_applications_ip.FieldDCInPresentCadre)
}

// SetDeputationOfficeId sets the "DeputationOfficeId" field.
func (m *ExamApplicationsIPMutation) SetDeputationOfficeId(s string) {
	m._DeputationOfficeId = &s
}

// DeputationOfficeId returns the value of the "DeputationOfficeId" field in the mutation.
func (m *ExamApplicationsIPMutation) DeputationOfficeId() (r string, exists bool) {
	v := m._DeputationOfficeId
	if v == nil {
		return
	}
	return *v, true
}

// OldDeputationOfficeId returns the old "DeputationOfficeId" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldDeputationOfficeId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeputationOfficeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeputationOfficeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeputationOfficeId: %w", err)
	}
	return oldValue.DeputationOfficeId, nil
}

// ClearDeputationOfficeId clears the value of the "DeputationOfficeId" field.
func (m *ExamApplicationsIPMutation) ClearDeputationOfficeId() {
	m._DeputationOfficeId = nil
	m.clearedFields[exam_applications_ip.FieldDeputationOfficeId] = struct{}{}
}

// DeputationOfficeIdCleared returns if the "DeputationOfficeId" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) DeputationOfficeIdCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldDeputationOfficeId]
	return ok
}

// ResetDeputationOfficeId resets all changes to the "DeputationOfficeId" field.
func (m *ExamApplicationsIPMutation) ResetDeputationOfficeId() {
	m._DeputationOfficeId = nil
	delete(m.clearedFields, exam_applications_ip.FieldDeputationOfficeId)
}

// SetDisabilityType sets the "DisabilityType" field.
func (m *ExamApplicationsIPMutation) SetDisabilityType(s string) {
	m._DisabilityType = &s
}

// DisabilityType returns the value of the "DisabilityType" field in the mutation.
func (m *ExamApplicationsIPMutation) DisabilityType() (r string, exists bool) {
	v := m._DisabilityType
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityType returns the old "DisabilityType" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldDisabilityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityType: %w", err)
	}
	return oldValue.DisabilityType, nil
}

// ClearDisabilityType clears the value of the "DisabilityType" field.
func (m *ExamApplicationsIPMutation) ClearDisabilityType() {
	m._DisabilityType = nil
	m.clearedFields[exam_applications_ip.FieldDisabilityType] = struct{}{}
}

// DisabilityTypeCleared returns if the "DisabilityType" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) DisabilityTypeCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldDisabilityType]
	return ok
}

// ResetDisabilityType resets all changes to the "DisabilityType" field.
func (m *ExamApplicationsIPMutation) ResetDisabilityType() {
	m._DisabilityType = nil
	delete(m.clearedFields, exam_applications_ip.FieldDisabilityType)
}

// SetDisabilityPercentage sets the "DisabilityPercentage" field.
func (m *ExamApplicationsIPMutation) SetDisabilityPercentage(s string) {
	m._DisabilityPercentage = &s
}

// DisabilityPercentage returns the value of the "DisabilityPercentage" field in the mutation.
func (m *ExamApplicationsIPMutation) DisabilityPercentage() (r string, exists bool) {
	v := m._DisabilityPercentage
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityPercentage returns the old "DisabilityPercentage" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldDisabilityPercentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityPercentage: %w", err)
	}
	return oldValue.DisabilityPercentage, nil
}

// ClearDisabilityPercentage clears the value of the "DisabilityPercentage" field.
func (m *ExamApplicationsIPMutation) ClearDisabilityPercentage() {
	m._DisabilityPercentage = nil
	m.clearedFields[exam_applications_ip.FieldDisabilityPercentage] = struct{}{}
}

// DisabilityPercentageCleared returns if the "DisabilityPercentage" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) DisabilityPercentageCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldDisabilityPercentage]
	return ok
}

// ResetDisabilityPercentage resets all changes to the "DisabilityPercentage" field.
func (m *ExamApplicationsIPMutation) ResetDisabilityPercentage() {
	m._DisabilityPercentage = nil
	delete(m.clearedFields, exam_applications_ip.FieldDisabilityPercentage)
}

// SetEducation sets the "Education" field.
func (m *ExamApplicationsIPMutation) SetEducation(s string) {
	m._Education = &s
}

// Education returns the value of the "Education" field in the mutation.
func (m *ExamApplicationsIPMutation) Education() (r string, exists bool) {
	v := m._Education
	if v == nil {
		return
	}
	return *v, true
}

// OldEducation returns the old "Education" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldEducation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducation: %w", err)
	}
	return oldValue.Education, nil
}

// ClearEducation clears the value of the "Education" field.
func (m *ExamApplicationsIPMutation) ClearEducation() {
	m._Education = nil
	m.clearedFields[exam_applications_ip.FieldEducation] = struct{}{}
}

// EducationCleared returns if the "Education" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) EducationCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldEducation]
	return ok
}

// ResetEducation resets all changes to the "Education" field.
func (m *ExamApplicationsIPMutation) ResetEducation() {
	m._Education = nil
	delete(m.clearedFields, exam_applications_ip.FieldEducation)
}

// SetExamNameCode sets the "ExamNameCode" field.
func (m *ExamApplicationsIPMutation) SetExamNameCode(s string) {
	m._ExamNameCode = &s
}

// ExamNameCode returns the value of the "ExamNameCode" field in the mutation.
func (m *ExamApplicationsIPMutation) ExamNameCode() (r string, exists bool) {
	v := m._ExamNameCode
	if v == nil {
		return
	}
	return *v, true
}

// OldExamNameCode returns the old "ExamNameCode" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldExamNameCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamNameCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamNameCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamNameCode: %w", err)
	}
	return oldValue.ExamNameCode, nil
}

// ClearExamNameCode clears the value of the "ExamNameCode" field.
func (m *ExamApplicationsIPMutation) ClearExamNameCode() {
	m._ExamNameCode = nil
	m.clearedFields[exam_applications_ip.FieldExamNameCode] = struct{}{}
}

// ExamNameCodeCleared returns if the "ExamNameCode" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) ExamNameCodeCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldExamNameCode]
	return ok
}

// ResetExamNameCode resets all changes to the "ExamNameCode" field.
func (m *ExamApplicationsIPMutation) ResetExamNameCode() {
	m._ExamNameCode = nil
	delete(m.clearedFields, exam_applications_ip.FieldExamNameCode)
}

// SetExamYear sets the "ExamYear" field.
func (m *ExamApplicationsIPMutation) SetExamYear(s string) {
	m._ExamYear = &s
}

// ExamYear returns the value of the "ExamYear" field in the mutation.
func (m *ExamApplicationsIPMutation) ExamYear() (r string, exists bool) {
	v := m._ExamYear
	if v == nil {
		return
	}
	return *v, true
}

// OldExamYear returns the old "ExamYear" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldExamYear(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamYear: %w", err)
	}
	return oldValue.ExamYear, nil
}

// ClearExamYear clears the value of the "ExamYear" field.
func (m *ExamApplicationsIPMutation) ClearExamYear() {
	m._ExamYear = nil
	m.clearedFields[exam_applications_ip.FieldExamYear] = struct{}{}
}

// ExamYearCleared returns if the "ExamYear" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) ExamYearCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldExamYear]
	return ok
}

// ResetExamYear resets all changes to the "ExamYear" field.
func (m *ExamApplicationsIPMutation) ResetExamYear() {
	m._ExamYear = nil
	delete(m.clearedFields, exam_applications_ip.FieldExamYear)
}

// SetExamName sets the "ExamName" field.
func (m *ExamApplicationsIPMutation) SetExamName(s string) {
	m._ExamName = &s
}

// ExamName returns the value of the "ExamName" field in the mutation.
func (m *ExamApplicationsIPMutation) ExamName() (r string, exists bool) {
	v := m._ExamName
	if v == nil {
		return
	}
	return *v, true
}

// OldExamName returns the old "ExamName" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldExamName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamName: %w", err)
	}
	return oldValue.ExamName, nil
}

// ClearExamName clears the value of the "ExamName" field.
func (m *ExamApplicationsIPMutation) ClearExamName() {
	m._ExamName = nil
	m.clearedFields[exam_applications_ip.FieldExamName] = struct{}{}
}

// ExamNameCleared returns if the "ExamName" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) ExamNameCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldExamName]
	return ok
}

// ResetExamName resets all changes to the "ExamName" field.
func (m *ExamApplicationsIPMutation) ResetExamName() {
	m._ExamName = nil
	delete(m.clearedFields, exam_applications_ip.FieldExamName)
}

// SetPresentCadre sets the "PresentCadre" field.
func (m *ExamApplicationsIPMutation) SetPresentCadre(s string) {
	m._PresentCadre = &s
}

// PresentCadre returns the value of the "PresentCadre" field in the mutation.
func (m *ExamApplicationsIPMutation) PresentCadre() (r string, exists bool) {
	v := m._PresentCadre
	if v == nil {
		return
	}
	return *v, true
}

// OldPresentCadre returns the old "PresentCadre" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldPresentCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPresentCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPresentCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPresentCadre: %w", err)
	}
	return oldValue.PresentCadre, nil
}

// ClearPresentCadre clears the value of the "PresentCadre" field.
func (m *ExamApplicationsIPMutation) ClearPresentCadre() {
	m._PresentCadre = nil
	m.clearedFields[exam_applications_ip.FieldPresentCadre] = struct{}{}
}

// PresentCadreCleared returns if the "PresentCadre" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) PresentCadreCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldPresentCadre]
	return ok
}

// ResetPresentCadre resets all changes to the "PresentCadre" field.
func (m *ExamApplicationsIPMutation) ResetPresentCadre() {
	m._PresentCadre = nil
	delete(m.clearedFields, exam_applications_ip.FieldPresentCadre)
}

// SetPresentDesignation sets the "PresentDesignation" field.
func (m *ExamApplicationsIPMutation) SetPresentDesignation(s string) {
	m._PresentDesignation = &s
}

// PresentDesignation returns the value of the "PresentDesignation" field in the mutation.
func (m *ExamApplicationsIPMutation) PresentDesignation() (r string, exists bool) {
	v := m._PresentDesignation
	if v == nil {
		return
	}
	return *v, true
}

// OldPresentDesignation returns the old "PresentDesignation" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldPresentDesignation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPresentDesignation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPresentDesignation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPresentDesignation: %w", err)
	}
	return oldValue.PresentDesignation, nil
}

// ClearPresentDesignation clears the value of the "PresentDesignation" field.
func (m *ExamApplicationsIPMutation) ClearPresentDesignation() {
	m._PresentDesignation = nil
	m.clearedFields[exam_applications_ip.FieldPresentDesignation] = struct{}{}
}

// PresentDesignationCleared returns if the "PresentDesignation" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) PresentDesignationCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldPresentDesignation]
	return ok
}

// ResetPresentDesignation resets all changes to the "PresentDesignation" field.
func (m *ExamApplicationsIPMutation) ResetPresentDesignation() {
	m._PresentDesignation = nil
	delete(m.clearedFields, exam_applications_ip.FieldPresentDesignation)
}

// SetEligibleCadre sets the "EligibleCadre" field.
func (m *ExamApplicationsIPMutation) SetEligibleCadre(s string) {
	m._EligibleCadre = &s
}

// EligibleCadre returns the value of the "EligibleCadre" field in the mutation.
func (m *ExamApplicationsIPMutation) EligibleCadre() (r string, exists bool) {
	v := m._EligibleCadre
	if v == nil {
		return
	}
	return *v, true
}

// OldEligibleCadre returns the old "EligibleCadre" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldEligibleCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligibleCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligibleCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligibleCadre: %w", err)
	}
	return oldValue.EligibleCadre, nil
}

// ClearEligibleCadre clears the value of the "EligibleCadre" field.
func (m *ExamApplicationsIPMutation) ClearEligibleCadre() {
	m._EligibleCadre = nil
	m.clearedFields[exam_applications_ip.FieldEligibleCadre] = struct{}{}
}

// EligibleCadreCleared returns if the "EligibleCadre" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) EligibleCadreCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldEligibleCadre]
	return ok
}

// ResetEligibleCadre resets all changes to the "EligibleCadre" field.
func (m *ExamApplicationsIPMutation) ResetEligibleCadre() {
	m._EligibleCadre = nil
	delete(m.clearedFields, exam_applications_ip.FieldEligibleCadre)
}

// SetEligibleCadreDate sets the "EligibleCadreDate" field.
func (m *ExamApplicationsIPMutation) SetEligibleCadreDate(s string) {
	m._EligibleCadreDate = &s
}

// EligibleCadreDate returns the value of the "EligibleCadreDate" field in the mutation.
func (m *ExamApplicationsIPMutation) EligibleCadreDate() (r string, exists bool) {
	v := m._EligibleCadreDate
	if v == nil {
		return
	}
	return *v, true
}

// OldEligibleCadreDate returns the old "EligibleCadreDate" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldEligibleCadreDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligibleCadreDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligibleCadreDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligibleCadreDate: %w", err)
	}
	return oldValue.EligibleCadreDate, nil
}

// ClearEligibleCadreDate clears the value of the "EligibleCadreDate" field.
func (m *ExamApplicationsIPMutation) ClearEligibleCadreDate() {
	m._EligibleCadreDate = nil
	m.clearedFields[exam_applications_ip.FieldEligibleCadreDate] = struct{}{}
}

// EligibleCadreDateCleared returns if the "EligibleCadreDate" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) EligibleCadreDateCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldEligibleCadreDate]
	return ok
}

// ResetEligibleCadreDate resets all changes to the "EligibleCadreDate" field.
func (m *ExamApplicationsIPMutation) ResetEligibleCadreDate() {
	m._EligibleCadreDate = nil
	delete(m.clearedFields, exam_applications_ip.FieldEligibleCadreDate)
}

// SetServiceLength sets the "ServiceLength" field.
func (m *ExamApplicationsIPMutation) SetServiceLength(i []interface{}) {
	m._ServiceLength = &i
	m.append_ServiceLength = nil
}

// ServiceLength returns the value of the "ServiceLength" field in the mutation.
func (m *ExamApplicationsIPMutation) ServiceLength() (r []interface{}, exists bool) {
	v := m._ServiceLength
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceLength returns the old "ServiceLength" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldServiceLength(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceLength: %w", err)
	}
	return oldValue.ServiceLength, nil
}

// AppendServiceLength adds i to the "ServiceLength" field.
func (m *ExamApplicationsIPMutation) AppendServiceLength(i []interface{}) {
	m.append_ServiceLength = append(m.append_ServiceLength, i...)
}

// AppendedServiceLength returns the list of values that were appended to the "ServiceLength" field in this mutation.
func (m *ExamApplicationsIPMutation) AppendedServiceLength() ([]interface{}, bool) {
	if len(m.append_ServiceLength) == 0 {
		return nil, false
	}
	return m.append_ServiceLength, true
}

// ClearServiceLength clears the value of the "ServiceLength" field.
func (m *ExamApplicationsIPMutation) ClearServiceLength() {
	m._ServiceLength = nil
	m.append_ServiceLength = nil
	m.clearedFields[exam_applications_ip.FieldServiceLength] = struct{}{}
}

// ServiceLengthCleared returns if the "ServiceLength" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) ServiceLengthCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldServiceLength]
	return ok
}

// ResetServiceLength resets all changes to the "ServiceLength" field.
func (m *ExamApplicationsIPMutation) ResetServiceLength() {
	m._ServiceLength = nil
	m.append_ServiceLength = nil
	delete(m.clearedFields, exam_applications_ip.FieldServiceLength)
}

// SetCentrePreference sets the "CentrePreference" field.
func (m *ExamApplicationsIPMutation) SetCentrePreference(s string) {
	m._CentrePreference = &s
}

// CentrePreference returns the value of the "CentrePreference" field in the mutation.
func (m *ExamApplicationsIPMutation) CentrePreference() (r string, exists bool) {
	v := m._CentrePreference
	if v == nil {
		return
	}
	return *v, true
}

// OldCentrePreference returns the old "CentrePreference" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldCentrePreference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCentrePreference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCentrePreference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCentrePreference: %w", err)
	}
	return oldValue.CentrePreference, nil
}

// ClearCentrePreference clears the value of the "CentrePreference" field.
func (m *ExamApplicationsIPMutation) ClearCentrePreference() {
	m._CentrePreference = nil
	m.clearedFields[exam_applications_ip.FieldCentrePreference] = struct{}{}
}

// CentrePreferenceCleared returns if the "CentrePreference" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) CentrePreferenceCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldCentrePreference]
	return ok
}

// ResetCentrePreference resets all changes to the "CentrePreference" field.
func (m *ExamApplicationsIPMutation) ResetCentrePreference() {
	m._CentrePreference = nil
	delete(m.clearedFields, exam_applications_ip.FieldCentrePreference)
}

// SetSignature sets the "Signature" field.
func (m *ExamApplicationsIPMutation) SetSignature(s string) {
	m._Signature = &s
}

// Signature returns the value of the "Signature" field in the mutation.
func (m *ExamApplicationsIPMutation) Signature() (r string, exists bool) {
	v := m._Signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "Signature" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "Signature" field.
func (m *ExamApplicationsIPMutation) ClearSignature() {
	m._Signature = nil
	m.clearedFields[exam_applications_ip.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "Signature" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "Signature" field.
func (m *ExamApplicationsIPMutation) ResetSignature() {
	m._Signature = nil
	delete(m.clearedFields, exam_applications_ip.FieldSignature)
}

// SetPhoto sets the "Photo" field.
func (m *ExamApplicationsIPMutation) SetPhoto(s string) {
	m._Photo = &s
}

// Photo returns the value of the "Photo" field in the mutation.
func (m *ExamApplicationsIPMutation) Photo() (r string, exists bool) {
	v := m._Photo
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoto returns the old "Photo" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoto: %w", err)
	}
	return oldValue.Photo, nil
}

// ClearPhoto clears the value of the "Photo" field.
func (m *ExamApplicationsIPMutation) ClearPhoto() {
	m._Photo = nil
	m.clearedFields[exam_applications_ip.FieldPhoto] = struct{}{}
}

// PhotoCleared returns if the "Photo" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) PhotoCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldPhoto]
	return ok
}

// ResetPhoto resets all changes to the "Photo" field.
func (m *ExamApplicationsIPMutation) ResetPhoto() {
	m._Photo = nil
	delete(m.clearedFields, exam_applications_ip.FieldPhoto)
}

// SetApplicationStatus sets the "ApplicationStatus" field.
func (m *ExamApplicationsIPMutation) SetApplicationStatus(s string) {
	m._ApplicationStatus = &s
}

// ApplicationStatus returns the value of the "ApplicationStatus" field in the mutation.
func (m *ExamApplicationsIPMutation) ApplicationStatus() (r string, exists bool) {
	v := m._ApplicationStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationStatus returns the old "ApplicationStatus" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldApplicationStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationStatus: %w", err)
	}
	return oldValue.ApplicationStatus, nil
}

// ClearApplicationStatus clears the value of the "ApplicationStatus" field.
func (m *ExamApplicationsIPMutation) ClearApplicationStatus() {
	m._ApplicationStatus = nil
	m.clearedFields[exam_applications_ip.FieldApplicationStatus] = struct{}{}
}

// ApplicationStatusCleared returns if the "ApplicationStatus" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) ApplicationStatusCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldApplicationStatus]
	return ok
}

// ResetApplicationStatus resets all changes to the "ApplicationStatus" field.
func (m *ExamApplicationsIPMutation) ResetApplicationStatus() {
	m._ApplicationStatus = nil
	delete(m.clearedFields, exam_applications_ip.FieldApplicationStatus)
}

// SetApplnSubmittedDate sets the "ApplnSubmittedDate" field.
func (m *ExamApplicationsIPMutation) SetApplnSubmittedDate(t time.Time) {
	m._ApplnSubmittedDate = &t
}

// ApplnSubmittedDate returns the value of the "ApplnSubmittedDate" field in the mutation.
func (m *ExamApplicationsIPMutation) ApplnSubmittedDate() (r time.Time, exists bool) {
	v := m._ApplnSubmittedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldApplnSubmittedDate returns the old "ApplnSubmittedDate" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldApplnSubmittedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplnSubmittedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplnSubmittedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplnSubmittedDate: %w", err)
	}
	return oldValue.ApplnSubmittedDate, nil
}

// ClearApplnSubmittedDate clears the value of the "ApplnSubmittedDate" field.
func (m *ExamApplicationsIPMutation) ClearApplnSubmittedDate() {
	m._ApplnSubmittedDate = nil
	m.clearedFields[exam_applications_ip.FieldApplnSubmittedDate] = struct{}{}
}

// ApplnSubmittedDateCleared returns if the "ApplnSubmittedDate" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) ApplnSubmittedDateCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldApplnSubmittedDate]
	return ok
}

// ResetApplnSubmittedDate resets all changes to the "ApplnSubmittedDate" field.
func (m *ExamApplicationsIPMutation) ResetApplnSubmittedDate() {
	m._ApplnSubmittedDate = nil
	delete(m.clearedFields, exam_applications_ip.FieldApplnSubmittedDate)
}

// SetVARemarks sets the "VA_Remarks" field.
func (m *ExamApplicationsIPMutation) SetVARemarks(s string) {
	m._VA_Remarks = &s
}

// VARemarks returns the value of the "VA_Remarks" field in the mutation.
func (m *ExamApplicationsIPMutation) VARemarks() (r string, exists bool) {
	v := m._VA_Remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldVARemarks returns the old "VA_Remarks" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldVARemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVARemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVARemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVARemarks: %w", err)
	}
	return oldValue.VARemarks, nil
}

// ClearVARemarks clears the value of the "VA_Remarks" field.
func (m *ExamApplicationsIPMutation) ClearVARemarks() {
	m._VA_Remarks = nil
	m.clearedFields[exam_applications_ip.FieldVARemarks] = struct{}{}
}

// VARemarksCleared returns if the "VA_Remarks" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) VARemarksCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldVARemarks]
	return ok
}

// ResetVARemarks resets all changes to the "VA_Remarks" field.
func (m *ExamApplicationsIPMutation) ResetVARemarks() {
	m._VA_Remarks = nil
	delete(m.clearedFields, exam_applications_ip.FieldVARemarks)
}

// SetVAUserName sets the "VA_UserName" field.
func (m *ExamApplicationsIPMutation) SetVAUserName(s string) {
	m._VA_UserName = &s
}

// VAUserName returns the value of the "VA_UserName" field in the mutation.
func (m *ExamApplicationsIPMutation) VAUserName() (r string, exists bool) {
	v := m._VA_UserName
	if v == nil {
		return
	}
	return *v, true
}

// OldVAUserName returns the old "VA_UserName" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldVAUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVAUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVAUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVAUserName: %w", err)
	}
	return oldValue.VAUserName, nil
}

// ClearVAUserName clears the value of the "VA_UserName" field.
func (m *ExamApplicationsIPMutation) ClearVAUserName() {
	m._VA_UserName = nil
	m.clearedFields[exam_applications_ip.FieldVAUserName] = struct{}{}
}

// VAUserNameCleared returns if the "VA_UserName" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) VAUserNameCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldVAUserName]
	return ok
}

// ResetVAUserName resets all changes to the "VA_UserName" field.
func (m *ExamApplicationsIPMutation) ResetVAUserName() {
	m._VA_UserName = nil
	delete(m.clearedFields, exam_applications_ip.FieldVAUserName)
}

// SetVADate sets the "VA_Date" field.
func (m *ExamApplicationsIPMutation) SetVADate(t time.Time) {
	m._VA_Date = &t
}

// VADate returns the value of the "VA_Date" field in the mutation.
func (m *ExamApplicationsIPMutation) VADate() (r time.Time, exists bool) {
	v := m._VA_Date
	if v == nil {
		return
	}
	return *v, true
}

// OldVADate returns the old "VA_Date" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldVADate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVADate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVADate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVADate: %w", err)
	}
	return oldValue.VADate, nil
}

// ClearVADate clears the value of the "VA_Date" field.
func (m *ExamApplicationsIPMutation) ClearVADate() {
	m._VA_Date = nil
	m.clearedFields[exam_applications_ip.FieldVADate] = struct{}{}
}

// VADateCleared returns if the "VA_Date" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) VADateCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldVADate]
	return ok
}

// ResetVADate resets all changes to the "VA_Date" field.
func (m *ExamApplicationsIPMutation) ResetVADate() {
	m._VA_Date = nil
	delete(m.clearedFields, exam_applications_ip.FieldVADate)
}

// SetCARemarks sets the "CA_Remarks" field.
func (m *ExamApplicationsIPMutation) SetCARemarks(s string) {
	m._CA_Remarks = &s
}

// CARemarks returns the value of the "CA_Remarks" field in the mutation.
func (m *ExamApplicationsIPMutation) CARemarks() (r string, exists bool) {
	v := m._CA_Remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldCARemarks returns the old "CA_Remarks" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldCARemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCARemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCARemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCARemarks: %w", err)
	}
	return oldValue.CARemarks, nil
}

// ClearCARemarks clears the value of the "CA_Remarks" field.
func (m *ExamApplicationsIPMutation) ClearCARemarks() {
	m._CA_Remarks = nil
	m.clearedFields[exam_applications_ip.FieldCARemarks] = struct{}{}
}

// CARemarksCleared returns if the "CA_Remarks" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) CARemarksCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldCARemarks]
	return ok
}

// ResetCARemarks resets all changes to the "CA_Remarks" field.
func (m *ExamApplicationsIPMutation) ResetCARemarks() {
	m._CA_Remarks = nil
	delete(m.clearedFields, exam_applications_ip.FieldCARemarks)
}

// SetCAUserName sets the "CA_UserName" field.
func (m *ExamApplicationsIPMutation) SetCAUserName(s string) {
	m._CA_UserName = &s
}

// CAUserName returns the value of the "CA_UserName" field in the mutation.
func (m *ExamApplicationsIPMutation) CAUserName() (r string, exists bool) {
	v := m._CA_UserName
	if v == nil {
		return
	}
	return *v, true
}

// OldCAUserName returns the old "CA_UserName" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldCAUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCAUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCAUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCAUserName: %w", err)
	}
	return oldValue.CAUserName, nil
}

// ClearCAUserName clears the value of the "CA_UserName" field.
func (m *ExamApplicationsIPMutation) ClearCAUserName() {
	m._CA_UserName = nil
	m.clearedFields[exam_applications_ip.FieldCAUserName] = struct{}{}
}

// CAUserNameCleared returns if the "CA_UserName" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) CAUserNameCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldCAUserName]
	return ok
}

// ResetCAUserName resets all changes to the "CA_UserName" field.
func (m *ExamApplicationsIPMutation) ResetCAUserName() {
	m._CA_UserName = nil
	delete(m.clearedFields, exam_applications_ip.FieldCAUserName)
}

// SetCADate sets the "CA_Date" field.
func (m *ExamApplicationsIPMutation) SetCADate(t time.Time) {
	m._CA_Date = &t
}

// CADate returns the value of the "CA_Date" field in the mutation.
func (m *ExamApplicationsIPMutation) CADate() (r time.Time, exists bool) {
	v := m._CA_Date
	if v == nil {
		return
	}
	return *v, true
}

// OldCADate returns the old "CA_Date" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldCADate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCADate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCADate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCADate: %w", err)
	}
	return oldValue.CADate, nil
}

// ClearCADate clears the value of the "CA_Date" field.
func (m *ExamApplicationsIPMutation) ClearCADate() {
	m._CA_Date = nil
	m.clearedFields[exam_applications_ip.FieldCADate] = struct{}{}
}

// CADateCleared returns if the "CA_Date" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) CADateCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldCADate]
	return ok
}

// ResetCADate resets all changes to the "CA_Date" field.
func (m *ExamApplicationsIPMutation) ResetCADate() {
	m._CA_Date = nil
	delete(m.clearedFields, exam_applications_ip.FieldCADate)
}

// SetApplicationWdlDate sets the "ApplicationWdlDate" field.
func (m *ExamApplicationsIPMutation) SetApplicationWdlDate(t time.Time) {
	m._ApplicationWdlDate = &t
}

// ApplicationWdlDate returns the value of the "ApplicationWdlDate" field in the mutation.
func (m *ExamApplicationsIPMutation) ApplicationWdlDate() (r time.Time, exists bool) {
	v := m._ApplicationWdlDate
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationWdlDate returns the old "ApplicationWdlDate" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldApplicationWdlDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationWdlDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationWdlDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationWdlDate: %w", err)
	}
	return oldValue.ApplicationWdlDate, nil
}

// ClearApplicationWdlDate clears the value of the "ApplicationWdlDate" field.
func (m *ExamApplicationsIPMutation) ClearApplicationWdlDate() {
	m._ApplicationWdlDate = nil
	m.clearedFields[exam_applications_ip.FieldApplicationWdlDate] = struct{}{}
}

// ApplicationWdlDateCleared returns if the "ApplicationWdlDate" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) ApplicationWdlDateCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldApplicationWdlDate]
	return ok
}

// ResetApplicationWdlDate resets all changes to the "ApplicationWdlDate" field.
func (m *ExamApplicationsIPMutation) ResetApplicationWdlDate() {
	m._ApplicationWdlDate = nil
	delete(m.clearedFields, exam_applications_ip.FieldApplicationWdlDate)
}

// SetNARemarks sets the "NA_Remarks" field.
func (m *ExamApplicationsIPMutation) SetNARemarks(s string) {
	m._NA_Remarks = &s
}

// NARemarks returns the value of the "NA_Remarks" field in the mutation.
func (m *ExamApplicationsIPMutation) NARemarks() (r string, exists bool) {
	v := m._NA_Remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldNARemarks returns the old "NA_Remarks" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldNARemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNARemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNARemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNARemarks: %w", err)
	}
	return oldValue.NARemarks, nil
}

// ClearNARemarks clears the value of the "NA_Remarks" field.
func (m *ExamApplicationsIPMutation) ClearNARemarks() {
	m._NA_Remarks = nil
	m.clearedFields[exam_applications_ip.FieldNARemarks] = struct{}{}
}

// NARemarksCleared returns if the "NA_Remarks" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) NARemarksCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldNARemarks]
	return ok
}

// ResetNARemarks resets all changes to the "NA_Remarks" field.
func (m *ExamApplicationsIPMutation) ResetNARemarks() {
	m._NA_Remarks = nil
	delete(m.clearedFields, exam_applications_ip.FieldNARemarks)
}

// SetNAUserName sets the "NA_UserName" field.
func (m *ExamApplicationsIPMutation) SetNAUserName(s string) {
	m._NA_UserName = &s
}

// NAUserName returns the value of the "NA_UserName" field in the mutation.
func (m *ExamApplicationsIPMutation) NAUserName() (r string, exists bool) {
	v := m._NA_UserName
	if v == nil {
		return
	}
	return *v, true
}

// OldNAUserName returns the old "NA_UserName" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldNAUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNAUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNAUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNAUserName: %w", err)
	}
	return oldValue.NAUserName, nil
}

// ClearNAUserName clears the value of the "NA_UserName" field.
func (m *ExamApplicationsIPMutation) ClearNAUserName() {
	m._NA_UserName = nil
	m.clearedFields[exam_applications_ip.FieldNAUserName] = struct{}{}
}

// NAUserNameCleared returns if the "NA_UserName" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) NAUserNameCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldNAUserName]
	return ok
}

// ResetNAUserName resets all changes to the "NA_UserName" field.
func (m *ExamApplicationsIPMutation) ResetNAUserName() {
	m._NA_UserName = nil
	delete(m.clearedFields, exam_applications_ip.FieldNAUserName)
}

// SetNADate sets the "NA_Date" field.
func (m *ExamApplicationsIPMutation) SetNADate(t time.Time) {
	m._NA_Date = &t
}

// NADate returns the value of the "NA_Date" field in the mutation.
func (m *ExamApplicationsIPMutation) NADate() (r time.Time, exists bool) {
	v := m._NA_Date
	if v == nil {
		return
	}
	return *v, true
}

// OldNADate returns the old "NA_Date" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldNADate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNADate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNADate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNADate: %w", err)
	}
	return oldValue.NADate, nil
}

// ClearNADate clears the value of the "NA_Date" field.
func (m *ExamApplicationsIPMutation) ClearNADate() {
	m._NA_Date = nil
	m.clearedFields[exam_applications_ip.FieldNADate] = struct{}{}
}

// NADateCleared returns if the "NA_Date" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) NADateCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldNADate]
	return ok
}

// ResetNADate resets all changes to the "NA_Date" field.
func (m *ExamApplicationsIPMutation) ResetNADate() {
	m._NA_Date = nil
	delete(m.clearedFields, exam_applications_ip.FieldNADate)
}

// SetAppliactionRemarks sets the "AppliactionRemarks" field.
func (m *ExamApplicationsIPMutation) SetAppliactionRemarks(s string) {
	m._AppliactionRemarks = &s
}

// AppliactionRemarks returns the value of the "AppliactionRemarks" field in the mutation.
func (m *ExamApplicationsIPMutation) AppliactionRemarks() (r string, exists bool) {
	v := m._AppliactionRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliactionRemarks returns the old "AppliactionRemarks" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldAppliactionRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliactionRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliactionRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliactionRemarks: %w", err)
	}
	return oldValue.AppliactionRemarks, nil
}

// ClearAppliactionRemarks clears the value of the "AppliactionRemarks" field.
func (m *ExamApplicationsIPMutation) ClearAppliactionRemarks() {
	m._AppliactionRemarks = nil
	m.clearedFields[exam_applications_ip.FieldAppliactionRemarks] = struct{}{}
}

// AppliactionRemarksCleared returns if the "AppliactionRemarks" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) AppliactionRemarksCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldAppliactionRemarks]
	return ok
}

// ResetAppliactionRemarks resets all changes to the "AppliactionRemarks" field.
func (m *ExamApplicationsIPMutation) ResetAppliactionRemarks() {
	m._AppliactionRemarks = nil
	delete(m.clearedFields, exam_applications_ip.FieldAppliactionRemarks)
}

// SetCadrePreferences sets the "CadrePreferences" field.
func (m *ExamApplicationsIPMutation) SetCadrePreferences(i []interface{}) {
	m._CadrePreferences = &i
	m.append_CadrePreferences = nil
}

// CadrePreferences returns the value of the "CadrePreferences" field in the mutation.
func (m *ExamApplicationsIPMutation) CadrePreferences() (r []interface{}, exists bool) {
	v := m._CadrePreferences
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePreferences returns the old "CadrePreferences" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldCadrePreferences(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePreferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePreferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePreferences: %w", err)
	}
	return oldValue.CadrePreferences, nil
}

// AppendCadrePreferences adds i to the "CadrePreferences" field.
func (m *ExamApplicationsIPMutation) AppendCadrePreferences(i []interface{}) {
	m.append_CadrePreferences = append(m.append_CadrePreferences, i...)
}

// AppendedCadrePreferences returns the list of values that were appended to the "CadrePreferences" field in this mutation.
func (m *ExamApplicationsIPMutation) AppendedCadrePreferences() ([]interface{}, bool) {
	if len(m.append_CadrePreferences) == 0 {
		return nil, false
	}
	return m.append_CadrePreferences, true
}

// ClearCadrePreferences clears the value of the "CadrePreferences" field.
func (m *ExamApplicationsIPMutation) ClearCadrePreferences() {
	m._CadrePreferences = nil
	m.append_CadrePreferences = nil
	m.clearedFields[exam_applications_ip.FieldCadrePreferences] = struct{}{}
}

// CadrePreferencesCleared returns if the "CadrePreferences" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) CadrePreferencesCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldCadrePreferences]
	return ok
}

// ResetCadrePreferences resets all changes to the "CadrePreferences" field.
func (m *ExamApplicationsIPMutation) ResetCadrePreferences() {
	m._CadrePreferences = nil
	m.append_CadrePreferences = nil
	delete(m.clearedFields, exam_applications_ip.FieldCadrePreferences)
}

// SetDivisionPreferences sets the "DivisionPreferences" field.
func (m *ExamApplicationsIPMutation) SetDivisionPreferences(i []interface{}) {
	m._DivisionPreferences = &i
	m.append_DivisionPreferences = nil
}

// DivisionPreferences returns the value of the "DivisionPreferences" field in the mutation.
func (m *ExamApplicationsIPMutation) DivisionPreferences() (r []interface{}, exists bool) {
	v := m._DivisionPreferences
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionPreferences returns the old "DivisionPreferences" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldDivisionPreferences(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionPreferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionPreferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionPreferences: %w", err)
	}
	return oldValue.DivisionPreferences, nil
}

// AppendDivisionPreferences adds i to the "DivisionPreferences" field.
func (m *ExamApplicationsIPMutation) AppendDivisionPreferences(i []interface{}) {
	m.append_DivisionPreferences = append(m.append_DivisionPreferences, i...)
}

// AppendedDivisionPreferences returns the list of values that were appended to the "DivisionPreferences" field in this mutation.
func (m *ExamApplicationsIPMutation) AppendedDivisionPreferences() ([]interface{}, bool) {
	if len(m.append_DivisionPreferences) == 0 {
		return nil, false
	}
	return m.append_DivisionPreferences, true
}

// ClearDivisionPreferences clears the value of the "DivisionPreferences" field.
func (m *ExamApplicationsIPMutation) ClearDivisionPreferences() {
	m._DivisionPreferences = nil
	m.append_DivisionPreferences = nil
	m.clearedFields[exam_applications_ip.FieldDivisionPreferences] = struct{}{}
}

// DivisionPreferencesCleared returns if the "DivisionPreferences" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) DivisionPreferencesCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldDivisionPreferences]
	return ok
}

// ResetDivisionPreferences resets all changes to the "DivisionPreferences" field.
func (m *ExamApplicationsIPMutation) ResetDivisionPreferences() {
	m._DivisionPreferences = nil
	m.append_DivisionPreferences = nil
	delete(m.clearedFields, exam_applications_ip.FieldDivisionPreferences)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *ExamApplicationsIPMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *ExamApplicationsIPMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *ExamApplicationsIPMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[exam_applications_ip.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *ExamApplicationsIPMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, exam_applications_ip.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *ExamApplicationsIPMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *ExamApplicationsIPMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *ExamApplicationsIPMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[exam_applications_ip.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *ExamApplicationsIPMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, exam_applications_ip.FieldUpdatedBy)
}

// SetCAPreviousRemarks sets the "CAPreviousRemarks" field.
func (m *ExamApplicationsIPMutation) SetCAPreviousRemarks(s string) {
	m._CAPreviousRemarks = &s
}

// CAPreviousRemarks returns the value of the "CAPreviousRemarks" field in the mutation.
func (m *ExamApplicationsIPMutation) CAPreviousRemarks() (r string, exists bool) {
	v := m._CAPreviousRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldCAPreviousRemarks returns the old "CAPreviousRemarks" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldCAPreviousRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCAPreviousRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCAPreviousRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCAPreviousRemarks: %w", err)
	}
	return oldValue.CAPreviousRemarks, nil
}

// ClearCAPreviousRemarks clears the value of the "CAPreviousRemarks" field.
func (m *ExamApplicationsIPMutation) ClearCAPreviousRemarks() {
	m._CAPreviousRemarks = nil
	m.clearedFields[exam_applications_ip.FieldCAPreviousRemarks] = struct{}{}
}

// CAPreviousRemarksCleared returns if the "CAPreviousRemarks" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) CAPreviousRemarksCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldCAPreviousRemarks]
	return ok
}

// ResetCAPreviousRemarks resets all changes to the "CAPreviousRemarks" field.
func (m *ExamApplicationsIPMutation) ResetCAPreviousRemarks() {
	m._CAPreviousRemarks = nil
	delete(m.clearedFields, exam_applications_ip.FieldCAPreviousRemarks)
}

// SetRoleUserCode sets the "RoleUserCode" field.
func (m *ExamApplicationsIPMutation) SetRoleUserCode(i int32) {
	m.roleusers = &i
}

// RoleUserCode returns the value of the "RoleUserCode" field in the mutation.
func (m *ExamApplicationsIPMutation) RoleUserCode() (r int32, exists bool) {
	v := m.roleusers
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleUserCode returns the old "RoleUserCode" field's value of the Exam_Applications_IP entity.
// If the Exam_Applications_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsIPMutation) OldRoleUserCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleUserCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleUserCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleUserCode: %w", err)
	}
	return oldValue.RoleUserCode, nil
}

// ClearRoleUserCode clears the value of the "RoleUserCode" field.
func (m *ExamApplicationsIPMutation) ClearRoleUserCode() {
	m.roleusers = nil
	m.clearedFields[exam_applications_ip.FieldRoleUserCode] = struct{}{}
}

// RoleUserCodeCleared returns if the "RoleUserCode" field was cleared in this mutation.
func (m *ExamApplicationsIPMutation) RoleUserCodeCleared() bool {
	_, ok := m.clearedFields[exam_applications_ip.FieldRoleUserCode]
	return ok
}

// ResetRoleUserCode resets all changes to the "RoleUserCode" field.
func (m *ExamApplicationsIPMutation) ResetRoleUserCode() {
	m.roleusers = nil
	delete(m.clearedFields, exam_applications_ip.FieldRoleUserCode)
}

// AddUsersIPRefIDs adds the "UsersIPRef" edge to the UserMaster entity by ids.
func (m *ExamApplicationsIPMutation) AddUsersIPRefIDs(ids ...int64) {
	if m._UsersIPRef == nil {
		m._UsersIPRef = make(map[int64]struct{})
	}
	for i := range ids {
		m._UsersIPRef[ids[i]] = struct{}{}
	}
}

// ClearUsersIPRef clears the "UsersIPRef" edge to the UserMaster entity.
func (m *ExamApplicationsIPMutation) ClearUsersIPRef() {
	m.cleared_UsersIPRef = true
}

// UsersIPRefCleared reports if the "UsersIPRef" edge to the UserMaster entity was cleared.
func (m *ExamApplicationsIPMutation) UsersIPRefCleared() bool {
	return m.cleared_UsersIPRef
}

// RemoveUsersIPRefIDs removes the "UsersIPRef" edge to the UserMaster entity by IDs.
func (m *ExamApplicationsIPMutation) RemoveUsersIPRefIDs(ids ...int64) {
	if m.removed_UsersIPRef == nil {
		m.removed_UsersIPRef = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._UsersIPRef, ids[i])
		m.removed_UsersIPRef[ids[i]] = struct{}{}
	}
}

// RemovedUsersIPRef returns the removed IDs of the "UsersIPRef" edge to the UserMaster entity.
func (m *ExamApplicationsIPMutation) RemovedUsersIPRefIDs() (ids []int64) {
	for id := range m.removed_UsersIPRef {
		ids = append(ids, id)
	}
	return
}

// UsersIPRefIDs returns the "UsersIPRef" edge IDs in the mutation.
func (m *ExamApplicationsIPMutation) UsersIPRefIDs() (ids []int64) {
	for id := range m._UsersIPRef {
		ids = append(ids, id)
	}
	return
}

// ResetUsersIPRef resets all changes to the "UsersIPRef" edge.
func (m *ExamApplicationsIPMutation) ResetUsersIPRef() {
	m._UsersIPRef = nil
	m.cleared_UsersIPRef = false
	m.removed_UsersIPRef = nil
}

// AddExamApplnIPRefIDs adds the "ExamAppln_IP_Ref" edge to the Exam_IP entity by ids.
func (m *ExamApplicationsIPMutation) AddExamApplnIPRefIDs(ids ...int32) {
	if m._ExamAppln_IP_Ref == nil {
		m._ExamAppln_IP_Ref = make(map[int32]struct{})
	}
	for i := range ids {
		m._ExamAppln_IP_Ref[ids[i]] = struct{}{}
	}
}

// ClearExamApplnIPRef clears the "ExamAppln_IP_Ref" edge to the Exam_IP entity.
func (m *ExamApplicationsIPMutation) ClearExamApplnIPRef() {
	m.cleared_ExamAppln_IP_Ref = true
}

// ExamApplnIPRefCleared reports if the "ExamAppln_IP_Ref" edge to the Exam_IP entity was cleared.
func (m *ExamApplicationsIPMutation) ExamApplnIPRefCleared() bool {
	return m.cleared_ExamAppln_IP_Ref
}

// RemoveExamApplnIPRefIDs removes the "ExamAppln_IP_Ref" edge to the Exam_IP entity by IDs.
func (m *ExamApplicationsIPMutation) RemoveExamApplnIPRefIDs(ids ...int32) {
	if m.removed_ExamAppln_IP_Ref == nil {
		m.removed_ExamAppln_IP_Ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m._ExamAppln_IP_Ref, ids[i])
		m.removed_ExamAppln_IP_Ref[ids[i]] = struct{}{}
	}
}

// RemovedExamApplnIPRef returns the removed IDs of the "ExamAppln_IP_Ref" edge to the Exam_IP entity.
func (m *ExamApplicationsIPMutation) RemovedExamApplnIPRefIDs() (ids []int32) {
	for id := range m.removed_ExamAppln_IP_Ref {
		ids = append(ids, id)
	}
	return
}

// ExamApplnIPRefIDs returns the "ExamAppln_IP_Ref" edge IDs in the mutation.
func (m *ExamApplicationsIPMutation) ExamApplnIPRefIDs() (ids []int32) {
	for id := range m._ExamAppln_IP_Ref {
		ids = append(ids, id)
	}
	return
}

// ResetExamApplnIPRef resets all changes to the "ExamAppln_IP_Ref" edge.
func (m *ExamApplicationsIPMutation) ResetExamApplnIPRef() {
	m._ExamAppln_IP_Ref = nil
	m.cleared_ExamAppln_IP_Ref = false
	m.removed_ExamAppln_IP_Ref = nil
}

// AddOfficeIPRefIDs adds the "Office_IP_Ref" edge to the Facility entity by ids.
func (m *ExamApplicationsIPMutation) AddOfficeIPRefIDs(ids ...int32) {
	if m._Office_IP_Ref == nil {
		m._Office_IP_Ref = make(map[int32]struct{})
	}
	for i := range ids {
		m._Office_IP_Ref[ids[i]] = struct{}{}
	}
}

// ClearOfficeIPRef clears the "Office_IP_Ref" edge to the Facility entity.
func (m *ExamApplicationsIPMutation) ClearOfficeIPRef() {
	m.cleared_Office_IP_Ref = true
}

// OfficeIPRefCleared reports if the "Office_IP_Ref" edge to the Facility entity was cleared.
func (m *ExamApplicationsIPMutation) OfficeIPRefCleared() bool {
	return m.cleared_Office_IP_Ref
}

// RemoveOfficeIPRefIDs removes the "Office_IP_Ref" edge to the Facility entity by IDs.
func (m *ExamApplicationsIPMutation) RemoveOfficeIPRefIDs(ids ...int32) {
	if m.removed_Office_IP_Ref == nil {
		m.removed_Office_IP_Ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m._Office_IP_Ref, ids[i])
		m.removed_Office_IP_Ref[ids[i]] = struct{}{}
	}
}

// RemovedOfficeIPRef returns the removed IDs of the "Office_IP_Ref" edge to the Facility entity.
func (m *ExamApplicationsIPMutation) RemovedOfficeIPRefIDs() (ids []int32) {
	for id := range m.removed_Office_IP_Ref {
		ids = append(ids, id)
	}
	return
}

// OfficeIPRefIDs returns the "Office_IP_Ref" edge IDs in the mutation.
func (m *ExamApplicationsIPMutation) OfficeIPRefIDs() (ids []int32) {
	for id := range m._Office_IP_Ref {
		ids = append(ids, id)
	}
	return
}

// ResetOfficeIPRef resets all changes to the "Office_IP_Ref" edge.
func (m *ExamApplicationsIPMutation) ResetOfficeIPRef() {
	m._Office_IP_Ref = nil
	m.cleared_Office_IP_Ref = false
	m.removed_Office_IP_Ref = nil
}

// SetRoleusersID sets the "roleusers" edge to the RoleMaster entity by id.
func (m *ExamApplicationsIPMutation) SetRoleusersID(id int32) {
	m.roleusers = &id
}

// ClearRoleusers clears the "roleusers" edge to the RoleMaster entity.
func (m *ExamApplicationsIPMutation) ClearRoleusers() {
	m.clearedroleusers = true
}

// RoleusersCleared reports if the "roleusers" edge to the RoleMaster entity was cleared.
func (m *ExamApplicationsIPMutation) RoleusersCleared() bool {
	return m.RoleUserCodeCleared() || m.clearedroleusers
}

// RoleusersID returns the "roleusers" edge ID in the mutation.
func (m *ExamApplicationsIPMutation) RoleusersID() (id int32, exists bool) {
	if m.roleusers != nil {
		return *m.roleusers, true
	}
	return
}

// RoleusersIDs returns the "roleusers" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleusersID instead. It exists only for internal usage by the builders.
func (m *ExamApplicationsIPMutation) RoleusersIDs() (ids []int32) {
	if id := m.roleusers; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoleusers resets all changes to the "roleusers" edge.
func (m *ExamApplicationsIPMutation) ResetRoleusers() {
	m.roleusers = nil
	m.clearedroleusers = false
}

// AddCadrePrefRefIDs adds the "CadrePref_Ref" edge to the Cadre_Choice_IP entity by ids.
func (m *ExamApplicationsIPMutation) AddCadrePrefRefIDs(ids ...int32) {
	if m._CadrePref_Ref == nil {
		m._CadrePref_Ref = make(map[int32]struct{})
	}
	for i := range ids {
		m._CadrePref_Ref[ids[i]] = struct{}{}
	}
}

// ClearCadrePrefRef clears the "CadrePref_Ref" edge to the Cadre_Choice_IP entity.
func (m *ExamApplicationsIPMutation) ClearCadrePrefRef() {
	m.cleared_CadrePref_Ref = true
}

// CadrePrefRefCleared reports if the "CadrePref_Ref" edge to the Cadre_Choice_IP entity was cleared.
func (m *ExamApplicationsIPMutation) CadrePrefRefCleared() bool {
	return m.cleared_CadrePref_Ref
}

// RemoveCadrePrefRefIDs removes the "CadrePref_Ref" edge to the Cadre_Choice_IP entity by IDs.
func (m *ExamApplicationsIPMutation) RemoveCadrePrefRefIDs(ids ...int32) {
	if m.removed_CadrePref_Ref == nil {
		m.removed_CadrePref_Ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m._CadrePref_Ref, ids[i])
		m.removed_CadrePref_Ref[ids[i]] = struct{}{}
	}
}

// RemovedCadrePrefRef returns the removed IDs of the "CadrePref_Ref" edge to the Cadre_Choice_IP entity.
func (m *ExamApplicationsIPMutation) RemovedCadrePrefRefIDs() (ids []int32) {
	for id := range m.removed_CadrePref_Ref {
		ids = append(ids, id)
	}
	return
}

// CadrePrefRefIDs returns the "CadrePref_Ref" edge IDs in the mutation.
func (m *ExamApplicationsIPMutation) CadrePrefRefIDs() (ids []int32) {
	for id := range m._CadrePref_Ref {
		ids = append(ids, id)
	}
	return
}

// ResetCadrePrefRef resets all changes to the "CadrePref_Ref" edge.
func (m *ExamApplicationsIPMutation) ResetCadrePrefRef() {
	m._CadrePref_Ref = nil
	m.cleared_CadrePref_Ref = false
	m.removed_CadrePref_Ref = nil
}

// AddCirclePrefRefIDs adds the "CirclePrefRef" edge to the PlaceOfPreferenceIP entity by ids.
func (m *ExamApplicationsIPMutation) AddCirclePrefRefIDs(ids ...int32) {
	if m._CirclePrefRef == nil {
		m._CirclePrefRef = make(map[int32]struct{})
	}
	for i := range ids {
		m._CirclePrefRef[ids[i]] = struct{}{}
	}
}

// ClearCirclePrefRef clears the "CirclePrefRef" edge to the PlaceOfPreferenceIP entity.
func (m *ExamApplicationsIPMutation) ClearCirclePrefRef() {
	m.cleared_CirclePrefRef = true
}

// CirclePrefRefCleared reports if the "CirclePrefRef" edge to the PlaceOfPreferenceIP entity was cleared.
func (m *ExamApplicationsIPMutation) CirclePrefRefCleared() bool {
	return m.cleared_CirclePrefRef
}

// RemoveCirclePrefRefIDs removes the "CirclePrefRef" edge to the PlaceOfPreferenceIP entity by IDs.
func (m *ExamApplicationsIPMutation) RemoveCirclePrefRefIDs(ids ...int32) {
	if m.removed_CirclePrefRef == nil {
		m.removed_CirclePrefRef = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m._CirclePrefRef, ids[i])
		m.removed_CirclePrefRef[ids[i]] = struct{}{}
	}
}

// RemovedCirclePrefRef returns the removed IDs of the "CirclePrefRef" edge to the PlaceOfPreferenceIP entity.
func (m *ExamApplicationsIPMutation) RemovedCirclePrefRefIDs() (ids []int32) {
	for id := range m.removed_CirclePrefRef {
		ids = append(ids, id)
	}
	return
}

// CirclePrefRefIDs returns the "CirclePrefRef" edge IDs in the mutation.
func (m *ExamApplicationsIPMutation) CirclePrefRefIDs() (ids []int32) {
	for id := range m._CirclePrefRef {
		ids = append(ids, id)
	}
	return
}

// ResetCirclePrefRef resets all changes to the "CirclePrefRef" edge.
func (m *ExamApplicationsIPMutation) ResetCirclePrefRef() {
	m._CirclePrefRef = nil
	m.cleared_CirclePrefRef = false
	m.removed_CirclePrefRef = nil
}

// AddIPApplicationsRefIDs adds the "IPApplicationsRef" edge to the RecommendationsIPApplications entity by ids.
func (m *ExamApplicationsIPMutation) AddIPApplicationsRefIDs(ids ...int64) {
	if m._IPApplicationsRef == nil {
		m._IPApplicationsRef = make(map[int64]struct{})
	}
	for i := range ids {
		m._IPApplicationsRef[ids[i]] = struct{}{}
	}
}

// ClearIPApplicationsRef clears the "IPApplicationsRef" edge to the RecommendationsIPApplications entity.
func (m *ExamApplicationsIPMutation) ClearIPApplicationsRef() {
	m.cleared_IPApplicationsRef = true
}

// IPApplicationsRefCleared reports if the "IPApplicationsRef" edge to the RecommendationsIPApplications entity was cleared.
func (m *ExamApplicationsIPMutation) IPApplicationsRefCleared() bool {
	return m.cleared_IPApplicationsRef
}

// RemoveIPApplicationsRefIDs removes the "IPApplicationsRef" edge to the RecommendationsIPApplications entity by IDs.
func (m *ExamApplicationsIPMutation) RemoveIPApplicationsRefIDs(ids ...int64) {
	if m.removed_IPApplicationsRef == nil {
		m.removed_IPApplicationsRef = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._IPApplicationsRef, ids[i])
		m.removed_IPApplicationsRef[ids[i]] = struct{}{}
	}
}

// RemovedIPApplicationsRef returns the removed IDs of the "IPApplicationsRef" edge to the RecommendationsIPApplications entity.
func (m *ExamApplicationsIPMutation) RemovedIPApplicationsRefIDs() (ids []int64) {
	for id := range m.removed_IPApplicationsRef {
		ids = append(ids, id)
	}
	return
}

// IPApplicationsRefIDs returns the "IPApplicationsRef" edge IDs in the mutation.
func (m *ExamApplicationsIPMutation) IPApplicationsRefIDs() (ids []int64) {
	for id := range m._IPApplicationsRef {
		ids = append(ids, id)
	}
	return
}

// ResetIPApplicationsRef resets all changes to the "IPApplicationsRef" edge.
func (m *ExamApplicationsIPMutation) ResetIPApplicationsRef() {
	m._IPApplicationsRef = nil
	m.cleared_IPApplicationsRef = false
	m.removed_IPApplicationsRef = nil
}

// Where appends a list predicates to the ExamApplicationsIPMutation builder.
func (m *ExamApplicationsIPMutation) Where(ps ...predicate.Exam_Applications_IP) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExamApplicationsIPMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExamApplicationsIPMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exam_Applications_IP, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExamApplicationsIPMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExamApplicationsIPMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exam_Applications_IP).
func (m *ExamApplicationsIPMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExamApplicationsIPMutation) Fields() []string {
	fields := make([]string, 0, 53)
	if m._ApplicationNumber != nil {
		fields = append(fields, exam_applications_ip.FieldApplicationNumber)
	}
	if m._EmployeeID != nil {
		fields = append(fields, exam_applications_ip.FieldEmployeeID)
	}
	if m._EmployeeName != nil {
		fields = append(fields, exam_applications_ip.FieldEmployeeName)
	}
	if m._DOB != nil {
		fields = append(fields, exam_applications_ip.FieldDOB)
	}
	if m._Gender != nil {
		fields = append(fields, exam_applications_ip.FieldGender)
	}
	if m._MobileNumber != nil {
		fields = append(fields, exam_applications_ip.FieldMobileNumber)
	}
	if m._EmailID != nil {
		fields = append(fields, exam_applications_ip.FieldEmailID)
	}
	if m._EmployeeCategory != nil {
		fields = append(fields, exam_applications_ip.FieldEmployeeCategory)
	}
	if m._Cadre != nil {
		fields = append(fields, exam_applications_ip.FieldCadre)
	}
	if m._EmployeePost != nil {
		fields = append(fields, exam_applications_ip.FieldEmployeePost)
	}
	if m._FacilityID != nil {
		fields = append(fields, exam_applications_ip.FieldFacilityID)
	}
	if m._FacilityName != nil {
		fields = append(fields, exam_applications_ip.FieldFacilityName)
	}
	if m._DivisionName != nil {
		fields = append(fields, exam_applications_ip.FieldDivisionName)
	}
	if m._RegionName != nil {
		fields = append(fields, exam_applications_ip.FieldRegionName)
	}
	if m._ReportingOfficeName != nil {
		fields = append(fields, exam_applications_ip.FieldReportingOfficeName)
	}
	if m._CircleName != nil {
		fields = append(fields, exam_applications_ip.FieldCircleName)
	}
	if m._EntryCadre != nil {
		fields = append(fields, exam_applications_ip.FieldEntryCadre)
	}
	if m._DCCS != nil {
		fields = append(fields, exam_applications_ip.FieldDCCS)
	}
	if m._DCInPresentCadre != nil {
		fields = append(fields, exam_applications_ip.FieldDCInPresentCadre)
	}
	if m._DeputationOfficeId != nil {
		fields = append(fields, exam_applications_ip.FieldDeputationOfficeId)
	}
	if m._DisabilityType != nil {
		fields = append(fields, exam_applications_ip.FieldDisabilityType)
	}
	if m._DisabilityPercentage != nil {
		fields = append(fields, exam_applications_ip.FieldDisabilityPercentage)
	}
	if m._Education != nil {
		fields = append(fields, exam_applications_ip.FieldEducation)
	}
	if m._ExamNameCode != nil {
		fields = append(fields, exam_applications_ip.FieldExamNameCode)
	}
	if m._ExamYear != nil {
		fields = append(fields, exam_applications_ip.FieldExamYear)
	}
	if m._ExamName != nil {
		fields = append(fields, exam_applications_ip.FieldExamName)
	}
	if m._PresentCadre != nil {
		fields = append(fields, exam_applications_ip.FieldPresentCadre)
	}
	if m._PresentDesignation != nil {
		fields = append(fields, exam_applications_ip.FieldPresentDesignation)
	}
	if m._EligibleCadre != nil {
		fields = append(fields, exam_applications_ip.FieldEligibleCadre)
	}
	if m._EligibleCadreDate != nil {
		fields = append(fields, exam_applications_ip.FieldEligibleCadreDate)
	}
	if m._ServiceLength != nil {
		fields = append(fields, exam_applications_ip.FieldServiceLength)
	}
	if m._CentrePreference != nil {
		fields = append(fields, exam_applications_ip.FieldCentrePreference)
	}
	if m._Signature != nil {
		fields = append(fields, exam_applications_ip.FieldSignature)
	}
	if m._Photo != nil {
		fields = append(fields, exam_applications_ip.FieldPhoto)
	}
	if m._ApplicationStatus != nil {
		fields = append(fields, exam_applications_ip.FieldApplicationStatus)
	}
	if m._ApplnSubmittedDate != nil {
		fields = append(fields, exam_applications_ip.FieldApplnSubmittedDate)
	}
	if m._VA_Remarks != nil {
		fields = append(fields, exam_applications_ip.FieldVARemarks)
	}
	if m._VA_UserName != nil {
		fields = append(fields, exam_applications_ip.FieldVAUserName)
	}
	if m._VA_Date != nil {
		fields = append(fields, exam_applications_ip.FieldVADate)
	}
	if m._CA_Remarks != nil {
		fields = append(fields, exam_applications_ip.FieldCARemarks)
	}
	if m._CA_UserName != nil {
		fields = append(fields, exam_applications_ip.FieldCAUserName)
	}
	if m._CA_Date != nil {
		fields = append(fields, exam_applications_ip.FieldCADate)
	}
	if m._ApplicationWdlDate != nil {
		fields = append(fields, exam_applications_ip.FieldApplicationWdlDate)
	}
	if m._NA_Remarks != nil {
		fields = append(fields, exam_applications_ip.FieldNARemarks)
	}
	if m._NA_UserName != nil {
		fields = append(fields, exam_applications_ip.FieldNAUserName)
	}
	if m._NA_Date != nil {
		fields = append(fields, exam_applications_ip.FieldNADate)
	}
	if m._AppliactionRemarks != nil {
		fields = append(fields, exam_applications_ip.FieldAppliactionRemarks)
	}
	if m._CadrePreferences != nil {
		fields = append(fields, exam_applications_ip.FieldCadrePreferences)
	}
	if m._DivisionPreferences != nil {
		fields = append(fields, exam_applications_ip.FieldDivisionPreferences)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, exam_applications_ip.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, exam_applications_ip.FieldUpdatedBy)
	}
	if m._CAPreviousRemarks != nil {
		fields = append(fields, exam_applications_ip.FieldCAPreviousRemarks)
	}
	if m.roleusers != nil {
		fields = append(fields, exam_applications_ip.FieldRoleUserCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExamApplicationsIPMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exam_applications_ip.FieldApplicationNumber:
		return m.ApplicationNumber()
	case exam_applications_ip.FieldEmployeeID:
		return m.EmployeeID()
	case exam_applications_ip.FieldEmployeeName:
		return m.EmployeeName()
	case exam_applications_ip.FieldDOB:
		return m.DOB()
	case exam_applications_ip.FieldGender:
		return m.Gender()
	case exam_applications_ip.FieldMobileNumber:
		return m.MobileNumber()
	case exam_applications_ip.FieldEmailID:
		return m.EmailID()
	case exam_applications_ip.FieldEmployeeCategory:
		return m.EmployeeCategory()
	case exam_applications_ip.FieldCadre:
		return m.Cadre()
	case exam_applications_ip.FieldEmployeePost:
		return m.EmployeePost()
	case exam_applications_ip.FieldFacilityID:
		return m.FacilityID()
	case exam_applications_ip.FieldFacilityName:
		return m.FacilityName()
	case exam_applications_ip.FieldDivisionName:
		return m.DivisionName()
	case exam_applications_ip.FieldRegionName:
		return m.RegionName()
	case exam_applications_ip.FieldReportingOfficeName:
		return m.ReportingOfficeName()
	case exam_applications_ip.FieldCircleName:
		return m.CircleName()
	case exam_applications_ip.FieldEntryCadre:
		return m.EntryCadre()
	case exam_applications_ip.FieldDCCS:
		return m.DCCS()
	case exam_applications_ip.FieldDCInPresentCadre:
		return m.DCInPresentCadre()
	case exam_applications_ip.FieldDeputationOfficeId:
		return m.DeputationOfficeId()
	case exam_applications_ip.FieldDisabilityType:
		return m.DisabilityType()
	case exam_applications_ip.FieldDisabilityPercentage:
		return m.DisabilityPercentage()
	case exam_applications_ip.FieldEducation:
		return m.Education()
	case exam_applications_ip.FieldExamNameCode:
		return m.ExamNameCode()
	case exam_applications_ip.FieldExamYear:
		return m.ExamYear()
	case exam_applications_ip.FieldExamName:
		return m.ExamName()
	case exam_applications_ip.FieldPresentCadre:
		return m.PresentCadre()
	case exam_applications_ip.FieldPresentDesignation:
		return m.PresentDesignation()
	case exam_applications_ip.FieldEligibleCadre:
		return m.EligibleCadre()
	case exam_applications_ip.FieldEligibleCadreDate:
		return m.EligibleCadreDate()
	case exam_applications_ip.FieldServiceLength:
		return m.ServiceLength()
	case exam_applications_ip.FieldCentrePreference:
		return m.CentrePreference()
	case exam_applications_ip.FieldSignature:
		return m.Signature()
	case exam_applications_ip.FieldPhoto:
		return m.Photo()
	case exam_applications_ip.FieldApplicationStatus:
		return m.ApplicationStatus()
	case exam_applications_ip.FieldApplnSubmittedDate:
		return m.ApplnSubmittedDate()
	case exam_applications_ip.FieldVARemarks:
		return m.VARemarks()
	case exam_applications_ip.FieldVAUserName:
		return m.VAUserName()
	case exam_applications_ip.FieldVADate:
		return m.VADate()
	case exam_applications_ip.FieldCARemarks:
		return m.CARemarks()
	case exam_applications_ip.FieldCAUserName:
		return m.CAUserName()
	case exam_applications_ip.FieldCADate:
		return m.CADate()
	case exam_applications_ip.FieldApplicationWdlDate:
		return m.ApplicationWdlDate()
	case exam_applications_ip.FieldNARemarks:
		return m.NARemarks()
	case exam_applications_ip.FieldNAUserName:
		return m.NAUserName()
	case exam_applications_ip.FieldNADate:
		return m.NADate()
	case exam_applications_ip.FieldAppliactionRemarks:
		return m.AppliactionRemarks()
	case exam_applications_ip.FieldCadrePreferences:
		return m.CadrePreferences()
	case exam_applications_ip.FieldDivisionPreferences:
		return m.DivisionPreferences()
	case exam_applications_ip.FieldUpdatedAt:
		return m.UpdatedAt()
	case exam_applications_ip.FieldUpdatedBy:
		return m.UpdatedBy()
	case exam_applications_ip.FieldCAPreviousRemarks:
		return m.CAPreviousRemarks()
	case exam_applications_ip.FieldRoleUserCode:
		return m.RoleUserCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExamApplicationsIPMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exam_applications_ip.FieldApplicationNumber:
		return m.OldApplicationNumber(ctx)
	case exam_applications_ip.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case exam_applications_ip.FieldEmployeeName:
		return m.OldEmployeeName(ctx)
	case exam_applications_ip.FieldDOB:
		return m.OldDOB(ctx)
	case exam_applications_ip.FieldGender:
		return m.OldGender(ctx)
	case exam_applications_ip.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case exam_applications_ip.FieldEmailID:
		return m.OldEmailID(ctx)
	case exam_applications_ip.FieldEmployeeCategory:
		return m.OldEmployeeCategory(ctx)
	case exam_applications_ip.FieldCadre:
		return m.OldCadre(ctx)
	case exam_applications_ip.FieldEmployeePost:
		return m.OldEmployeePost(ctx)
	case exam_applications_ip.FieldFacilityID:
		return m.OldFacilityID(ctx)
	case exam_applications_ip.FieldFacilityName:
		return m.OldFacilityName(ctx)
	case exam_applications_ip.FieldDivisionName:
		return m.OldDivisionName(ctx)
	case exam_applications_ip.FieldRegionName:
		return m.OldRegionName(ctx)
	case exam_applications_ip.FieldReportingOfficeName:
		return m.OldReportingOfficeName(ctx)
	case exam_applications_ip.FieldCircleName:
		return m.OldCircleName(ctx)
	case exam_applications_ip.FieldEntryCadre:
		return m.OldEntryCadre(ctx)
	case exam_applications_ip.FieldDCCS:
		return m.OldDCCS(ctx)
	case exam_applications_ip.FieldDCInPresentCadre:
		return m.OldDCInPresentCadre(ctx)
	case exam_applications_ip.FieldDeputationOfficeId:
		return m.OldDeputationOfficeId(ctx)
	case exam_applications_ip.FieldDisabilityType:
		return m.OldDisabilityType(ctx)
	case exam_applications_ip.FieldDisabilityPercentage:
		return m.OldDisabilityPercentage(ctx)
	case exam_applications_ip.FieldEducation:
		return m.OldEducation(ctx)
	case exam_applications_ip.FieldExamNameCode:
		return m.OldExamNameCode(ctx)
	case exam_applications_ip.FieldExamYear:
		return m.OldExamYear(ctx)
	case exam_applications_ip.FieldExamName:
		return m.OldExamName(ctx)
	case exam_applications_ip.FieldPresentCadre:
		return m.OldPresentCadre(ctx)
	case exam_applications_ip.FieldPresentDesignation:
		return m.OldPresentDesignation(ctx)
	case exam_applications_ip.FieldEligibleCadre:
		return m.OldEligibleCadre(ctx)
	case exam_applications_ip.FieldEligibleCadreDate:
		return m.OldEligibleCadreDate(ctx)
	case exam_applications_ip.FieldServiceLength:
		return m.OldServiceLength(ctx)
	case exam_applications_ip.FieldCentrePreference:
		return m.OldCentrePreference(ctx)
	case exam_applications_ip.FieldSignature:
		return m.OldSignature(ctx)
	case exam_applications_ip.FieldPhoto:
		return m.OldPhoto(ctx)
	case exam_applications_ip.FieldApplicationStatus:
		return m.OldApplicationStatus(ctx)
	case exam_applications_ip.FieldApplnSubmittedDate:
		return m.OldApplnSubmittedDate(ctx)
	case exam_applications_ip.FieldVARemarks:
		return m.OldVARemarks(ctx)
	case exam_applications_ip.FieldVAUserName:
		return m.OldVAUserName(ctx)
	case exam_applications_ip.FieldVADate:
		return m.OldVADate(ctx)
	case exam_applications_ip.FieldCARemarks:
		return m.OldCARemarks(ctx)
	case exam_applications_ip.FieldCAUserName:
		return m.OldCAUserName(ctx)
	case exam_applications_ip.FieldCADate:
		return m.OldCADate(ctx)
	case exam_applications_ip.FieldApplicationWdlDate:
		return m.OldApplicationWdlDate(ctx)
	case exam_applications_ip.FieldNARemarks:
		return m.OldNARemarks(ctx)
	case exam_applications_ip.FieldNAUserName:
		return m.OldNAUserName(ctx)
	case exam_applications_ip.FieldNADate:
		return m.OldNADate(ctx)
	case exam_applications_ip.FieldAppliactionRemarks:
		return m.OldAppliactionRemarks(ctx)
	case exam_applications_ip.FieldCadrePreferences:
		return m.OldCadrePreferences(ctx)
	case exam_applications_ip.FieldDivisionPreferences:
		return m.OldDivisionPreferences(ctx)
	case exam_applications_ip.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case exam_applications_ip.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case exam_applications_ip.FieldCAPreviousRemarks:
		return m.OldCAPreviousRemarks(ctx)
	case exam_applications_ip.FieldRoleUserCode:
		return m.OldRoleUserCode(ctx)
	}
	return nil, fmt.Errorf("unknown Exam_Applications_IP field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamApplicationsIPMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exam_applications_ip.FieldApplicationNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationNumber(v)
		return nil
	case exam_applications_ip.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case exam_applications_ip.FieldEmployeeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeName(v)
		return nil
	case exam_applications_ip.FieldDOB:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOB(v)
		return nil
	case exam_applications_ip.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case exam_applications_ip.FieldMobileNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case exam_applications_ip.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case exam_applications_ip.FieldEmployeeCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCategory(v)
		return nil
	case exam_applications_ip.FieldCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadre(v)
		return nil
	case exam_applications_ip.FieldEmployeePost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeePost(v)
		return nil
	case exam_applications_ip.FieldFacilityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityID(v)
		return nil
	case exam_applications_ip.FieldFacilityName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityName(v)
		return nil
	case exam_applications_ip.FieldDivisionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionName(v)
		return nil
	case exam_applications_ip.FieldRegionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionName(v)
		return nil
	case exam_applications_ip.FieldReportingOfficeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingOfficeName(v)
		return nil
	case exam_applications_ip.FieldCircleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleName(v)
		return nil
	case exam_applications_ip.FieldEntryCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryCadre(v)
		return nil
	case exam_applications_ip.FieldDCCS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCCS(v)
		return nil
	case exam_applications_ip.FieldDCInPresentCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCInPresentCadre(v)
		return nil
	case exam_applications_ip.FieldDeputationOfficeId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeputationOfficeId(v)
		return nil
	case exam_applications_ip.FieldDisabilityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityType(v)
		return nil
	case exam_applications_ip.FieldDisabilityPercentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityPercentage(v)
		return nil
	case exam_applications_ip.FieldEducation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducation(v)
		return nil
	case exam_applications_ip.FieldExamNameCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamNameCode(v)
		return nil
	case exam_applications_ip.FieldExamYear:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamYear(v)
		return nil
	case exam_applications_ip.FieldExamName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamName(v)
		return nil
	case exam_applications_ip.FieldPresentCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPresentCadre(v)
		return nil
	case exam_applications_ip.FieldPresentDesignation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPresentDesignation(v)
		return nil
	case exam_applications_ip.FieldEligibleCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligibleCadre(v)
		return nil
	case exam_applications_ip.FieldEligibleCadreDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligibleCadreDate(v)
		return nil
	case exam_applications_ip.FieldServiceLength:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceLength(v)
		return nil
	case exam_applications_ip.FieldCentrePreference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCentrePreference(v)
		return nil
	case exam_applications_ip.FieldSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case exam_applications_ip.FieldPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoto(v)
		return nil
	case exam_applications_ip.FieldApplicationStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationStatus(v)
		return nil
	case exam_applications_ip.FieldApplnSubmittedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplnSubmittedDate(v)
		return nil
	case exam_applications_ip.FieldVARemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVARemarks(v)
		return nil
	case exam_applications_ip.FieldVAUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVAUserName(v)
		return nil
	case exam_applications_ip.FieldVADate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVADate(v)
		return nil
	case exam_applications_ip.FieldCARemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCARemarks(v)
		return nil
	case exam_applications_ip.FieldCAUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCAUserName(v)
		return nil
	case exam_applications_ip.FieldCADate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCADate(v)
		return nil
	case exam_applications_ip.FieldApplicationWdlDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationWdlDate(v)
		return nil
	case exam_applications_ip.FieldNARemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNARemarks(v)
		return nil
	case exam_applications_ip.FieldNAUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNAUserName(v)
		return nil
	case exam_applications_ip.FieldNADate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNADate(v)
		return nil
	case exam_applications_ip.FieldAppliactionRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliactionRemarks(v)
		return nil
	case exam_applications_ip.FieldCadrePreferences:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePreferences(v)
		return nil
	case exam_applications_ip.FieldDivisionPreferences:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionPreferences(v)
		return nil
	case exam_applications_ip.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case exam_applications_ip.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case exam_applications_ip.FieldCAPreviousRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCAPreviousRemarks(v)
		return nil
	case exam_applications_ip.FieldRoleUserCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleUserCode(v)
		return nil
	}
	return fmt.Errorf("unknown Exam_Applications_IP field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExamApplicationsIPMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeeID != nil {
		fields = append(fields, exam_applications_ip.FieldEmployeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExamApplicationsIPMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exam_applications_ip.FieldEmployeeID:
		return m.AddedEmployeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamApplicationsIPMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exam_applications_ip.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown Exam_Applications_IP numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExamApplicationsIPMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exam_applications_ip.FieldApplicationNumber) {
		fields = append(fields, exam_applications_ip.FieldApplicationNumber)
	}
	if m.FieldCleared(exam_applications_ip.FieldEmployeeID) {
		fields = append(fields, exam_applications_ip.FieldEmployeeID)
	}
	if m.FieldCleared(exam_applications_ip.FieldEmployeeName) {
		fields = append(fields, exam_applications_ip.FieldEmployeeName)
	}
	if m.FieldCleared(exam_applications_ip.FieldDOB) {
		fields = append(fields, exam_applications_ip.FieldDOB)
	}
	if m.FieldCleared(exam_applications_ip.FieldGender) {
		fields = append(fields, exam_applications_ip.FieldGender)
	}
	if m.FieldCleared(exam_applications_ip.FieldMobileNumber) {
		fields = append(fields, exam_applications_ip.FieldMobileNumber)
	}
	if m.FieldCleared(exam_applications_ip.FieldEmailID) {
		fields = append(fields, exam_applications_ip.FieldEmailID)
	}
	if m.FieldCleared(exam_applications_ip.FieldEmployeeCategory) {
		fields = append(fields, exam_applications_ip.FieldEmployeeCategory)
	}
	if m.FieldCleared(exam_applications_ip.FieldCadre) {
		fields = append(fields, exam_applications_ip.FieldCadre)
	}
	if m.FieldCleared(exam_applications_ip.FieldEmployeePost) {
		fields = append(fields, exam_applications_ip.FieldEmployeePost)
	}
	if m.FieldCleared(exam_applications_ip.FieldFacilityID) {
		fields = append(fields, exam_applications_ip.FieldFacilityID)
	}
	if m.FieldCleared(exam_applications_ip.FieldFacilityName) {
		fields = append(fields, exam_applications_ip.FieldFacilityName)
	}
	if m.FieldCleared(exam_applications_ip.FieldDivisionName) {
		fields = append(fields, exam_applications_ip.FieldDivisionName)
	}
	if m.FieldCleared(exam_applications_ip.FieldRegionName) {
		fields = append(fields, exam_applications_ip.FieldRegionName)
	}
	if m.FieldCleared(exam_applications_ip.FieldReportingOfficeName) {
		fields = append(fields, exam_applications_ip.FieldReportingOfficeName)
	}
	if m.FieldCleared(exam_applications_ip.FieldCircleName) {
		fields = append(fields, exam_applications_ip.FieldCircleName)
	}
	if m.FieldCleared(exam_applications_ip.FieldEntryCadre) {
		fields = append(fields, exam_applications_ip.FieldEntryCadre)
	}
	if m.FieldCleared(exam_applications_ip.FieldDCCS) {
		fields = append(fields, exam_applications_ip.FieldDCCS)
	}
	if m.FieldCleared(exam_applications_ip.FieldDCInPresentCadre) {
		fields = append(fields, exam_applications_ip.FieldDCInPresentCadre)
	}
	if m.FieldCleared(exam_applications_ip.FieldDeputationOfficeId) {
		fields = append(fields, exam_applications_ip.FieldDeputationOfficeId)
	}
	if m.FieldCleared(exam_applications_ip.FieldDisabilityType) {
		fields = append(fields, exam_applications_ip.FieldDisabilityType)
	}
	if m.FieldCleared(exam_applications_ip.FieldDisabilityPercentage) {
		fields = append(fields, exam_applications_ip.FieldDisabilityPercentage)
	}
	if m.FieldCleared(exam_applications_ip.FieldEducation) {
		fields = append(fields, exam_applications_ip.FieldEducation)
	}
	if m.FieldCleared(exam_applications_ip.FieldExamNameCode) {
		fields = append(fields, exam_applications_ip.FieldExamNameCode)
	}
	if m.FieldCleared(exam_applications_ip.FieldExamYear) {
		fields = append(fields, exam_applications_ip.FieldExamYear)
	}
	if m.FieldCleared(exam_applications_ip.FieldExamName) {
		fields = append(fields, exam_applications_ip.FieldExamName)
	}
	if m.FieldCleared(exam_applications_ip.FieldPresentCadre) {
		fields = append(fields, exam_applications_ip.FieldPresentCadre)
	}
	if m.FieldCleared(exam_applications_ip.FieldPresentDesignation) {
		fields = append(fields, exam_applications_ip.FieldPresentDesignation)
	}
	if m.FieldCleared(exam_applications_ip.FieldEligibleCadre) {
		fields = append(fields, exam_applications_ip.FieldEligibleCadre)
	}
	if m.FieldCleared(exam_applications_ip.FieldEligibleCadreDate) {
		fields = append(fields, exam_applications_ip.FieldEligibleCadreDate)
	}
	if m.FieldCleared(exam_applications_ip.FieldServiceLength) {
		fields = append(fields, exam_applications_ip.FieldServiceLength)
	}
	if m.FieldCleared(exam_applications_ip.FieldCentrePreference) {
		fields = append(fields, exam_applications_ip.FieldCentrePreference)
	}
	if m.FieldCleared(exam_applications_ip.FieldSignature) {
		fields = append(fields, exam_applications_ip.FieldSignature)
	}
	if m.FieldCleared(exam_applications_ip.FieldPhoto) {
		fields = append(fields, exam_applications_ip.FieldPhoto)
	}
	if m.FieldCleared(exam_applications_ip.FieldApplicationStatus) {
		fields = append(fields, exam_applications_ip.FieldApplicationStatus)
	}
	if m.FieldCleared(exam_applications_ip.FieldApplnSubmittedDate) {
		fields = append(fields, exam_applications_ip.FieldApplnSubmittedDate)
	}
	if m.FieldCleared(exam_applications_ip.FieldVARemarks) {
		fields = append(fields, exam_applications_ip.FieldVARemarks)
	}
	if m.FieldCleared(exam_applications_ip.FieldVAUserName) {
		fields = append(fields, exam_applications_ip.FieldVAUserName)
	}
	if m.FieldCleared(exam_applications_ip.FieldVADate) {
		fields = append(fields, exam_applications_ip.FieldVADate)
	}
	if m.FieldCleared(exam_applications_ip.FieldCARemarks) {
		fields = append(fields, exam_applications_ip.FieldCARemarks)
	}
	if m.FieldCleared(exam_applications_ip.FieldCAUserName) {
		fields = append(fields, exam_applications_ip.FieldCAUserName)
	}
	if m.FieldCleared(exam_applications_ip.FieldCADate) {
		fields = append(fields, exam_applications_ip.FieldCADate)
	}
	if m.FieldCleared(exam_applications_ip.FieldApplicationWdlDate) {
		fields = append(fields, exam_applications_ip.FieldApplicationWdlDate)
	}
	if m.FieldCleared(exam_applications_ip.FieldNARemarks) {
		fields = append(fields, exam_applications_ip.FieldNARemarks)
	}
	if m.FieldCleared(exam_applications_ip.FieldNAUserName) {
		fields = append(fields, exam_applications_ip.FieldNAUserName)
	}
	if m.FieldCleared(exam_applications_ip.FieldNADate) {
		fields = append(fields, exam_applications_ip.FieldNADate)
	}
	if m.FieldCleared(exam_applications_ip.FieldAppliactionRemarks) {
		fields = append(fields, exam_applications_ip.FieldAppliactionRemarks)
	}
	if m.FieldCleared(exam_applications_ip.FieldCadrePreferences) {
		fields = append(fields, exam_applications_ip.FieldCadrePreferences)
	}
	if m.FieldCleared(exam_applications_ip.FieldDivisionPreferences) {
		fields = append(fields, exam_applications_ip.FieldDivisionPreferences)
	}
	if m.FieldCleared(exam_applications_ip.FieldUpdatedAt) {
		fields = append(fields, exam_applications_ip.FieldUpdatedAt)
	}
	if m.FieldCleared(exam_applications_ip.FieldUpdatedBy) {
		fields = append(fields, exam_applications_ip.FieldUpdatedBy)
	}
	if m.FieldCleared(exam_applications_ip.FieldCAPreviousRemarks) {
		fields = append(fields, exam_applications_ip.FieldCAPreviousRemarks)
	}
	if m.FieldCleared(exam_applications_ip.FieldRoleUserCode) {
		fields = append(fields, exam_applications_ip.FieldRoleUserCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExamApplicationsIPMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExamApplicationsIPMutation) ClearField(name string) error {
	switch name {
	case exam_applications_ip.FieldApplicationNumber:
		m.ClearApplicationNumber()
		return nil
	case exam_applications_ip.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case exam_applications_ip.FieldEmployeeName:
		m.ClearEmployeeName()
		return nil
	case exam_applications_ip.FieldDOB:
		m.ClearDOB()
		return nil
	case exam_applications_ip.FieldGender:
		m.ClearGender()
		return nil
	case exam_applications_ip.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	case exam_applications_ip.FieldEmailID:
		m.ClearEmailID()
		return nil
	case exam_applications_ip.FieldEmployeeCategory:
		m.ClearEmployeeCategory()
		return nil
	case exam_applications_ip.FieldCadre:
		m.ClearCadre()
		return nil
	case exam_applications_ip.FieldEmployeePost:
		m.ClearEmployeePost()
		return nil
	case exam_applications_ip.FieldFacilityID:
		m.ClearFacilityID()
		return nil
	case exam_applications_ip.FieldFacilityName:
		m.ClearFacilityName()
		return nil
	case exam_applications_ip.FieldDivisionName:
		m.ClearDivisionName()
		return nil
	case exam_applications_ip.FieldRegionName:
		m.ClearRegionName()
		return nil
	case exam_applications_ip.FieldReportingOfficeName:
		m.ClearReportingOfficeName()
		return nil
	case exam_applications_ip.FieldCircleName:
		m.ClearCircleName()
		return nil
	case exam_applications_ip.FieldEntryCadre:
		m.ClearEntryCadre()
		return nil
	case exam_applications_ip.FieldDCCS:
		m.ClearDCCS()
		return nil
	case exam_applications_ip.FieldDCInPresentCadre:
		m.ClearDCInPresentCadre()
		return nil
	case exam_applications_ip.FieldDeputationOfficeId:
		m.ClearDeputationOfficeId()
		return nil
	case exam_applications_ip.FieldDisabilityType:
		m.ClearDisabilityType()
		return nil
	case exam_applications_ip.FieldDisabilityPercentage:
		m.ClearDisabilityPercentage()
		return nil
	case exam_applications_ip.FieldEducation:
		m.ClearEducation()
		return nil
	case exam_applications_ip.FieldExamNameCode:
		m.ClearExamNameCode()
		return nil
	case exam_applications_ip.FieldExamYear:
		m.ClearExamYear()
		return nil
	case exam_applications_ip.FieldExamName:
		m.ClearExamName()
		return nil
	case exam_applications_ip.FieldPresentCadre:
		m.ClearPresentCadre()
		return nil
	case exam_applications_ip.FieldPresentDesignation:
		m.ClearPresentDesignation()
		return nil
	case exam_applications_ip.FieldEligibleCadre:
		m.ClearEligibleCadre()
		return nil
	case exam_applications_ip.FieldEligibleCadreDate:
		m.ClearEligibleCadreDate()
		return nil
	case exam_applications_ip.FieldServiceLength:
		m.ClearServiceLength()
		return nil
	case exam_applications_ip.FieldCentrePreference:
		m.ClearCentrePreference()
		return nil
	case exam_applications_ip.FieldSignature:
		m.ClearSignature()
		return nil
	case exam_applications_ip.FieldPhoto:
		m.ClearPhoto()
		return nil
	case exam_applications_ip.FieldApplicationStatus:
		m.ClearApplicationStatus()
		return nil
	case exam_applications_ip.FieldApplnSubmittedDate:
		m.ClearApplnSubmittedDate()
		return nil
	case exam_applications_ip.FieldVARemarks:
		m.ClearVARemarks()
		return nil
	case exam_applications_ip.FieldVAUserName:
		m.ClearVAUserName()
		return nil
	case exam_applications_ip.FieldVADate:
		m.ClearVADate()
		return nil
	case exam_applications_ip.FieldCARemarks:
		m.ClearCARemarks()
		return nil
	case exam_applications_ip.FieldCAUserName:
		m.ClearCAUserName()
		return nil
	case exam_applications_ip.FieldCADate:
		m.ClearCADate()
		return nil
	case exam_applications_ip.FieldApplicationWdlDate:
		m.ClearApplicationWdlDate()
		return nil
	case exam_applications_ip.FieldNARemarks:
		m.ClearNARemarks()
		return nil
	case exam_applications_ip.FieldNAUserName:
		m.ClearNAUserName()
		return nil
	case exam_applications_ip.FieldNADate:
		m.ClearNADate()
		return nil
	case exam_applications_ip.FieldAppliactionRemarks:
		m.ClearAppliactionRemarks()
		return nil
	case exam_applications_ip.FieldCadrePreferences:
		m.ClearCadrePreferences()
		return nil
	case exam_applications_ip.FieldDivisionPreferences:
		m.ClearDivisionPreferences()
		return nil
	case exam_applications_ip.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case exam_applications_ip.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case exam_applications_ip.FieldCAPreviousRemarks:
		m.ClearCAPreviousRemarks()
		return nil
	case exam_applications_ip.FieldRoleUserCode:
		m.ClearRoleUserCode()
		return nil
	}
	return fmt.Errorf("unknown Exam_Applications_IP nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExamApplicationsIPMutation) ResetField(name string) error {
	switch name {
	case exam_applications_ip.FieldApplicationNumber:
		m.ResetApplicationNumber()
		return nil
	case exam_applications_ip.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case exam_applications_ip.FieldEmployeeName:
		m.ResetEmployeeName()
		return nil
	case exam_applications_ip.FieldDOB:
		m.ResetDOB()
		return nil
	case exam_applications_ip.FieldGender:
		m.ResetGender()
		return nil
	case exam_applications_ip.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case exam_applications_ip.FieldEmailID:
		m.ResetEmailID()
		return nil
	case exam_applications_ip.FieldEmployeeCategory:
		m.ResetEmployeeCategory()
		return nil
	case exam_applications_ip.FieldCadre:
		m.ResetCadre()
		return nil
	case exam_applications_ip.FieldEmployeePost:
		m.ResetEmployeePost()
		return nil
	case exam_applications_ip.FieldFacilityID:
		m.ResetFacilityID()
		return nil
	case exam_applications_ip.FieldFacilityName:
		m.ResetFacilityName()
		return nil
	case exam_applications_ip.FieldDivisionName:
		m.ResetDivisionName()
		return nil
	case exam_applications_ip.FieldRegionName:
		m.ResetRegionName()
		return nil
	case exam_applications_ip.FieldReportingOfficeName:
		m.ResetReportingOfficeName()
		return nil
	case exam_applications_ip.FieldCircleName:
		m.ResetCircleName()
		return nil
	case exam_applications_ip.FieldEntryCadre:
		m.ResetEntryCadre()
		return nil
	case exam_applications_ip.FieldDCCS:
		m.ResetDCCS()
		return nil
	case exam_applications_ip.FieldDCInPresentCadre:
		m.ResetDCInPresentCadre()
		return nil
	case exam_applications_ip.FieldDeputationOfficeId:
		m.ResetDeputationOfficeId()
		return nil
	case exam_applications_ip.FieldDisabilityType:
		m.ResetDisabilityType()
		return nil
	case exam_applications_ip.FieldDisabilityPercentage:
		m.ResetDisabilityPercentage()
		return nil
	case exam_applications_ip.FieldEducation:
		m.ResetEducation()
		return nil
	case exam_applications_ip.FieldExamNameCode:
		m.ResetExamNameCode()
		return nil
	case exam_applications_ip.FieldExamYear:
		m.ResetExamYear()
		return nil
	case exam_applications_ip.FieldExamName:
		m.ResetExamName()
		return nil
	case exam_applications_ip.FieldPresentCadre:
		m.ResetPresentCadre()
		return nil
	case exam_applications_ip.FieldPresentDesignation:
		m.ResetPresentDesignation()
		return nil
	case exam_applications_ip.FieldEligibleCadre:
		m.ResetEligibleCadre()
		return nil
	case exam_applications_ip.FieldEligibleCadreDate:
		m.ResetEligibleCadreDate()
		return nil
	case exam_applications_ip.FieldServiceLength:
		m.ResetServiceLength()
		return nil
	case exam_applications_ip.FieldCentrePreference:
		m.ResetCentrePreference()
		return nil
	case exam_applications_ip.FieldSignature:
		m.ResetSignature()
		return nil
	case exam_applications_ip.FieldPhoto:
		m.ResetPhoto()
		return nil
	case exam_applications_ip.FieldApplicationStatus:
		m.ResetApplicationStatus()
		return nil
	case exam_applications_ip.FieldApplnSubmittedDate:
		m.ResetApplnSubmittedDate()
		return nil
	case exam_applications_ip.FieldVARemarks:
		m.ResetVARemarks()
		return nil
	case exam_applications_ip.FieldVAUserName:
		m.ResetVAUserName()
		return nil
	case exam_applications_ip.FieldVADate:
		m.ResetVADate()
		return nil
	case exam_applications_ip.FieldCARemarks:
		m.ResetCARemarks()
		return nil
	case exam_applications_ip.FieldCAUserName:
		m.ResetCAUserName()
		return nil
	case exam_applications_ip.FieldCADate:
		m.ResetCADate()
		return nil
	case exam_applications_ip.FieldApplicationWdlDate:
		m.ResetApplicationWdlDate()
		return nil
	case exam_applications_ip.FieldNARemarks:
		m.ResetNARemarks()
		return nil
	case exam_applications_ip.FieldNAUserName:
		m.ResetNAUserName()
		return nil
	case exam_applications_ip.FieldNADate:
		m.ResetNADate()
		return nil
	case exam_applications_ip.FieldAppliactionRemarks:
		m.ResetAppliactionRemarks()
		return nil
	case exam_applications_ip.FieldCadrePreferences:
		m.ResetCadrePreferences()
		return nil
	case exam_applications_ip.FieldDivisionPreferences:
		m.ResetDivisionPreferences()
		return nil
	case exam_applications_ip.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case exam_applications_ip.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case exam_applications_ip.FieldCAPreviousRemarks:
		m.ResetCAPreviousRemarks()
		return nil
	case exam_applications_ip.FieldRoleUserCode:
		m.ResetRoleUserCode()
		return nil
	}
	return fmt.Errorf("unknown Exam_Applications_IP field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExamApplicationsIPMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m._UsersIPRef != nil {
		edges = append(edges, exam_applications_ip.EdgeUsersIPRef)
	}
	if m._ExamAppln_IP_Ref != nil {
		edges = append(edges, exam_applications_ip.EdgeExamApplnIPRef)
	}
	if m._Office_IP_Ref != nil {
		edges = append(edges, exam_applications_ip.EdgeOfficeIPRef)
	}
	if m.roleusers != nil {
		edges = append(edges, exam_applications_ip.EdgeRoleusers)
	}
	if m._CadrePref_Ref != nil {
		edges = append(edges, exam_applications_ip.EdgeCadrePrefRef)
	}
	if m._CirclePrefRef != nil {
		edges = append(edges, exam_applications_ip.EdgeCirclePrefRef)
	}
	if m._IPApplicationsRef != nil {
		edges = append(edges, exam_applications_ip.EdgeIPApplicationsRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExamApplicationsIPMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exam_applications_ip.EdgeUsersIPRef:
		ids := make([]ent.Value, 0, len(m._UsersIPRef))
		for id := range m._UsersIPRef {
			ids = append(ids, id)
		}
		return ids
	case exam_applications_ip.EdgeExamApplnIPRef:
		ids := make([]ent.Value, 0, len(m._ExamAppln_IP_Ref))
		for id := range m._ExamAppln_IP_Ref {
			ids = append(ids, id)
		}
		return ids
	case exam_applications_ip.EdgeOfficeIPRef:
		ids := make([]ent.Value, 0, len(m._Office_IP_Ref))
		for id := range m._Office_IP_Ref {
			ids = append(ids, id)
		}
		return ids
	case exam_applications_ip.EdgeRoleusers:
		if id := m.roleusers; id != nil {
			return []ent.Value{*id}
		}
	case exam_applications_ip.EdgeCadrePrefRef:
		ids := make([]ent.Value, 0, len(m._CadrePref_Ref))
		for id := range m._CadrePref_Ref {
			ids = append(ids, id)
		}
		return ids
	case exam_applications_ip.EdgeCirclePrefRef:
		ids := make([]ent.Value, 0, len(m._CirclePrefRef))
		for id := range m._CirclePrefRef {
			ids = append(ids, id)
		}
		return ids
	case exam_applications_ip.EdgeIPApplicationsRef:
		ids := make([]ent.Value, 0, len(m._IPApplicationsRef))
		for id := range m._IPApplicationsRef {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExamApplicationsIPMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removed_UsersIPRef != nil {
		edges = append(edges, exam_applications_ip.EdgeUsersIPRef)
	}
	if m.removed_ExamAppln_IP_Ref != nil {
		edges = append(edges, exam_applications_ip.EdgeExamApplnIPRef)
	}
	if m.removed_Office_IP_Ref != nil {
		edges = append(edges, exam_applications_ip.EdgeOfficeIPRef)
	}
	if m.removed_CadrePref_Ref != nil {
		edges = append(edges, exam_applications_ip.EdgeCadrePrefRef)
	}
	if m.removed_CirclePrefRef != nil {
		edges = append(edges, exam_applications_ip.EdgeCirclePrefRef)
	}
	if m.removed_IPApplicationsRef != nil {
		edges = append(edges, exam_applications_ip.EdgeIPApplicationsRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExamApplicationsIPMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exam_applications_ip.EdgeUsersIPRef:
		ids := make([]ent.Value, 0, len(m.removed_UsersIPRef))
		for id := range m.removed_UsersIPRef {
			ids = append(ids, id)
		}
		return ids
	case exam_applications_ip.EdgeExamApplnIPRef:
		ids := make([]ent.Value, 0, len(m.removed_ExamAppln_IP_Ref))
		for id := range m.removed_ExamAppln_IP_Ref {
			ids = append(ids, id)
		}
		return ids
	case exam_applications_ip.EdgeOfficeIPRef:
		ids := make([]ent.Value, 0, len(m.removed_Office_IP_Ref))
		for id := range m.removed_Office_IP_Ref {
			ids = append(ids, id)
		}
		return ids
	case exam_applications_ip.EdgeCadrePrefRef:
		ids := make([]ent.Value, 0, len(m.removed_CadrePref_Ref))
		for id := range m.removed_CadrePref_Ref {
			ids = append(ids, id)
		}
		return ids
	case exam_applications_ip.EdgeCirclePrefRef:
		ids := make([]ent.Value, 0, len(m.removed_CirclePrefRef))
		for id := range m.removed_CirclePrefRef {
			ids = append(ids, id)
		}
		return ids
	case exam_applications_ip.EdgeIPApplicationsRef:
		ids := make([]ent.Value, 0, len(m.removed_IPApplicationsRef))
		for id := range m.removed_IPApplicationsRef {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExamApplicationsIPMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleared_UsersIPRef {
		edges = append(edges, exam_applications_ip.EdgeUsersIPRef)
	}
	if m.cleared_ExamAppln_IP_Ref {
		edges = append(edges, exam_applications_ip.EdgeExamApplnIPRef)
	}
	if m.cleared_Office_IP_Ref {
		edges = append(edges, exam_applications_ip.EdgeOfficeIPRef)
	}
	if m.clearedroleusers {
		edges = append(edges, exam_applications_ip.EdgeRoleusers)
	}
	if m.cleared_CadrePref_Ref {
		edges = append(edges, exam_applications_ip.EdgeCadrePrefRef)
	}
	if m.cleared_CirclePrefRef {
		edges = append(edges, exam_applications_ip.EdgeCirclePrefRef)
	}
	if m.cleared_IPApplicationsRef {
		edges = append(edges, exam_applications_ip.EdgeIPApplicationsRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExamApplicationsIPMutation) EdgeCleared(name string) bool {
	switch name {
	case exam_applications_ip.EdgeUsersIPRef:
		return m.cleared_UsersIPRef
	case exam_applications_ip.EdgeExamApplnIPRef:
		return m.cleared_ExamAppln_IP_Ref
	case exam_applications_ip.EdgeOfficeIPRef:
		return m.cleared_Office_IP_Ref
	case exam_applications_ip.EdgeRoleusers:
		return m.clearedroleusers
	case exam_applications_ip.EdgeCadrePrefRef:
		return m.cleared_CadrePref_Ref
	case exam_applications_ip.EdgeCirclePrefRef:
		return m.cleared_CirclePrefRef
	case exam_applications_ip.EdgeIPApplicationsRef:
		return m.cleared_IPApplicationsRef
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExamApplicationsIPMutation) ClearEdge(name string) error {
	switch name {
	case exam_applications_ip.EdgeRoleusers:
		m.ClearRoleusers()
		return nil
	}
	return fmt.Errorf("unknown Exam_Applications_IP unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExamApplicationsIPMutation) ResetEdge(name string) error {
	switch name {
	case exam_applications_ip.EdgeUsersIPRef:
		m.ResetUsersIPRef()
		return nil
	case exam_applications_ip.EdgeExamApplnIPRef:
		m.ResetExamApplnIPRef()
		return nil
	case exam_applications_ip.EdgeOfficeIPRef:
		m.ResetOfficeIPRef()
		return nil
	case exam_applications_ip.EdgeRoleusers:
		m.ResetRoleusers()
		return nil
	case exam_applications_ip.EdgeCadrePrefRef:
		m.ResetCadrePrefRef()
		return nil
	case exam_applications_ip.EdgeCirclePrefRef:
		m.ResetCirclePrefRef()
		return nil
	case exam_applications_ip.EdgeIPApplicationsRef:
		m.ResetIPApplicationsRef()
		return nil
	}
	return fmt.Errorf("unknown Exam_Applications_IP edge %s", name)
}

// ExamApplicationsPSMutation represents an operation that mutates the Exam_Applications_PS nodes in the graph.
type ExamApplicationsPSMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	_ApplicationNumber         *string
	_EmployeeID                *int64
	add_EmployeeID             *int64
	_EmployeeName              *string
	_DOB                       *string
	_Gender                    *exam_applications_ps.Gender
	_MobileNumber              *string
	_EmailID                   *string
	_EmployeeCategory          *string
	_Cadre                     *string
	_EmployeePost              *string
	_FacilityID                *string
	_DCCS                      *string
	_DCInPresentCadre          *string
	_DeputationOfficeId        *string
	_DisabilityType            *string
	_DisabilityPercentage      *string
	_Education                 *string
	_ExamNameCode              *string
	_ExamYear                  *string
	_ExamName                  *string
	_CentrePreference          *string
	_Signature                 *string
	_Photo                     *string
	_ApplicationStatus         *string
	_ApplnSubmittedDate        *time.Time
	_VA_Remarks                *string
	_VA_UserName               *string
	_VA_Date                   *time.Time
	_CA_Remarks                *string
	_CA_UserName               *string
	_CA_Date                   *time.Time
	_ApplicationWdlDate        *time.Time
	_NA_Remarks                *string
	_NA_UserName               *string
	_NA_Date                   *time.Time
	_AppliactionRemarks        *string
	_CadrePreferences          *[]interface{}
	append_CadrePreferences    []interface{}
	_DivisionPreferences       *[]interface{}
	append_DivisionPreferences []interface{}
	_CirclePreferences         *[]interface{}
	append_CirclePreferences   []interface{}
	_UpdatedAt                 *time.Time
	_UpdatedBy                 *string
	clearedFields              map[string]struct{}
	_UsersPSRef                map[int64]struct{}
	removed_UsersPSRef         map[int64]struct{}
	cleared_UsersPSRef         bool
	_ExamAppln_PS_Ref          map[int32]struct{}
	removed_ExamAppln_PS_Ref   map[int32]struct{}
	cleared_ExamAppln_PS_Ref   bool
	_Office_PS_Ref             map[int32]struct{}
	removed_Office_PS_Ref      map[int32]struct{}
	cleared_Office_PS_Ref      bool
	roleusers                  *int32
	clearedroleusers           bool
	done                       bool
	oldValue                   func(context.Context) (*Exam_Applications_PS, error)
	predicates                 []predicate.Exam_Applications_PS
}

var _ ent.Mutation = (*ExamApplicationsPSMutation)(nil)

// examApplicationsPSOption allows management of the mutation configuration using functional options.
type examApplicationsPSOption func(*ExamApplicationsPSMutation)

// newExamApplicationsPSMutation creates new mutation for the Exam_Applications_PS entity.
func newExamApplicationsPSMutation(c config, op Op, opts ...examApplicationsPSOption) *ExamApplicationsPSMutation {
	m := &ExamApplicationsPSMutation{
		config:        c,
		op:            op,
		typ:           TypeExamApplicationsPS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExam_Applications_PSID sets the ID field of the mutation.
func withExam_Applications_PSID(id int64) examApplicationsPSOption {
	return func(m *ExamApplicationsPSMutation) {
		var (
			err   error
			once  sync.Once
			value *Exam_Applications_PS
		)
		m.oldValue = func(ctx context.Context) (*Exam_Applications_PS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exam_Applications_PS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExam_Applications_PS sets the old Exam_Applications_PS of the mutation.
func withExam_Applications_PS(node *Exam_Applications_PS) examApplicationsPSOption {
	return func(m *ExamApplicationsPSMutation) {
		m.oldValue = func(context.Context) (*Exam_Applications_PS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExamApplicationsPSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExamApplicationsPSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exam_Applications_PS entities.
func (m *ExamApplicationsPSMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExamApplicationsPSMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExamApplicationsPSMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exam_Applications_PS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApplicationNumber sets the "ApplicationNumber" field.
func (m *ExamApplicationsPSMutation) SetApplicationNumber(s string) {
	m._ApplicationNumber = &s
}

// ApplicationNumber returns the value of the "ApplicationNumber" field in the mutation.
func (m *ExamApplicationsPSMutation) ApplicationNumber() (r string, exists bool) {
	v := m._ApplicationNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationNumber returns the old "ApplicationNumber" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldApplicationNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationNumber: %w", err)
	}
	return oldValue.ApplicationNumber, nil
}

// ClearApplicationNumber clears the value of the "ApplicationNumber" field.
func (m *ExamApplicationsPSMutation) ClearApplicationNumber() {
	m._ApplicationNumber = nil
	m.clearedFields[exam_applications_ps.FieldApplicationNumber] = struct{}{}
}

// ApplicationNumberCleared returns if the "ApplicationNumber" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) ApplicationNumberCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldApplicationNumber]
	return ok
}

// ResetApplicationNumber resets all changes to the "ApplicationNumber" field.
func (m *ExamApplicationsPSMutation) ResetApplicationNumber() {
	m._ApplicationNumber = nil
	delete(m.clearedFields, exam_applications_ps.FieldApplicationNumber)
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *ExamApplicationsPSMutation) SetEmployeeID(i int64) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *ExamApplicationsPSMutation) EmployeeID() (r int64, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldEmployeeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *ExamApplicationsPSMutation) AddEmployeeID(i int64) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *ExamApplicationsPSMutation) AddedEmployeeID() (r int64, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeeID clears the value of the "EmployeeID" field.
func (m *ExamApplicationsPSMutation) ClearEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	m.clearedFields[exam_applications_ps.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "EmployeeID" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *ExamApplicationsPSMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	delete(m.clearedFields, exam_applications_ps.FieldEmployeeID)
}

// SetEmployeeName sets the "EmployeeName" field.
func (m *ExamApplicationsPSMutation) SetEmployeeName(s string) {
	m._EmployeeName = &s
}

// EmployeeName returns the value of the "EmployeeName" field in the mutation.
func (m *ExamApplicationsPSMutation) EmployeeName() (r string, exists bool) {
	v := m._EmployeeName
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeName returns the old "EmployeeName" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldEmployeeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeName: %w", err)
	}
	return oldValue.EmployeeName, nil
}

// ClearEmployeeName clears the value of the "EmployeeName" field.
func (m *ExamApplicationsPSMutation) ClearEmployeeName() {
	m._EmployeeName = nil
	m.clearedFields[exam_applications_ps.FieldEmployeeName] = struct{}{}
}

// EmployeeNameCleared returns if the "EmployeeName" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) EmployeeNameCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldEmployeeName]
	return ok
}

// ResetEmployeeName resets all changes to the "EmployeeName" field.
func (m *ExamApplicationsPSMutation) ResetEmployeeName() {
	m._EmployeeName = nil
	delete(m.clearedFields, exam_applications_ps.FieldEmployeeName)
}

// SetDOB sets the "DOB" field.
func (m *ExamApplicationsPSMutation) SetDOB(s string) {
	m._DOB = &s
}

// DOB returns the value of the "DOB" field in the mutation.
func (m *ExamApplicationsPSMutation) DOB() (r string, exists bool) {
	v := m._DOB
	if v == nil {
		return
	}
	return *v, true
}

// OldDOB returns the old "DOB" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldDOB(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOB: %w", err)
	}
	return oldValue.DOB, nil
}

// ClearDOB clears the value of the "DOB" field.
func (m *ExamApplicationsPSMutation) ClearDOB() {
	m._DOB = nil
	m.clearedFields[exam_applications_ps.FieldDOB] = struct{}{}
}

// DOBCleared returns if the "DOB" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) DOBCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldDOB]
	return ok
}

// ResetDOB resets all changes to the "DOB" field.
func (m *ExamApplicationsPSMutation) ResetDOB() {
	m._DOB = nil
	delete(m.clearedFields, exam_applications_ps.FieldDOB)
}

// SetGender sets the "Gender" field.
func (m *ExamApplicationsPSMutation) SetGender(eap exam_applications_ps.Gender) {
	m._Gender = &eap
}

// Gender returns the value of the "Gender" field in the mutation.
func (m *ExamApplicationsPSMutation) Gender() (r exam_applications_ps.Gender, exists bool) {
	v := m._Gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "Gender" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldGender(ctx context.Context) (v exam_applications_ps.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "Gender" field.
func (m *ExamApplicationsPSMutation) ResetGender() {
	m._Gender = nil
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *ExamApplicationsPSMutation) SetMobileNumber(s string) {
	m._MobileNumber = &s
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *ExamApplicationsPSMutation) MobileNumber() (r string, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldMobileNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// ClearMobileNumber clears the value of the "MobileNumber" field.
func (m *ExamApplicationsPSMutation) ClearMobileNumber() {
	m._MobileNumber = nil
	m.clearedFields[exam_applications_ps.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "MobileNumber" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *ExamApplicationsPSMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	delete(m.clearedFields, exam_applications_ps.FieldMobileNumber)
}

// SetEmailID sets the "EmailID" field.
func (m *ExamApplicationsPSMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *ExamApplicationsPSMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ClearEmailID clears the value of the "EmailID" field.
func (m *ExamApplicationsPSMutation) ClearEmailID() {
	m._EmailID = nil
	m.clearedFields[exam_applications_ps.FieldEmailID] = struct{}{}
}

// EmailIDCleared returns if the "EmailID" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) EmailIDCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldEmailID]
	return ok
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *ExamApplicationsPSMutation) ResetEmailID() {
	m._EmailID = nil
	delete(m.clearedFields, exam_applications_ps.FieldEmailID)
}

// SetEmployeeCategory sets the "EmployeeCategory" field.
func (m *ExamApplicationsPSMutation) SetEmployeeCategory(s string) {
	m._EmployeeCategory = &s
}

// EmployeeCategory returns the value of the "EmployeeCategory" field in the mutation.
func (m *ExamApplicationsPSMutation) EmployeeCategory() (r string, exists bool) {
	v := m._EmployeeCategory
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCategory returns the old "EmployeeCategory" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldEmployeeCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCategory: %w", err)
	}
	return oldValue.EmployeeCategory, nil
}

// ClearEmployeeCategory clears the value of the "EmployeeCategory" field.
func (m *ExamApplicationsPSMutation) ClearEmployeeCategory() {
	m._EmployeeCategory = nil
	m.clearedFields[exam_applications_ps.FieldEmployeeCategory] = struct{}{}
}

// EmployeeCategoryCleared returns if the "EmployeeCategory" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) EmployeeCategoryCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldEmployeeCategory]
	return ok
}

// ResetEmployeeCategory resets all changes to the "EmployeeCategory" field.
func (m *ExamApplicationsPSMutation) ResetEmployeeCategory() {
	m._EmployeeCategory = nil
	delete(m.clearedFields, exam_applications_ps.FieldEmployeeCategory)
}

// SetCadre sets the "Cadre" field.
func (m *ExamApplicationsPSMutation) SetCadre(s string) {
	m._Cadre = &s
}

// Cadre returns the value of the "Cadre" field in the mutation.
func (m *ExamApplicationsPSMutation) Cadre() (r string, exists bool) {
	v := m._Cadre
	if v == nil {
		return
	}
	return *v, true
}

// OldCadre returns the old "Cadre" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadre: %w", err)
	}
	return oldValue.Cadre, nil
}

// ClearCadre clears the value of the "Cadre" field.
func (m *ExamApplicationsPSMutation) ClearCadre() {
	m._Cadre = nil
	m.clearedFields[exam_applications_ps.FieldCadre] = struct{}{}
}

// CadreCleared returns if the "Cadre" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) CadreCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldCadre]
	return ok
}

// ResetCadre resets all changes to the "Cadre" field.
func (m *ExamApplicationsPSMutation) ResetCadre() {
	m._Cadre = nil
	delete(m.clearedFields, exam_applications_ps.FieldCadre)
}

// SetEmployeePost sets the "EmployeePost" field.
func (m *ExamApplicationsPSMutation) SetEmployeePost(s string) {
	m._EmployeePost = &s
}

// EmployeePost returns the value of the "EmployeePost" field in the mutation.
func (m *ExamApplicationsPSMutation) EmployeePost() (r string, exists bool) {
	v := m._EmployeePost
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeePost returns the old "EmployeePost" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldEmployeePost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeePost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeePost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeePost: %w", err)
	}
	return oldValue.EmployeePost, nil
}

// ClearEmployeePost clears the value of the "EmployeePost" field.
func (m *ExamApplicationsPSMutation) ClearEmployeePost() {
	m._EmployeePost = nil
	m.clearedFields[exam_applications_ps.FieldEmployeePost] = struct{}{}
}

// EmployeePostCleared returns if the "EmployeePost" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) EmployeePostCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldEmployeePost]
	return ok
}

// ResetEmployeePost resets all changes to the "EmployeePost" field.
func (m *ExamApplicationsPSMutation) ResetEmployeePost() {
	m._EmployeePost = nil
	delete(m.clearedFields, exam_applications_ps.FieldEmployeePost)
}

// SetFacilityID sets the "FacilityID" field.
func (m *ExamApplicationsPSMutation) SetFacilityID(s string) {
	m._FacilityID = &s
}

// FacilityID returns the value of the "FacilityID" field in the mutation.
func (m *ExamApplicationsPSMutation) FacilityID() (r string, exists bool) {
	v := m._FacilityID
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityID returns the old "FacilityID" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldFacilityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityID: %w", err)
	}
	return oldValue.FacilityID, nil
}

// ClearFacilityID clears the value of the "FacilityID" field.
func (m *ExamApplicationsPSMutation) ClearFacilityID() {
	m._FacilityID = nil
	m.clearedFields[exam_applications_ps.FieldFacilityID] = struct{}{}
}

// FacilityIDCleared returns if the "FacilityID" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) FacilityIDCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldFacilityID]
	return ok
}

// ResetFacilityID resets all changes to the "FacilityID" field.
func (m *ExamApplicationsPSMutation) ResetFacilityID() {
	m._FacilityID = nil
	delete(m.clearedFields, exam_applications_ps.FieldFacilityID)
}

// SetDCCS sets the "DCCS" field.
func (m *ExamApplicationsPSMutation) SetDCCS(s string) {
	m._DCCS = &s
}

// DCCS returns the value of the "DCCS" field in the mutation.
func (m *ExamApplicationsPSMutation) DCCS() (r string, exists bool) {
	v := m._DCCS
	if v == nil {
		return
	}
	return *v, true
}

// OldDCCS returns the old "DCCS" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldDCCS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCCS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCCS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCCS: %w", err)
	}
	return oldValue.DCCS, nil
}

// ClearDCCS clears the value of the "DCCS" field.
func (m *ExamApplicationsPSMutation) ClearDCCS() {
	m._DCCS = nil
	m.clearedFields[exam_applications_ps.FieldDCCS] = struct{}{}
}

// DCCSCleared returns if the "DCCS" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) DCCSCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldDCCS]
	return ok
}

// ResetDCCS resets all changes to the "DCCS" field.
func (m *ExamApplicationsPSMutation) ResetDCCS() {
	m._DCCS = nil
	delete(m.clearedFields, exam_applications_ps.FieldDCCS)
}

// SetDCInPresentCadre sets the "DCInPresentCadre" field.
func (m *ExamApplicationsPSMutation) SetDCInPresentCadre(s string) {
	m._DCInPresentCadre = &s
}

// DCInPresentCadre returns the value of the "DCInPresentCadre" field in the mutation.
func (m *ExamApplicationsPSMutation) DCInPresentCadre() (r string, exists bool) {
	v := m._DCInPresentCadre
	if v == nil {
		return
	}
	return *v, true
}

// OldDCInPresentCadre returns the old "DCInPresentCadre" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldDCInPresentCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCInPresentCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCInPresentCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCInPresentCadre: %w", err)
	}
	return oldValue.DCInPresentCadre, nil
}

// ClearDCInPresentCadre clears the value of the "DCInPresentCadre" field.
func (m *ExamApplicationsPSMutation) ClearDCInPresentCadre() {
	m._DCInPresentCadre = nil
	m.clearedFields[exam_applications_ps.FieldDCInPresentCadre] = struct{}{}
}

// DCInPresentCadreCleared returns if the "DCInPresentCadre" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) DCInPresentCadreCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldDCInPresentCadre]
	return ok
}

// ResetDCInPresentCadre resets all changes to the "DCInPresentCadre" field.
func (m *ExamApplicationsPSMutation) ResetDCInPresentCadre() {
	m._DCInPresentCadre = nil
	delete(m.clearedFields, exam_applications_ps.FieldDCInPresentCadre)
}

// SetDeputationOfficeId sets the "DeputationOfficeId" field.
func (m *ExamApplicationsPSMutation) SetDeputationOfficeId(s string) {
	m._DeputationOfficeId = &s
}

// DeputationOfficeId returns the value of the "DeputationOfficeId" field in the mutation.
func (m *ExamApplicationsPSMutation) DeputationOfficeId() (r string, exists bool) {
	v := m._DeputationOfficeId
	if v == nil {
		return
	}
	return *v, true
}

// OldDeputationOfficeId returns the old "DeputationOfficeId" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldDeputationOfficeId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeputationOfficeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeputationOfficeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeputationOfficeId: %w", err)
	}
	return oldValue.DeputationOfficeId, nil
}

// ClearDeputationOfficeId clears the value of the "DeputationOfficeId" field.
func (m *ExamApplicationsPSMutation) ClearDeputationOfficeId() {
	m._DeputationOfficeId = nil
	m.clearedFields[exam_applications_ps.FieldDeputationOfficeId] = struct{}{}
}

// DeputationOfficeIdCleared returns if the "DeputationOfficeId" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) DeputationOfficeIdCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldDeputationOfficeId]
	return ok
}

// ResetDeputationOfficeId resets all changes to the "DeputationOfficeId" field.
func (m *ExamApplicationsPSMutation) ResetDeputationOfficeId() {
	m._DeputationOfficeId = nil
	delete(m.clearedFields, exam_applications_ps.FieldDeputationOfficeId)
}

// SetDisabilityType sets the "DisabilityType" field.
func (m *ExamApplicationsPSMutation) SetDisabilityType(s string) {
	m._DisabilityType = &s
}

// DisabilityType returns the value of the "DisabilityType" field in the mutation.
func (m *ExamApplicationsPSMutation) DisabilityType() (r string, exists bool) {
	v := m._DisabilityType
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityType returns the old "DisabilityType" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldDisabilityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityType: %w", err)
	}
	return oldValue.DisabilityType, nil
}

// ClearDisabilityType clears the value of the "DisabilityType" field.
func (m *ExamApplicationsPSMutation) ClearDisabilityType() {
	m._DisabilityType = nil
	m.clearedFields[exam_applications_ps.FieldDisabilityType] = struct{}{}
}

// DisabilityTypeCleared returns if the "DisabilityType" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) DisabilityTypeCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldDisabilityType]
	return ok
}

// ResetDisabilityType resets all changes to the "DisabilityType" field.
func (m *ExamApplicationsPSMutation) ResetDisabilityType() {
	m._DisabilityType = nil
	delete(m.clearedFields, exam_applications_ps.FieldDisabilityType)
}

// SetDisabilityPercentage sets the "DisabilityPercentage" field.
func (m *ExamApplicationsPSMutation) SetDisabilityPercentage(s string) {
	m._DisabilityPercentage = &s
}

// DisabilityPercentage returns the value of the "DisabilityPercentage" field in the mutation.
func (m *ExamApplicationsPSMutation) DisabilityPercentage() (r string, exists bool) {
	v := m._DisabilityPercentage
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityPercentage returns the old "DisabilityPercentage" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldDisabilityPercentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityPercentage: %w", err)
	}
	return oldValue.DisabilityPercentage, nil
}

// ClearDisabilityPercentage clears the value of the "DisabilityPercentage" field.
func (m *ExamApplicationsPSMutation) ClearDisabilityPercentage() {
	m._DisabilityPercentage = nil
	m.clearedFields[exam_applications_ps.FieldDisabilityPercentage] = struct{}{}
}

// DisabilityPercentageCleared returns if the "DisabilityPercentage" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) DisabilityPercentageCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldDisabilityPercentage]
	return ok
}

// ResetDisabilityPercentage resets all changes to the "DisabilityPercentage" field.
func (m *ExamApplicationsPSMutation) ResetDisabilityPercentage() {
	m._DisabilityPercentage = nil
	delete(m.clearedFields, exam_applications_ps.FieldDisabilityPercentage)
}

// SetEducation sets the "Education" field.
func (m *ExamApplicationsPSMutation) SetEducation(s string) {
	m._Education = &s
}

// Education returns the value of the "Education" field in the mutation.
func (m *ExamApplicationsPSMutation) Education() (r string, exists bool) {
	v := m._Education
	if v == nil {
		return
	}
	return *v, true
}

// OldEducation returns the old "Education" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldEducation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducation: %w", err)
	}
	return oldValue.Education, nil
}

// ClearEducation clears the value of the "Education" field.
func (m *ExamApplicationsPSMutation) ClearEducation() {
	m._Education = nil
	m.clearedFields[exam_applications_ps.FieldEducation] = struct{}{}
}

// EducationCleared returns if the "Education" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) EducationCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldEducation]
	return ok
}

// ResetEducation resets all changes to the "Education" field.
func (m *ExamApplicationsPSMutation) ResetEducation() {
	m._Education = nil
	delete(m.clearedFields, exam_applications_ps.FieldEducation)
}

// SetExamNameCode sets the "ExamNameCode" field.
func (m *ExamApplicationsPSMutation) SetExamNameCode(s string) {
	m._ExamNameCode = &s
}

// ExamNameCode returns the value of the "ExamNameCode" field in the mutation.
func (m *ExamApplicationsPSMutation) ExamNameCode() (r string, exists bool) {
	v := m._ExamNameCode
	if v == nil {
		return
	}
	return *v, true
}

// OldExamNameCode returns the old "ExamNameCode" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldExamNameCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamNameCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamNameCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamNameCode: %w", err)
	}
	return oldValue.ExamNameCode, nil
}

// ClearExamNameCode clears the value of the "ExamNameCode" field.
func (m *ExamApplicationsPSMutation) ClearExamNameCode() {
	m._ExamNameCode = nil
	m.clearedFields[exam_applications_ps.FieldExamNameCode] = struct{}{}
}

// ExamNameCodeCleared returns if the "ExamNameCode" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) ExamNameCodeCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldExamNameCode]
	return ok
}

// ResetExamNameCode resets all changes to the "ExamNameCode" field.
func (m *ExamApplicationsPSMutation) ResetExamNameCode() {
	m._ExamNameCode = nil
	delete(m.clearedFields, exam_applications_ps.FieldExamNameCode)
}

// SetExamYear sets the "ExamYear" field.
func (m *ExamApplicationsPSMutation) SetExamYear(s string) {
	m._ExamYear = &s
}

// ExamYear returns the value of the "ExamYear" field in the mutation.
func (m *ExamApplicationsPSMutation) ExamYear() (r string, exists bool) {
	v := m._ExamYear
	if v == nil {
		return
	}
	return *v, true
}

// OldExamYear returns the old "ExamYear" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldExamYear(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamYear: %w", err)
	}
	return oldValue.ExamYear, nil
}

// ClearExamYear clears the value of the "ExamYear" field.
func (m *ExamApplicationsPSMutation) ClearExamYear() {
	m._ExamYear = nil
	m.clearedFields[exam_applications_ps.FieldExamYear] = struct{}{}
}

// ExamYearCleared returns if the "ExamYear" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) ExamYearCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldExamYear]
	return ok
}

// ResetExamYear resets all changes to the "ExamYear" field.
func (m *ExamApplicationsPSMutation) ResetExamYear() {
	m._ExamYear = nil
	delete(m.clearedFields, exam_applications_ps.FieldExamYear)
}

// SetExamName sets the "ExamName" field.
func (m *ExamApplicationsPSMutation) SetExamName(s string) {
	m._ExamName = &s
}

// ExamName returns the value of the "ExamName" field in the mutation.
func (m *ExamApplicationsPSMutation) ExamName() (r string, exists bool) {
	v := m._ExamName
	if v == nil {
		return
	}
	return *v, true
}

// OldExamName returns the old "ExamName" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldExamName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamName: %w", err)
	}
	return oldValue.ExamName, nil
}

// ClearExamName clears the value of the "ExamName" field.
func (m *ExamApplicationsPSMutation) ClearExamName() {
	m._ExamName = nil
	m.clearedFields[exam_applications_ps.FieldExamName] = struct{}{}
}

// ExamNameCleared returns if the "ExamName" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) ExamNameCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldExamName]
	return ok
}

// ResetExamName resets all changes to the "ExamName" field.
func (m *ExamApplicationsPSMutation) ResetExamName() {
	m._ExamName = nil
	delete(m.clearedFields, exam_applications_ps.FieldExamName)
}

// SetCentrePreference sets the "CentrePreference" field.
func (m *ExamApplicationsPSMutation) SetCentrePreference(s string) {
	m._CentrePreference = &s
}

// CentrePreference returns the value of the "CentrePreference" field in the mutation.
func (m *ExamApplicationsPSMutation) CentrePreference() (r string, exists bool) {
	v := m._CentrePreference
	if v == nil {
		return
	}
	return *v, true
}

// OldCentrePreference returns the old "CentrePreference" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldCentrePreference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCentrePreference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCentrePreference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCentrePreference: %w", err)
	}
	return oldValue.CentrePreference, nil
}

// ClearCentrePreference clears the value of the "CentrePreference" field.
func (m *ExamApplicationsPSMutation) ClearCentrePreference() {
	m._CentrePreference = nil
	m.clearedFields[exam_applications_ps.FieldCentrePreference] = struct{}{}
}

// CentrePreferenceCleared returns if the "CentrePreference" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) CentrePreferenceCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldCentrePreference]
	return ok
}

// ResetCentrePreference resets all changes to the "CentrePreference" field.
func (m *ExamApplicationsPSMutation) ResetCentrePreference() {
	m._CentrePreference = nil
	delete(m.clearedFields, exam_applications_ps.FieldCentrePreference)
}

// SetSignature sets the "Signature" field.
func (m *ExamApplicationsPSMutation) SetSignature(s string) {
	m._Signature = &s
}

// Signature returns the value of the "Signature" field in the mutation.
func (m *ExamApplicationsPSMutation) Signature() (r string, exists bool) {
	v := m._Signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "Signature" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "Signature" field.
func (m *ExamApplicationsPSMutation) ClearSignature() {
	m._Signature = nil
	m.clearedFields[exam_applications_ps.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "Signature" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "Signature" field.
func (m *ExamApplicationsPSMutation) ResetSignature() {
	m._Signature = nil
	delete(m.clearedFields, exam_applications_ps.FieldSignature)
}

// SetPhoto sets the "Photo" field.
func (m *ExamApplicationsPSMutation) SetPhoto(s string) {
	m._Photo = &s
}

// Photo returns the value of the "Photo" field in the mutation.
func (m *ExamApplicationsPSMutation) Photo() (r string, exists bool) {
	v := m._Photo
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoto returns the old "Photo" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoto: %w", err)
	}
	return oldValue.Photo, nil
}

// ClearPhoto clears the value of the "Photo" field.
func (m *ExamApplicationsPSMutation) ClearPhoto() {
	m._Photo = nil
	m.clearedFields[exam_applications_ps.FieldPhoto] = struct{}{}
}

// PhotoCleared returns if the "Photo" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) PhotoCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldPhoto]
	return ok
}

// ResetPhoto resets all changes to the "Photo" field.
func (m *ExamApplicationsPSMutation) ResetPhoto() {
	m._Photo = nil
	delete(m.clearedFields, exam_applications_ps.FieldPhoto)
}

// SetApplicationStatus sets the "ApplicationStatus" field.
func (m *ExamApplicationsPSMutation) SetApplicationStatus(s string) {
	m._ApplicationStatus = &s
}

// ApplicationStatus returns the value of the "ApplicationStatus" field in the mutation.
func (m *ExamApplicationsPSMutation) ApplicationStatus() (r string, exists bool) {
	v := m._ApplicationStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationStatus returns the old "ApplicationStatus" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldApplicationStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationStatus: %w", err)
	}
	return oldValue.ApplicationStatus, nil
}

// ClearApplicationStatus clears the value of the "ApplicationStatus" field.
func (m *ExamApplicationsPSMutation) ClearApplicationStatus() {
	m._ApplicationStatus = nil
	m.clearedFields[exam_applications_ps.FieldApplicationStatus] = struct{}{}
}

// ApplicationStatusCleared returns if the "ApplicationStatus" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) ApplicationStatusCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldApplicationStatus]
	return ok
}

// ResetApplicationStatus resets all changes to the "ApplicationStatus" field.
func (m *ExamApplicationsPSMutation) ResetApplicationStatus() {
	m._ApplicationStatus = nil
	delete(m.clearedFields, exam_applications_ps.FieldApplicationStatus)
}

// SetApplnSubmittedDate sets the "ApplnSubmittedDate" field.
func (m *ExamApplicationsPSMutation) SetApplnSubmittedDate(t time.Time) {
	m._ApplnSubmittedDate = &t
}

// ApplnSubmittedDate returns the value of the "ApplnSubmittedDate" field in the mutation.
func (m *ExamApplicationsPSMutation) ApplnSubmittedDate() (r time.Time, exists bool) {
	v := m._ApplnSubmittedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldApplnSubmittedDate returns the old "ApplnSubmittedDate" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldApplnSubmittedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplnSubmittedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplnSubmittedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplnSubmittedDate: %w", err)
	}
	return oldValue.ApplnSubmittedDate, nil
}

// ClearApplnSubmittedDate clears the value of the "ApplnSubmittedDate" field.
func (m *ExamApplicationsPSMutation) ClearApplnSubmittedDate() {
	m._ApplnSubmittedDate = nil
	m.clearedFields[exam_applications_ps.FieldApplnSubmittedDate] = struct{}{}
}

// ApplnSubmittedDateCleared returns if the "ApplnSubmittedDate" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) ApplnSubmittedDateCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldApplnSubmittedDate]
	return ok
}

// ResetApplnSubmittedDate resets all changes to the "ApplnSubmittedDate" field.
func (m *ExamApplicationsPSMutation) ResetApplnSubmittedDate() {
	m._ApplnSubmittedDate = nil
	delete(m.clearedFields, exam_applications_ps.FieldApplnSubmittedDate)
}

// SetVARemarks sets the "VA_Remarks" field.
func (m *ExamApplicationsPSMutation) SetVARemarks(s string) {
	m._VA_Remarks = &s
}

// VARemarks returns the value of the "VA_Remarks" field in the mutation.
func (m *ExamApplicationsPSMutation) VARemarks() (r string, exists bool) {
	v := m._VA_Remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldVARemarks returns the old "VA_Remarks" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldVARemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVARemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVARemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVARemarks: %w", err)
	}
	return oldValue.VARemarks, nil
}

// ClearVARemarks clears the value of the "VA_Remarks" field.
func (m *ExamApplicationsPSMutation) ClearVARemarks() {
	m._VA_Remarks = nil
	m.clearedFields[exam_applications_ps.FieldVARemarks] = struct{}{}
}

// VARemarksCleared returns if the "VA_Remarks" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) VARemarksCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldVARemarks]
	return ok
}

// ResetVARemarks resets all changes to the "VA_Remarks" field.
func (m *ExamApplicationsPSMutation) ResetVARemarks() {
	m._VA_Remarks = nil
	delete(m.clearedFields, exam_applications_ps.FieldVARemarks)
}

// SetVAUserName sets the "VA_UserName" field.
func (m *ExamApplicationsPSMutation) SetVAUserName(s string) {
	m._VA_UserName = &s
}

// VAUserName returns the value of the "VA_UserName" field in the mutation.
func (m *ExamApplicationsPSMutation) VAUserName() (r string, exists bool) {
	v := m._VA_UserName
	if v == nil {
		return
	}
	return *v, true
}

// OldVAUserName returns the old "VA_UserName" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldVAUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVAUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVAUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVAUserName: %w", err)
	}
	return oldValue.VAUserName, nil
}

// ClearVAUserName clears the value of the "VA_UserName" field.
func (m *ExamApplicationsPSMutation) ClearVAUserName() {
	m._VA_UserName = nil
	m.clearedFields[exam_applications_ps.FieldVAUserName] = struct{}{}
}

// VAUserNameCleared returns if the "VA_UserName" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) VAUserNameCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldVAUserName]
	return ok
}

// ResetVAUserName resets all changes to the "VA_UserName" field.
func (m *ExamApplicationsPSMutation) ResetVAUserName() {
	m._VA_UserName = nil
	delete(m.clearedFields, exam_applications_ps.FieldVAUserName)
}

// SetVADate sets the "VA_Date" field.
func (m *ExamApplicationsPSMutation) SetVADate(t time.Time) {
	m._VA_Date = &t
}

// VADate returns the value of the "VA_Date" field in the mutation.
func (m *ExamApplicationsPSMutation) VADate() (r time.Time, exists bool) {
	v := m._VA_Date
	if v == nil {
		return
	}
	return *v, true
}

// OldVADate returns the old "VA_Date" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldVADate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVADate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVADate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVADate: %w", err)
	}
	return oldValue.VADate, nil
}

// ClearVADate clears the value of the "VA_Date" field.
func (m *ExamApplicationsPSMutation) ClearVADate() {
	m._VA_Date = nil
	m.clearedFields[exam_applications_ps.FieldVADate] = struct{}{}
}

// VADateCleared returns if the "VA_Date" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) VADateCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldVADate]
	return ok
}

// ResetVADate resets all changes to the "VA_Date" field.
func (m *ExamApplicationsPSMutation) ResetVADate() {
	m._VA_Date = nil
	delete(m.clearedFields, exam_applications_ps.FieldVADate)
}

// SetCARemarks sets the "CA_Remarks" field.
func (m *ExamApplicationsPSMutation) SetCARemarks(s string) {
	m._CA_Remarks = &s
}

// CARemarks returns the value of the "CA_Remarks" field in the mutation.
func (m *ExamApplicationsPSMutation) CARemarks() (r string, exists bool) {
	v := m._CA_Remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldCARemarks returns the old "CA_Remarks" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldCARemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCARemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCARemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCARemarks: %w", err)
	}
	return oldValue.CARemarks, nil
}

// ClearCARemarks clears the value of the "CA_Remarks" field.
func (m *ExamApplicationsPSMutation) ClearCARemarks() {
	m._CA_Remarks = nil
	m.clearedFields[exam_applications_ps.FieldCARemarks] = struct{}{}
}

// CARemarksCleared returns if the "CA_Remarks" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) CARemarksCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldCARemarks]
	return ok
}

// ResetCARemarks resets all changes to the "CA_Remarks" field.
func (m *ExamApplicationsPSMutation) ResetCARemarks() {
	m._CA_Remarks = nil
	delete(m.clearedFields, exam_applications_ps.FieldCARemarks)
}

// SetCAUserName sets the "CA_UserName" field.
func (m *ExamApplicationsPSMutation) SetCAUserName(s string) {
	m._CA_UserName = &s
}

// CAUserName returns the value of the "CA_UserName" field in the mutation.
func (m *ExamApplicationsPSMutation) CAUserName() (r string, exists bool) {
	v := m._CA_UserName
	if v == nil {
		return
	}
	return *v, true
}

// OldCAUserName returns the old "CA_UserName" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldCAUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCAUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCAUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCAUserName: %w", err)
	}
	return oldValue.CAUserName, nil
}

// ClearCAUserName clears the value of the "CA_UserName" field.
func (m *ExamApplicationsPSMutation) ClearCAUserName() {
	m._CA_UserName = nil
	m.clearedFields[exam_applications_ps.FieldCAUserName] = struct{}{}
}

// CAUserNameCleared returns if the "CA_UserName" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) CAUserNameCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldCAUserName]
	return ok
}

// ResetCAUserName resets all changes to the "CA_UserName" field.
func (m *ExamApplicationsPSMutation) ResetCAUserName() {
	m._CA_UserName = nil
	delete(m.clearedFields, exam_applications_ps.FieldCAUserName)
}

// SetCADate sets the "CA_Date" field.
func (m *ExamApplicationsPSMutation) SetCADate(t time.Time) {
	m._CA_Date = &t
}

// CADate returns the value of the "CA_Date" field in the mutation.
func (m *ExamApplicationsPSMutation) CADate() (r time.Time, exists bool) {
	v := m._CA_Date
	if v == nil {
		return
	}
	return *v, true
}

// OldCADate returns the old "CA_Date" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldCADate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCADate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCADate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCADate: %w", err)
	}
	return oldValue.CADate, nil
}

// ClearCADate clears the value of the "CA_Date" field.
func (m *ExamApplicationsPSMutation) ClearCADate() {
	m._CA_Date = nil
	m.clearedFields[exam_applications_ps.FieldCADate] = struct{}{}
}

// CADateCleared returns if the "CA_Date" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) CADateCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldCADate]
	return ok
}

// ResetCADate resets all changes to the "CA_Date" field.
func (m *ExamApplicationsPSMutation) ResetCADate() {
	m._CA_Date = nil
	delete(m.clearedFields, exam_applications_ps.FieldCADate)
}

// SetApplicationWdlDate sets the "ApplicationWdlDate" field.
func (m *ExamApplicationsPSMutation) SetApplicationWdlDate(t time.Time) {
	m._ApplicationWdlDate = &t
}

// ApplicationWdlDate returns the value of the "ApplicationWdlDate" field in the mutation.
func (m *ExamApplicationsPSMutation) ApplicationWdlDate() (r time.Time, exists bool) {
	v := m._ApplicationWdlDate
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationWdlDate returns the old "ApplicationWdlDate" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldApplicationWdlDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationWdlDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationWdlDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationWdlDate: %w", err)
	}
	return oldValue.ApplicationWdlDate, nil
}

// ClearApplicationWdlDate clears the value of the "ApplicationWdlDate" field.
func (m *ExamApplicationsPSMutation) ClearApplicationWdlDate() {
	m._ApplicationWdlDate = nil
	m.clearedFields[exam_applications_ps.FieldApplicationWdlDate] = struct{}{}
}

// ApplicationWdlDateCleared returns if the "ApplicationWdlDate" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) ApplicationWdlDateCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldApplicationWdlDate]
	return ok
}

// ResetApplicationWdlDate resets all changes to the "ApplicationWdlDate" field.
func (m *ExamApplicationsPSMutation) ResetApplicationWdlDate() {
	m._ApplicationWdlDate = nil
	delete(m.clearedFields, exam_applications_ps.FieldApplicationWdlDate)
}

// SetNARemarks sets the "NA_Remarks" field.
func (m *ExamApplicationsPSMutation) SetNARemarks(s string) {
	m._NA_Remarks = &s
}

// NARemarks returns the value of the "NA_Remarks" field in the mutation.
func (m *ExamApplicationsPSMutation) NARemarks() (r string, exists bool) {
	v := m._NA_Remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldNARemarks returns the old "NA_Remarks" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldNARemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNARemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNARemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNARemarks: %w", err)
	}
	return oldValue.NARemarks, nil
}

// ClearNARemarks clears the value of the "NA_Remarks" field.
func (m *ExamApplicationsPSMutation) ClearNARemarks() {
	m._NA_Remarks = nil
	m.clearedFields[exam_applications_ps.FieldNARemarks] = struct{}{}
}

// NARemarksCleared returns if the "NA_Remarks" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) NARemarksCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldNARemarks]
	return ok
}

// ResetNARemarks resets all changes to the "NA_Remarks" field.
func (m *ExamApplicationsPSMutation) ResetNARemarks() {
	m._NA_Remarks = nil
	delete(m.clearedFields, exam_applications_ps.FieldNARemarks)
}

// SetNAUserName sets the "NA_UserName" field.
func (m *ExamApplicationsPSMutation) SetNAUserName(s string) {
	m._NA_UserName = &s
}

// NAUserName returns the value of the "NA_UserName" field in the mutation.
func (m *ExamApplicationsPSMutation) NAUserName() (r string, exists bool) {
	v := m._NA_UserName
	if v == nil {
		return
	}
	return *v, true
}

// OldNAUserName returns the old "NA_UserName" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldNAUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNAUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNAUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNAUserName: %w", err)
	}
	return oldValue.NAUserName, nil
}

// ClearNAUserName clears the value of the "NA_UserName" field.
func (m *ExamApplicationsPSMutation) ClearNAUserName() {
	m._NA_UserName = nil
	m.clearedFields[exam_applications_ps.FieldNAUserName] = struct{}{}
}

// NAUserNameCleared returns if the "NA_UserName" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) NAUserNameCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldNAUserName]
	return ok
}

// ResetNAUserName resets all changes to the "NA_UserName" field.
func (m *ExamApplicationsPSMutation) ResetNAUserName() {
	m._NA_UserName = nil
	delete(m.clearedFields, exam_applications_ps.FieldNAUserName)
}

// SetNADate sets the "NA_Date" field.
func (m *ExamApplicationsPSMutation) SetNADate(t time.Time) {
	m._NA_Date = &t
}

// NADate returns the value of the "NA_Date" field in the mutation.
func (m *ExamApplicationsPSMutation) NADate() (r time.Time, exists bool) {
	v := m._NA_Date
	if v == nil {
		return
	}
	return *v, true
}

// OldNADate returns the old "NA_Date" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldNADate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNADate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNADate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNADate: %w", err)
	}
	return oldValue.NADate, nil
}

// ClearNADate clears the value of the "NA_Date" field.
func (m *ExamApplicationsPSMutation) ClearNADate() {
	m._NA_Date = nil
	m.clearedFields[exam_applications_ps.FieldNADate] = struct{}{}
}

// NADateCleared returns if the "NA_Date" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) NADateCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldNADate]
	return ok
}

// ResetNADate resets all changes to the "NA_Date" field.
func (m *ExamApplicationsPSMutation) ResetNADate() {
	m._NA_Date = nil
	delete(m.clearedFields, exam_applications_ps.FieldNADate)
}

// SetAppliactionRemarks sets the "AppliactionRemarks" field.
func (m *ExamApplicationsPSMutation) SetAppliactionRemarks(s string) {
	m._AppliactionRemarks = &s
}

// AppliactionRemarks returns the value of the "AppliactionRemarks" field in the mutation.
func (m *ExamApplicationsPSMutation) AppliactionRemarks() (r string, exists bool) {
	v := m._AppliactionRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliactionRemarks returns the old "AppliactionRemarks" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldAppliactionRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliactionRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliactionRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliactionRemarks: %w", err)
	}
	return oldValue.AppliactionRemarks, nil
}

// ClearAppliactionRemarks clears the value of the "AppliactionRemarks" field.
func (m *ExamApplicationsPSMutation) ClearAppliactionRemarks() {
	m._AppliactionRemarks = nil
	m.clearedFields[exam_applications_ps.FieldAppliactionRemarks] = struct{}{}
}

// AppliactionRemarksCleared returns if the "AppliactionRemarks" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) AppliactionRemarksCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldAppliactionRemarks]
	return ok
}

// ResetAppliactionRemarks resets all changes to the "AppliactionRemarks" field.
func (m *ExamApplicationsPSMutation) ResetAppliactionRemarks() {
	m._AppliactionRemarks = nil
	delete(m.clearedFields, exam_applications_ps.FieldAppliactionRemarks)
}

// SetCadrePreferences sets the "CadrePreferences" field.
func (m *ExamApplicationsPSMutation) SetCadrePreferences(i []interface{}) {
	m._CadrePreferences = &i
	m.append_CadrePreferences = nil
}

// CadrePreferences returns the value of the "CadrePreferences" field in the mutation.
func (m *ExamApplicationsPSMutation) CadrePreferences() (r []interface{}, exists bool) {
	v := m._CadrePreferences
	if v == nil {
		return
	}
	return *v, true
}

// OldCadrePreferences returns the old "CadrePreferences" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldCadrePreferences(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadrePreferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadrePreferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadrePreferences: %w", err)
	}
	return oldValue.CadrePreferences, nil
}

// AppendCadrePreferences adds i to the "CadrePreferences" field.
func (m *ExamApplicationsPSMutation) AppendCadrePreferences(i []interface{}) {
	m.append_CadrePreferences = append(m.append_CadrePreferences, i...)
}

// AppendedCadrePreferences returns the list of values that were appended to the "CadrePreferences" field in this mutation.
func (m *ExamApplicationsPSMutation) AppendedCadrePreferences() ([]interface{}, bool) {
	if len(m.append_CadrePreferences) == 0 {
		return nil, false
	}
	return m.append_CadrePreferences, true
}

// ClearCadrePreferences clears the value of the "CadrePreferences" field.
func (m *ExamApplicationsPSMutation) ClearCadrePreferences() {
	m._CadrePreferences = nil
	m.append_CadrePreferences = nil
	m.clearedFields[exam_applications_ps.FieldCadrePreferences] = struct{}{}
}

// CadrePreferencesCleared returns if the "CadrePreferences" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) CadrePreferencesCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldCadrePreferences]
	return ok
}

// ResetCadrePreferences resets all changes to the "CadrePreferences" field.
func (m *ExamApplicationsPSMutation) ResetCadrePreferences() {
	m._CadrePreferences = nil
	m.append_CadrePreferences = nil
	delete(m.clearedFields, exam_applications_ps.FieldCadrePreferences)
}

// SetDivisionPreferences sets the "DivisionPreferences" field.
func (m *ExamApplicationsPSMutation) SetDivisionPreferences(i []interface{}) {
	m._DivisionPreferences = &i
	m.append_DivisionPreferences = nil
}

// DivisionPreferences returns the value of the "DivisionPreferences" field in the mutation.
func (m *ExamApplicationsPSMutation) DivisionPreferences() (r []interface{}, exists bool) {
	v := m._DivisionPreferences
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionPreferences returns the old "DivisionPreferences" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldDivisionPreferences(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionPreferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionPreferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionPreferences: %w", err)
	}
	return oldValue.DivisionPreferences, nil
}

// AppendDivisionPreferences adds i to the "DivisionPreferences" field.
func (m *ExamApplicationsPSMutation) AppendDivisionPreferences(i []interface{}) {
	m.append_DivisionPreferences = append(m.append_DivisionPreferences, i...)
}

// AppendedDivisionPreferences returns the list of values that were appended to the "DivisionPreferences" field in this mutation.
func (m *ExamApplicationsPSMutation) AppendedDivisionPreferences() ([]interface{}, bool) {
	if len(m.append_DivisionPreferences) == 0 {
		return nil, false
	}
	return m.append_DivisionPreferences, true
}

// ClearDivisionPreferences clears the value of the "DivisionPreferences" field.
func (m *ExamApplicationsPSMutation) ClearDivisionPreferences() {
	m._DivisionPreferences = nil
	m.append_DivisionPreferences = nil
	m.clearedFields[exam_applications_ps.FieldDivisionPreferences] = struct{}{}
}

// DivisionPreferencesCleared returns if the "DivisionPreferences" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) DivisionPreferencesCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldDivisionPreferences]
	return ok
}

// ResetDivisionPreferences resets all changes to the "DivisionPreferences" field.
func (m *ExamApplicationsPSMutation) ResetDivisionPreferences() {
	m._DivisionPreferences = nil
	m.append_DivisionPreferences = nil
	delete(m.clearedFields, exam_applications_ps.FieldDivisionPreferences)
}

// SetCirclePreferences sets the "CirclePreferences" field.
func (m *ExamApplicationsPSMutation) SetCirclePreferences(i []interface{}) {
	m._CirclePreferences = &i
	m.append_CirclePreferences = nil
}

// CirclePreferences returns the value of the "CirclePreferences" field in the mutation.
func (m *ExamApplicationsPSMutation) CirclePreferences() (r []interface{}, exists bool) {
	v := m._CirclePreferences
	if v == nil {
		return
	}
	return *v, true
}

// OldCirclePreferences returns the old "CirclePreferences" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldCirclePreferences(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCirclePreferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCirclePreferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCirclePreferences: %w", err)
	}
	return oldValue.CirclePreferences, nil
}

// AppendCirclePreferences adds i to the "CirclePreferences" field.
func (m *ExamApplicationsPSMutation) AppendCirclePreferences(i []interface{}) {
	m.append_CirclePreferences = append(m.append_CirclePreferences, i...)
}

// AppendedCirclePreferences returns the list of values that were appended to the "CirclePreferences" field in this mutation.
func (m *ExamApplicationsPSMutation) AppendedCirclePreferences() ([]interface{}, bool) {
	if len(m.append_CirclePreferences) == 0 {
		return nil, false
	}
	return m.append_CirclePreferences, true
}

// ClearCirclePreferences clears the value of the "CirclePreferences" field.
func (m *ExamApplicationsPSMutation) ClearCirclePreferences() {
	m._CirclePreferences = nil
	m.append_CirclePreferences = nil
	m.clearedFields[exam_applications_ps.FieldCirclePreferences] = struct{}{}
}

// CirclePreferencesCleared returns if the "CirclePreferences" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) CirclePreferencesCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldCirclePreferences]
	return ok
}

// ResetCirclePreferences resets all changes to the "CirclePreferences" field.
func (m *ExamApplicationsPSMutation) ResetCirclePreferences() {
	m._CirclePreferences = nil
	m.append_CirclePreferences = nil
	delete(m.clearedFields, exam_applications_ps.FieldCirclePreferences)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *ExamApplicationsPSMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *ExamApplicationsPSMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *ExamApplicationsPSMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[exam_applications_ps.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *ExamApplicationsPSMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, exam_applications_ps.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *ExamApplicationsPSMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *ExamApplicationsPSMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *ExamApplicationsPSMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[exam_applications_ps.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *ExamApplicationsPSMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, exam_applications_ps.FieldUpdatedBy)
}

// SetRoleUserCode sets the "RoleUserCode" field.
func (m *ExamApplicationsPSMutation) SetRoleUserCode(i int32) {
	m.roleusers = &i
}

// RoleUserCode returns the value of the "RoleUserCode" field in the mutation.
func (m *ExamApplicationsPSMutation) RoleUserCode() (r int32, exists bool) {
	v := m.roleusers
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleUserCode returns the old "RoleUserCode" field's value of the Exam_Applications_PS entity.
// If the Exam_Applications_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamApplicationsPSMutation) OldRoleUserCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleUserCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleUserCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleUserCode: %w", err)
	}
	return oldValue.RoleUserCode, nil
}

// ClearRoleUserCode clears the value of the "RoleUserCode" field.
func (m *ExamApplicationsPSMutation) ClearRoleUserCode() {
	m.roleusers = nil
	m.clearedFields[exam_applications_ps.FieldRoleUserCode] = struct{}{}
}

// RoleUserCodeCleared returns if the "RoleUserCode" field was cleared in this mutation.
func (m *ExamApplicationsPSMutation) RoleUserCodeCleared() bool {
	_, ok := m.clearedFields[exam_applications_ps.FieldRoleUserCode]
	return ok
}

// ResetRoleUserCode resets all changes to the "RoleUserCode" field.
func (m *ExamApplicationsPSMutation) ResetRoleUserCode() {
	m.roleusers = nil
	delete(m.clearedFields, exam_applications_ps.FieldRoleUserCode)
}

// AddUsersPSRefIDs adds the "UsersPSRef" edge to the UserMaster entity by ids.
func (m *ExamApplicationsPSMutation) AddUsersPSRefIDs(ids ...int64) {
	if m._UsersPSRef == nil {
		m._UsersPSRef = make(map[int64]struct{})
	}
	for i := range ids {
		m._UsersPSRef[ids[i]] = struct{}{}
	}
}

// ClearUsersPSRef clears the "UsersPSRef" edge to the UserMaster entity.
func (m *ExamApplicationsPSMutation) ClearUsersPSRef() {
	m.cleared_UsersPSRef = true
}

// UsersPSRefCleared reports if the "UsersPSRef" edge to the UserMaster entity was cleared.
func (m *ExamApplicationsPSMutation) UsersPSRefCleared() bool {
	return m.cleared_UsersPSRef
}

// RemoveUsersPSRefIDs removes the "UsersPSRef" edge to the UserMaster entity by IDs.
func (m *ExamApplicationsPSMutation) RemoveUsersPSRefIDs(ids ...int64) {
	if m.removed_UsersPSRef == nil {
		m.removed_UsersPSRef = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._UsersPSRef, ids[i])
		m.removed_UsersPSRef[ids[i]] = struct{}{}
	}
}

// RemovedUsersPSRef returns the removed IDs of the "UsersPSRef" edge to the UserMaster entity.
func (m *ExamApplicationsPSMutation) RemovedUsersPSRefIDs() (ids []int64) {
	for id := range m.removed_UsersPSRef {
		ids = append(ids, id)
	}
	return
}

// UsersPSRefIDs returns the "UsersPSRef" edge IDs in the mutation.
func (m *ExamApplicationsPSMutation) UsersPSRefIDs() (ids []int64) {
	for id := range m._UsersPSRef {
		ids = append(ids, id)
	}
	return
}

// ResetUsersPSRef resets all changes to the "UsersPSRef" edge.
func (m *ExamApplicationsPSMutation) ResetUsersPSRef() {
	m._UsersPSRef = nil
	m.cleared_UsersPSRef = false
	m.removed_UsersPSRef = nil
}

// AddExamApplnPSRefIDs adds the "ExamAppln_PS_Ref" edge to the Exam_PS entity by ids.
func (m *ExamApplicationsPSMutation) AddExamApplnPSRefIDs(ids ...int32) {
	if m._ExamAppln_PS_Ref == nil {
		m._ExamAppln_PS_Ref = make(map[int32]struct{})
	}
	for i := range ids {
		m._ExamAppln_PS_Ref[ids[i]] = struct{}{}
	}
}

// ClearExamApplnPSRef clears the "ExamAppln_PS_Ref" edge to the Exam_PS entity.
func (m *ExamApplicationsPSMutation) ClearExamApplnPSRef() {
	m.cleared_ExamAppln_PS_Ref = true
}

// ExamApplnPSRefCleared reports if the "ExamAppln_PS_Ref" edge to the Exam_PS entity was cleared.
func (m *ExamApplicationsPSMutation) ExamApplnPSRefCleared() bool {
	return m.cleared_ExamAppln_PS_Ref
}

// RemoveExamApplnPSRefIDs removes the "ExamAppln_PS_Ref" edge to the Exam_PS entity by IDs.
func (m *ExamApplicationsPSMutation) RemoveExamApplnPSRefIDs(ids ...int32) {
	if m.removed_ExamAppln_PS_Ref == nil {
		m.removed_ExamAppln_PS_Ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m._ExamAppln_PS_Ref, ids[i])
		m.removed_ExamAppln_PS_Ref[ids[i]] = struct{}{}
	}
}

// RemovedExamApplnPSRef returns the removed IDs of the "ExamAppln_PS_Ref" edge to the Exam_PS entity.
func (m *ExamApplicationsPSMutation) RemovedExamApplnPSRefIDs() (ids []int32) {
	for id := range m.removed_ExamAppln_PS_Ref {
		ids = append(ids, id)
	}
	return
}

// ExamApplnPSRefIDs returns the "ExamAppln_PS_Ref" edge IDs in the mutation.
func (m *ExamApplicationsPSMutation) ExamApplnPSRefIDs() (ids []int32) {
	for id := range m._ExamAppln_PS_Ref {
		ids = append(ids, id)
	}
	return
}

// ResetExamApplnPSRef resets all changes to the "ExamAppln_PS_Ref" edge.
func (m *ExamApplicationsPSMutation) ResetExamApplnPSRef() {
	m._ExamAppln_PS_Ref = nil
	m.cleared_ExamAppln_PS_Ref = false
	m.removed_ExamAppln_PS_Ref = nil
}

// AddOfficePSRefIDs adds the "Office_PS_Ref" edge to the Facility entity by ids.
func (m *ExamApplicationsPSMutation) AddOfficePSRefIDs(ids ...int32) {
	if m._Office_PS_Ref == nil {
		m._Office_PS_Ref = make(map[int32]struct{})
	}
	for i := range ids {
		m._Office_PS_Ref[ids[i]] = struct{}{}
	}
}

// ClearOfficePSRef clears the "Office_PS_Ref" edge to the Facility entity.
func (m *ExamApplicationsPSMutation) ClearOfficePSRef() {
	m.cleared_Office_PS_Ref = true
}

// OfficePSRefCleared reports if the "Office_PS_Ref" edge to the Facility entity was cleared.
func (m *ExamApplicationsPSMutation) OfficePSRefCleared() bool {
	return m.cleared_Office_PS_Ref
}

// RemoveOfficePSRefIDs removes the "Office_PS_Ref" edge to the Facility entity by IDs.
func (m *ExamApplicationsPSMutation) RemoveOfficePSRefIDs(ids ...int32) {
	if m.removed_Office_PS_Ref == nil {
		m.removed_Office_PS_Ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m._Office_PS_Ref, ids[i])
		m.removed_Office_PS_Ref[ids[i]] = struct{}{}
	}
}

// RemovedOfficePSRef returns the removed IDs of the "Office_PS_Ref" edge to the Facility entity.
func (m *ExamApplicationsPSMutation) RemovedOfficePSRefIDs() (ids []int32) {
	for id := range m.removed_Office_PS_Ref {
		ids = append(ids, id)
	}
	return
}

// OfficePSRefIDs returns the "Office_PS_Ref" edge IDs in the mutation.
func (m *ExamApplicationsPSMutation) OfficePSRefIDs() (ids []int32) {
	for id := range m._Office_PS_Ref {
		ids = append(ids, id)
	}
	return
}

// ResetOfficePSRef resets all changes to the "Office_PS_Ref" edge.
func (m *ExamApplicationsPSMutation) ResetOfficePSRef() {
	m._Office_PS_Ref = nil
	m.cleared_Office_PS_Ref = false
	m.removed_Office_PS_Ref = nil
}

// SetRoleusersID sets the "roleusers" edge to the RoleMaster entity by id.
func (m *ExamApplicationsPSMutation) SetRoleusersID(id int32) {
	m.roleusers = &id
}

// ClearRoleusers clears the "roleusers" edge to the RoleMaster entity.
func (m *ExamApplicationsPSMutation) ClearRoleusers() {
	m.clearedroleusers = true
}

// RoleusersCleared reports if the "roleusers" edge to the RoleMaster entity was cleared.
func (m *ExamApplicationsPSMutation) RoleusersCleared() bool {
	return m.RoleUserCodeCleared() || m.clearedroleusers
}

// RoleusersID returns the "roleusers" edge ID in the mutation.
func (m *ExamApplicationsPSMutation) RoleusersID() (id int32, exists bool) {
	if m.roleusers != nil {
		return *m.roleusers, true
	}
	return
}

// RoleusersIDs returns the "roleusers" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleusersID instead. It exists only for internal usage by the builders.
func (m *ExamApplicationsPSMutation) RoleusersIDs() (ids []int32) {
	if id := m.roleusers; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoleusers resets all changes to the "roleusers" edge.
func (m *ExamApplicationsPSMutation) ResetRoleusers() {
	m.roleusers = nil
	m.clearedroleusers = false
}

// Where appends a list predicates to the ExamApplicationsPSMutation builder.
func (m *ExamApplicationsPSMutation) Where(ps ...predicate.Exam_Applications_PS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExamApplicationsPSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExamApplicationsPSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exam_Applications_PS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExamApplicationsPSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExamApplicationsPSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exam_Applications_PS).
func (m *ExamApplicationsPSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExamApplicationsPSMutation) Fields() []string {
	fields := make([]string, 0, 42)
	if m._ApplicationNumber != nil {
		fields = append(fields, exam_applications_ps.FieldApplicationNumber)
	}
	if m._EmployeeID != nil {
		fields = append(fields, exam_applications_ps.FieldEmployeeID)
	}
	if m._EmployeeName != nil {
		fields = append(fields, exam_applications_ps.FieldEmployeeName)
	}
	if m._DOB != nil {
		fields = append(fields, exam_applications_ps.FieldDOB)
	}
	if m._Gender != nil {
		fields = append(fields, exam_applications_ps.FieldGender)
	}
	if m._MobileNumber != nil {
		fields = append(fields, exam_applications_ps.FieldMobileNumber)
	}
	if m._EmailID != nil {
		fields = append(fields, exam_applications_ps.FieldEmailID)
	}
	if m._EmployeeCategory != nil {
		fields = append(fields, exam_applications_ps.FieldEmployeeCategory)
	}
	if m._Cadre != nil {
		fields = append(fields, exam_applications_ps.FieldCadre)
	}
	if m._EmployeePost != nil {
		fields = append(fields, exam_applications_ps.FieldEmployeePost)
	}
	if m._FacilityID != nil {
		fields = append(fields, exam_applications_ps.FieldFacilityID)
	}
	if m._DCCS != nil {
		fields = append(fields, exam_applications_ps.FieldDCCS)
	}
	if m._DCInPresentCadre != nil {
		fields = append(fields, exam_applications_ps.FieldDCInPresentCadre)
	}
	if m._DeputationOfficeId != nil {
		fields = append(fields, exam_applications_ps.FieldDeputationOfficeId)
	}
	if m._DisabilityType != nil {
		fields = append(fields, exam_applications_ps.FieldDisabilityType)
	}
	if m._DisabilityPercentage != nil {
		fields = append(fields, exam_applications_ps.FieldDisabilityPercentage)
	}
	if m._Education != nil {
		fields = append(fields, exam_applications_ps.FieldEducation)
	}
	if m._ExamNameCode != nil {
		fields = append(fields, exam_applications_ps.FieldExamNameCode)
	}
	if m._ExamYear != nil {
		fields = append(fields, exam_applications_ps.FieldExamYear)
	}
	if m._ExamName != nil {
		fields = append(fields, exam_applications_ps.FieldExamName)
	}
	if m._CentrePreference != nil {
		fields = append(fields, exam_applications_ps.FieldCentrePreference)
	}
	if m._Signature != nil {
		fields = append(fields, exam_applications_ps.FieldSignature)
	}
	if m._Photo != nil {
		fields = append(fields, exam_applications_ps.FieldPhoto)
	}
	if m._ApplicationStatus != nil {
		fields = append(fields, exam_applications_ps.FieldApplicationStatus)
	}
	if m._ApplnSubmittedDate != nil {
		fields = append(fields, exam_applications_ps.FieldApplnSubmittedDate)
	}
	if m._VA_Remarks != nil {
		fields = append(fields, exam_applications_ps.FieldVARemarks)
	}
	if m._VA_UserName != nil {
		fields = append(fields, exam_applications_ps.FieldVAUserName)
	}
	if m._VA_Date != nil {
		fields = append(fields, exam_applications_ps.FieldVADate)
	}
	if m._CA_Remarks != nil {
		fields = append(fields, exam_applications_ps.FieldCARemarks)
	}
	if m._CA_UserName != nil {
		fields = append(fields, exam_applications_ps.FieldCAUserName)
	}
	if m._CA_Date != nil {
		fields = append(fields, exam_applications_ps.FieldCADate)
	}
	if m._ApplicationWdlDate != nil {
		fields = append(fields, exam_applications_ps.FieldApplicationWdlDate)
	}
	if m._NA_Remarks != nil {
		fields = append(fields, exam_applications_ps.FieldNARemarks)
	}
	if m._NA_UserName != nil {
		fields = append(fields, exam_applications_ps.FieldNAUserName)
	}
	if m._NA_Date != nil {
		fields = append(fields, exam_applications_ps.FieldNADate)
	}
	if m._AppliactionRemarks != nil {
		fields = append(fields, exam_applications_ps.FieldAppliactionRemarks)
	}
	if m._CadrePreferences != nil {
		fields = append(fields, exam_applications_ps.FieldCadrePreferences)
	}
	if m._DivisionPreferences != nil {
		fields = append(fields, exam_applications_ps.FieldDivisionPreferences)
	}
	if m._CirclePreferences != nil {
		fields = append(fields, exam_applications_ps.FieldCirclePreferences)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, exam_applications_ps.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, exam_applications_ps.FieldUpdatedBy)
	}
	if m.roleusers != nil {
		fields = append(fields, exam_applications_ps.FieldRoleUserCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExamApplicationsPSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exam_applications_ps.FieldApplicationNumber:
		return m.ApplicationNumber()
	case exam_applications_ps.FieldEmployeeID:
		return m.EmployeeID()
	case exam_applications_ps.FieldEmployeeName:
		return m.EmployeeName()
	case exam_applications_ps.FieldDOB:
		return m.DOB()
	case exam_applications_ps.FieldGender:
		return m.Gender()
	case exam_applications_ps.FieldMobileNumber:
		return m.MobileNumber()
	case exam_applications_ps.FieldEmailID:
		return m.EmailID()
	case exam_applications_ps.FieldEmployeeCategory:
		return m.EmployeeCategory()
	case exam_applications_ps.FieldCadre:
		return m.Cadre()
	case exam_applications_ps.FieldEmployeePost:
		return m.EmployeePost()
	case exam_applications_ps.FieldFacilityID:
		return m.FacilityID()
	case exam_applications_ps.FieldDCCS:
		return m.DCCS()
	case exam_applications_ps.FieldDCInPresentCadre:
		return m.DCInPresentCadre()
	case exam_applications_ps.FieldDeputationOfficeId:
		return m.DeputationOfficeId()
	case exam_applications_ps.FieldDisabilityType:
		return m.DisabilityType()
	case exam_applications_ps.FieldDisabilityPercentage:
		return m.DisabilityPercentage()
	case exam_applications_ps.FieldEducation:
		return m.Education()
	case exam_applications_ps.FieldExamNameCode:
		return m.ExamNameCode()
	case exam_applications_ps.FieldExamYear:
		return m.ExamYear()
	case exam_applications_ps.FieldExamName:
		return m.ExamName()
	case exam_applications_ps.FieldCentrePreference:
		return m.CentrePreference()
	case exam_applications_ps.FieldSignature:
		return m.Signature()
	case exam_applications_ps.FieldPhoto:
		return m.Photo()
	case exam_applications_ps.FieldApplicationStatus:
		return m.ApplicationStatus()
	case exam_applications_ps.FieldApplnSubmittedDate:
		return m.ApplnSubmittedDate()
	case exam_applications_ps.FieldVARemarks:
		return m.VARemarks()
	case exam_applications_ps.FieldVAUserName:
		return m.VAUserName()
	case exam_applications_ps.FieldVADate:
		return m.VADate()
	case exam_applications_ps.FieldCARemarks:
		return m.CARemarks()
	case exam_applications_ps.FieldCAUserName:
		return m.CAUserName()
	case exam_applications_ps.FieldCADate:
		return m.CADate()
	case exam_applications_ps.FieldApplicationWdlDate:
		return m.ApplicationWdlDate()
	case exam_applications_ps.FieldNARemarks:
		return m.NARemarks()
	case exam_applications_ps.FieldNAUserName:
		return m.NAUserName()
	case exam_applications_ps.FieldNADate:
		return m.NADate()
	case exam_applications_ps.FieldAppliactionRemarks:
		return m.AppliactionRemarks()
	case exam_applications_ps.FieldCadrePreferences:
		return m.CadrePreferences()
	case exam_applications_ps.FieldDivisionPreferences:
		return m.DivisionPreferences()
	case exam_applications_ps.FieldCirclePreferences:
		return m.CirclePreferences()
	case exam_applications_ps.FieldUpdatedAt:
		return m.UpdatedAt()
	case exam_applications_ps.FieldUpdatedBy:
		return m.UpdatedBy()
	case exam_applications_ps.FieldRoleUserCode:
		return m.RoleUserCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExamApplicationsPSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exam_applications_ps.FieldApplicationNumber:
		return m.OldApplicationNumber(ctx)
	case exam_applications_ps.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case exam_applications_ps.FieldEmployeeName:
		return m.OldEmployeeName(ctx)
	case exam_applications_ps.FieldDOB:
		return m.OldDOB(ctx)
	case exam_applications_ps.FieldGender:
		return m.OldGender(ctx)
	case exam_applications_ps.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case exam_applications_ps.FieldEmailID:
		return m.OldEmailID(ctx)
	case exam_applications_ps.FieldEmployeeCategory:
		return m.OldEmployeeCategory(ctx)
	case exam_applications_ps.FieldCadre:
		return m.OldCadre(ctx)
	case exam_applications_ps.FieldEmployeePost:
		return m.OldEmployeePost(ctx)
	case exam_applications_ps.FieldFacilityID:
		return m.OldFacilityID(ctx)
	case exam_applications_ps.FieldDCCS:
		return m.OldDCCS(ctx)
	case exam_applications_ps.FieldDCInPresentCadre:
		return m.OldDCInPresentCadre(ctx)
	case exam_applications_ps.FieldDeputationOfficeId:
		return m.OldDeputationOfficeId(ctx)
	case exam_applications_ps.FieldDisabilityType:
		return m.OldDisabilityType(ctx)
	case exam_applications_ps.FieldDisabilityPercentage:
		return m.OldDisabilityPercentage(ctx)
	case exam_applications_ps.FieldEducation:
		return m.OldEducation(ctx)
	case exam_applications_ps.FieldExamNameCode:
		return m.OldExamNameCode(ctx)
	case exam_applications_ps.FieldExamYear:
		return m.OldExamYear(ctx)
	case exam_applications_ps.FieldExamName:
		return m.OldExamName(ctx)
	case exam_applications_ps.FieldCentrePreference:
		return m.OldCentrePreference(ctx)
	case exam_applications_ps.FieldSignature:
		return m.OldSignature(ctx)
	case exam_applications_ps.FieldPhoto:
		return m.OldPhoto(ctx)
	case exam_applications_ps.FieldApplicationStatus:
		return m.OldApplicationStatus(ctx)
	case exam_applications_ps.FieldApplnSubmittedDate:
		return m.OldApplnSubmittedDate(ctx)
	case exam_applications_ps.FieldVARemarks:
		return m.OldVARemarks(ctx)
	case exam_applications_ps.FieldVAUserName:
		return m.OldVAUserName(ctx)
	case exam_applications_ps.FieldVADate:
		return m.OldVADate(ctx)
	case exam_applications_ps.FieldCARemarks:
		return m.OldCARemarks(ctx)
	case exam_applications_ps.FieldCAUserName:
		return m.OldCAUserName(ctx)
	case exam_applications_ps.FieldCADate:
		return m.OldCADate(ctx)
	case exam_applications_ps.FieldApplicationWdlDate:
		return m.OldApplicationWdlDate(ctx)
	case exam_applications_ps.FieldNARemarks:
		return m.OldNARemarks(ctx)
	case exam_applications_ps.FieldNAUserName:
		return m.OldNAUserName(ctx)
	case exam_applications_ps.FieldNADate:
		return m.OldNADate(ctx)
	case exam_applications_ps.FieldAppliactionRemarks:
		return m.OldAppliactionRemarks(ctx)
	case exam_applications_ps.FieldCadrePreferences:
		return m.OldCadrePreferences(ctx)
	case exam_applications_ps.FieldDivisionPreferences:
		return m.OldDivisionPreferences(ctx)
	case exam_applications_ps.FieldCirclePreferences:
		return m.OldCirclePreferences(ctx)
	case exam_applications_ps.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case exam_applications_ps.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case exam_applications_ps.FieldRoleUserCode:
		return m.OldRoleUserCode(ctx)
	}
	return nil, fmt.Errorf("unknown Exam_Applications_PS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamApplicationsPSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exam_applications_ps.FieldApplicationNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationNumber(v)
		return nil
	case exam_applications_ps.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case exam_applications_ps.FieldEmployeeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeName(v)
		return nil
	case exam_applications_ps.FieldDOB:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOB(v)
		return nil
	case exam_applications_ps.FieldGender:
		v, ok := value.(exam_applications_ps.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case exam_applications_ps.FieldMobileNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case exam_applications_ps.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case exam_applications_ps.FieldEmployeeCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCategory(v)
		return nil
	case exam_applications_ps.FieldCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadre(v)
		return nil
	case exam_applications_ps.FieldEmployeePost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeePost(v)
		return nil
	case exam_applications_ps.FieldFacilityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityID(v)
		return nil
	case exam_applications_ps.FieldDCCS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCCS(v)
		return nil
	case exam_applications_ps.FieldDCInPresentCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCInPresentCadre(v)
		return nil
	case exam_applications_ps.FieldDeputationOfficeId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeputationOfficeId(v)
		return nil
	case exam_applications_ps.FieldDisabilityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityType(v)
		return nil
	case exam_applications_ps.FieldDisabilityPercentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityPercentage(v)
		return nil
	case exam_applications_ps.FieldEducation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducation(v)
		return nil
	case exam_applications_ps.FieldExamNameCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamNameCode(v)
		return nil
	case exam_applications_ps.FieldExamYear:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamYear(v)
		return nil
	case exam_applications_ps.FieldExamName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamName(v)
		return nil
	case exam_applications_ps.FieldCentrePreference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCentrePreference(v)
		return nil
	case exam_applications_ps.FieldSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case exam_applications_ps.FieldPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoto(v)
		return nil
	case exam_applications_ps.FieldApplicationStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationStatus(v)
		return nil
	case exam_applications_ps.FieldApplnSubmittedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplnSubmittedDate(v)
		return nil
	case exam_applications_ps.FieldVARemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVARemarks(v)
		return nil
	case exam_applications_ps.FieldVAUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVAUserName(v)
		return nil
	case exam_applications_ps.FieldVADate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVADate(v)
		return nil
	case exam_applications_ps.FieldCARemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCARemarks(v)
		return nil
	case exam_applications_ps.FieldCAUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCAUserName(v)
		return nil
	case exam_applications_ps.FieldCADate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCADate(v)
		return nil
	case exam_applications_ps.FieldApplicationWdlDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationWdlDate(v)
		return nil
	case exam_applications_ps.FieldNARemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNARemarks(v)
		return nil
	case exam_applications_ps.FieldNAUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNAUserName(v)
		return nil
	case exam_applications_ps.FieldNADate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNADate(v)
		return nil
	case exam_applications_ps.FieldAppliactionRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliactionRemarks(v)
		return nil
	case exam_applications_ps.FieldCadrePreferences:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadrePreferences(v)
		return nil
	case exam_applications_ps.FieldDivisionPreferences:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionPreferences(v)
		return nil
	case exam_applications_ps.FieldCirclePreferences:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCirclePreferences(v)
		return nil
	case exam_applications_ps.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case exam_applications_ps.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case exam_applications_ps.FieldRoleUserCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleUserCode(v)
		return nil
	}
	return fmt.Errorf("unknown Exam_Applications_PS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExamApplicationsPSMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeeID != nil {
		fields = append(fields, exam_applications_ps.FieldEmployeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExamApplicationsPSMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exam_applications_ps.FieldEmployeeID:
		return m.AddedEmployeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamApplicationsPSMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exam_applications_ps.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown Exam_Applications_PS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExamApplicationsPSMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exam_applications_ps.FieldApplicationNumber) {
		fields = append(fields, exam_applications_ps.FieldApplicationNumber)
	}
	if m.FieldCleared(exam_applications_ps.FieldEmployeeID) {
		fields = append(fields, exam_applications_ps.FieldEmployeeID)
	}
	if m.FieldCleared(exam_applications_ps.FieldEmployeeName) {
		fields = append(fields, exam_applications_ps.FieldEmployeeName)
	}
	if m.FieldCleared(exam_applications_ps.FieldDOB) {
		fields = append(fields, exam_applications_ps.FieldDOB)
	}
	if m.FieldCleared(exam_applications_ps.FieldMobileNumber) {
		fields = append(fields, exam_applications_ps.FieldMobileNumber)
	}
	if m.FieldCleared(exam_applications_ps.FieldEmailID) {
		fields = append(fields, exam_applications_ps.FieldEmailID)
	}
	if m.FieldCleared(exam_applications_ps.FieldEmployeeCategory) {
		fields = append(fields, exam_applications_ps.FieldEmployeeCategory)
	}
	if m.FieldCleared(exam_applications_ps.FieldCadre) {
		fields = append(fields, exam_applications_ps.FieldCadre)
	}
	if m.FieldCleared(exam_applications_ps.FieldEmployeePost) {
		fields = append(fields, exam_applications_ps.FieldEmployeePost)
	}
	if m.FieldCleared(exam_applications_ps.FieldFacilityID) {
		fields = append(fields, exam_applications_ps.FieldFacilityID)
	}
	if m.FieldCleared(exam_applications_ps.FieldDCCS) {
		fields = append(fields, exam_applications_ps.FieldDCCS)
	}
	if m.FieldCleared(exam_applications_ps.FieldDCInPresentCadre) {
		fields = append(fields, exam_applications_ps.FieldDCInPresentCadre)
	}
	if m.FieldCleared(exam_applications_ps.FieldDeputationOfficeId) {
		fields = append(fields, exam_applications_ps.FieldDeputationOfficeId)
	}
	if m.FieldCleared(exam_applications_ps.FieldDisabilityType) {
		fields = append(fields, exam_applications_ps.FieldDisabilityType)
	}
	if m.FieldCleared(exam_applications_ps.FieldDisabilityPercentage) {
		fields = append(fields, exam_applications_ps.FieldDisabilityPercentage)
	}
	if m.FieldCleared(exam_applications_ps.FieldEducation) {
		fields = append(fields, exam_applications_ps.FieldEducation)
	}
	if m.FieldCleared(exam_applications_ps.FieldExamNameCode) {
		fields = append(fields, exam_applications_ps.FieldExamNameCode)
	}
	if m.FieldCleared(exam_applications_ps.FieldExamYear) {
		fields = append(fields, exam_applications_ps.FieldExamYear)
	}
	if m.FieldCleared(exam_applications_ps.FieldExamName) {
		fields = append(fields, exam_applications_ps.FieldExamName)
	}
	if m.FieldCleared(exam_applications_ps.FieldCentrePreference) {
		fields = append(fields, exam_applications_ps.FieldCentrePreference)
	}
	if m.FieldCleared(exam_applications_ps.FieldSignature) {
		fields = append(fields, exam_applications_ps.FieldSignature)
	}
	if m.FieldCleared(exam_applications_ps.FieldPhoto) {
		fields = append(fields, exam_applications_ps.FieldPhoto)
	}
	if m.FieldCleared(exam_applications_ps.FieldApplicationStatus) {
		fields = append(fields, exam_applications_ps.FieldApplicationStatus)
	}
	if m.FieldCleared(exam_applications_ps.FieldApplnSubmittedDate) {
		fields = append(fields, exam_applications_ps.FieldApplnSubmittedDate)
	}
	if m.FieldCleared(exam_applications_ps.FieldVARemarks) {
		fields = append(fields, exam_applications_ps.FieldVARemarks)
	}
	if m.FieldCleared(exam_applications_ps.FieldVAUserName) {
		fields = append(fields, exam_applications_ps.FieldVAUserName)
	}
	if m.FieldCleared(exam_applications_ps.FieldVADate) {
		fields = append(fields, exam_applications_ps.FieldVADate)
	}
	if m.FieldCleared(exam_applications_ps.FieldCARemarks) {
		fields = append(fields, exam_applications_ps.FieldCARemarks)
	}
	if m.FieldCleared(exam_applications_ps.FieldCAUserName) {
		fields = append(fields, exam_applications_ps.FieldCAUserName)
	}
	if m.FieldCleared(exam_applications_ps.FieldCADate) {
		fields = append(fields, exam_applications_ps.FieldCADate)
	}
	if m.FieldCleared(exam_applications_ps.FieldApplicationWdlDate) {
		fields = append(fields, exam_applications_ps.FieldApplicationWdlDate)
	}
	if m.FieldCleared(exam_applications_ps.FieldNARemarks) {
		fields = append(fields, exam_applications_ps.FieldNARemarks)
	}
	if m.FieldCleared(exam_applications_ps.FieldNAUserName) {
		fields = append(fields, exam_applications_ps.FieldNAUserName)
	}
	if m.FieldCleared(exam_applications_ps.FieldNADate) {
		fields = append(fields, exam_applications_ps.FieldNADate)
	}
	if m.FieldCleared(exam_applications_ps.FieldAppliactionRemarks) {
		fields = append(fields, exam_applications_ps.FieldAppliactionRemarks)
	}
	if m.FieldCleared(exam_applications_ps.FieldCadrePreferences) {
		fields = append(fields, exam_applications_ps.FieldCadrePreferences)
	}
	if m.FieldCleared(exam_applications_ps.FieldDivisionPreferences) {
		fields = append(fields, exam_applications_ps.FieldDivisionPreferences)
	}
	if m.FieldCleared(exam_applications_ps.FieldCirclePreferences) {
		fields = append(fields, exam_applications_ps.FieldCirclePreferences)
	}
	if m.FieldCleared(exam_applications_ps.FieldUpdatedAt) {
		fields = append(fields, exam_applications_ps.FieldUpdatedAt)
	}
	if m.FieldCleared(exam_applications_ps.FieldUpdatedBy) {
		fields = append(fields, exam_applications_ps.FieldUpdatedBy)
	}
	if m.FieldCleared(exam_applications_ps.FieldRoleUserCode) {
		fields = append(fields, exam_applications_ps.FieldRoleUserCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExamApplicationsPSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExamApplicationsPSMutation) ClearField(name string) error {
	switch name {
	case exam_applications_ps.FieldApplicationNumber:
		m.ClearApplicationNumber()
		return nil
	case exam_applications_ps.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case exam_applications_ps.FieldEmployeeName:
		m.ClearEmployeeName()
		return nil
	case exam_applications_ps.FieldDOB:
		m.ClearDOB()
		return nil
	case exam_applications_ps.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	case exam_applications_ps.FieldEmailID:
		m.ClearEmailID()
		return nil
	case exam_applications_ps.FieldEmployeeCategory:
		m.ClearEmployeeCategory()
		return nil
	case exam_applications_ps.FieldCadre:
		m.ClearCadre()
		return nil
	case exam_applications_ps.FieldEmployeePost:
		m.ClearEmployeePost()
		return nil
	case exam_applications_ps.FieldFacilityID:
		m.ClearFacilityID()
		return nil
	case exam_applications_ps.FieldDCCS:
		m.ClearDCCS()
		return nil
	case exam_applications_ps.FieldDCInPresentCadre:
		m.ClearDCInPresentCadre()
		return nil
	case exam_applications_ps.FieldDeputationOfficeId:
		m.ClearDeputationOfficeId()
		return nil
	case exam_applications_ps.FieldDisabilityType:
		m.ClearDisabilityType()
		return nil
	case exam_applications_ps.FieldDisabilityPercentage:
		m.ClearDisabilityPercentage()
		return nil
	case exam_applications_ps.FieldEducation:
		m.ClearEducation()
		return nil
	case exam_applications_ps.FieldExamNameCode:
		m.ClearExamNameCode()
		return nil
	case exam_applications_ps.FieldExamYear:
		m.ClearExamYear()
		return nil
	case exam_applications_ps.FieldExamName:
		m.ClearExamName()
		return nil
	case exam_applications_ps.FieldCentrePreference:
		m.ClearCentrePreference()
		return nil
	case exam_applications_ps.FieldSignature:
		m.ClearSignature()
		return nil
	case exam_applications_ps.FieldPhoto:
		m.ClearPhoto()
		return nil
	case exam_applications_ps.FieldApplicationStatus:
		m.ClearApplicationStatus()
		return nil
	case exam_applications_ps.FieldApplnSubmittedDate:
		m.ClearApplnSubmittedDate()
		return nil
	case exam_applications_ps.FieldVARemarks:
		m.ClearVARemarks()
		return nil
	case exam_applications_ps.FieldVAUserName:
		m.ClearVAUserName()
		return nil
	case exam_applications_ps.FieldVADate:
		m.ClearVADate()
		return nil
	case exam_applications_ps.FieldCARemarks:
		m.ClearCARemarks()
		return nil
	case exam_applications_ps.FieldCAUserName:
		m.ClearCAUserName()
		return nil
	case exam_applications_ps.FieldCADate:
		m.ClearCADate()
		return nil
	case exam_applications_ps.FieldApplicationWdlDate:
		m.ClearApplicationWdlDate()
		return nil
	case exam_applications_ps.FieldNARemarks:
		m.ClearNARemarks()
		return nil
	case exam_applications_ps.FieldNAUserName:
		m.ClearNAUserName()
		return nil
	case exam_applications_ps.FieldNADate:
		m.ClearNADate()
		return nil
	case exam_applications_ps.FieldAppliactionRemarks:
		m.ClearAppliactionRemarks()
		return nil
	case exam_applications_ps.FieldCadrePreferences:
		m.ClearCadrePreferences()
		return nil
	case exam_applications_ps.FieldDivisionPreferences:
		m.ClearDivisionPreferences()
		return nil
	case exam_applications_ps.FieldCirclePreferences:
		m.ClearCirclePreferences()
		return nil
	case exam_applications_ps.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case exam_applications_ps.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case exam_applications_ps.FieldRoleUserCode:
		m.ClearRoleUserCode()
		return nil
	}
	return fmt.Errorf("unknown Exam_Applications_PS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExamApplicationsPSMutation) ResetField(name string) error {
	switch name {
	case exam_applications_ps.FieldApplicationNumber:
		m.ResetApplicationNumber()
		return nil
	case exam_applications_ps.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case exam_applications_ps.FieldEmployeeName:
		m.ResetEmployeeName()
		return nil
	case exam_applications_ps.FieldDOB:
		m.ResetDOB()
		return nil
	case exam_applications_ps.FieldGender:
		m.ResetGender()
		return nil
	case exam_applications_ps.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case exam_applications_ps.FieldEmailID:
		m.ResetEmailID()
		return nil
	case exam_applications_ps.FieldEmployeeCategory:
		m.ResetEmployeeCategory()
		return nil
	case exam_applications_ps.FieldCadre:
		m.ResetCadre()
		return nil
	case exam_applications_ps.FieldEmployeePost:
		m.ResetEmployeePost()
		return nil
	case exam_applications_ps.FieldFacilityID:
		m.ResetFacilityID()
		return nil
	case exam_applications_ps.FieldDCCS:
		m.ResetDCCS()
		return nil
	case exam_applications_ps.FieldDCInPresentCadre:
		m.ResetDCInPresentCadre()
		return nil
	case exam_applications_ps.FieldDeputationOfficeId:
		m.ResetDeputationOfficeId()
		return nil
	case exam_applications_ps.FieldDisabilityType:
		m.ResetDisabilityType()
		return nil
	case exam_applications_ps.FieldDisabilityPercentage:
		m.ResetDisabilityPercentage()
		return nil
	case exam_applications_ps.FieldEducation:
		m.ResetEducation()
		return nil
	case exam_applications_ps.FieldExamNameCode:
		m.ResetExamNameCode()
		return nil
	case exam_applications_ps.FieldExamYear:
		m.ResetExamYear()
		return nil
	case exam_applications_ps.FieldExamName:
		m.ResetExamName()
		return nil
	case exam_applications_ps.FieldCentrePreference:
		m.ResetCentrePreference()
		return nil
	case exam_applications_ps.FieldSignature:
		m.ResetSignature()
		return nil
	case exam_applications_ps.FieldPhoto:
		m.ResetPhoto()
		return nil
	case exam_applications_ps.FieldApplicationStatus:
		m.ResetApplicationStatus()
		return nil
	case exam_applications_ps.FieldApplnSubmittedDate:
		m.ResetApplnSubmittedDate()
		return nil
	case exam_applications_ps.FieldVARemarks:
		m.ResetVARemarks()
		return nil
	case exam_applications_ps.FieldVAUserName:
		m.ResetVAUserName()
		return nil
	case exam_applications_ps.FieldVADate:
		m.ResetVADate()
		return nil
	case exam_applications_ps.FieldCARemarks:
		m.ResetCARemarks()
		return nil
	case exam_applications_ps.FieldCAUserName:
		m.ResetCAUserName()
		return nil
	case exam_applications_ps.FieldCADate:
		m.ResetCADate()
		return nil
	case exam_applications_ps.FieldApplicationWdlDate:
		m.ResetApplicationWdlDate()
		return nil
	case exam_applications_ps.FieldNARemarks:
		m.ResetNARemarks()
		return nil
	case exam_applications_ps.FieldNAUserName:
		m.ResetNAUserName()
		return nil
	case exam_applications_ps.FieldNADate:
		m.ResetNADate()
		return nil
	case exam_applications_ps.FieldAppliactionRemarks:
		m.ResetAppliactionRemarks()
		return nil
	case exam_applications_ps.FieldCadrePreferences:
		m.ResetCadrePreferences()
		return nil
	case exam_applications_ps.FieldDivisionPreferences:
		m.ResetDivisionPreferences()
		return nil
	case exam_applications_ps.FieldCirclePreferences:
		m.ResetCirclePreferences()
		return nil
	case exam_applications_ps.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case exam_applications_ps.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case exam_applications_ps.FieldRoleUserCode:
		m.ResetRoleUserCode()
		return nil
	}
	return fmt.Errorf("unknown Exam_Applications_PS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExamApplicationsPSMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._UsersPSRef != nil {
		edges = append(edges, exam_applications_ps.EdgeUsersPSRef)
	}
	if m._ExamAppln_PS_Ref != nil {
		edges = append(edges, exam_applications_ps.EdgeExamApplnPSRef)
	}
	if m._Office_PS_Ref != nil {
		edges = append(edges, exam_applications_ps.EdgeOfficePSRef)
	}
	if m.roleusers != nil {
		edges = append(edges, exam_applications_ps.EdgeRoleusers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExamApplicationsPSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exam_applications_ps.EdgeUsersPSRef:
		ids := make([]ent.Value, 0, len(m._UsersPSRef))
		for id := range m._UsersPSRef {
			ids = append(ids, id)
		}
		return ids
	case exam_applications_ps.EdgeExamApplnPSRef:
		ids := make([]ent.Value, 0, len(m._ExamAppln_PS_Ref))
		for id := range m._ExamAppln_PS_Ref {
			ids = append(ids, id)
		}
		return ids
	case exam_applications_ps.EdgeOfficePSRef:
		ids := make([]ent.Value, 0, len(m._Office_PS_Ref))
		for id := range m._Office_PS_Ref {
			ids = append(ids, id)
		}
		return ids
	case exam_applications_ps.EdgeRoleusers:
		if id := m.roleusers; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExamApplicationsPSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_UsersPSRef != nil {
		edges = append(edges, exam_applications_ps.EdgeUsersPSRef)
	}
	if m.removed_ExamAppln_PS_Ref != nil {
		edges = append(edges, exam_applications_ps.EdgeExamApplnPSRef)
	}
	if m.removed_Office_PS_Ref != nil {
		edges = append(edges, exam_applications_ps.EdgeOfficePSRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExamApplicationsPSMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exam_applications_ps.EdgeUsersPSRef:
		ids := make([]ent.Value, 0, len(m.removed_UsersPSRef))
		for id := range m.removed_UsersPSRef {
			ids = append(ids, id)
		}
		return ids
	case exam_applications_ps.EdgeExamApplnPSRef:
		ids := make([]ent.Value, 0, len(m.removed_ExamAppln_PS_Ref))
		for id := range m.removed_ExamAppln_PS_Ref {
			ids = append(ids, id)
		}
		return ids
	case exam_applications_ps.EdgeOfficePSRef:
		ids := make([]ent.Value, 0, len(m.removed_Office_PS_Ref))
		for id := range m.removed_Office_PS_Ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExamApplicationsPSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_UsersPSRef {
		edges = append(edges, exam_applications_ps.EdgeUsersPSRef)
	}
	if m.cleared_ExamAppln_PS_Ref {
		edges = append(edges, exam_applications_ps.EdgeExamApplnPSRef)
	}
	if m.cleared_Office_PS_Ref {
		edges = append(edges, exam_applications_ps.EdgeOfficePSRef)
	}
	if m.clearedroleusers {
		edges = append(edges, exam_applications_ps.EdgeRoleusers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExamApplicationsPSMutation) EdgeCleared(name string) bool {
	switch name {
	case exam_applications_ps.EdgeUsersPSRef:
		return m.cleared_UsersPSRef
	case exam_applications_ps.EdgeExamApplnPSRef:
		return m.cleared_ExamAppln_PS_Ref
	case exam_applications_ps.EdgeOfficePSRef:
		return m.cleared_Office_PS_Ref
	case exam_applications_ps.EdgeRoleusers:
		return m.clearedroleusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExamApplicationsPSMutation) ClearEdge(name string) error {
	switch name {
	case exam_applications_ps.EdgeRoleusers:
		m.ClearRoleusers()
		return nil
	}
	return fmt.Errorf("unknown Exam_Applications_PS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExamApplicationsPSMutation) ResetEdge(name string) error {
	switch name {
	case exam_applications_ps.EdgeUsersPSRef:
		m.ResetUsersPSRef()
		return nil
	case exam_applications_ps.EdgeExamApplnPSRef:
		m.ResetExamApplnPSRef()
		return nil
	case exam_applications_ps.EdgeOfficePSRef:
		m.ResetOfficePSRef()
		return nil
	case exam_applications_ps.EdgeRoleusers:
		m.ResetRoleusers()
		return nil
	}
	return fmt.Errorf("unknown Exam_Applications_PS edge %s", name)
}

// ExamIPMutation represents an operation that mutates the Exam_IP nodes in the graph.
type ExamIPMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int32
	_ExamNameCode            *string
	_ExamName                *string
	_ExamType                *string
	_NotificationCode        *int32
	add_NotificationCode     *int32
	_ConductedBy             *string
	_NodalOffice             *string
	_CalendarCode            *int32
	add_CalendarCode         *int32
	_PaperCode               *int32
	add_PaperCode            *int32
	_EligibleCadre           *string
	_EligiblePost1           *string
	_EligiblePost2           *string
	_EligiblePost3           *string
	_EligiblePost4           *string
	_EligiblePost5           *string
	_ExamPost1               *string
	_ExamPost2               *string
	_ExamPost3               *string
	_ExamPost4               *string
	_ExamPost5               *string
	_EducationCriteria       *string
	_CategoryAgeLimitGEN     *string
	_CategoryAgeLimitSC      *string
	_CategoryAgeLimitST      *string
	_ServiceYears            *string
	_DrivingLicenseRequired  *string
	_ExamPaperCode           *string
	_ExamPaper1              *string
	_ExamPaper2              *string
	_ExamPaper3              *string
	_ExamPaper4              *string
	_ExamPaper5              *string
	_ExamPaper6              *string
	_PayLevelEligibilty      *bool
	_CategoryMinMarksSCSTPH  *string
	_CategoryMinMarksGENOBC  *string
	_LocalLanguageAllowed    *bool
	_UpdatedAt               *time.Time
	_UpdatedBy               *string
	clearedFields            map[string]struct{}
	examcal_ip_ref           map[int32]struct{}
	removedexamcal_ip_ref    map[int32]struct{}
	clearedexamcal_ip_ref    bool
	papers_ip_ref            map[int32]struct{}
	removedpapers_ip_ref     map[int32]struct{}
	clearedpapers_ip_ref     bool
	users_ip_type            map[int64]struct{}
	removedusers_ip_type     map[int64]struct{}
	clearedusers_ip_type     bool
	_ExamAppln_IP_Ref        map[int64]struct{}
	removed_ExamAppln_IP_Ref map[int64]struct{}
	cleared_ExamAppln_IP_Ref bool
	notifications_ip         map[int32]struct{}
	removednotifications_ip  map[int32]struct{}
	clearednotifications_ip  bool
	done                     bool
	oldValue                 func(context.Context) (*Exam_IP, error)
	predicates               []predicate.Exam_IP
}

var _ ent.Mutation = (*ExamIPMutation)(nil)

// examIPOption allows management of the mutation configuration using functional options.
type examIPOption func(*ExamIPMutation)

// newExamIPMutation creates new mutation for the Exam_IP entity.
func newExamIPMutation(c config, op Op, opts ...examIPOption) *ExamIPMutation {
	m := &ExamIPMutation{
		config:        c,
		op:            op,
		typ:           TypeExamIP,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExam_IPID sets the ID field of the mutation.
func withExam_IPID(id int32) examIPOption {
	return func(m *ExamIPMutation) {
		var (
			err   error
			once  sync.Once
			value *Exam_IP
		)
		m.oldValue = func(ctx context.Context) (*Exam_IP, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exam_IP.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExam_IP sets the old Exam_IP of the mutation.
func withExam_IP(node *Exam_IP) examIPOption {
	return func(m *ExamIPMutation) {
		m.oldValue = func(context.Context) (*Exam_IP, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExamIPMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExamIPMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exam_IP entities.
func (m *ExamIPMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExamIPMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExamIPMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exam_IP.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExamNameCode sets the "ExamNameCode" field.
func (m *ExamIPMutation) SetExamNameCode(s string) {
	m._ExamNameCode = &s
}

// ExamNameCode returns the value of the "ExamNameCode" field in the mutation.
func (m *ExamIPMutation) ExamNameCode() (r string, exists bool) {
	v := m._ExamNameCode
	if v == nil {
		return
	}
	return *v, true
}

// OldExamNameCode returns the old "ExamNameCode" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldExamNameCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamNameCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamNameCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamNameCode: %w", err)
	}
	return oldValue.ExamNameCode, nil
}

// ClearExamNameCode clears the value of the "ExamNameCode" field.
func (m *ExamIPMutation) ClearExamNameCode() {
	m._ExamNameCode = nil
	m.clearedFields[exam_ip.FieldExamNameCode] = struct{}{}
}

// ExamNameCodeCleared returns if the "ExamNameCode" field was cleared in this mutation.
func (m *ExamIPMutation) ExamNameCodeCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldExamNameCode]
	return ok
}

// ResetExamNameCode resets all changes to the "ExamNameCode" field.
func (m *ExamIPMutation) ResetExamNameCode() {
	m._ExamNameCode = nil
	delete(m.clearedFields, exam_ip.FieldExamNameCode)
}

// SetExamName sets the "ExamName" field.
func (m *ExamIPMutation) SetExamName(s string) {
	m._ExamName = &s
}

// ExamName returns the value of the "ExamName" field in the mutation.
func (m *ExamIPMutation) ExamName() (r string, exists bool) {
	v := m._ExamName
	if v == nil {
		return
	}
	return *v, true
}

// OldExamName returns the old "ExamName" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldExamName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamName: %w", err)
	}
	return oldValue.ExamName, nil
}

// ResetExamName resets all changes to the "ExamName" field.
func (m *ExamIPMutation) ResetExamName() {
	m._ExamName = nil
}

// SetExamType sets the "ExamType" field.
func (m *ExamIPMutation) SetExamType(s string) {
	m._ExamType = &s
}

// ExamType returns the value of the "ExamType" field in the mutation.
func (m *ExamIPMutation) ExamType() (r string, exists bool) {
	v := m._ExamType
	if v == nil {
		return
	}
	return *v, true
}

// OldExamType returns the old "ExamType" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldExamType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamType: %w", err)
	}
	return oldValue.ExamType, nil
}

// ResetExamType resets all changes to the "ExamType" field.
func (m *ExamIPMutation) ResetExamType() {
	m._ExamType = nil
}

// SetNotificationCode sets the "NotificationCode" field.
func (m *ExamIPMutation) SetNotificationCode(i int32) {
	m._NotificationCode = &i
	m.add_NotificationCode = nil
}

// NotificationCode returns the value of the "NotificationCode" field in the mutation.
func (m *ExamIPMutation) NotificationCode() (r int32, exists bool) {
	v := m._NotificationCode
	if v == nil {
		return
	}
	return *v, true
}

// OldNotificationCode returns the old "NotificationCode" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldNotificationCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotificationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotificationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotificationCode: %w", err)
	}
	return oldValue.NotificationCode, nil
}

// AddNotificationCode adds i to the "NotificationCode" field.
func (m *ExamIPMutation) AddNotificationCode(i int32) {
	if m.add_NotificationCode != nil {
		*m.add_NotificationCode += i
	} else {
		m.add_NotificationCode = &i
	}
}

// AddedNotificationCode returns the value that was added to the "NotificationCode" field in this mutation.
func (m *ExamIPMutation) AddedNotificationCode() (r int32, exists bool) {
	v := m.add_NotificationCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearNotificationCode clears the value of the "NotificationCode" field.
func (m *ExamIPMutation) ClearNotificationCode() {
	m._NotificationCode = nil
	m.add_NotificationCode = nil
	m.clearedFields[exam_ip.FieldNotificationCode] = struct{}{}
}

// NotificationCodeCleared returns if the "NotificationCode" field was cleared in this mutation.
func (m *ExamIPMutation) NotificationCodeCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldNotificationCode]
	return ok
}

// ResetNotificationCode resets all changes to the "NotificationCode" field.
func (m *ExamIPMutation) ResetNotificationCode() {
	m._NotificationCode = nil
	m.add_NotificationCode = nil
	delete(m.clearedFields, exam_ip.FieldNotificationCode)
}

// SetConductedBy sets the "ConductedBy" field.
func (m *ExamIPMutation) SetConductedBy(s string) {
	m._ConductedBy = &s
}

// ConductedBy returns the value of the "ConductedBy" field in the mutation.
func (m *ExamIPMutation) ConductedBy() (r string, exists bool) {
	v := m._ConductedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldConductedBy returns the old "ConductedBy" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldConductedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConductedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConductedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConductedBy: %w", err)
	}
	return oldValue.ConductedBy, nil
}

// ResetConductedBy resets all changes to the "ConductedBy" field.
func (m *ExamIPMutation) ResetConductedBy() {
	m._ConductedBy = nil
}

// SetNodalOffice sets the "NodalOffice" field.
func (m *ExamIPMutation) SetNodalOffice(s string) {
	m._NodalOffice = &s
}

// NodalOffice returns the value of the "NodalOffice" field in the mutation.
func (m *ExamIPMutation) NodalOffice() (r string, exists bool) {
	v := m._NodalOffice
	if v == nil {
		return
	}
	return *v, true
}

// OldNodalOffice returns the old "NodalOffice" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldNodalOffice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodalOffice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodalOffice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodalOffice: %w", err)
	}
	return oldValue.NodalOffice, nil
}

// ClearNodalOffice clears the value of the "NodalOffice" field.
func (m *ExamIPMutation) ClearNodalOffice() {
	m._NodalOffice = nil
	m.clearedFields[exam_ip.FieldNodalOffice] = struct{}{}
}

// NodalOfficeCleared returns if the "NodalOffice" field was cleared in this mutation.
func (m *ExamIPMutation) NodalOfficeCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldNodalOffice]
	return ok
}

// ResetNodalOffice resets all changes to the "NodalOffice" field.
func (m *ExamIPMutation) ResetNodalOffice() {
	m._NodalOffice = nil
	delete(m.clearedFields, exam_ip.FieldNodalOffice)
}

// SetCalendarCode sets the "CalendarCode" field.
func (m *ExamIPMutation) SetCalendarCode(i int32) {
	m._CalendarCode = &i
	m.add_CalendarCode = nil
}

// CalendarCode returns the value of the "CalendarCode" field in the mutation.
func (m *ExamIPMutation) CalendarCode() (r int32, exists bool) {
	v := m._CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCalendarCode returns the old "CalendarCode" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldCalendarCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalendarCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalendarCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalendarCode: %w", err)
	}
	return oldValue.CalendarCode, nil
}

// AddCalendarCode adds i to the "CalendarCode" field.
func (m *ExamIPMutation) AddCalendarCode(i int32) {
	if m.add_CalendarCode != nil {
		*m.add_CalendarCode += i
	} else {
		m.add_CalendarCode = &i
	}
}

// AddedCalendarCode returns the value that was added to the "CalendarCode" field in this mutation.
func (m *ExamIPMutation) AddedCalendarCode() (r int32, exists bool) {
	v := m.add_CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalendarCode clears the value of the "CalendarCode" field.
func (m *ExamIPMutation) ClearCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	m.clearedFields[exam_ip.FieldCalendarCode] = struct{}{}
}

// CalendarCodeCleared returns if the "CalendarCode" field was cleared in this mutation.
func (m *ExamIPMutation) CalendarCodeCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldCalendarCode]
	return ok
}

// ResetCalendarCode resets all changes to the "CalendarCode" field.
func (m *ExamIPMutation) ResetCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	delete(m.clearedFields, exam_ip.FieldCalendarCode)
}

// SetPaperCode sets the "PaperCode" field.
func (m *ExamIPMutation) SetPaperCode(i int32) {
	m._PaperCode = &i
	m.add_PaperCode = nil
}

// PaperCode returns the value of the "PaperCode" field in the mutation.
func (m *ExamIPMutation) PaperCode() (r int32, exists bool) {
	v := m._PaperCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperCode returns the old "PaperCode" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldPaperCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperCode: %w", err)
	}
	return oldValue.PaperCode, nil
}

// AddPaperCode adds i to the "PaperCode" field.
func (m *ExamIPMutation) AddPaperCode(i int32) {
	if m.add_PaperCode != nil {
		*m.add_PaperCode += i
	} else {
		m.add_PaperCode = &i
	}
}

// AddedPaperCode returns the value that was added to the "PaperCode" field in this mutation.
func (m *ExamIPMutation) AddedPaperCode() (r int32, exists bool) {
	v := m.add_PaperCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaperCode clears the value of the "PaperCode" field.
func (m *ExamIPMutation) ClearPaperCode() {
	m._PaperCode = nil
	m.add_PaperCode = nil
	m.clearedFields[exam_ip.FieldPaperCode] = struct{}{}
}

// PaperCodeCleared returns if the "PaperCode" field was cleared in this mutation.
func (m *ExamIPMutation) PaperCodeCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldPaperCode]
	return ok
}

// ResetPaperCode resets all changes to the "PaperCode" field.
func (m *ExamIPMutation) ResetPaperCode() {
	m._PaperCode = nil
	m.add_PaperCode = nil
	delete(m.clearedFields, exam_ip.FieldPaperCode)
}

// SetEligibleCadre sets the "EligibleCadre" field.
func (m *ExamIPMutation) SetEligibleCadre(s string) {
	m._EligibleCadre = &s
}

// EligibleCadre returns the value of the "EligibleCadre" field in the mutation.
func (m *ExamIPMutation) EligibleCadre() (r string, exists bool) {
	v := m._EligibleCadre
	if v == nil {
		return
	}
	return *v, true
}

// OldEligibleCadre returns the old "EligibleCadre" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldEligibleCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligibleCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligibleCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligibleCadre: %w", err)
	}
	return oldValue.EligibleCadre, nil
}

// ClearEligibleCadre clears the value of the "EligibleCadre" field.
func (m *ExamIPMutation) ClearEligibleCadre() {
	m._EligibleCadre = nil
	m.clearedFields[exam_ip.FieldEligibleCadre] = struct{}{}
}

// EligibleCadreCleared returns if the "EligibleCadre" field was cleared in this mutation.
func (m *ExamIPMutation) EligibleCadreCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldEligibleCadre]
	return ok
}

// ResetEligibleCadre resets all changes to the "EligibleCadre" field.
func (m *ExamIPMutation) ResetEligibleCadre() {
	m._EligibleCadre = nil
	delete(m.clearedFields, exam_ip.FieldEligibleCadre)
}

// SetEligiblePost1 sets the "EligiblePost1" field.
func (m *ExamIPMutation) SetEligiblePost1(s string) {
	m._EligiblePost1 = &s
}

// EligiblePost1 returns the value of the "EligiblePost1" field in the mutation.
func (m *ExamIPMutation) EligiblePost1() (r string, exists bool) {
	v := m._EligiblePost1
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost1 returns the old "EligiblePost1" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldEligiblePost1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost1: %w", err)
	}
	return oldValue.EligiblePost1, nil
}

// ClearEligiblePost1 clears the value of the "EligiblePost1" field.
func (m *ExamIPMutation) ClearEligiblePost1() {
	m._EligiblePost1 = nil
	m.clearedFields[exam_ip.FieldEligiblePost1] = struct{}{}
}

// EligiblePost1Cleared returns if the "EligiblePost1" field was cleared in this mutation.
func (m *ExamIPMutation) EligiblePost1Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldEligiblePost1]
	return ok
}

// ResetEligiblePost1 resets all changes to the "EligiblePost1" field.
func (m *ExamIPMutation) ResetEligiblePost1() {
	m._EligiblePost1 = nil
	delete(m.clearedFields, exam_ip.FieldEligiblePost1)
}

// SetEligiblePost2 sets the "EligiblePost2" field.
func (m *ExamIPMutation) SetEligiblePost2(s string) {
	m._EligiblePost2 = &s
}

// EligiblePost2 returns the value of the "EligiblePost2" field in the mutation.
func (m *ExamIPMutation) EligiblePost2() (r string, exists bool) {
	v := m._EligiblePost2
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost2 returns the old "EligiblePost2" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldEligiblePost2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost2: %w", err)
	}
	return oldValue.EligiblePost2, nil
}

// ClearEligiblePost2 clears the value of the "EligiblePost2" field.
func (m *ExamIPMutation) ClearEligiblePost2() {
	m._EligiblePost2 = nil
	m.clearedFields[exam_ip.FieldEligiblePost2] = struct{}{}
}

// EligiblePost2Cleared returns if the "EligiblePost2" field was cleared in this mutation.
func (m *ExamIPMutation) EligiblePost2Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldEligiblePost2]
	return ok
}

// ResetEligiblePost2 resets all changes to the "EligiblePost2" field.
func (m *ExamIPMutation) ResetEligiblePost2() {
	m._EligiblePost2 = nil
	delete(m.clearedFields, exam_ip.FieldEligiblePost2)
}

// SetEligiblePost3 sets the "EligiblePost3" field.
func (m *ExamIPMutation) SetEligiblePost3(s string) {
	m._EligiblePost3 = &s
}

// EligiblePost3 returns the value of the "EligiblePost3" field in the mutation.
func (m *ExamIPMutation) EligiblePost3() (r string, exists bool) {
	v := m._EligiblePost3
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost3 returns the old "EligiblePost3" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldEligiblePost3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost3: %w", err)
	}
	return oldValue.EligiblePost3, nil
}

// ClearEligiblePost3 clears the value of the "EligiblePost3" field.
func (m *ExamIPMutation) ClearEligiblePost3() {
	m._EligiblePost3 = nil
	m.clearedFields[exam_ip.FieldEligiblePost3] = struct{}{}
}

// EligiblePost3Cleared returns if the "EligiblePost3" field was cleared in this mutation.
func (m *ExamIPMutation) EligiblePost3Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldEligiblePost3]
	return ok
}

// ResetEligiblePost3 resets all changes to the "EligiblePost3" field.
func (m *ExamIPMutation) ResetEligiblePost3() {
	m._EligiblePost3 = nil
	delete(m.clearedFields, exam_ip.FieldEligiblePost3)
}

// SetEligiblePost4 sets the "EligiblePost4" field.
func (m *ExamIPMutation) SetEligiblePost4(s string) {
	m._EligiblePost4 = &s
}

// EligiblePost4 returns the value of the "EligiblePost4" field in the mutation.
func (m *ExamIPMutation) EligiblePost4() (r string, exists bool) {
	v := m._EligiblePost4
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost4 returns the old "EligiblePost4" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldEligiblePost4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost4: %w", err)
	}
	return oldValue.EligiblePost4, nil
}

// ClearEligiblePost4 clears the value of the "EligiblePost4" field.
func (m *ExamIPMutation) ClearEligiblePost4() {
	m._EligiblePost4 = nil
	m.clearedFields[exam_ip.FieldEligiblePost4] = struct{}{}
}

// EligiblePost4Cleared returns if the "EligiblePost4" field was cleared in this mutation.
func (m *ExamIPMutation) EligiblePost4Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldEligiblePost4]
	return ok
}

// ResetEligiblePost4 resets all changes to the "EligiblePost4" field.
func (m *ExamIPMutation) ResetEligiblePost4() {
	m._EligiblePost4 = nil
	delete(m.clearedFields, exam_ip.FieldEligiblePost4)
}

// SetEligiblePost5 sets the "EligiblePost5" field.
func (m *ExamIPMutation) SetEligiblePost5(s string) {
	m._EligiblePost5 = &s
}

// EligiblePost5 returns the value of the "EligiblePost5" field in the mutation.
func (m *ExamIPMutation) EligiblePost5() (r string, exists bool) {
	v := m._EligiblePost5
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost5 returns the old "EligiblePost5" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldEligiblePost5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost5: %w", err)
	}
	return oldValue.EligiblePost5, nil
}

// ClearEligiblePost5 clears the value of the "EligiblePost5" field.
func (m *ExamIPMutation) ClearEligiblePost5() {
	m._EligiblePost5 = nil
	m.clearedFields[exam_ip.FieldEligiblePost5] = struct{}{}
}

// EligiblePost5Cleared returns if the "EligiblePost5" field was cleared in this mutation.
func (m *ExamIPMutation) EligiblePost5Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldEligiblePost5]
	return ok
}

// ResetEligiblePost5 resets all changes to the "EligiblePost5" field.
func (m *ExamIPMutation) ResetEligiblePost5() {
	m._EligiblePost5 = nil
	delete(m.clearedFields, exam_ip.FieldEligiblePost5)
}

// SetExamPost1 sets the "ExamPost1" field.
func (m *ExamIPMutation) SetExamPost1(s string) {
	m._ExamPost1 = &s
}

// ExamPost1 returns the value of the "ExamPost1" field in the mutation.
func (m *ExamIPMutation) ExamPost1() (r string, exists bool) {
	v := m._ExamPost1
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost1 returns the old "ExamPost1" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldExamPost1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost1: %w", err)
	}
	return oldValue.ExamPost1, nil
}

// ClearExamPost1 clears the value of the "ExamPost1" field.
func (m *ExamIPMutation) ClearExamPost1() {
	m._ExamPost1 = nil
	m.clearedFields[exam_ip.FieldExamPost1] = struct{}{}
}

// ExamPost1Cleared returns if the "ExamPost1" field was cleared in this mutation.
func (m *ExamIPMutation) ExamPost1Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldExamPost1]
	return ok
}

// ResetExamPost1 resets all changes to the "ExamPost1" field.
func (m *ExamIPMutation) ResetExamPost1() {
	m._ExamPost1 = nil
	delete(m.clearedFields, exam_ip.FieldExamPost1)
}

// SetExamPost2 sets the "ExamPost2" field.
func (m *ExamIPMutation) SetExamPost2(s string) {
	m._ExamPost2 = &s
}

// ExamPost2 returns the value of the "ExamPost2" field in the mutation.
func (m *ExamIPMutation) ExamPost2() (r string, exists bool) {
	v := m._ExamPost2
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost2 returns the old "ExamPost2" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldExamPost2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost2: %w", err)
	}
	return oldValue.ExamPost2, nil
}

// ClearExamPost2 clears the value of the "ExamPost2" field.
func (m *ExamIPMutation) ClearExamPost2() {
	m._ExamPost2 = nil
	m.clearedFields[exam_ip.FieldExamPost2] = struct{}{}
}

// ExamPost2Cleared returns if the "ExamPost2" field was cleared in this mutation.
func (m *ExamIPMutation) ExamPost2Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldExamPost2]
	return ok
}

// ResetExamPost2 resets all changes to the "ExamPost2" field.
func (m *ExamIPMutation) ResetExamPost2() {
	m._ExamPost2 = nil
	delete(m.clearedFields, exam_ip.FieldExamPost2)
}

// SetExamPost3 sets the "ExamPost3" field.
func (m *ExamIPMutation) SetExamPost3(s string) {
	m._ExamPost3 = &s
}

// ExamPost3 returns the value of the "ExamPost3" field in the mutation.
func (m *ExamIPMutation) ExamPost3() (r string, exists bool) {
	v := m._ExamPost3
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost3 returns the old "ExamPost3" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldExamPost3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost3: %w", err)
	}
	return oldValue.ExamPost3, nil
}

// ClearExamPost3 clears the value of the "ExamPost3" field.
func (m *ExamIPMutation) ClearExamPost3() {
	m._ExamPost3 = nil
	m.clearedFields[exam_ip.FieldExamPost3] = struct{}{}
}

// ExamPost3Cleared returns if the "ExamPost3" field was cleared in this mutation.
func (m *ExamIPMutation) ExamPost3Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldExamPost3]
	return ok
}

// ResetExamPost3 resets all changes to the "ExamPost3" field.
func (m *ExamIPMutation) ResetExamPost3() {
	m._ExamPost3 = nil
	delete(m.clearedFields, exam_ip.FieldExamPost3)
}

// SetExamPost4 sets the "ExamPost4" field.
func (m *ExamIPMutation) SetExamPost4(s string) {
	m._ExamPost4 = &s
}

// ExamPost4 returns the value of the "ExamPost4" field in the mutation.
func (m *ExamIPMutation) ExamPost4() (r string, exists bool) {
	v := m._ExamPost4
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost4 returns the old "ExamPost4" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldExamPost4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost4: %w", err)
	}
	return oldValue.ExamPost4, nil
}

// ClearExamPost4 clears the value of the "ExamPost4" field.
func (m *ExamIPMutation) ClearExamPost4() {
	m._ExamPost4 = nil
	m.clearedFields[exam_ip.FieldExamPost4] = struct{}{}
}

// ExamPost4Cleared returns if the "ExamPost4" field was cleared in this mutation.
func (m *ExamIPMutation) ExamPost4Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldExamPost4]
	return ok
}

// ResetExamPost4 resets all changes to the "ExamPost4" field.
func (m *ExamIPMutation) ResetExamPost4() {
	m._ExamPost4 = nil
	delete(m.clearedFields, exam_ip.FieldExamPost4)
}

// SetExamPost5 sets the "ExamPost5" field.
func (m *ExamIPMutation) SetExamPost5(s string) {
	m._ExamPost5 = &s
}

// ExamPost5 returns the value of the "ExamPost5" field in the mutation.
func (m *ExamIPMutation) ExamPost5() (r string, exists bool) {
	v := m._ExamPost5
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost5 returns the old "ExamPost5" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldExamPost5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost5: %w", err)
	}
	return oldValue.ExamPost5, nil
}

// ClearExamPost5 clears the value of the "ExamPost5" field.
func (m *ExamIPMutation) ClearExamPost5() {
	m._ExamPost5 = nil
	m.clearedFields[exam_ip.FieldExamPost5] = struct{}{}
}

// ExamPost5Cleared returns if the "ExamPost5" field was cleared in this mutation.
func (m *ExamIPMutation) ExamPost5Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldExamPost5]
	return ok
}

// ResetExamPost5 resets all changes to the "ExamPost5" field.
func (m *ExamIPMutation) ResetExamPost5() {
	m._ExamPost5 = nil
	delete(m.clearedFields, exam_ip.FieldExamPost5)
}

// SetEducationCriteria sets the "EducationCriteria" field.
func (m *ExamIPMutation) SetEducationCriteria(s string) {
	m._EducationCriteria = &s
}

// EducationCriteria returns the value of the "EducationCriteria" field in the mutation.
func (m *ExamIPMutation) EducationCriteria() (r string, exists bool) {
	v := m._EducationCriteria
	if v == nil {
		return
	}
	return *v, true
}

// OldEducationCriteria returns the old "EducationCriteria" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldEducationCriteria(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducationCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducationCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducationCriteria: %w", err)
	}
	return oldValue.EducationCriteria, nil
}

// ClearEducationCriteria clears the value of the "EducationCriteria" field.
func (m *ExamIPMutation) ClearEducationCriteria() {
	m._EducationCriteria = nil
	m.clearedFields[exam_ip.FieldEducationCriteria] = struct{}{}
}

// EducationCriteriaCleared returns if the "EducationCriteria" field was cleared in this mutation.
func (m *ExamIPMutation) EducationCriteriaCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldEducationCriteria]
	return ok
}

// ResetEducationCriteria resets all changes to the "EducationCriteria" field.
func (m *ExamIPMutation) ResetEducationCriteria() {
	m._EducationCriteria = nil
	delete(m.clearedFields, exam_ip.FieldEducationCriteria)
}

// SetCategoryAgeLimitGEN sets the "CategoryAgeLimitGEN" field.
func (m *ExamIPMutation) SetCategoryAgeLimitGEN(s string) {
	m._CategoryAgeLimitGEN = &s
}

// CategoryAgeLimitGEN returns the value of the "CategoryAgeLimitGEN" field in the mutation.
func (m *ExamIPMutation) CategoryAgeLimitGEN() (r string, exists bool) {
	v := m._CategoryAgeLimitGEN
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryAgeLimitGEN returns the old "CategoryAgeLimitGEN" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldCategoryAgeLimitGEN(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryAgeLimitGEN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryAgeLimitGEN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryAgeLimitGEN: %w", err)
	}
	return oldValue.CategoryAgeLimitGEN, nil
}

// ClearCategoryAgeLimitGEN clears the value of the "CategoryAgeLimitGEN" field.
func (m *ExamIPMutation) ClearCategoryAgeLimitGEN() {
	m._CategoryAgeLimitGEN = nil
	m.clearedFields[exam_ip.FieldCategoryAgeLimitGEN] = struct{}{}
}

// CategoryAgeLimitGENCleared returns if the "CategoryAgeLimitGEN" field was cleared in this mutation.
func (m *ExamIPMutation) CategoryAgeLimitGENCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldCategoryAgeLimitGEN]
	return ok
}

// ResetCategoryAgeLimitGEN resets all changes to the "CategoryAgeLimitGEN" field.
func (m *ExamIPMutation) ResetCategoryAgeLimitGEN() {
	m._CategoryAgeLimitGEN = nil
	delete(m.clearedFields, exam_ip.FieldCategoryAgeLimitGEN)
}

// SetCategoryAgeLimitSC sets the "CategoryAgeLimitSC" field.
func (m *ExamIPMutation) SetCategoryAgeLimitSC(s string) {
	m._CategoryAgeLimitSC = &s
}

// CategoryAgeLimitSC returns the value of the "CategoryAgeLimitSC" field in the mutation.
func (m *ExamIPMutation) CategoryAgeLimitSC() (r string, exists bool) {
	v := m._CategoryAgeLimitSC
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryAgeLimitSC returns the old "CategoryAgeLimitSC" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldCategoryAgeLimitSC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryAgeLimitSC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryAgeLimitSC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryAgeLimitSC: %w", err)
	}
	return oldValue.CategoryAgeLimitSC, nil
}

// ClearCategoryAgeLimitSC clears the value of the "CategoryAgeLimitSC" field.
func (m *ExamIPMutation) ClearCategoryAgeLimitSC() {
	m._CategoryAgeLimitSC = nil
	m.clearedFields[exam_ip.FieldCategoryAgeLimitSC] = struct{}{}
}

// CategoryAgeLimitSCCleared returns if the "CategoryAgeLimitSC" field was cleared in this mutation.
func (m *ExamIPMutation) CategoryAgeLimitSCCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldCategoryAgeLimitSC]
	return ok
}

// ResetCategoryAgeLimitSC resets all changes to the "CategoryAgeLimitSC" field.
func (m *ExamIPMutation) ResetCategoryAgeLimitSC() {
	m._CategoryAgeLimitSC = nil
	delete(m.clearedFields, exam_ip.FieldCategoryAgeLimitSC)
}

// SetCategoryAgeLimitST sets the "CategoryAgeLimitST" field.
func (m *ExamIPMutation) SetCategoryAgeLimitST(s string) {
	m._CategoryAgeLimitST = &s
}

// CategoryAgeLimitST returns the value of the "CategoryAgeLimitST" field in the mutation.
func (m *ExamIPMutation) CategoryAgeLimitST() (r string, exists bool) {
	v := m._CategoryAgeLimitST
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryAgeLimitST returns the old "CategoryAgeLimitST" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldCategoryAgeLimitST(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryAgeLimitST is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryAgeLimitST requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryAgeLimitST: %w", err)
	}
	return oldValue.CategoryAgeLimitST, nil
}

// ClearCategoryAgeLimitST clears the value of the "CategoryAgeLimitST" field.
func (m *ExamIPMutation) ClearCategoryAgeLimitST() {
	m._CategoryAgeLimitST = nil
	m.clearedFields[exam_ip.FieldCategoryAgeLimitST] = struct{}{}
}

// CategoryAgeLimitSTCleared returns if the "CategoryAgeLimitST" field was cleared in this mutation.
func (m *ExamIPMutation) CategoryAgeLimitSTCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldCategoryAgeLimitST]
	return ok
}

// ResetCategoryAgeLimitST resets all changes to the "CategoryAgeLimitST" field.
func (m *ExamIPMutation) ResetCategoryAgeLimitST() {
	m._CategoryAgeLimitST = nil
	delete(m.clearedFields, exam_ip.FieldCategoryAgeLimitST)
}

// SetServiceYears sets the "ServiceYears" field.
func (m *ExamIPMutation) SetServiceYears(s string) {
	m._ServiceYears = &s
}

// ServiceYears returns the value of the "ServiceYears" field in the mutation.
func (m *ExamIPMutation) ServiceYears() (r string, exists bool) {
	v := m._ServiceYears
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceYears returns the old "ServiceYears" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldServiceYears(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceYears is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceYears requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceYears: %w", err)
	}
	return oldValue.ServiceYears, nil
}

// ClearServiceYears clears the value of the "ServiceYears" field.
func (m *ExamIPMutation) ClearServiceYears() {
	m._ServiceYears = nil
	m.clearedFields[exam_ip.FieldServiceYears] = struct{}{}
}

// ServiceYearsCleared returns if the "ServiceYears" field was cleared in this mutation.
func (m *ExamIPMutation) ServiceYearsCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldServiceYears]
	return ok
}

// ResetServiceYears resets all changes to the "ServiceYears" field.
func (m *ExamIPMutation) ResetServiceYears() {
	m._ServiceYears = nil
	delete(m.clearedFields, exam_ip.FieldServiceYears)
}

// SetDrivingLicenseRequired sets the "DrivingLicenseRequired" field.
func (m *ExamIPMutation) SetDrivingLicenseRequired(s string) {
	m._DrivingLicenseRequired = &s
}

// DrivingLicenseRequired returns the value of the "DrivingLicenseRequired" field in the mutation.
func (m *ExamIPMutation) DrivingLicenseRequired() (r string, exists bool) {
	v := m._DrivingLicenseRequired
	if v == nil {
		return
	}
	return *v, true
}

// OldDrivingLicenseRequired returns the old "DrivingLicenseRequired" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldDrivingLicenseRequired(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrivingLicenseRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrivingLicenseRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrivingLicenseRequired: %w", err)
	}
	return oldValue.DrivingLicenseRequired, nil
}

// ClearDrivingLicenseRequired clears the value of the "DrivingLicenseRequired" field.
func (m *ExamIPMutation) ClearDrivingLicenseRequired() {
	m._DrivingLicenseRequired = nil
	m.clearedFields[exam_ip.FieldDrivingLicenseRequired] = struct{}{}
}

// DrivingLicenseRequiredCleared returns if the "DrivingLicenseRequired" field was cleared in this mutation.
func (m *ExamIPMutation) DrivingLicenseRequiredCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldDrivingLicenseRequired]
	return ok
}

// ResetDrivingLicenseRequired resets all changes to the "DrivingLicenseRequired" field.
func (m *ExamIPMutation) ResetDrivingLicenseRequired() {
	m._DrivingLicenseRequired = nil
	delete(m.clearedFields, exam_ip.FieldDrivingLicenseRequired)
}

// SetExamPaperCode sets the "ExamPaperCode" field.
func (m *ExamIPMutation) SetExamPaperCode(s string) {
	m._ExamPaperCode = &s
}

// ExamPaperCode returns the value of the "ExamPaperCode" field in the mutation.
func (m *ExamIPMutation) ExamPaperCode() (r string, exists bool) {
	v := m._ExamPaperCode
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaperCode returns the old "ExamPaperCode" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldExamPaperCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaperCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaperCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaperCode: %w", err)
	}
	return oldValue.ExamPaperCode, nil
}

// ClearExamPaperCode clears the value of the "ExamPaperCode" field.
func (m *ExamIPMutation) ClearExamPaperCode() {
	m._ExamPaperCode = nil
	m.clearedFields[exam_ip.FieldExamPaperCode] = struct{}{}
}

// ExamPaperCodeCleared returns if the "ExamPaperCode" field was cleared in this mutation.
func (m *ExamIPMutation) ExamPaperCodeCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldExamPaperCode]
	return ok
}

// ResetExamPaperCode resets all changes to the "ExamPaperCode" field.
func (m *ExamIPMutation) ResetExamPaperCode() {
	m._ExamPaperCode = nil
	delete(m.clearedFields, exam_ip.FieldExamPaperCode)
}

// SetExamPaper1 sets the "ExamPaper1" field.
func (m *ExamIPMutation) SetExamPaper1(s string) {
	m._ExamPaper1 = &s
}

// ExamPaper1 returns the value of the "ExamPaper1" field in the mutation.
func (m *ExamIPMutation) ExamPaper1() (r string, exists bool) {
	v := m._ExamPaper1
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper1 returns the old "ExamPaper1" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldExamPaper1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper1: %w", err)
	}
	return oldValue.ExamPaper1, nil
}

// ClearExamPaper1 clears the value of the "ExamPaper1" field.
func (m *ExamIPMutation) ClearExamPaper1() {
	m._ExamPaper1 = nil
	m.clearedFields[exam_ip.FieldExamPaper1] = struct{}{}
}

// ExamPaper1Cleared returns if the "ExamPaper1" field was cleared in this mutation.
func (m *ExamIPMutation) ExamPaper1Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldExamPaper1]
	return ok
}

// ResetExamPaper1 resets all changes to the "ExamPaper1" field.
func (m *ExamIPMutation) ResetExamPaper1() {
	m._ExamPaper1 = nil
	delete(m.clearedFields, exam_ip.FieldExamPaper1)
}

// SetExamPaper2 sets the "ExamPaper2" field.
func (m *ExamIPMutation) SetExamPaper2(s string) {
	m._ExamPaper2 = &s
}

// ExamPaper2 returns the value of the "ExamPaper2" field in the mutation.
func (m *ExamIPMutation) ExamPaper2() (r string, exists bool) {
	v := m._ExamPaper2
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper2 returns the old "ExamPaper2" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldExamPaper2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper2: %w", err)
	}
	return oldValue.ExamPaper2, nil
}

// ClearExamPaper2 clears the value of the "ExamPaper2" field.
func (m *ExamIPMutation) ClearExamPaper2() {
	m._ExamPaper2 = nil
	m.clearedFields[exam_ip.FieldExamPaper2] = struct{}{}
}

// ExamPaper2Cleared returns if the "ExamPaper2" field was cleared in this mutation.
func (m *ExamIPMutation) ExamPaper2Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldExamPaper2]
	return ok
}

// ResetExamPaper2 resets all changes to the "ExamPaper2" field.
func (m *ExamIPMutation) ResetExamPaper2() {
	m._ExamPaper2 = nil
	delete(m.clearedFields, exam_ip.FieldExamPaper2)
}

// SetExamPaper3 sets the "ExamPaper3" field.
func (m *ExamIPMutation) SetExamPaper3(s string) {
	m._ExamPaper3 = &s
}

// ExamPaper3 returns the value of the "ExamPaper3" field in the mutation.
func (m *ExamIPMutation) ExamPaper3() (r string, exists bool) {
	v := m._ExamPaper3
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper3 returns the old "ExamPaper3" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldExamPaper3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper3: %w", err)
	}
	return oldValue.ExamPaper3, nil
}

// ClearExamPaper3 clears the value of the "ExamPaper3" field.
func (m *ExamIPMutation) ClearExamPaper3() {
	m._ExamPaper3 = nil
	m.clearedFields[exam_ip.FieldExamPaper3] = struct{}{}
}

// ExamPaper3Cleared returns if the "ExamPaper3" field was cleared in this mutation.
func (m *ExamIPMutation) ExamPaper3Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldExamPaper3]
	return ok
}

// ResetExamPaper3 resets all changes to the "ExamPaper3" field.
func (m *ExamIPMutation) ResetExamPaper3() {
	m._ExamPaper3 = nil
	delete(m.clearedFields, exam_ip.FieldExamPaper3)
}

// SetExamPaper4 sets the "ExamPaper4" field.
func (m *ExamIPMutation) SetExamPaper4(s string) {
	m._ExamPaper4 = &s
}

// ExamPaper4 returns the value of the "ExamPaper4" field in the mutation.
func (m *ExamIPMutation) ExamPaper4() (r string, exists bool) {
	v := m._ExamPaper4
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper4 returns the old "ExamPaper4" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldExamPaper4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper4: %w", err)
	}
	return oldValue.ExamPaper4, nil
}

// ClearExamPaper4 clears the value of the "ExamPaper4" field.
func (m *ExamIPMutation) ClearExamPaper4() {
	m._ExamPaper4 = nil
	m.clearedFields[exam_ip.FieldExamPaper4] = struct{}{}
}

// ExamPaper4Cleared returns if the "ExamPaper4" field was cleared in this mutation.
func (m *ExamIPMutation) ExamPaper4Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldExamPaper4]
	return ok
}

// ResetExamPaper4 resets all changes to the "ExamPaper4" field.
func (m *ExamIPMutation) ResetExamPaper4() {
	m._ExamPaper4 = nil
	delete(m.clearedFields, exam_ip.FieldExamPaper4)
}

// SetExamPaper5 sets the "ExamPaper5" field.
func (m *ExamIPMutation) SetExamPaper5(s string) {
	m._ExamPaper5 = &s
}

// ExamPaper5 returns the value of the "ExamPaper5" field in the mutation.
func (m *ExamIPMutation) ExamPaper5() (r string, exists bool) {
	v := m._ExamPaper5
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper5 returns the old "ExamPaper5" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldExamPaper5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper5: %w", err)
	}
	return oldValue.ExamPaper5, nil
}

// ClearExamPaper5 clears the value of the "ExamPaper5" field.
func (m *ExamIPMutation) ClearExamPaper5() {
	m._ExamPaper5 = nil
	m.clearedFields[exam_ip.FieldExamPaper5] = struct{}{}
}

// ExamPaper5Cleared returns if the "ExamPaper5" field was cleared in this mutation.
func (m *ExamIPMutation) ExamPaper5Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldExamPaper5]
	return ok
}

// ResetExamPaper5 resets all changes to the "ExamPaper5" field.
func (m *ExamIPMutation) ResetExamPaper5() {
	m._ExamPaper5 = nil
	delete(m.clearedFields, exam_ip.FieldExamPaper5)
}

// SetExamPaper6 sets the "ExamPaper6" field.
func (m *ExamIPMutation) SetExamPaper6(s string) {
	m._ExamPaper6 = &s
}

// ExamPaper6 returns the value of the "ExamPaper6" field in the mutation.
func (m *ExamIPMutation) ExamPaper6() (r string, exists bool) {
	v := m._ExamPaper6
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper6 returns the old "ExamPaper6" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldExamPaper6(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper6: %w", err)
	}
	return oldValue.ExamPaper6, nil
}

// ClearExamPaper6 clears the value of the "ExamPaper6" field.
func (m *ExamIPMutation) ClearExamPaper6() {
	m._ExamPaper6 = nil
	m.clearedFields[exam_ip.FieldExamPaper6] = struct{}{}
}

// ExamPaper6Cleared returns if the "ExamPaper6" field was cleared in this mutation.
func (m *ExamIPMutation) ExamPaper6Cleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldExamPaper6]
	return ok
}

// ResetExamPaper6 resets all changes to the "ExamPaper6" field.
func (m *ExamIPMutation) ResetExamPaper6() {
	m._ExamPaper6 = nil
	delete(m.clearedFields, exam_ip.FieldExamPaper6)
}

// SetPayLevelEligibilty sets the "PayLevelEligibilty" field.
func (m *ExamIPMutation) SetPayLevelEligibilty(b bool) {
	m._PayLevelEligibilty = &b
}

// PayLevelEligibilty returns the value of the "PayLevelEligibilty" field in the mutation.
func (m *ExamIPMutation) PayLevelEligibilty() (r bool, exists bool) {
	v := m._PayLevelEligibilty
	if v == nil {
		return
	}
	return *v, true
}

// OldPayLevelEligibilty returns the old "PayLevelEligibilty" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldPayLevelEligibilty(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayLevelEligibilty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayLevelEligibilty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayLevelEligibilty: %w", err)
	}
	return oldValue.PayLevelEligibilty, nil
}

// ClearPayLevelEligibilty clears the value of the "PayLevelEligibilty" field.
func (m *ExamIPMutation) ClearPayLevelEligibilty() {
	m._PayLevelEligibilty = nil
	m.clearedFields[exam_ip.FieldPayLevelEligibilty] = struct{}{}
}

// PayLevelEligibiltyCleared returns if the "PayLevelEligibilty" field was cleared in this mutation.
func (m *ExamIPMutation) PayLevelEligibiltyCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldPayLevelEligibilty]
	return ok
}

// ResetPayLevelEligibilty resets all changes to the "PayLevelEligibilty" field.
func (m *ExamIPMutation) ResetPayLevelEligibilty() {
	m._PayLevelEligibilty = nil
	delete(m.clearedFields, exam_ip.FieldPayLevelEligibilty)
}

// SetCategoryMinMarksSCSTPH sets the "CategoryMinMarksSCSTPH" field.
func (m *ExamIPMutation) SetCategoryMinMarksSCSTPH(s string) {
	m._CategoryMinMarksSCSTPH = &s
}

// CategoryMinMarksSCSTPH returns the value of the "CategoryMinMarksSCSTPH" field in the mutation.
func (m *ExamIPMutation) CategoryMinMarksSCSTPH() (r string, exists bool) {
	v := m._CategoryMinMarksSCSTPH
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryMinMarksSCSTPH returns the old "CategoryMinMarksSCSTPH" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldCategoryMinMarksSCSTPH(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryMinMarksSCSTPH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryMinMarksSCSTPH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryMinMarksSCSTPH: %w", err)
	}
	return oldValue.CategoryMinMarksSCSTPH, nil
}

// ClearCategoryMinMarksSCSTPH clears the value of the "CategoryMinMarksSCSTPH" field.
func (m *ExamIPMutation) ClearCategoryMinMarksSCSTPH() {
	m._CategoryMinMarksSCSTPH = nil
	m.clearedFields[exam_ip.FieldCategoryMinMarksSCSTPH] = struct{}{}
}

// CategoryMinMarksSCSTPHCleared returns if the "CategoryMinMarksSCSTPH" field was cleared in this mutation.
func (m *ExamIPMutation) CategoryMinMarksSCSTPHCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldCategoryMinMarksSCSTPH]
	return ok
}

// ResetCategoryMinMarksSCSTPH resets all changes to the "CategoryMinMarksSCSTPH" field.
func (m *ExamIPMutation) ResetCategoryMinMarksSCSTPH() {
	m._CategoryMinMarksSCSTPH = nil
	delete(m.clearedFields, exam_ip.FieldCategoryMinMarksSCSTPH)
}

// SetCategoryMinMarksGENOBC sets the "CategoryMinMarksGENOBC" field.
func (m *ExamIPMutation) SetCategoryMinMarksGENOBC(s string) {
	m._CategoryMinMarksGENOBC = &s
}

// CategoryMinMarksGENOBC returns the value of the "CategoryMinMarksGENOBC" field in the mutation.
func (m *ExamIPMutation) CategoryMinMarksGENOBC() (r string, exists bool) {
	v := m._CategoryMinMarksGENOBC
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryMinMarksGENOBC returns the old "CategoryMinMarksGENOBC" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldCategoryMinMarksGENOBC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryMinMarksGENOBC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryMinMarksGENOBC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryMinMarksGENOBC: %w", err)
	}
	return oldValue.CategoryMinMarksGENOBC, nil
}

// ClearCategoryMinMarksGENOBC clears the value of the "CategoryMinMarksGENOBC" field.
func (m *ExamIPMutation) ClearCategoryMinMarksGENOBC() {
	m._CategoryMinMarksGENOBC = nil
	m.clearedFields[exam_ip.FieldCategoryMinMarksGENOBC] = struct{}{}
}

// CategoryMinMarksGENOBCCleared returns if the "CategoryMinMarksGENOBC" field was cleared in this mutation.
func (m *ExamIPMutation) CategoryMinMarksGENOBCCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldCategoryMinMarksGENOBC]
	return ok
}

// ResetCategoryMinMarksGENOBC resets all changes to the "CategoryMinMarksGENOBC" field.
func (m *ExamIPMutation) ResetCategoryMinMarksGENOBC() {
	m._CategoryMinMarksGENOBC = nil
	delete(m.clearedFields, exam_ip.FieldCategoryMinMarksGENOBC)
}

// SetLocalLanguageAllowed sets the "LocalLanguageAllowed" field.
func (m *ExamIPMutation) SetLocalLanguageAllowed(b bool) {
	m._LocalLanguageAllowed = &b
}

// LocalLanguageAllowed returns the value of the "LocalLanguageAllowed" field in the mutation.
func (m *ExamIPMutation) LocalLanguageAllowed() (r bool, exists bool) {
	v := m._LocalLanguageAllowed
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalLanguageAllowed returns the old "LocalLanguageAllowed" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldLocalLanguageAllowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalLanguageAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalLanguageAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalLanguageAllowed: %w", err)
	}
	return oldValue.LocalLanguageAllowed, nil
}

// ClearLocalLanguageAllowed clears the value of the "LocalLanguageAllowed" field.
func (m *ExamIPMutation) ClearLocalLanguageAllowed() {
	m._LocalLanguageAllowed = nil
	m.clearedFields[exam_ip.FieldLocalLanguageAllowed] = struct{}{}
}

// LocalLanguageAllowedCleared returns if the "LocalLanguageAllowed" field was cleared in this mutation.
func (m *ExamIPMutation) LocalLanguageAllowedCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldLocalLanguageAllowed]
	return ok
}

// ResetLocalLanguageAllowed resets all changes to the "LocalLanguageAllowed" field.
func (m *ExamIPMutation) ResetLocalLanguageAllowed() {
	m._LocalLanguageAllowed = nil
	delete(m.clearedFields, exam_ip.FieldLocalLanguageAllowed)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *ExamIPMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *ExamIPMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *ExamIPMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[exam_ip.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *ExamIPMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *ExamIPMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, exam_ip.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *ExamIPMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *ExamIPMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the Exam_IP entity.
// If the Exam_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamIPMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *ExamIPMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[exam_ip.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *ExamIPMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[exam_ip.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *ExamIPMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, exam_ip.FieldUpdatedBy)
}

// AddExamcalIPRefIDs adds the "examcal_ip_ref" edge to the ExamCalendar entity by ids.
func (m *ExamIPMutation) AddExamcalIPRefIDs(ids ...int32) {
	if m.examcal_ip_ref == nil {
		m.examcal_ip_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.examcal_ip_ref[ids[i]] = struct{}{}
	}
}

// ClearExamcalIPRef clears the "examcal_ip_ref" edge to the ExamCalendar entity.
func (m *ExamIPMutation) ClearExamcalIPRef() {
	m.clearedexamcal_ip_ref = true
}

// ExamcalIPRefCleared reports if the "examcal_ip_ref" edge to the ExamCalendar entity was cleared.
func (m *ExamIPMutation) ExamcalIPRefCleared() bool {
	return m.clearedexamcal_ip_ref
}

// RemoveExamcalIPRefIDs removes the "examcal_ip_ref" edge to the ExamCalendar entity by IDs.
func (m *ExamIPMutation) RemoveExamcalIPRefIDs(ids ...int32) {
	if m.removedexamcal_ip_ref == nil {
		m.removedexamcal_ip_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.examcal_ip_ref, ids[i])
		m.removedexamcal_ip_ref[ids[i]] = struct{}{}
	}
}

// RemovedExamcalIPRef returns the removed IDs of the "examcal_ip_ref" edge to the ExamCalendar entity.
func (m *ExamIPMutation) RemovedExamcalIPRefIDs() (ids []int32) {
	for id := range m.removedexamcal_ip_ref {
		ids = append(ids, id)
	}
	return
}

// ExamcalIPRefIDs returns the "examcal_ip_ref" edge IDs in the mutation.
func (m *ExamIPMutation) ExamcalIPRefIDs() (ids []int32) {
	for id := range m.examcal_ip_ref {
		ids = append(ids, id)
	}
	return
}

// ResetExamcalIPRef resets all changes to the "examcal_ip_ref" edge.
func (m *ExamIPMutation) ResetExamcalIPRef() {
	m.examcal_ip_ref = nil
	m.clearedexamcal_ip_ref = false
	m.removedexamcal_ip_ref = nil
}

// AddPapersIPRefIDs adds the "papers_ip_ref" edge to the ExamPapers entity by ids.
func (m *ExamIPMutation) AddPapersIPRefIDs(ids ...int32) {
	if m.papers_ip_ref == nil {
		m.papers_ip_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.papers_ip_ref[ids[i]] = struct{}{}
	}
}

// ClearPapersIPRef clears the "papers_ip_ref" edge to the ExamPapers entity.
func (m *ExamIPMutation) ClearPapersIPRef() {
	m.clearedpapers_ip_ref = true
}

// PapersIPRefCleared reports if the "papers_ip_ref" edge to the ExamPapers entity was cleared.
func (m *ExamIPMutation) PapersIPRefCleared() bool {
	return m.clearedpapers_ip_ref
}

// RemovePapersIPRefIDs removes the "papers_ip_ref" edge to the ExamPapers entity by IDs.
func (m *ExamIPMutation) RemovePapersIPRefIDs(ids ...int32) {
	if m.removedpapers_ip_ref == nil {
		m.removedpapers_ip_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.papers_ip_ref, ids[i])
		m.removedpapers_ip_ref[ids[i]] = struct{}{}
	}
}

// RemovedPapersIPRef returns the removed IDs of the "papers_ip_ref" edge to the ExamPapers entity.
func (m *ExamIPMutation) RemovedPapersIPRefIDs() (ids []int32) {
	for id := range m.removedpapers_ip_ref {
		ids = append(ids, id)
	}
	return
}

// PapersIPRefIDs returns the "papers_ip_ref" edge IDs in the mutation.
func (m *ExamIPMutation) PapersIPRefIDs() (ids []int32) {
	for id := range m.papers_ip_ref {
		ids = append(ids, id)
	}
	return
}

// ResetPapersIPRef resets all changes to the "papers_ip_ref" edge.
func (m *ExamIPMutation) ResetPapersIPRef() {
	m.papers_ip_ref = nil
	m.clearedpapers_ip_ref = false
	m.removedpapers_ip_ref = nil
}

// AddUsersIPTypeIDs adds the "users_ip_type" edge to the UserMaster entity by ids.
func (m *ExamIPMutation) AddUsersIPTypeIDs(ids ...int64) {
	if m.users_ip_type == nil {
		m.users_ip_type = make(map[int64]struct{})
	}
	for i := range ids {
		m.users_ip_type[ids[i]] = struct{}{}
	}
}

// ClearUsersIPType clears the "users_ip_type" edge to the UserMaster entity.
func (m *ExamIPMutation) ClearUsersIPType() {
	m.clearedusers_ip_type = true
}

// UsersIPTypeCleared reports if the "users_ip_type" edge to the UserMaster entity was cleared.
func (m *ExamIPMutation) UsersIPTypeCleared() bool {
	return m.clearedusers_ip_type
}

// RemoveUsersIPTypeIDs removes the "users_ip_type" edge to the UserMaster entity by IDs.
func (m *ExamIPMutation) RemoveUsersIPTypeIDs(ids ...int64) {
	if m.removedusers_ip_type == nil {
		m.removedusers_ip_type = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users_ip_type, ids[i])
		m.removedusers_ip_type[ids[i]] = struct{}{}
	}
}

// RemovedUsersIPType returns the removed IDs of the "users_ip_type" edge to the UserMaster entity.
func (m *ExamIPMutation) RemovedUsersIPTypeIDs() (ids []int64) {
	for id := range m.removedusers_ip_type {
		ids = append(ids, id)
	}
	return
}

// UsersIPTypeIDs returns the "users_ip_type" edge IDs in the mutation.
func (m *ExamIPMutation) UsersIPTypeIDs() (ids []int64) {
	for id := range m.users_ip_type {
		ids = append(ids, id)
	}
	return
}

// ResetUsersIPType resets all changes to the "users_ip_type" edge.
func (m *ExamIPMutation) ResetUsersIPType() {
	m.users_ip_type = nil
	m.clearedusers_ip_type = false
	m.removedusers_ip_type = nil
}

// AddExamApplnIPRefIDs adds the "ExamAppln_IP_Ref" edge to the Exam_Applications_IP entity by ids.
func (m *ExamIPMutation) AddExamApplnIPRefIDs(ids ...int64) {
	if m._ExamAppln_IP_Ref == nil {
		m._ExamAppln_IP_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		m._ExamAppln_IP_Ref[ids[i]] = struct{}{}
	}
}

// ClearExamApplnIPRef clears the "ExamAppln_IP_Ref" edge to the Exam_Applications_IP entity.
func (m *ExamIPMutation) ClearExamApplnIPRef() {
	m.cleared_ExamAppln_IP_Ref = true
}

// ExamApplnIPRefCleared reports if the "ExamAppln_IP_Ref" edge to the Exam_Applications_IP entity was cleared.
func (m *ExamIPMutation) ExamApplnIPRefCleared() bool {
	return m.cleared_ExamAppln_IP_Ref
}

// RemoveExamApplnIPRefIDs removes the "ExamAppln_IP_Ref" edge to the Exam_Applications_IP entity by IDs.
func (m *ExamIPMutation) RemoveExamApplnIPRefIDs(ids ...int64) {
	if m.removed_ExamAppln_IP_Ref == nil {
		m.removed_ExamAppln_IP_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._ExamAppln_IP_Ref, ids[i])
		m.removed_ExamAppln_IP_Ref[ids[i]] = struct{}{}
	}
}

// RemovedExamApplnIPRef returns the removed IDs of the "ExamAppln_IP_Ref" edge to the Exam_Applications_IP entity.
func (m *ExamIPMutation) RemovedExamApplnIPRefIDs() (ids []int64) {
	for id := range m.removed_ExamAppln_IP_Ref {
		ids = append(ids, id)
	}
	return
}

// ExamApplnIPRefIDs returns the "ExamAppln_IP_Ref" edge IDs in the mutation.
func (m *ExamIPMutation) ExamApplnIPRefIDs() (ids []int64) {
	for id := range m._ExamAppln_IP_Ref {
		ids = append(ids, id)
	}
	return
}

// ResetExamApplnIPRef resets all changes to the "ExamAppln_IP_Ref" edge.
func (m *ExamIPMutation) ResetExamApplnIPRef() {
	m._ExamAppln_IP_Ref = nil
	m.cleared_ExamAppln_IP_Ref = false
	m.removed_ExamAppln_IP_Ref = nil
}

// AddNotificationsIPIDs adds the "notifications_ip" edge to the Notification entity by ids.
func (m *ExamIPMutation) AddNotificationsIPIDs(ids ...int32) {
	if m.notifications_ip == nil {
		m.notifications_ip = make(map[int32]struct{})
	}
	for i := range ids {
		m.notifications_ip[ids[i]] = struct{}{}
	}
}

// ClearNotificationsIP clears the "notifications_ip" edge to the Notification entity.
func (m *ExamIPMutation) ClearNotificationsIP() {
	m.clearednotifications_ip = true
}

// NotificationsIPCleared reports if the "notifications_ip" edge to the Notification entity was cleared.
func (m *ExamIPMutation) NotificationsIPCleared() bool {
	return m.clearednotifications_ip
}

// RemoveNotificationsIPIDs removes the "notifications_ip" edge to the Notification entity by IDs.
func (m *ExamIPMutation) RemoveNotificationsIPIDs(ids ...int32) {
	if m.removednotifications_ip == nil {
		m.removednotifications_ip = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.notifications_ip, ids[i])
		m.removednotifications_ip[ids[i]] = struct{}{}
	}
}

// RemovedNotificationsIP returns the removed IDs of the "notifications_ip" edge to the Notification entity.
func (m *ExamIPMutation) RemovedNotificationsIPIDs() (ids []int32) {
	for id := range m.removednotifications_ip {
		ids = append(ids, id)
	}
	return
}

// NotificationsIPIDs returns the "notifications_ip" edge IDs in the mutation.
func (m *ExamIPMutation) NotificationsIPIDs() (ids []int32) {
	for id := range m.notifications_ip {
		ids = append(ids, id)
	}
	return
}

// ResetNotificationsIP resets all changes to the "notifications_ip" edge.
func (m *ExamIPMutation) ResetNotificationsIP() {
	m.notifications_ip = nil
	m.clearednotifications_ip = false
	m.removednotifications_ip = nil
}

// Where appends a list predicates to the ExamIPMutation builder.
func (m *ExamIPMutation) Where(ps ...predicate.Exam_IP) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExamIPMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExamIPMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exam_IP, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExamIPMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExamIPMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exam_IP).
func (m *ExamIPMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExamIPMutation) Fields() []string {
	fields := make([]string, 0, 38)
	if m._ExamNameCode != nil {
		fields = append(fields, exam_ip.FieldExamNameCode)
	}
	if m._ExamName != nil {
		fields = append(fields, exam_ip.FieldExamName)
	}
	if m._ExamType != nil {
		fields = append(fields, exam_ip.FieldExamType)
	}
	if m._NotificationCode != nil {
		fields = append(fields, exam_ip.FieldNotificationCode)
	}
	if m._ConductedBy != nil {
		fields = append(fields, exam_ip.FieldConductedBy)
	}
	if m._NodalOffice != nil {
		fields = append(fields, exam_ip.FieldNodalOffice)
	}
	if m._CalendarCode != nil {
		fields = append(fields, exam_ip.FieldCalendarCode)
	}
	if m._PaperCode != nil {
		fields = append(fields, exam_ip.FieldPaperCode)
	}
	if m._EligibleCadre != nil {
		fields = append(fields, exam_ip.FieldEligibleCadre)
	}
	if m._EligiblePost1 != nil {
		fields = append(fields, exam_ip.FieldEligiblePost1)
	}
	if m._EligiblePost2 != nil {
		fields = append(fields, exam_ip.FieldEligiblePost2)
	}
	if m._EligiblePost3 != nil {
		fields = append(fields, exam_ip.FieldEligiblePost3)
	}
	if m._EligiblePost4 != nil {
		fields = append(fields, exam_ip.FieldEligiblePost4)
	}
	if m._EligiblePost5 != nil {
		fields = append(fields, exam_ip.FieldEligiblePost5)
	}
	if m._ExamPost1 != nil {
		fields = append(fields, exam_ip.FieldExamPost1)
	}
	if m._ExamPost2 != nil {
		fields = append(fields, exam_ip.FieldExamPost2)
	}
	if m._ExamPost3 != nil {
		fields = append(fields, exam_ip.FieldExamPost3)
	}
	if m._ExamPost4 != nil {
		fields = append(fields, exam_ip.FieldExamPost4)
	}
	if m._ExamPost5 != nil {
		fields = append(fields, exam_ip.FieldExamPost5)
	}
	if m._EducationCriteria != nil {
		fields = append(fields, exam_ip.FieldEducationCriteria)
	}
	if m._CategoryAgeLimitGEN != nil {
		fields = append(fields, exam_ip.FieldCategoryAgeLimitGEN)
	}
	if m._CategoryAgeLimitSC != nil {
		fields = append(fields, exam_ip.FieldCategoryAgeLimitSC)
	}
	if m._CategoryAgeLimitST != nil {
		fields = append(fields, exam_ip.FieldCategoryAgeLimitST)
	}
	if m._ServiceYears != nil {
		fields = append(fields, exam_ip.FieldServiceYears)
	}
	if m._DrivingLicenseRequired != nil {
		fields = append(fields, exam_ip.FieldDrivingLicenseRequired)
	}
	if m._ExamPaperCode != nil {
		fields = append(fields, exam_ip.FieldExamPaperCode)
	}
	if m._ExamPaper1 != nil {
		fields = append(fields, exam_ip.FieldExamPaper1)
	}
	if m._ExamPaper2 != nil {
		fields = append(fields, exam_ip.FieldExamPaper2)
	}
	if m._ExamPaper3 != nil {
		fields = append(fields, exam_ip.FieldExamPaper3)
	}
	if m._ExamPaper4 != nil {
		fields = append(fields, exam_ip.FieldExamPaper4)
	}
	if m._ExamPaper5 != nil {
		fields = append(fields, exam_ip.FieldExamPaper5)
	}
	if m._ExamPaper6 != nil {
		fields = append(fields, exam_ip.FieldExamPaper6)
	}
	if m._PayLevelEligibilty != nil {
		fields = append(fields, exam_ip.FieldPayLevelEligibilty)
	}
	if m._CategoryMinMarksSCSTPH != nil {
		fields = append(fields, exam_ip.FieldCategoryMinMarksSCSTPH)
	}
	if m._CategoryMinMarksGENOBC != nil {
		fields = append(fields, exam_ip.FieldCategoryMinMarksGENOBC)
	}
	if m._LocalLanguageAllowed != nil {
		fields = append(fields, exam_ip.FieldLocalLanguageAllowed)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, exam_ip.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, exam_ip.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExamIPMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exam_ip.FieldExamNameCode:
		return m.ExamNameCode()
	case exam_ip.FieldExamName:
		return m.ExamName()
	case exam_ip.FieldExamType:
		return m.ExamType()
	case exam_ip.FieldNotificationCode:
		return m.NotificationCode()
	case exam_ip.FieldConductedBy:
		return m.ConductedBy()
	case exam_ip.FieldNodalOffice:
		return m.NodalOffice()
	case exam_ip.FieldCalendarCode:
		return m.CalendarCode()
	case exam_ip.FieldPaperCode:
		return m.PaperCode()
	case exam_ip.FieldEligibleCadre:
		return m.EligibleCadre()
	case exam_ip.FieldEligiblePost1:
		return m.EligiblePost1()
	case exam_ip.FieldEligiblePost2:
		return m.EligiblePost2()
	case exam_ip.FieldEligiblePost3:
		return m.EligiblePost3()
	case exam_ip.FieldEligiblePost4:
		return m.EligiblePost4()
	case exam_ip.FieldEligiblePost5:
		return m.EligiblePost5()
	case exam_ip.FieldExamPost1:
		return m.ExamPost1()
	case exam_ip.FieldExamPost2:
		return m.ExamPost2()
	case exam_ip.FieldExamPost3:
		return m.ExamPost3()
	case exam_ip.FieldExamPost4:
		return m.ExamPost4()
	case exam_ip.FieldExamPost5:
		return m.ExamPost5()
	case exam_ip.FieldEducationCriteria:
		return m.EducationCriteria()
	case exam_ip.FieldCategoryAgeLimitGEN:
		return m.CategoryAgeLimitGEN()
	case exam_ip.FieldCategoryAgeLimitSC:
		return m.CategoryAgeLimitSC()
	case exam_ip.FieldCategoryAgeLimitST:
		return m.CategoryAgeLimitST()
	case exam_ip.FieldServiceYears:
		return m.ServiceYears()
	case exam_ip.FieldDrivingLicenseRequired:
		return m.DrivingLicenseRequired()
	case exam_ip.FieldExamPaperCode:
		return m.ExamPaperCode()
	case exam_ip.FieldExamPaper1:
		return m.ExamPaper1()
	case exam_ip.FieldExamPaper2:
		return m.ExamPaper2()
	case exam_ip.FieldExamPaper3:
		return m.ExamPaper3()
	case exam_ip.FieldExamPaper4:
		return m.ExamPaper4()
	case exam_ip.FieldExamPaper5:
		return m.ExamPaper5()
	case exam_ip.FieldExamPaper6:
		return m.ExamPaper6()
	case exam_ip.FieldPayLevelEligibilty:
		return m.PayLevelEligibilty()
	case exam_ip.FieldCategoryMinMarksSCSTPH:
		return m.CategoryMinMarksSCSTPH()
	case exam_ip.FieldCategoryMinMarksGENOBC:
		return m.CategoryMinMarksGENOBC()
	case exam_ip.FieldLocalLanguageAllowed:
		return m.LocalLanguageAllowed()
	case exam_ip.FieldUpdatedAt:
		return m.UpdatedAt()
	case exam_ip.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExamIPMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exam_ip.FieldExamNameCode:
		return m.OldExamNameCode(ctx)
	case exam_ip.FieldExamName:
		return m.OldExamName(ctx)
	case exam_ip.FieldExamType:
		return m.OldExamType(ctx)
	case exam_ip.FieldNotificationCode:
		return m.OldNotificationCode(ctx)
	case exam_ip.FieldConductedBy:
		return m.OldConductedBy(ctx)
	case exam_ip.FieldNodalOffice:
		return m.OldNodalOffice(ctx)
	case exam_ip.FieldCalendarCode:
		return m.OldCalendarCode(ctx)
	case exam_ip.FieldPaperCode:
		return m.OldPaperCode(ctx)
	case exam_ip.FieldEligibleCadre:
		return m.OldEligibleCadre(ctx)
	case exam_ip.FieldEligiblePost1:
		return m.OldEligiblePost1(ctx)
	case exam_ip.FieldEligiblePost2:
		return m.OldEligiblePost2(ctx)
	case exam_ip.FieldEligiblePost3:
		return m.OldEligiblePost3(ctx)
	case exam_ip.FieldEligiblePost4:
		return m.OldEligiblePost4(ctx)
	case exam_ip.FieldEligiblePost5:
		return m.OldEligiblePost5(ctx)
	case exam_ip.FieldExamPost1:
		return m.OldExamPost1(ctx)
	case exam_ip.FieldExamPost2:
		return m.OldExamPost2(ctx)
	case exam_ip.FieldExamPost3:
		return m.OldExamPost3(ctx)
	case exam_ip.FieldExamPost4:
		return m.OldExamPost4(ctx)
	case exam_ip.FieldExamPost5:
		return m.OldExamPost5(ctx)
	case exam_ip.FieldEducationCriteria:
		return m.OldEducationCriteria(ctx)
	case exam_ip.FieldCategoryAgeLimitGEN:
		return m.OldCategoryAgeLimitGEN(ctx)
	case exam_ip.FieldCategoryAgeLimitSC:
		return m.OldCategoryAgeLimitSC(ctx)
	case exam_ip.FieldCategoryAgeLimitST:
		return m.OldCategoryAgeLimitST(ctx)
	case exam_ip.FieldServiceYears:
		return m.OldServiceYears(ctx)
	case exam_ip.FieldDrivingLicenseRequired:
		return m.OldDrivingLicenseRequired(ctx)
	case exam_ip.FieldExamPaperCode:
		return m.OldExamPaperCode(ctx)
	case exam_ip.FieldExamPaper1:
		return m.OldExamPaper1(ctx)
	case exam_ip.FieldExamPaper2:
		return m.OldExamPaper2(ctx)
	case exam_ip.FieldExamPaper3:
		return m.OldExamPaper3(ctx)
	case exam_ip.FieldExamPaper4:
		return m.OldExamPaper4(ctx)
	case exam_ip.FieldExamPaper5:
		return m.OldExamPaper5(ctx)
	case exam_ip.FieldExamPaper6:
		return m.OldExamPaper6(ctx)
	case exam_ip.FieldPayLevelEligibilty:
		return m.OldPayLevelEligibilty(ctx)
	case exam_ip.FieldCategoryMinMarksSCSTPH:
		return m.OldCategoryMinMarksSCSTPH(ctx)
	case exam_ip.FieldCategoryMinMarksGENOBC:
		return m.OldCategoryMinMarksGENOBC(ctx)
	case exam_ip.FieldLocalLanguageAllowed:
		return m.OldLocalLanguageAllowed(ctx)
	case exam_ip.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case exam_ip.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Exam_IP field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamIPMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exam_ip.FieldExamNameCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamNameCode(v)
		return nil
	case exam_ip.FieldExamName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamName(v)
		return nil
	case exam_ip.FieldExamType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamType(v)
		return nil
	case exam_ip.FieldNotificationCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotificationCode(v)
		return nil
	case exam_ip.FieldConductedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConductedBy(v)
		return nil
	case exam_ip.FieldNodalOffice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodalOffice(v)
		return nil
	case exam_ip.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalendarCode(v)
		return nil
	case exam_ip.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperCode(v)
		return nil
	case exam_ip.FieldEligibleCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligibleCadre(v)
		return nil
	case exam_ip.FieldEligiblePost1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost1(v)
		return nil
	case exam_ip.FieldEligiblePost2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost2(v)
		return nil
	case exam_ip.FieldEligiblePost3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost3(v)
		return nil
	case exam_ip.FieldEligiblePost4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost4(v)
		return nil
	case exam_ip.FieldEligiblePost5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost5(v)
		return nil
	case exam_ip.FieldExamPost1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost1(v)
		return nil
	case exam_ip.FieldExamPost2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost2(v)
		return nil
	case exam_ip.FieldExamPost3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost3(v)
		return nil
	case exam_ip.FieldExamPost4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost4(v)
		return nil
	case exam_ip.FieldExamPost5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost5(v)
		return nil
	case exam_ip.FieldEducationCriteria:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducationCriteria(v)
		return nil
	case exam_ip.FieldCategoryAgeLimitGEN:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryAgeLimitGEN(v)
		return nil
	case exam_ip.FieldCategoryAgeLimitSC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryAgeLimitSC(v)
		return nil
	case exam_ip.FieldCategoryAgeLimitST:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryAgeLimitST(v)
		return nil
	case exam_ip.FieldServiceYears:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceYears(v)
		return nil
	case exam_ip.FieldDrivingLicenseRequired:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrivingLicenseRequired(v)
		return nil
	case exam_ip.FieldExamPaperCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaperCode(v)
		return nil
	case exam_ip.FieldExamPaper1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper1(v)
		return nil
	case exam_ip.FieldExamPaper2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper2(v)
		return nil
	case exam_ip.FieldExamPaper3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper3(v)
		return nil
	case exam_ip.FieldExamPaper4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper4(v)
		return nil
	case exam_ip.FieldExamPaper5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper5(v)
		return nil
	case exam_ip.FieldExamPaper6:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper6(v)
		return nil
	case exam_ip.FieldPayLevelEligibilty:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayLevelEligibilty(v)
		return nil
	case exam_ip.FieldCategoryMinMarksSCSTPH:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryMinMarksSCSTPH(v)
		return nil
	case exam_ip.FieldCategoryMinMarksGENOBC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryMinMarksGENOBC(v)
		return nil
	case exam_ip.FieldLocalLanguageAllowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalLanguageAllowed(v)
		return nil
	case exam_ip.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case exam_ip.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Exam_IP field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExamIPMutation) AddedFields() []string {
	var fields []string
	if m.add_NotificationCode != nil {
		fields = append(fields, exam_ip.FieldNotificationCode)
	}
	if m.add_CalendarCode != nil {
		fields = append(fields, exam_ip.FieldCalendarCode)
	}
	if m.add_PaperCode != nil {
		fields = append(fields, exam_ip.FieldPaperCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExamIPMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exam_ip.FieldNotificationCode:
		return m.AddedNotificationCode()
	case exam_ip.FieldCalendarCode:
		return m.AddedCalendarCode()
	case exam_ip.FieldPaperCode:
		return m.AddedPaperCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamIPMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exam_ip.FieldNotificationCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotificationCode(v)
		return nil
	case exam_ip.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalendarCode(v)
		return nil
	case exam_ip.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaperCode(v)
		return nil
	}
	return fmt.Errorf("unknown Exam_IP numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExamIPMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exam_ip.FieldExamNameCode) {
		fields = append(fields, exam_ip.FieldExamNameCode)
	}
	if m.FieldCleared(exam_ip.FieldNotificationCode) {
		fields = append(fields, exam_ip.FieldNotificationCode)
	}
	if m.FieldCleared(exam_ip.FieldNodalOffice) {
		fields = append(fields, exam_ip.FieldNodalOffice)
	}
	if m.FieldCleared(exam_ip.FieldCalendarCode) {
		fields = append(fields, exam_ip.FieldCalendarCode)
	}
	if m.FieldCleared(exam_ip.FieldPaperCode) {
		fields = append(fields, exam_ip.FieldPaperCode)
	}
	if m.FieldCleared(exam_ip.FieldEligibleCadre) {
		fields = append(fields, exam_ip.FieldEligibleCadre)
	}
	if m.FieldCleared(exam_ip.FieldEligiblePost1) {
		fields = append(fields, exam_ip.FieldEligiblePost1)
	}
	if m.FieldCleared(exam_ip.FieldEligiblePost2) {
		fields = append(fields, exam_ip.FieldEligiblePost2)
	}
	if m.FieldCleared(exam_ip.FieldEligiblePost3) {
		fields = append(fields, exam_ip.FieldEligiblePost3)
	}
	if m.FieldCleared(exam_ip.FieldEligiblePost4) {
		fields = append(fields, exam_ip.FieldEligiblePost4)
	}
	if m.FieldCleared(exam_ip.FieldEligiblePost5) {
		fields = append(fields, exam_ip.FieldEligiblePost5)
	}
	if m.FieldCleared(exam_ip.FieldExamPost1) {
		fields = append(fields, exam_ip.FieldExamPost1)
	}
	if m.FieldCleared(exam_ip.FieldExamPost2) {
		fields = append(fields, exam_ip.FieldExamPost2)
	}
	if m.FieldCleared(exam_ip.FieldExamPost3) {
		fields = append(fields, exam_ip.FieldExamPost3)
	}
	if m.FieldCleared(exam_ip.FieldExamPost4) {
		fields = append(fields, exam_ip.FieldExamPost4)
	}
	if m.FieldCleared(exam_ip.FieldExamPost5) {
		fields = append(fields, exam_ip.FieldExamPost5)
	}
	if m.FieldCleared(exam_ip.FieldEducationCriteria) {
		fields = append(fields, exam_ip.FieldEducationCriteria)
	}
	if m.FieldCleared(exam_ip.FieldCategoryAgeLimitGEN) {
		fields = append(fields, exam_ip.FieldCategoryAgeLimitGEN)
	}
	if m.FieldCleared(exam_ip.FieldCategoryAgeLimitSC) {
		fields = append(fields, exam_ip.FieldCategoryAgeLimitSC)
	}
	if m.FieldCleared(exam_ip.FieldCategoryAgeLimitST) {
		fields = append(fields, exam_ip.FieldCategoryAgeLimitST)
	}
	if m.FieldCleared(exam_ip.FieldServiceYears) {
		fields = append(fields, exam_ip.FieldServiceYears)
	}
	if m.FieldCleared(exam_ip.FieldDrivingLicenseRequired) {
		fields = append(fields, exam_ip.FieldDrivingLicenseRequired)
	}
	if m.FieldCleared(exam_ip.FieldExamPaperCode) {
		fields = append(fields, exam_ip.FieldExamPaperCode)
	}
	if m.FieldCleared(exam_ip.FieldExamPaper1) {
		fields = append(fields, exam_ip.FieldExamPaper1)
	}
	if m.FieldCleared(exam_ip.FieldExamPaper2) {
		fields = append(fields, exam_ip.FieldExamPaper2)
	}
	if m.FieldCleared(exam_ip.FieldExamPaper3) {
		fields = append(fields, exam_ip.FieldExamPaper3)
	}
	if m.FieldCleared(exam_ip.FieldExamPaper4) {
		fields = append(fields, exam_ip.FieldExamPaper4)
	}
	if m.FieldCleared(exam_ip.FieldExamPaper5) {
		fields = append(fields, exam_ip.FieldExamPaper5)
	}
	if m.FieldCleared(exam_ip.FieldExamPaper6) {
		fields = append(fields, exam_ip.FieldExamPaper6)
	}
	if m.FieldCleared(exam_ip.FieldPayLevelEligibilty) {
		fields = append(fields, exam_ip.FieldPayLevelEligibilty)
	}
	if m.FieldCleared(exam_ip.FieldCategoryMinMarksSCSTPH) {
		fields = append(fields, exam_ip.FieldCategoryMinMarksSCSTPH)
	}
	if m.FieldCleared(exam_ip.FieldCategoryMinMarksGENOBC) {
		fields = append(fields, exam_ip.FieldCategoryMinMarksGENOBC)
	}
	if m.FieldCleared(exam_ip.FieldLocalLanguageAllowed) {
		fields = append(fields, exam_ip.FieldLocalLanguageAllowed)
	}
	if m.FieldCleared(exam_ip.FieldUpdatedAt) {
		fields = append(fields, exam_ip.FieldUpdatedAt)
	}
	if m.FieldCleared(exam_ip.FieldUpdatedBy) {
		fields = append(fields, exam_ip.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExamIPMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExamIPMutation) ClearField(name string) error {
	switch name {
	case exam_ip.FieldExamNameCode:
		m.ClearExamNameCode()
		return nil
	case exam_ip.FieldNotificationCode:
		m.ClearNotificationCode()
		return nil
	case exam_ip.FieldNodalOffice:
		m.ClearNodalOffice()
		return nil
	case exam_ip.FieldCalendarCode:
		m.ClearCalendarCode()
		return nil
	case exam_ip.FieldPaperCode:
		m.ClearPaperCode()
		return nil
	case exam_ip.FieldEligibleCadre:
		m.ClearEligibleCadre()
		return nil
	case exam_ip.FieldEligiblePost1:
		m.ClearEligiblePost1()
		return nil
	case exam_ip.FieldEligiblePost2:
		m.ClearEligiblePost2()
		return nil
	case exam_ip.FieldEligiblePost3:
		m.ClearEligiblePost3()
		return nil
	case exam_ip.FieldEligiblePost4:
		m.ClearEligiblePost4()
		return nil
	case exam_ip.FieldEligiblePost5:
		m.ClearEligiblePost5()
		return nil
	case exam_ip.FieldExamPost1:
		m.ClearExamPost1()
		return nil
	case exam_ip.FieldExamPost2:
		m.ClearExamPost2()
		return nil
	case exam_ip.FieldExamPost3:
		m.ClearExamPost3()
		return nil
	case exam_ip.FieldExamPost4:
		m.ClearExamPost4()
		return nil
	case exam_ip.FieldExamPost5:
		m.ClearExamPost5()
		return nil
	case exam_ip.FieldEducationCriteria:
		m.ClearEducationCriteria()
		return nil
	case exam_ip.FieldCategoryAgeLimitGEN:
		m.ClearCategoryAgeLimitGEN()
		return nil
	case exam_ip.FieldCategoryAgeLimitSC:
		m.ClearCategoryAgeLimitSC()
		return nil
	case exam_ip.FieldCategoryAgeLimitST:
		m.ClearCategoryAgeLimitST()
		return nil
	case exam_ip.FieldServiceYears:
		m.ClearServiceYears()
		return nil
	case exam_ip.FieldDrivingLicenseRequired:
		m.ClearDrivingLicenseRequired()
		return nil
	case exam_ip.FieldExamPaperCode:
		m.ClearExamPaperCode()
		return nil
	case exam_ip.FieldExamPaper1:
		m.ClearExamPaper1()
		return nil
	case exam_ip.FieldExamPaper2:
		m.ClearExamPaper2()
		return nil
	case exam_ip.FieldExamPaper3:
		m.ClearExamPaper3()
		return nil
	case exam_ip.FieldExamPaper4:
		m.ClearExamPaper4()
		return nil
	case exam_ip.FieldExamPaper5:
		m.ClearExamPaper5()
		return nil
	case exam_ip.FieldExamPaper6:
		m.ClearExamPaper6()
		return nil
	case exam_ip.FieldPayLevelEligibilty:
		m.ClearPayLevelEligibilty()
		return nil
	case exam_ip.FieldCategoryMinMarksSCSTPH:
		m.ClearCategoryMinMarksSCSTPH()
		return nil
	case exam_ip.FieldCategoryMinMarksGENOBC:
		m.ClearCategoryMinMarksGENOBC()
		return nil
	case exam_ip.FieldLocalLanguageAllowed:
		m.ClearLocalLanguageAllowed()
		return nil
	case exam_ip.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case exam_ip.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Exam_IP nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExamIPMutation) ResetField(name string) error {
	switch name {
	case exam_ip.FieldExamNameCode:
		m.ResetExamNameCode()
		return nil
	case exam_ip.FieldExamName:
		m.ResetExamName()
		return nil
	case exam_ip.FieldExamType:
		m.ResetExamType()
		return nil
	case exam_ip.FieldNotificationCode:
		m.ResetNotificationCode()
		return nil
	case exam_ip.FieldConductedBy:
		m.ResetConductedBy()
		return nil
	case exam_ip.FieldNodalOffice:
		m.ResetNodalOffice()
		return nil
	case exam_ip.FieldCalendarCode:
		m.ResetCalendarCode()
		return nil
	case exam_ip.FieldPaperCode:
		m.ResetPaperCode()
		return nil
	case exam_ip.FieldEligibleCadre:
		m.ResetEligibleCadre()
		return nil
	case exam_ip.FieldEligiblePost1:
		m.ResetEligiblePost1()
		return nil
	case exam_ip.FieldEligiblePost2:
		m.ResetEligiblePost2()
		return nil
	case exam_ip.FieldEligiblePost3:
		m.ResetEligiblePost3()
		return nil
	case exam_ip.FieldEligiblePost4:
		m.ResetEligiblePost4()
		return nil
	case exam_ip.FieldEligiblePost5:
		m.ResetEligiblePost5()
		return nil
	case exam_ip.FieldExamPost1:
		m.ResetExamPost1()
		return nil
	case exam_ip.FieldExamPost2:
		m.ResetExamPost2()
		return nil
	case exam_ip.FieldExamPost3:
		m.ResetExamPost3()
		return nil
	case exam_ip.FieldExamPost4:
		m.ResetExamPost4()
		return nil
	case exam_ip.FieldExamPost5:
		m.ResetExamPost5()
		return nil
	case exam_ip.FieldEducationCriteria:
		m.ResetEducationCriteria()
		return nil
	case exam_ip.FieldCategoryAgeLimitGEN:
		m.ResetCategoryAgeLimitGEN()
		return nil
	case exam_ip.FieldCategoryAgeLimitSC:
		m.ResetCategoryAgeLimitSC()
		return nil
	case exam_ip.FieldCategoryAgeLimitST:
		m.ResetCategoryAgeLimitST()
		return nil
	case exam_ip.FieldServiceYears:
		m.ResetServiceYears()
		return nil
	case exam_ip.FieldDrivingLicenseRequired:
		m.ResetDrivingLicenseRequired()
		return nil
	case exam_ip.FieldExamPaperCode:
		m.ResetExamPaperCode()
		return nil
	case exam_ip.FieldExamPaper1:
		m.ResetExamPaper1()
		return nil
	case exam_ip.FieldExamPaper2:
		m.ResetExamPaper2()
		return nil
	case exam_ip.FieldExamPaper3:
		m.ResetExamPaper3()
		return nil
	case exam_ip.FieldExamPaper4:
		m.ResetExamPaper4()
		return nil
	case exam_ip.FieldExamPaper5:
		m.ResetExamPaper5()
		return nil
	case exam_ip.FieldExamPaper6:
		m.ResetExamPaper6()
		return nil
	case exam_ip.FieldPayLevelEligibilty:
		m.ResetPayLevelEligibilty()
		return nil
	case exam_ip.FieldCategoryMinMarksSCSTPH:
		m.ResetCategoryMinMarksSCSTPH()
		return nil
	case exam_ip.FieldCategoryMinMarksGENOBC:
		m.ResetCategoryMinMarksGENOBC()
		return nil
	case exam_ip.FieldLocalLanguageAllowed:
		m.ResetLocalLanguageAllowed()
		return nil
	case exam_ip.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case exam_ip.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Exam_IP field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExamIPMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.examcal_ip_ref != nil {
		edges = append(edges, exam_ip.EdgeExamcalIPRef)
	}
	if m.papers_ip_ref != nil {
		edges = append(edges, exam_ip.EdgePapersIPRef)
	}
	if m.users_ip_type != nil {
		edges = append(edges, exam_ip.EdgeUsersIPType)
	}
	if m._ExamAppln_IP_Ref != nil {
		edges = append(edges, exam_ip.EdgeExamApplnIPRef)
	}
	if m.notifications_ip != nil {
		edges = append(edges, exam_ip.EdgeNotificationsIP)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExamIPMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exam_ip.EdgeExamcalIPRef:
		ids := make([]ent.Value, 0, len(m.examcal_ip_ref))
		for id := range m.examcal_ip_ref {
			ids = append(ids, id)
		}
		return ids
	case exam_ip.EdgePapersIPRef:
		ids := make([]ent.Value, 0, len(m.papers_ip_ref))
		for id := range m.papers_ip_ref {
			ids = append(ids, id)
		}
		return ids
	case exam_ip.EdgeUsersIPType:
		ids := make([]ent.Value, 0, len(m.users_ip_type))
		for id := range m.users_ip_type {
			ids = append(ids, id)
		}
		return ids
	case exam_ip.EdgeExamApplnIPRef:
		ids := make([]ent.Value, 0, len(m._ExamAppln_IP_Ref))
		for id := range m._ExamAppln_IP_Ref {
			ids = append(ids, id)
		}
		return ids
	case exam_ip.EdgeNotificationsIP:
		ids := make([]ent.Value, 0, len(m.notifications_ip))
		for id := range m.notifications_ip {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExamIPMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedexamcal_ip_ref != nil {
		edges = append(edges, exam_ip.EdgeExamcalIPRef)
	}
	if m.removedpapers_ip_ref != nil {
		edges = append(edges, exam_ip.EdgePapersIPRef)
	}
	if m.removedusers_ip_type != nil {
		edges = append(edges, exam_ip.EdgeUsersIPType)
	}
	if m.removed_ExamAppln_IP_Ref != nil {
		edges = append(edges, exam_ip.EdgeExamApplnIPRef)
	}
	if m.removednotifications_ip != nil {
		edges = append(edges, exam_ip.EdgeNotificationsIP)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExamIPMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exam_ip.EdgeExamcalIPRef:
		ids := make([]ent.Value, 0, len(m.removedexamcal_ip_ref))
		for id := range m.removedexamcal_ip_ref {
			ids = append(ids, id)
		}
		return ids
	case exam_ip.EdgePapersIPRef:
		ids := make([]ent.Value, 0, len(m.removedpapers_ip_ref))
		for id := range m.removedpapers_ip_ref {
			ids = append(ids, id)
		}
		return ids
	case exam_ip.EdgeUsersIPType:
		ids := make([]ent.Value, 0, len(m.removedusers_ip_type))
		for id := range m.removedusers_ip_type {
			ids = append(ids, id)
		}
		return ids
	case exam_ip.EdgeExamApplnIPRef:
		ids := make([]ent.Value, 0, len(m.removed_ExamAppln_IP_Ref))
		for id := range m.removed_ExamAppln_IP_Ref {
			ids = append(ids, id)
		}
		return ids
	case exam_ip.EdgeNotificationsIP:
		ids := make([]ent.Value, 0, len(m.removednotifications_ip))
		for id := range m.removednotifications_ip {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExamIPMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedexamcal_ip_ref {
		edges = append(edges, exam_ip.EdgeExamcalIPRef)
	}
	if m.clearedpapers_ip_ref {
		edges = append(edges, exam_ip.EdgePapersIPRef)
	}
	if m.clearedusers_ip_type {
		edges = append(edges, exam_ip.EdgeUsersIPType)
	}
	if m.cleared_ExamAppln_IP_Ref {
		edges = append(edges, exam_ip.EdgeExamApplnIPRef)
	}
	if m.clearednotifications_ip {
		edges = append(edges, exam_ip.EdgeNotificationsIP)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExamIPMutation) EdgeCleared(name string) bool {
	switch name {
	case exam_ip.EdgeExamcalIPRef:
		return m.clearedexamcal_ip_ref
	case exam_ip.EdgePapersIPRef:
		return m.clearedpapers_ip_ref
	case exam_ip.EdgeUsersIPType:
		return m.clearedusers_ip_type
	case exam_ip.EdgeExamApplnIPRef:
		return m.cleared_ExamAppln_IP_Ref
	case exam_ip.EdgeNotificationsIP:
		return m.clearednotifications_ip
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExamIPMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Exam_IP unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExamIPMutation) ResetEdge(name string) error {
	switch name {
	case exam_ip.EdgeExamcalIPRef:
		m.ResetExamcalIPRef()
		return nil
	case exam_ip.EdgePapersIPRef:
		m.ResetPapersIPRef()
		return nil
	case exam_ip.EdgeUsersIPType:
		m.ResetUsersIPType()
		return nil
	case exam_ip.EdgeExamApplnIPRef:
		m.ResetExamApplnIPRef()
		return nil
	case exam_ip.EdgeNotificationsIP:
		m.ResetNotificationsIP()
		return nil
	}
	return fmt.Errorf("unknown Exam_IP edge %s", name)
}

// ExamPAMutation represents an operation that mutates the Exam_PA nodes in the graph.
type ExamPAMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int32
	_ExamNameCode            *string
	_ExamName                *string
	_ExamType                *string
	_NotificationCode        *int32
	add_NotificationCode     *int32
	_ConductedBy             *string
	_NodalOffice             *string
	_CalendarCode            *int32
	add_CalendarCode         *int32
	_PaperCode               *int32
	add_PaperCode            *int32
	_EligibleCadre           *string
	_EligiblePost1           *string
	_EligiblePost2           *string
	_EligiblePost3           *string
	_EligiblePost4           *string
	_EligiblePost5           *string
	_ExamPost1               *string
	_ExamPost2               *string
	_ExamPost3               *string
	_ExamPost4               *string
	_ExamPost5               *string
	_EducationCriteria       *string
	_CategoryAgeLimitGEN     *string
	_CategoryAgeLimitSC      *string
	_CategoryAgeLimitST      *string
	_ServiceYears            *string
	_DrivingLicenseRequired  *string
	_ExamPaperCode           *string
	_ExamPaper1              *string
	_ExamPaper2              *string
	_ExamPaper3              *string
	_ExamPaper4              *string
	_ExamPaper5              *string
	_ExamPaper6              *string
	_PayLevelEligibilty      *bool
	_CategoryMinMarksSCSTPH  *string
	_CategoryMinMarksGENOBC  *string
	_LocalLanguageAllowed    *bool
	_UpdatedAt               *time.Time
	_UpdatedBy               *string
	clearedFields            map[string]struct{}
	examcal_ps_ref           map[int32]struct{}
	removedexamcal_ps_ref    map[int32]struct{}
	clearedexamcal_ps_ref    bool
	papers_ps_ref            map[int32]struct{}
	removedpapers_ps_ref     map[int32]struct{}
	clearedpapers_ps_ref     bool
	users_ps_type            map[int64]struct{}
	removedusers_ps_type     map[int64]struct{}
	clearedusers_ps_type     bool
	_ExamAppln_PS_Ref        map[int64]struct{}
	removed_ExamAppln_PS_Ref map[int64]struct{}
	cleared_ExamAppln_PS_Ref bool
	notifications_ps         map[int32]struct{}
	removednotifications_ps  map[int32]struct{}
	clearednotifications_ps  bool
	done                     bool
	oldValue                 func(context.Context) (*Exam_PA, error)
	predicates               []predicate.Exam_PA
}

var _ ent.Mutation = (*ExamPAMutation)(nil)

// examPAOption allows management of the mutation configuration using functional options.
type examPAOption func(*ExamPAMutation)

// newExamPAMutation creates new mutation for the Exam_PA entity.
func newExamPAMutation(c config, op Op, opts ...examPAOption) *ExamPAMutation {
	m := &ExamPAMutation{
		config:        c,
		op:            op,
		typ:           TypeExamPA,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExam_PAID sets the ID field of the mutation.
func withExam_PAID(id int32) examPAOption {
	return func(m *ExamPAMutation) {
		var (
			err   error
			once  sync.Once
			value *Exam_PA
		)
		m.oldValue = func(ctx context.Context) (*Exam_PA, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exam_PA.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExam_PA sets the old Exam_PA of the mutation.
func withExam_PA(node *Exam_PA) examPAOption {
	return func(m *ExamPAMutation) {
		m.oldValue = func(context.Context) (*Exam_PA, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExamPAMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExamPAMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exam_PA entities.
func (m *ExamPAMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExamPAMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExamPAMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exam_PA.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExamNameCode sets the "ExamNameCode" field.
func (m *ExamPAMutation) SetExamNameCode(s string) {
	m._ExamNameCode = &s
}

// ExamNameCode returns the value of the "ExamNameCode" field in the mutation.
func (m *ExamPAMutation) ExamNameCode() (r string, exists bool) {
	v := m._ExamNameCode
	if v == nil {
		return
	}
	return *v, true
}

// OldExamNameCode returns the old "ExamNameCode" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldExamNameCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamNameCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamNameCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamNameCode: %w", err)
	}
	return oldValue.ExamNameCode, nil
}

// ClearExamNameCode clears the value of the "ExamNameCode" field.
func (m *ExamPAMutation) ClearExamNameCode() {
	m._ExamNameCode = nil
	m.clearedFields[exam_pa.FieldExamNameCode] = struct{}{}
}

// ExamNameCodeCleared returns if the "ExamNameCode" field was cleared in this mutation.
func (m *ExamPAMutation) ExamNameCodeCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldExamNameCode]
	return ok
}

// ResetExamNameCode resets all changes to the "ExamNameCode" field.
func (m *ExamPAMutation) ResetExamNameCode() {
	m._ExamNameCode = nil
	delete(m.clearedFields, exam_pa.FieldExamNameCode)
}

// SetExamName sets the "ExamName" field.
func (m *ExamPAMutation) SetExamName(s string) {
	m._ExamName = &s
}

// ExamName returns the value of the "ExamName" field in the mutation.
func (m *ExamPAMutation) ExamName() (r string, exists bool) {
	v := m._ExamName
	if v == nil {
		return
	}
	return *v, true
}

// OldExamName returns the old "ExamName" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldExamName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamName: %w", err)
	}
	return oldValue.ExamName, nil
}

// ResetExamName resets all changes to the "ExamName" field.
func (m *ExamPAMutation) ResetExamName() {
	m._ExamName = nil
}

// SetExamType sets the "ExamType" field.
func (m *ExamPAMutation) SetExamType(s string) {
	m._ExamType = &s
}

// ExamType returns the value of the "ExamType" field in the mutation.
func (m *ExamPAMutation) ExamType() (r string, exists bool) {
	v := m._ExamType
	if v == nil {
		return
	}
	return *v, true
}

// OldExamType returns the old "ExamType" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldExamType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamType: %w", err)
	}
	return oldValue.ExamType, nil
}

// ResetExamType resets all changes to the "ExamType" field.
func (m *ExamPAMutation) ResetExamType() {
	m._ExamType = nil
}

// SetNotificationCode sets the "NotificationCode" field.
func (m *ExamPAMutation) SetNotificationCode(i int32) {
	m._NotificationCode = &i
	m.add_NotificationCode = nil
}

// NotificationCode returns the value of the "NotificationCode" field in the mutation.
func (m *ExamPAMutation) NotificationCode() (r int32, exists bool) {
	v := m._NotificationCode
	if v == nil {
		return
	}
	return *v, true
}

// OldNotificationCode returns the old "NotificationCode" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldNotificationCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotificationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotificationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotificationCode: %w", err)
	}
	return oldValue.NotificationCode, nil
}

// AddNotificationCode adds i to the "NotificationCode" field.
func (m *ExamPAMutation) AddNotificationCode(i int32) {
	if m.add_NotificationCode != nil {
		*m.add_NotificationCode += i
	} else {
		m.add_NotificationCode = &i
	}
}

// AddedNotificationCode returns the value that was added to the "NotificationCode" field in this mutation.
func (m *ExamPAMutation) AddedNotificationCode() (r int32, exists bool) {
	v := m.add_NotificationCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearNotificationCode clears the value of the "NotificationCode" field.
func (m *ExamPAMutation) ClearNotificationCode() {
	m._NotificationCode = nil
	m.add_NotificationCode = nil
	m.clearedFields[exam_pa.FieldNotificationCode] = struct{}{}
}

// NotificationCodeCleared returns if the "NotificationCode" field was cleared in this mutation.
func (m *ExamPAMutation) NotificationCodeCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldNotificationCode]
	return ok
}

// ResetNotificationCode resets all changes to the "NotificationCode" field.
func (m *ExamPAMutation) ResetNotificationCode() {
	m._NotificationCode = nil
	m.add_NotificationCode = nil
	delete(m.clearedFields, exam_pa.FieldNotificationCode)
}

// SetConductedBy sets the "ConductedBy" field.
func (m *ExamPAMutation) SetConductedBy(s string) {
	m._ConductedBy = &s
}

// ConductedBy returns the value of the "ConductedBy" field in the mutation.
func (m *ExamPAMutation) ConductedBy() (r string, exists bool) {
	v := m._ConductedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldConductedBy returns the old "ConductedBy" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldConductedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConductedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConductedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConductedBy: %w", err)
	}
	return oldValue.ConductedBy, nil
}

// ResetConductedBy resets all changes to the "ConductedBy" field.
func (m *ExamPAMutation) ResetConductedBy() {
	m._ConductedBy = nil
}

// SetNodalOffice sets the "NodalOffice" field.
func (m *ExamPAMutation) SetNodalOffice(s string) {
	m._NodalOffice = &s
}

// NodalOffice returns the value of the "NodalOffice" field in the mutation.
func (m *ExamPAMutation) NodalOffice() (r string, exists bool) {
	v := m._NodalOffice
	if v == nil {
		return
	}
	return *v, true
}

// OldNodalOffice returns the old "NodalOffice" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldNodalOffice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodalOffice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodalOffice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodalOffice: %w", err)
	}
	return oldValue.NodalOffice, nil
}

// ClearNodalOffice clears the value of the "NodalOffice" field.
func (m *ExamPAMutation) ClearNodalOffice() {
	m._NodalOffice = nil
	m.clearedFields[exam_pa.FieldNodalOffice] = struct{}{}
}

// NodalOfficeCleared returns if the "NodalOffice" field was cleared in this mutation.
func (m *ExamPAMutation) NodalOfficeCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldNodalOffice]
	return ok
}

// ResetNodalOffice resets all changes to the "NodalOffice" field.
func (m *ExamPAMutation) ResetNodalOffice() {
	m._NodalOffice = nil
	delete(m.clearedFields, exam_pa.FieldNodalOffice)
}

// SetCalendarCode sets the "CalendarCode" field.
func (m *ExamPAMutation) SetCalendarCode(i int32) {
	m._CalendarCode = &i
	m.add_CalendarCode = nil
}

// CalendarCode returns the value of the "CalendarCode" field in the mutation.
func (m *ExamPAMutation) CalendarCode() (r int32, exists bool) {
	v := m._CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCalendarCode returns the old "CalendarCode" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldCalendarCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalendarCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalendarCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalendarCode: %w", err)
	}
	return oldValue.CalendarCode, nil
}

// AddCalendarCode adds i to the "CalendarCode" field.
func (m *ExamPAMutation) AddCalendarCode(i int32) {
	if m.add_CalendarCode != nil {
		*m.add_CalendarCode += i
	} else {
		m.add_CalendarCode = &i
	}
}

// AddedCalendarCode returns the value that was added to the "CalendarCode" field in this mutation.
func (m *ExamPAMutation) AddedCalendarCode() (r int32, exists bool) {
	v := m.add_CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalendarCode clears the value of the "CalendarCode" field.
func (m *ExamPAMutation) ClearCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	m.clearedFields[exam_pa.FieldCalendarCode] = struct{}{}
}

// CalendarCodeCleared returns if the "CalendarCode" field was cleared in this mutation.
func (m *ExamPAMutation) CalendarCodeCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldCalendarCode]
	return ok
}

// ResetCalendarCode resets all changes to the "CalendarCode" field.
func (m *ExamPAMutation) ResetCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	delete(m.clearedFields, exam_pa.FieldCalendarCode)
}

// SetPaperCode sets the "PaperCode" field.
func (m *ExamPAMutation) SetPaperCode(i int32) {
	m._PaperCode = &i
	m.add_PaperCode = nil
}

// PaperCode returns the value of the "PaperCode" field in the mutation.
func (m *ExamPAMutation) PaperCode() (r int32, exists bool) {
	v := m._PaperCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperCode returns the old "PaperCode" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldPaperCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperCode: %w", err)
	}
	return oldValue.PaperCode, nil
}

// AddPaperCode adds i to the "PaperCode" field.
func (m *ExamPAMutation) AddPaperCode(i int32) {
	if m.add_PaperCode != nil {
		*m.add_PaperCode += i
	} else {
		m.add_PaperCode = &i
	}
}

// AddedPaperCode returns the value that was added to the "PaperCode" field in this mutation.
func (m *ExamPAMutation) AddedPaperCode() (r int32, exists bool) {
	v := m.add_PaperCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaperCode clears the value of the "PaperCode" field.
func (m *ExamPAMutation) ClearPaperCode() {
	m._PaperCode = nil
	m.add_PaperCode = nil
	m.clearedFields[exam_pa.FieldPaperCode] = struct{}{}
}

// PaperCodeCleared returns if the "PaperCode" field was cleared in this mutation.
func (m *ExamPAMutation) PaperCodeCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldPaperCode]
	return ok
}

// ResetPaperCode resets all changes to the "PaperCode" field.
func (m *ExamPAMutation) ResetPaperCode() {
	m._PaperCode = nil
	m.add_PaperCode = nil
	delete(m.clearedFields, exam_pa.FieldPaperCode)
}

// SetEligibleCadre sets the "EligibleCadre" field.
func (m *ExamPAMutation) SetEligibleCadre(s string) {
	m._EligibleCadre = &s
}

// EligibleCadre returns the value of the "EligibleCadre" field in the mutation.
func (m *ExamPAMutation) EligibleCadre() (r string, exists bool) {
	v := m._EligibleCadre
	if v == nil {
		return
	}
	return *v, true
}

// OldEligibleCadre returns the old "EligibleCadre" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldEligibleCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligibleCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligibleCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligibleCadre: %w", err)
	}
	return oldValue.EligibleCadre, nil
}

// ClearEligibleCadre clears the value of the "EligibleCadre" field.
func (m *ExamPAMutation) ClearEligibleCadre() {
	m._EligibleCadre = nil
	m.clearedFields[exam_pa.FieldEligibleCadre] = struct{}{}
}

// EligibleCadreCleared returns if the "EligibleCadre" field was cleared in this mutation.
func (m *ExamPAMutation) EligibleCadreCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldEligibleCadre]
	return ok
}

// ResetEligibleCadre resets all changes to the "EligibleCadre" field.
func (m *ExamPAMutation) ResetEligibleCadre() {
	m._EligibleCadre = nil
	delete(m.clearedFields, exam_pa.FieldEligibleCadre)
}

// SetEligiblePost1 sets the "EligiblePost1" field.
func (m *ExamPAMutation) SetEligiblePost1(s string) {
	m._EligiblePost1 = &s
}

// EligiblePost1 returns the value of the "EligiblePost1" field in the mutation.
func (m *ExamPAMutation) EligiblePost1() (r string, exists bool) {
	v := m._EligiblePost1
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost1 returns the old "EligiblePost1" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldEligiblePost1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost1: %w", err)
	}
	return oldValue.EligiblePost1, nil
}

// ClearEligiblePost1 clears the value of the "EligiblePost1" field.
func (m *ExamPAMutation) ClearEligiblePost1() {
	m._EligiblePost1 = nil
	m.clearedFields[exam_pa.FieldEligiblePost1] = struct{}{}
}

// EligiblePost1Cleared returns if the "EligiblePost1" field was cleared in this mutation.
func (m *ExamPAMutation) EligiblePost1Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldEligiblePost1]
	return ok
}

// ResetEligiblePost1 resets all changes to the "EligiblePost1" field.
func (m *ExamPAMutation) ResetEligiblePost1() {
	m._EligiblePost1 = nil
	delete(m.clearedFields, exam_pa.FieldEligiblePost1)
}

// SetEligiblePost2 sets the "EligiblePost2" field.
func (m *ExamPAMutation) SetEligiblePost2(s string) {
	m._EligiblePost2 = &s
}

// EligiblePost2 returns the value of the "EligiblePost2" field in the mutation.
func (m *ExamPAMutation) EligiblePost2() (r string, exists bool) {
	v := m._EligiblePost2
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost2 returns the old "EligiblePost2" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldEligiblePost2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost2: %w", err)
	}
	return oldValue.EligiblePost2, nil
}

// ClearEligiblePost2 clears the value of the "EligiblePost2" field.
func (m *ExamPAMutation) ClearEligiblePost2() {
	m._EligiblePost2 = nil
	m.clearedFields[exam_pa.FieldEligiblePost2] = struct{}{}
}

// EligiblePost2Cleared returns if the "EligiblePost2" field was cleared in this mutation.
func (m *ExamPAMutation) EligiblePost2Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldEligiblePost2]
	return ok
}

// ResetEligiblePost2 resets all changes to the "EligiblePost2" field.
func (m *ExamPAMutation) ResetEligiblePost2() {
	m._EligiblePost2 = nil
	delete(m.clearedFields, exam_pa.FieldEligiblePost2)
}

// SetEligiblePost3 sets the "EligiblePost3" field.
func (m *ExamPAMutation) SetEligiblePost3(s string) {
	m._EligiblePost3 = &s
}

// EligiblePost3 returns the value of the "EligiblePost3" field in the mutation.
func (m *ExamPAMutation) EligiblePost3() (r string, exists bool) {
	v := m._EligiblePost3
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost3 returns the old "EligiblePost3" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldEligiblePost3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost3: %w", err)
	}
	return oldValue.EligiblePost3, nil
}

// ClearEligiblePost3 clears the value of the "EligiblePost3" field.
func (m *ExamPAMutation) ClearEligiblePost3() {
	m._EligiblePost3 = nil
	m.clearedFields[exam_pa.FieldEligiblePost3] = struct{}{}
}

// EligiblePost3Cleared returns if the "EligiblePost3" field was cleared in this mutation.
func (m *ExamPAMutation) EligiblePost3Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldEligiblePost3]
	return ok
}

// ResetEligiblePost3 resets all changes to the "EligiblePost3" field.
func (m *ExamPAMutation) ResetEligiblePost3() {
	m._EligiblePost3 = nil
	delete(m.clearedFields, exam_pa.FieldEligiblePost3)
}

// SetEligiblePost4 sets the "EligiblePost4" field.
func (m *ExamPAMutation) SetEligiblePost4(s string) {
	m._EligiblePost4 = &s
}

// EligiblePost4 returns the value of the "EligiblePost4" field in the mutation.
func (m *ExamPAMutation) EligiblePost4() (r string, exists bool) {
	v := m._EligiblePost4
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost4 returns the old "EligiblePost4" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldEligiblePost4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost4: %w", err)
	}
	return oldValue.EligiblePost4, nil
}

// ClearEligiblePost4 clears the value of the "EligiblePost4" field.
func (m *ExamPAMutation) ClearEligiblePost4() {
	m._EligiblePost4 = nil
	m.clearedFields[exam_pa.FieldEligiblePost4] = struct{}{}
}

// EligiblePost4Cleared returns if the "EligiblePost4" field was cleared in this mutation.
func (m *ExamPAMutation) EligiblePost4Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldEligiblePost4]
	return ok
}

// ResetEligiblePost4 resets all changes to the "EligiblePost4" field.
func (m *ExamPAMutation) ResetEligiblePost4() {
	m._EligiblePost4 = nil
	delete(m.clearedFields, exam_pa.FieldEligiblePost4)
}

// SetEligiblePost5 sets the "EligiblePost5" field.
func (m *ExamPAMutation) SetEligiblePost5(s string) {
	m._EligiblePost5 = &s
}

// EligiblePost5 returns the value of the "EligiblePost5" field in the mutation.
func (m *ExamPAMutation) EligiblePost5() (r string, exists bool) {
	v := m._EligiblePost5
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost5 returns the old "EligiblePost5" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldEligiblePost5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost5: %w", err)
	}
	return oldValue.EligiblePost5, nil
}

// ClearEligiblePost5 clears the value of the "EligiblePost5" field.
func (m *ExamPAMutation) ClearEligiblePost5() {
	m._EligiblePost5 = nil
	m.clearedFields[exam_pa.FieldEligiblePost5] = struct{}{}
}

// EligiblePost5Cleared returns if the "EligiblePost5" field was cleared in this mutation.
func (m *ExamPAMutation) EligiblePost5Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldEligiblePost5]
	return ok
}

// ResetEligiblePost5 resets all changes to the "EligiblePost5" field.
func (m *ExamPAMutation) ResetEligiblePost5() {
	m._EligiblePost5 = nil
	delete(m.clearedFields, exam_pa.FieldEligiblePost5)
}

// SetExamPost1 sets the "ExamPost1" field.
func (m *ExamPAMutation) SetExamPost1(s string) {
	m._ExamPost1 = &s
}

// ExamPost1 returns the value of the "ExamPost1" field in the mutation.
func (m *ExamPAMutation) ExamPost1() (r string, exists bool) {
	v := m._ExamPost1
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost1 returns the old "ExamPost1" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldExamPost1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost1: %w", err)
	}
	return oldValue.ExamPost1, nil
}

// ClearExamPost1 clears the value of the "ExamPost1" field.
func (m *ExamPAMutation) ClearExamPost1() {
	m._ExamPost1 = nil
	m.clearedFields[exam_pa.FieldExamPost1] = struct{}{}
}

// ExamPost1Cleared returns if the "ExamPost1" field was cleared in this mutation.
func (m *ExamPAMutation) ExamPost1Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldExamPost1]
	return ok
}

// ResetExamPost1 resets all changes to the "ExamPost1" field.
func (m *ExamPAMutation) ResetExamPost1() {
	m._ExamPost1 = nil
	delete(m.clearedFields, exam_pa.FieldExamPost1)
}

// SetExamPost2 sets the "ExamPost2" field.
func (m *ExamPAMutation) SetExamPost2(s string) {
	m._ExamPost2 = &s
}

// ExamPost2 returns the value of the "ExamPost2" field in the mutation.
func (m *ExamPAMutation) ExamPost2() (r string, exists bool) {
	v := m._ExamPost2
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost2 returns the old "ExamPost2" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldExamPost2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost2: %w", err)
	}
	return oldValue.ExamPost2, nil
}

// ClearExamPost2 clears the value of the "ExamPost2" field.
func (m *ExamPAMutation) ClearExamPost2() {
	m._ExamPost2 = nil
	m.clearedFields[exam_pa.FieldExamPost2] = struct{}{}
}

// ExamPost2Cleared returns if the "ExamPost2" field was cleared in this mutation.
func (m *ExamPAMutation) ExamPost2Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldExamPost2]
	return ok
}

// ResetExamPost2 resets all changes to the "ExamPost2" field.
func (m *ExamPAMutation) ResetExamPost2() {
	m._ExamPost2 = nil
	delete(m.clearedFields, exam_pa.FieldExamPost2)
}

// SetExamPost3 sets the "ExamPost3" field.
func (m *ExamPAMutation) SetExamPost3(s string) {
	m._ExamPost3 = &s
}

// ExamPost3 returns the value of the "ExamPost3" field in the mutation.
func (m *ExamPAMutation) ExamPost3() (r string, exists bool) {
	v := m._ExamPost3
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost3 returns the old "ExamPost3" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldExamPost3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost3: %w", err)
	}
	return oldValue.ExamPost3, nil
}

// ClearExamPost3 clears the value of the "ExamPost3" field.
func (m *ExamPAMutation) ClearExamPost3() {
	m._ExamPost3 = nil
	m.clearedFields[exam_pa.FieldExamPost3] = struct{}{}
}

// ExamPost3Cleared returns if the "ExamPost3" field was cleared in this mutation.
func (m *ExamPAMutation) ExamPost3Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldExamPost3]
	return ok
}

// ResetExamPost3 resets all changes to the "ExamPost3" field.
func (m *ExamPAMutation) ResetExamPost3() {
	m._ExamPost3 = nil
	delete(m.clearedFields, exam_pa.FieldExamPost3)
}

// SetExamPost4 sets the "ExamPost4" field.
func (m *ExamPAMutation) SetExamPost4(s string) {
	m._ExamPost4 = &s
}

// ExamPost4 returns the value of the "ExamPost4" field in the mutation.
func (m *ExamPAMutation) ExamPost4() (r string, exists bool) {
	v := m._ExamPost4
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost4 returns the old "ExamPost4" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldExamPost4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost4: %w", err)
	}
	return oldValue.ExamPost4, nil
}

// ClearExamPost4 clears the value of the "ExamPost4" field.
func (m *ExamPAMutation) ClearExamPost4() {
	m._ExamPost4 = nil
	m.clearedFields[exam_pa.FieldExamPost4] = struct{}{}
}

// ExamPost4Cleared returns if the "ExamPost4" field was cleared in this mutation.
func (m *ExamPAMutation) ExamPost4Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldExamPost4]
	return ok
}

// ResetExamPost4 resets all changes to the "ExamPost4" field.
func (m *ExamPAMutation) ResetExamPost4() {
	m._ExamPost4 = nil
	delete(m.clearedFields, exam_pa.FieldExamPost4)
}

// SetExamPost5 sets the "ExamPost5" field.
func (m *ExamPAMutation) SetExamPost5(s string) {
	m._ExamPost5 = &s
}

// ExamPost5 returns the value of the "ExamPost5" field in the mutation.
func (m *ExamPAMutation) ExamPost5() (r string, exists bool) {
	v := m._ExamPost5
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost5 returns the old "ExamPost5" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldExamPost5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost5: %w", err)
	}
	return oldValue.ExamPost5, nil
}

// ClearExamPost5 clears the value of the "ExamPost5" field.
func (m *ExamPAMutation) ClearExamPost5() {
	m._ExamPost5 = nil
	m.clearedFields[exam_pa.FieldExamPost5] = struct{}{}
}

// ExamPost5Cleared returns if the "ExamPost5" field was cleared in this mutation.
func (m *ExamPAMutation) ExamPost5Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldExamPost5]
	return ok
}

// ResetExamPost5 resets all changes to the "ExamPost5" field.
func (m *ExamPAMutation) ResetExamPost5() {
	m._ExamPost5 = nil
	delete(m.clearedFields, exam_pa.FieldExamPost5)
}

// SetEducationCriteria sets the "EducationCriteria" field.
func (m *ExamPAMutation) SetEducationCriteria(s string) {
	m._EducationCriteria = &s
}

// EducationCriteria returns the value of the "EducationCriteria" field in the mutation.
func (m *ExamPAMutation) EducationCriteria() (r string, exists bool) {
	v := m._EducationCriteria
	if v == nil {
		return
	}
	return *v, true
}

// OldEducationCriteria returns the old "EducationCriteria" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldEducationCriteria(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducationCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducationCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducationCriteria: %w", err)
	}
	return oldValue.EducationCriteria, nil
}

// ClearEducationCriteria clears the value of the "EducationCriteria" field.
func (m *ExamPAMutation) ClearEducationCriteria() {
	m._EducationCriteria = nil
	m.clearedFields[exam_pa.FieldEducationCriteria] = struct{}{}
}

// EducationCriteriaCleared returns if the "EducationCriteria" field was cleared in this mutation.
func (m *ExamPAMutation) EducationCriteriaCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldEducationCriteria]
	return ok
}

// ResetEducationCriteria resets all changes to the "EducationCriteria" field.
func (m *ExamPAMutation) ResetEducationCriteria() {
	m._EducationCriteria = nil
	delete(m.clearedFields, exam_pa.FieldEducationCriteria)
}

// SetCategoryAgeLimitGEN sets the "CategoryAgeLimitGEN" field.
func (m *ExamPAMutation) SetCategoryAgeLimitGEN(s string) {
	m._CategoryAgeLimitGEN = &s
}

// CategoryAgeLimitGEN returns the value of the "CategoryAgeLimitGEN" field in the mutation.
func (m *ExamPAMutation) CategoryAgeLimitGEN() (r string, exists bool) {
	v := m._CategoryAgeLimitGEN
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryAgeLimitGEN returns the old "CategoryAgeLimitGEN" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldCategoryAgeLimitGEN(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryAgeLimitGEN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryAgeLimitGEN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryAgeLimitGEN: %w", err)
	}
	return oldValue.CategoryAgeLimitGEN, nil
}

// ClearCategoryAgeLimitGEN clears the value of the "CategoryAgeLimitGEN" field.
func (m *ExamPAMutation) ClearCategoryAgeLimitGEN() {
	m._CategoryAgeLimitGEN = nil
	m.clearedFields[exam_pa.FieldCategoryAgeLimitGEN] = struct{}{}
}

// CategoryAgeLimitGENCleared returns if the "CategoryAgeLimitGEN" field was cleared in this mutation.
func (m *ExamPAMutation) CategoryAgeLimitGENCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldCategoryAgeLimitGEN]
	return ok
}

// ResetCategoryAgeLimitGEN resets all changes to the "CategoryAgeLimitGEN" field.
func (m *ExamPAMutation) ResetCategoryAgeLimitGEN() {
	m._CategoryAgeLimitGEN = nil
	delete(m.clearedFields, exam_pa.FieldCategoryAgeLimitGEN)
}

// SetCategoryAgeLimitSC sets the "CategoryAgeLimitSC" field.
func (m *ExamPAMutation) SetCategoryAgeLimitSC(s string) {
	m._CategoryAgeLimitSC = &s
}

// CategoryAgeLimitSC returns the value of the "CategoryAgeLimitSC" field in the mutation.
func (m *ExamPAMutation) CategoryAgeLimitSC() (r string, exists bool) {
	v := m._CategoryAgeLimitSC
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryAgeLimitSC returns the old "CategoryAgeLimitSC" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldCategoryAgeLimitSC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryAgeLimitSC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryAgeLimitSC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryAgeLimitSC: %w", err)
	}
	return oldValue.CategoryAgeLimitSC, nil
}

// ClearCategoryAgeLimitSC clears the value of the "CategoryAgeLimitSC" field.
func (m *ExamPAMutation) ClearCategoryAgeLimitSC() {
	m._CategoryAgeLimitSC = nil
	m.clearedFields[exam_pa.FieldCategoryAgeLimitSC] = struct{}{}
}

// CategoryAgeLimitSCCleared returns if the "CategoryAgeLimitSC" field was cleared in this mutation.
func (m *ExamPAMutation) CategoryAgeLimitSCCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldCategoryAgeLimitSC]
	return ok
}

// ResetCategoryAgeLimitSC resets all changes to the "CategoryAgeLimitSC" field.
func (m *ExamPAMutation) ResetCategoryAgeLimitSC() {
	m._CategoryAgeLimitSC = nil
	delete(m.clearedFields, exam_pa.FieldCategoryAgeLimitSC)
}

// SetCategoryAgeLimitST sets the "CategoryAgeLimitST" field.
func (m *ExamPAMutation) SetCategoryAgeLimitST(s string) {
	m._CategoryAgeLimitST = &s
}

// CategoryAgeLimitST returns the value of the "CategoryAgeLimitST" field in the mutation.
func (m *ExamPAMutation) CategoryAgeLimitST() (r string, exists bool) {
	v := m._CategoryAgeLimitST
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryAgeLimitST returns the old "CategoryAgeLimitST" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldCategoryAgeLimitST(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryAgeLimitST is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryAgeLimitST requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryAgeLimitST: %w", err)
	}
	return oldValue.CategoryAgeLimitST, nil
}

// ClearCategoryAgeLimitST clears the value of the "CategoryAgeLimitST" field.
func (m *ExamPAMutation) ClearCategoryAgeLimitST() {
	m._CategoryAgeLimitST = nil
	m.clearedFields[exam_pa.FieldCategoryAgeLimitST] = struct{}{}
}

// CategoryAgeLimitSTCleared returns if the "CategoryAgeLimitST" field was cleared in this mutation.
func (m *ExamPAMutation) CategoryAgeLimitSTCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldCategoryAgeLimitST]
	return ok
}

// ResetCategoryAgeLimitST resets all changes to the "CategoryAgeLimitST" field.
func (m *ExamPAMutation) ResetCategoryAgeLimitST() {
	m._CategoryAgeLimitST = nil
	delete(m.clearedFields, exam_pa.FieldCategoryAgeLimitST)
}

// SetServiceYears sets the "ServiceYears" field.
func (m *ExamPAMutation) SetServiceYears(s string) {
	m._ServiceYears = &s
}

// ServiceYears returns the value of the "ServiceYears" field in the mutation.
func (m *ExamPAMutation) ServiceYears() (r string, exists bool) {
	v := m._ServiceYears
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceYears returns the old "ServiceYears" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldServiceYears(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceYears is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceYears requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceYears: %w", err)
	}
	return oldValue.ServiceYears, nil
}

// ClearServiceYears clears the value of the "ServiceYears" field.
func (m *ExamPAMutation) ClearServiceYears() {
	m._ServiceYears = nil
	m.clearedFields[exam_pa.FieldServiceYears] = struct{}{}
}

// ServiceYearsCleared returns if the "ServiceYears" field was cleared in this mutation.
func (m *ExamPAMutation) ServiceYearsCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldServiceYears]
	return ok
}

// ResetServiceYears resets all changes to the "ServiceYears" field.
func (m *ExamPAMutation) ResetServiceYears() {
	m._ServiceYears = nil
	delete(m.clearedFields, exam_pa.FieldServiceYears)
}

// SetDrivingLicenseRequired sets the "DrivingLicenseRequired" field.
func (m *ExamPAMutation) SetDrivingLicenseRequired(s string) {
	m._DrivingLicenseRequired = &s
}

// DrivingLicenseRequired returns the value of the "DrivingLicenseRequired" field in the mutation.
func (m *ExamPAMutation) DrivingLicenseRequired() (r string, exists bool) {
	v := m._DrivingLicenseRequired
	if v == nil {
		return
	}
	return *v, true
}

// OldDrivingLicenseRequired returns the old "DrivingLicenseRequired" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldDrivingLicenseRequired(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrivingLicenseRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrivingLicenseRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrivingLicenseRequired: %w", err)
	}
	return oldValue.DrivingLicenseRequired, nil
}

// ClearDrivingLicenseRequired clears the value of the "DrivingLicenseRequired" field.
func (m *ExamPAMutation) ClearDrivingLicenseRequired() {
	m._DrivingLicenseRequired = nil
	m.clearedFields[exam_pa.FieldDrivingLicenseRequired] = struct{}{}
}

// DrivingLicenseRequiredCleared returns if the "DrivingLicenseRequired" field was cleared in this mutation.
func (m *ExamPAMutation) DrivingLicenseRequiredCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldDrivingLicenseRequired]
	return ok
}

// ResetDrivingLicenseRequired resets all changes to the "DrivingLicenseRequired" field.
func (m *ExamPAMutation) ResetDrivingLicenseRequired() {
	m._DrivingLicenseRequired = nil
	delete(m.clearedFields, exam_pa.FieldDrivingLicenseRequired)
}

// SetExamPaperCode sets the "ExamPaperCode" field.
func (m *ExamPAMutation) SetExamPaperCode(s string) {
	m._ExamPaperCode = &s
}

// ExamPaperCode returns the value of the "ExamPaperCode" field in the mutation.
func (m *ExamPAMutation) ExamPaperCode() (r string, exists bool) {
	v := m._ExamPaperCode
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaperCode returns the old "ExamPaperCode" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldExamPaperCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaperCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaperCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaperCode: %w", err)
	}
	return oldValue.ExamPaperCode, nil
}

// ClearExamPaperCode clears the value of the "ExamPaperCode" field.
func (m *ExamPAMutation) ClearExamPaperCode() {
	m._ExamPaperCode = nil
	m.clearedFields[exam_pa.FieldExamPaperCode] = struct{}{}
}

// ExamPaperCodeCleared returns if the "ExamPaperCode" field was cleared in this mutation.
func (m *ExamPAMutation) ExamPaperCodeCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldExamPaperCode]
	return ok
}

// ResetExamPaperCode resets all changes to the "ExamPaperCode" field.
func (m *ExamPAMutation) ResetExamPaperCode() {
	m._ExamPaperCode = nil
	delete(m.clearedFields, exam_pa.FieldExamPaperCode)
}

// SetExamPaper1 sets the "ExamPaper1" field.
func (m *ExamPAMutation) SetExamPaper1(s string) {
	m._ExamPaper1 = &s
}

// ExamPaper1 returns the value of the "ExamPaper1" field in the mutation.
func (m *ExamPAMutation) ExamPaper1() (r string, exists bool) {
	v := m._ExamPaper1
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper1 returns the old "ExamPaper1" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldExamPaper1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper1: %w", err)
	}
	return oldValue.ExamPaper1, nil
}

// ClearExamPaper1 clears the value of the "ExamPaper1" field.
func (m *ExamPAMutation) ClearExamPaper1() {
	m._ExamPaper1 = nil
	m.clearedFields[exam_pa.FieldExamPaper1] = struct{}{}
}

// ExamPaper1Cleared returns if the "ExamPaper1" field was cleared in this mutation.
func (m *ExamPAMutation) ExamPaper1Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldExamPaper1]
	return ok
}

// ResetExamPaper1 resets all changes to the "ExamPaper1" field.
func (m *ExamPAMutation) ResetExamPaper1() {
	m._ExamPaper1 = nil
	delete(m.clearedFields, exam_pa.FieldExamPaper1)
}

// SetExamPaper2 sets the "ExamPaper2" field.
func (m *ExamPAMutation) SetExamPaper2(s string) {
	m._ExamPaper2 = &s
}

// ExamPaper2 returns the value of the "ExamPaper2" field in the mutation.
func (m *ExamPAMutation) ExamPaper2() (r string, exists bool) {
	v := m._ExamPaper2
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper2 returns the old "ExamPaper2" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldExamPaper2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper2: %w", err)
	}
	return oldValue.ExamPaper2, nil
}

// ClearExamPaper2 clears the value of the "ExamPaper2" field.
func (m *ExamPAMutation) ClearExamPaper2() {
	m._ExamPaper2 = nil
	m.clearedFields[exam_pa.FieldExamPaper2] = struct{}{}
}

// ExamPaper2Cleared returns if the "ExamPaper2" field was cleared in this mutation.
func (m *ExamPAMutation) ExamPaper2Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldExamPaper2]
	return ok
}

// ResetExamPaper2 resets all changes to the "ExamPaper2" field.
func (m *ExamPAMutation) ResetExamPaper2() {
	m._ExamPaper2 = nil
	delete(m.clearedFields, exam_pa.FieldExamPaper2)
}

// SetExamPaper3 sets the "ExamPaper3" field.
func (m *ExamPAMutation) SetExamPaper3(s string) {
	m._ExamPaper3 = &s
}

// ExamPaper3 returns the value of the "ExamPaper3" field in the mutation.
func (m *ExamPAMutation) ExamPaper3() (r string, exists bool) {
	v := m._ExamPaper3
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper3 returns the old "ExamPaper3" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldExamPaper3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper3: %w", err)
	}
	return oldValue.ExamPaper3, nil
}

// ClearExamPaper3 clears the value of the "ExamPaper3" field.
func (m *ExamPAMutation) ClearExamPaper3() {
	m._ExamPaper3 = nil
	m.clearedFields[exam_pa.FieldExamPaper3] = struct{}{}
}

// ExamPaper3Cleared returns if the "ExamPaper3" field was cleared in this mutation.
func (m *ExamPAMutation) ExamPaper3Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldExamPaper3]
	return ok
}

// ResetExamPaper3 resets all changes to the "ExamPaper3" field.
func (m *ExamPAMutation) ResetExamPaper3() {
	m._ExamPaper3 = nil
	delete(m.clearedFields, exam_pa.FieldExamPaper3)
}

// SetExamPaper4 sets the "ExamPaper4" field.
func (m *ExamPAMutation) SetExamPaper4(s string) {
	m._ExamPaper4 = &s
}

// ExamPaper4 returns the value of the "ExamPaper4" field in the mutation.
func (m *ExamPAMutation) ExamPaper4() (r string, exists bool) {
	v := m._ExamPaper4
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper4 returns the old "ExamPaper4" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldExamPaper4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper4: %w", err)
	}
	return oldValue.ExamPaper4, nil
}

// ClearExamPaper4 clears the value of the "ExamPaper4" field.
func (m *ExamPAMutation) ClearExamPaper4() {
	m._ExamPaper4 = nil
	m.clearedFields[exam_pa.FieldExamPaper4] = struct{}{}
}

// ExamPaper4Cleared returns if the "ExamPaper4" field was cleared in this mutation.
func (m *ExamPAMutation) ExamPaper4Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldExamPaper4]
	return ok
}

// ResetExamPaper4 resets all changes to the "ExamPaper4" field.
func (m *ExamPAMutation) ResetExamPaper4() {
	m._ExamPaper4 = nil
	delete(m.clearedFields, exam_pa.FieldExamPaper4)
}

// SetExamPaper5 sets the "ExamPaper5" field.
func (m *ExamPAMutation) SetExamPaper5(s string) {
	m._ExamPaper5 = &s
}

// ExamPaper5 returns the value of the "ExamPaper5" field in the mutation.
func (m *ExamPAMutation) ExamPaper5() (r string, exists bool) {
	v := m._ExamPaper5
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper5 returns the old "ExamPaper5" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldExamPaper5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper5: %w", err)
	}
	return oldValue.ExamPaper5, nil
}

// ClearExamPaper5 clears the value of the "ExamPaper5" field.
func (m *ExamPAMutation) ClearExamPaper5() {
	m._ExamPaper5 = nil
	m.clearedFields[exam_pa.FieldExamPaper5] = struct{}{}
}

// ExamPaper5Cleared returns if the "ExamPaper5" field was cleared in this mutation.
func (m *ExamPAMutation) ExamPaper5Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldExamPaper5]
	return ok
}

// ResetExamPaper5 resets all changes to the "ExamPaper5" field.
func (m *ExamPAMutation) ResetExamPaper5() {
	m._ExamPaper5 = nil
	delete(m.clearedFields, exam_pa.FieldExamPaper5)
}

// SetExamPaper6 sets the "ExamPaper6" field.
func (m *ExamPAMutation) SetExamPaper6(s string) {
	m._ExamPaper6 = &s
}

// ExamPaper6 returns the value of the "ExamPaper6" field in the mutation.
func (m *ExamPAMutation) ExamPaper6() (r string, exists bool) {
	v := m._ExamPaper6
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper6 returns the old "ExamPaper6" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldExamPaper6(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper6: %w", err)
	}
	return oldValue.ExamPaper6, nil
}

// ClearExamPaper6 clears the value of the "ExamPaper6" field.
func (m *ExamPAMutation) ClearExamPaper6() {
	m._ExamPaper6 = nil
	m.clearedFields[exam_pa.FieldExamPaper6] = struct{}{}
}

// ExamPaper6Cleared returns if the "ExamPaper6" field was cleared in this mutation.
func (m *ExamPAMutation) ExamPaper6Cleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldExamPaper6]
	return ok
}

// ResetExamPaper6 resets all changes to the "ExamPaper6" field.
func (m *ExamPAMutation) ResetExamPaper6() {
	m._ExamPaper6 = nil
	delete(m.clearedFields, exam_pa.FieldExamPaper6)
}

// SetPayLevelEligibilty sets the "PayLevelEligibilty" field.
func (m *ExamPAMutation) SetPayLevelEligibilty(b bool) {
	m._PayLevelEligibilty = &b
}

// PayLevelEligibilty returns the value of the "PayLevelEligibilty" field in the mutation.
func (m *ExamPAMutation) PayLevelEligibilty() (r bool, exists bool) {
	v := m._PayLevelEligibilty
	if v == nil {
		return
	}
	return *v, true
}

// OldPayLevelEligibilty returns the old "PayLevelEligibilty" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldPayLevelEligibilty(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayLevelEligibilty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayLevelEligibilty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayLevelEligibilty: %w", err)
	}
	return oldValue.PayLevelEligibilty, nil
}

// ClearPayLevelEligibilty clears the value of the "PayLevelEligibilty" field.
func (m *ExamPAMutation) ClearPayLevelEligibilty() {
	m._PayLevelEligibilty = nil
	m.clearedFields[exam_pa.FieldPayLevelEligibilty] = struct{}{}
}

// PayLevelEligibiltyCleared returns if the "PayLevelEligibilty" field was cleared in this mutation.
func (m *ExamPAMutation) PayLevelEligibiltyCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldPayLevelEligibilty]
	return ok
}

// ResetPayLevelEligibilty resets all changes to the "PayLevelEligibilty" field.
func (m *ExamPAMutation) ResetPayLevelEligibilty() {
	m._PayLevelEligibilty = nil
	delete(m.clearedFields, exam_pa.FieldPayLevelEligibilty)
}

// SetCategoryMinMarksSCSTPH sets the "CategoryMinMarksSCSTPH" field.
func (m *ExamPAMutation) SetCategoryMinMarksSCSTPH(s string) {
	m._CategoryMinMarksSCSTPH = &s
}

// CategoryMinMarksSCSTPH returns the value of the "CategoryMinMarksSCSTPH" field in the mutation.
func (m *ExamPAMutation) CategoryMinMarksSCSTPH() (r string, exists bool) {
	v := m._CategoryMinMarksSCSTPH
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryMinMarksSCSTPH returns the old "CategoryMinMarksSCSTPH" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldCategoryMinMarksSCSTPH(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryMinMarksSCSTPH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryMinMarksSCSTPH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryMinMarksSCSTPH: %w", err)
	}
	return oldValue.CategoryMinMarksSCSTPH, nil
}

// ClearCategoryMinMarksSCSTPH clears the value of the "CategoryMinMarksSCSTPH" field.
func (m *ExamPAMutation) ClearCategoryMinMarksSCSTPH() {
	m._CategoryMinMarksSCSTPH = nil
	m.clearedFields[exam_pa.FieldCategoryMinMarksSCSTPH] = struct{}{}
}

// CategoryMinMarksSCSTPHCleared returns if the "CategoryMinMarksSCSTPH" field was cleared in this mutation.
func (m *ExamPAMutation) CategoryMinMarksSCSTPHCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldCategoryMinMarksSCSTPH]
	return ok
}

// ResetCategoryMinMarksSCSTPH resets all changes to the "CategoryMinMarksSCSTPH" field.
func (m *ExamPAMutation) ResetCategoryMinMarksSCSTPH() {
	m._CategoryMinMarksSCSTPH = nil
	delete(m.clearedFields, exam_pa.FieldCategoryMinMarksSCSTPH)
}

// SetCategoryMinMarksGENOBC sets the "CategoryMinMarksGENOBC" field.
func (m *ExamPAMutation) SetCategoryMinMarksGENOBC(s string) {
	m._CategoryMinMarksGENOBC = &s
}

// CategoryMinMarksGENOBC returns the value of the "CategoryMinMarksGENOBC" field in the mutation.
func (m *ExamPAMutation) CategoryMinMarksGENOBC() (r string, exists bool) {
	v := m._CategoryMinMarksGENOBC
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryMinMarksGENOBC returns the old "CategoryMinMarksGENOBC" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldCategoryMinMarksGENOBC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryMinMarksGENOBC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryMinMarksGENOBC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryMinMarksGENOBC: %w", err)
	}
	return oldValue.CategoryMinMarksGENOBC, nil
}

// ClearCategoryMinMarksGENOBC clears the value of the "CategoryMinMarksGENOBC" field.
func (m *ExamPAMutation) ClearCategoryMinMarksGENOBC() {
	m._CategoryMinMarksGENOBC = nil
	m.clearedFields[exam_pa.FieldCategoryMinMarksGENOBC] = struct{}{}
}

// CategoryMinMarksGENOBCCleared returns if the "CategoryMinMarksGENOBC" field was cleared in this mutation.
func (m *ExamPAMutation) CategoryMinMarksGENOBCCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldCategoryMinMarksGENOBC]
	return ok
}

// ResetCategoryMinMarksGENOBC resets all changes to the "CategoryMinMarksGENOBC" field.
func (m *ExamPAMutation) ResetCategoryMinMarksGENOBC() {
	m._CategoryMinMarksGENOBC = nil
	delete(m.clearedFields, exam_pa.FieldCategoryMinMarksGENOBC)
}

// SetLocalLanguageAllowed sets the "LocalLanguageAllowed" field.
func (m *ExamPAMutation) SetLocalLanguageAllowed(b bool) {
	m._LocalLanguageAllowed = &b
}

// LocalLanguageAllowed returns the value of the "LocalLanguageAllowed" field in the mutation.
func (m *ExamPAMutation) LocalLanguageAllowed() (r bool, exists bool) {
	v := m._LocalLanguageAllowed
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalLanguageAllowed returns the old "LocalLanguageAllowed" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldLocalLanguageAllowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalLanguageAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalLanguageAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalLanguageAllowed: %w", err)
	}
	return oldValue.LocalLanguageAllowed, nil
}

// ClearLocalLanguageAllowed clears the value of the "LocalLanguageAllowed" field.
func (m *ExamPAMutation) ClearLocalLanguageAllowed() {
	m._LocalLanguageAllowed = nil
	m.clearedFields[exam_pa.FieldLocalLanguageAllowed] = struct{}{}
}

// LocalLanguageAllowedCleared returns if the "LocalLanguageAllowed" field was cleared in this mutation.
func (m *ExamPAMutation) LocalLanguageAllowedCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldLocalLanguageAllowed]
	return ok
}

// ResetLocalLanguageAllowed resets all changes to the "LocalLanguageAllowed" field.
func (m *ExamPAMutation) ResetLocalLanguageAllowed() {
	m._LocalLanguageAllowed = nil
	delete(m.clearedFields, exam_pa.FieldLocalLanguageAllowed)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *ExamPAMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *ExamPAMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *ExamPAMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[exam_pa.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *ExamPAMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *ExamPAMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, exam_pa.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *ExamPAMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *ExamPAMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the Exam_PA entity.
// If the Exam_PA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPAMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *ExamPAMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[exam_pa.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *ExamPAMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[exam_pa.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *ExamPAMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, exam_pa.FieldUpdatedBy)
}

// AddExamcalPsRefIDs adds the "examcal_ps_ref" edge to the ExamCalendar entity by ids.
func (m *ExamPAMutation) AddExamcalPsRefIDs(ids ...int32) {
	if m.examcal_ps_ref == nil {
		m.examcal_ps_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.examcal_ps_ref[ids[i]] = struct{}{}
	}
}

// ClearExamcalPsRef clears the "examcal_ps_ref" edge to the ExamCalendar entity.
func (m *ExamPAMutation) ClearExamcalPsRef() {
	m.clearedexamcal_ps_ref = true
}

// ExamcalPsRefCleared reports if the "examcal_ps_ref" edge to the ExamCalendar entity was cleared.
func (m *ExamPAMutation) ExamcalPsRefCleared() bool {
	return m.clearedexamcal_ps_ref
}

// RemoveExamcalPsRefIDs removes the "examcal_ps_ref" edge to the ExamCalendar entity by IDs.
func (m *ExamPAMutation) RemoveExamcalPsRefIDs(ids ...int32) {
	if m.removedexamcal_ps_ref == nil {
		m.removedexamcal_ps_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.examcal_ps_ref, ids[i])
		m.removedexamcal_ps_ref[ids[i]] = struct{}{}
	}
}

// RemovedExamcalPsRef returns the removed IDs of the "examcal_ps_ref" edge to the ExamCalendar entity.
func (m *ExamPAMutation) RemovedExamcalPsRefIDs() (ids []int32) {
	for id := range m.removedexamcal_ps_ref {
		ids = append(ids, id)
	}
	return
}

// ExamcalPsRefIDs returns the "examcal_ps_ref" edge IDs in the mutation.
func (m *ExamPAMutation) ExamcalPsRefIDs() (ids []int32) {
	for id := range m.examcal_ps_ref {
		ids = append(ids, id)
	}
	return
}

// ResetExamcalPsRef resets all changes to the "examcal_ps_ref" edge.
func (m *ExamPAMutation) ResetExamcalPsRef() {
	m.examcal_ps_ref = nil
	m.clearedexamcal_ps_ref = false
	m.removedexamcal_ps_ref = nil
}

// AddPapersPsRefIDs adds the "papers_ps_ref" edge to the ExamPapers entity by ids.
func (m *ExamPAMutation) AddPapersPsRefIDs(ids ...int32) {
	if m.papers_ps_ref == nil {
		m.papers_ps_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.papers_ps_ref[ids[i]] = struct{}{}
	}
}

// ClearPapersPsRef clears the "papers_ps_ref" edge to the ExamPapers entity.
func (m *ExamPAMutation) ClearPapersPsRef() {
	m.clearedpapers_ps_ref = true
}

// PapersPsRefCleared reports if the "papers_ps_ref" edge to the ExamPapers entity was cleared.
func (m *ExamPAMutation) PapersPsRefCleared() bool {
	return m.clearedpapers_ps_ref
}

// RemovePapersPsRefIDs removes the "papers_ps_ref" edge to the ExamPapers entity by IDs.
func (m *ExamPAMutation) RemovePapersPsRefIDs(ids ...int32) {
	if m.removedpapers_ps_ref == nil {
		m.removedpapers_ps_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.papers_ps_ref, ids[i])
		m.removedpapers_ps_ref[ids[i]] = struct{}{}
	}
}

// RemovedPapersPsRef returns the removed IDs of the "papers_ps_ref" edge to the ExamPapers entity.
func (m *ExamPAMutation) RemovedPapersPsRefIDs() (ids []int32) {
	for id := range m.removedpapers_ps_ref {
		ids = append(ids, id)
	}
	return
}

// PapersPsRefIDs returns the "papers_ps_ref" edge IDs in the mutation.
func (m *ExamPAMutation) PapersPsRefIDs() (ids []int32) {
	for id := range m.papers_ps_ref {
		ids = append(ids, id)
	}
	return
}

// ResetPapersPsRef resets all changes to the "papers_ps_ref" edge.
func (m *ExamPAMutation) ResetPapersPsRef() {
	m.papers_ps_ref = nil
	m.clearedpapers_ps_ref = false
	m.removedpapers_ps_ref = nil
}

// AddUsersPsTypeIDs adds the "users_ps_type" edge to the UserMaster entity by ids.
func (m *ExamPAMutation) AddUsersPsTypeIDs(ids ...int64) {
	if m.users_ps_type == nil {
		m.users_ps_type = make(map[int64]struct{})
	}
	for i := range ids {
		m.users_ps_type[ids[i]] = struct{}{}
	}
}

// ClearUsersPsType clears the "users_ps_type" edge to the UserMaster entity.
func (m *ExamPAMutation) ClearUsersPsType() {
	m.clearedusers_ps_type = true
}

// UsersPsTypeCleared reports if the "users_ps_type" edge to the UserMaster entity was cleared.
func (m *ExamPAMutation) UsersPsTypeCleared() bool {
	return m.clearedusers_ps_type
}

// RemoveUsersPsTypeIDs removes the "users_ps_type" edge to the UserMaster entity by IDs.
func (m *ExamPAMutation) RemoveUsersPsTypeIDs(ids ...int64) {
	if m.removedusers_ps_type == nil {
		m.removedusers_ps_type = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users_ps_type, ids[i])
		m.removedusers_ps_type[ids[i]] = struct{}{}
	}
}

// RemovedUsersPsType returns the removed IDs of the "users_ps_type" edge to the UserMaster entity.
func (m *ExamPAMutation) RemovedUsersPsTypeIDs() (ids []int64) {
	for id := range m.removedusers_ps_type {
		ids = append(ids, id)
	}
	return
}

// UsersPsTypeIDs returns the "users_ps_type" edge IDs in the mutation.
func (m *ExamPAMutation) UsersPsTypeIDs() (ids []int64) {
	for id := range m.users_ps_type {
		ids = append(ids, id)
	}
	return
}

// ResetUsersPsType resets all changes to the "users_ps_type" edge.
func (m *ExamPAMutation) ResetUsersPsType() {
	m.users_ps_type = nil
	m.clearedusers_ps_type = false
	m.removedusers_ps_type = nil
}

// AddExamApplnPSRefIDs adds the "ExamAppln_PS_Ref" edge to the Exam_Applications_PS entity by ids.
func (m *ExamPAMutation) AddExamApplnPSRefIDs(ids ...int64) {
	if m._ExamAppln_PS_Ref == nil {
		m._ExamAppln_PS_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		m._ExamAppln_PS_Ref[ids[i]] = struct{}{}
	}
}

// ClearExamApplnPSRef clears the "ExamAppln_PS_Ref" edge to the Exam_Applications_PS entity.
func (m *ExamPAMutation) ClearExamApplnPSRef() {
	m.cleared_ExamAppln_PS_Ref = true
}

// ExamApplnPSRefCleared reports if the "ExamAppln_PS_Ref" edge to the Exam_Applications_PS entity was cleared.
func (m *ExamPAMutation) ExamApplnPSRefCleared() bool {
	return m.cleared_ExamAppln_PS_Ref
}

// RemoveExamApplnPSRefIDs removes the "ExamAppln_PS_Ref" edge to the Exam_Applications_PS entity by IDs.
func (m *ExamPAMutation) RemoveExamApplnPSRefIDs(ids ...int64) {
	if m.removed_ExamAppln_PS_Ref == nil {
		m.removed_ExamAppln_PS_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._ExamAppln_PS_Ref, ids[i])
		m.removed_ExamAppln_PS_Ref[ids[i]] = struct{}{}
	}
}

// RemovedExamApplnPSRef returns the removed IDs of the "ExamAppln_PS_Ref" edge to the Exam_Applications_PS entity.
func (m *ExamPAMutation) RemovedExamApplnPSRefIDs() (ids []int64) {
	for id := range m.removed_ExamAppln_PS_Ref {
		ids = append(ids, id)
	}
	return
}

// ExamApplnPSRefIDs returns the "ExamAppln_PS_Ref" edge IDs in the mutation.
func (m *ExamPAMutation) ExamApplnPSRefIDs() (ids []int64) {
	for id := range m._ExamAppln_PS_Ref {
		ids = append(ids, id)
	}
	return
}

// ResetExamApplnPSRef resets all changes to the "ExamAppln_PS_Ref" edge.
func (m *ExamPAMutation) ResetExamApplnPSRef() {
	m._ExamAppln_PS_Ref = nil
	m.cleared_ExamAppln_PS_Ref = false
	m.removed_ExamAppln_PS_Ref = nil
}

// AddNotificationsPIDs adds the "notifications_ps" edge to the Notification entity by ids.
func (m *ExamPAMutation) AddNotificationsPIDs(ids ...int32) {
	if m.notifications_ps == nil {
		m.notifications_ps = make(map[int32]struct{})
	}
	for i := range ids {
		m.notifications_ps[ids[i]] = struct{}{}
	}
}

// ClearNotificationsPs clears the "notifications_ps" edge to the Notification entity.
func (m *ExamPAMutation) ClearNotificationsPs() {
	m.clearednotifications_ps = true
}

// NotificationsPsCleared reports if the "notifications_ps" edge to the Notification entity was cleared.
func (m *ExamPAMutation) NotificationsPsCleared() bool {
	return m.clearednotifications_ps
}

// RemoveNotificationsPIDs removes the "notifications_ps" edge to the Notification entity by IDs.
func (m *ExamPAMutation) RemoveNotificationsPIDs(ids ...int32) {
	if m.removednotifications_ps == nil {
		m.removednotifications_ps = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.notifications_ps, ids[i])
		m.removednotifications_ps[ids[i]] = struct{}{}
	}
}

// RemovedNotificationsPs returns the removed IDs of the "notifications_ps" edge to the Notification entity.
func (m *ExamPAMutation) RemovedNotificationsPsIDs() (ids []int32) {
	for id := range m.removednotifications_ps {
		ids = append(ids, id)
	}
	return
}

// NotificationsPsIDs returns the "notifications_ps" edge IDs in the mutation.
func (m *ExamPAMutation) NotificationsPsIDs() (ids []int32) {
	for id := range m.notifications_ps {
		ids = append(ids, id)
	}
	return
}

// ResetNotificationsPs resets all changes to the "notifications_ps" edge.
func (m *ExamPAMutation) ResetNotificationsPs() {
	m.notifications_ps = nil
	m.clearednotifications_ps = false
	m.removednotifications_ps = nil
}

// Where appends a list predicates to the ExamPAMutation builder.
func (m *ExamPAMutation) Where(ps ...predicate.Exam_PA) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExamPAMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExamPAMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exam_PA, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExamPAMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExamPAMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exam_PA).
func (m *ExamPAMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExamPAMutation) Fields() []string {
	fields := make([]string, 0, 38)
	if m._ExamNameCode != nil {
		fields = append(fields, exam_pa.FieldExamNameCode)
	}
	if m._ExamName != nil {
		fields = append(fields, exam_pa.FieldExamName)
	}
	if m._ExamType != nil {
		fields = append(fields, exam_pa.FieldExamType)
	}
	if m._NotificationCode != nil {
		fields = append(fields, exam_pa.FieldNotificationCode)
	}
	if m._ConductedBy != nil {
		fields = append(fields, exam_pa.FieldConductedBy)
	}
	if m._NodalOffice != nil {
		fields = append(fields, exam_pa.FieldNodalOffice)
	}
	if m._CalendarCode != nil {
		fields = append(fields, exam_pa.FieldCalendarCode)
	}
	if m._PaperCode != nil {
		fields = append(fields, exam_pa.FieldPaperCode)
	}
	if m._EligibleCadre != nil {
		fields = append(fields, exam_pa.FieldEligibleCadre)
	}
	if m._EligiblePost1 != nil {
		fields = append(fields, exam_pa.FieldEligiblePost1)
	}
	if m._EligiblePost2 != nil {
		fields = append(fields, exam_pa.FieldEligiblePost2)
	}
	if m._EligiblePost3 != nil {
		fields = append(fields, exam_pa.FieldEligiblePost3)
	}
	if m._EligiblePost4 != nil {
		fields = append(fields, exam_pa.FieldEligiblePost4)
	}
	if m._EligiblePost5 != nil {
		fields = append(fields, exam_pa.FieldEligiblePost5)
	}
	if m._ExamPost1 != nil {
		fields = append(fields, exam_pa.FieldExamPost1)
	}
	if m._ExamPost2 != nil {
		fields = append(fields, exam_pa.FieldExamPost2)
	}
	if m._ExamPost3 != nil {
		fields = append(fields, exam_pa.FieldExamPost3)
	}
	if m._ExamPost4 != nil {
		fields = append(fields, exam_pa.FieldExamPost4)
	}
	if m._ExamPost5 != nil {
		fields = append(fields, exam_pa.FieldExamPost5)
	}
	if m._EducationCriteria != nil {
		fields = append(fields, exam_pa.FieldEducationCriteria)
	}
	if m._CategoryAgeLimitGEN != nil {
		fields = append(fields, exam_pa.FieldCategoryAgeLimitGEN)
	}
	if m._CategoryAgeLimitSC != nil {
		fields = append(fields, exam_pa.FieldCategoryAgeLimitSC)
	}
	if m._CategoryAgeLimitST != nil {
		fields = append(fields, exam_pa.FieldCategoryAgeLimitST)
	}
	if m._ServiceYears != nil {
		fields = append(fields, exam_pa.FieldServiceYears)
	}
	if m._DrivingLicenseRequired != nil {
		fields = append(fields, exam_pa.FieldDrivingLicenseRequired)
	}
	if m._ExamPaperCode != nil {
		fields = append(fields, exam_pa.FieldExamPaperCode)
	}
	if m._ExamPaper1 != nil {
		fields = append(fields, exam_pa.FieldExamPaper1)
	}
	if m._ExamPaper2 != nil {
		fields = append(fields, exam_pa.FieldExamPaper2)
	}
	if m._ExamPaper3 != nil {
		fields = append(fields, exam_pa.FieldExamPaper3)
	}
	if m._ExamPaper4 != nil {
		fields = append(fields, exam_pa.FieldExamPaper4)
	}
	if m._ExamPaper5 != nil {
		fields = append(fields, exam_pa.FieldExamPaper5)
	}
	if m._ExamPaper6 != nil {
		fields = append(fields, exam_pa.FieldExamPaper6)
	}
	if m._PayLevelEligibilty != nil {
		fields = append(fields, exam_pa.FieldPayLevelEligibilty)
	}
	if m._CategoryMinMarksSCSTPH != nil {
		fields = append(fields, exam_pa.FieldCategoryMinMarksSCSTPH)
	}
	if m._CategoryMinMarksGENOBC != nil {
		fields = append(fields, exam_pa.FieldCategoryMinMarksGENOBC)
	}
	if m._LocalLanguageAllowed != nil {
		fields = append(fields, exam_pa.FieldLocalLanguageAllowed)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, exam_pa.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, exam_pa.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExamPAMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exam_pa.FieldExamNameCode:
		return m.ExamNameCode()
	case exam_pa.FieldExamName:
		return m.ExamName()
	case exam_pa.FieldExamType:
		return m.ExamType()
	case exam_pa.FieldNotificationCode:
		return m.NotificationCode()
	case exam_pa.FieldConductedBy:
		return m.ConductedBy()
	case exam_pa.FieldNodalOffice:
		return m.NodalOffice()
	case exam_pa.FieldCalendarCode:
		return m.CalendarCode()
	case exam_pa.FieldPaperCode:
		return m.PaperCode()
	case exam_pa.FieldEligibleCadre:
		return m.EligibleCadre()
	case exam_pa.FieldEligiblePost1:
		return m.EligiblePost1()
	case exam_pa.FieldEligiblePost2:
		return m.EligiblePost2()
	case exam_pa.FieldEligiblePost3:
		return m.EligiblePost3()
	case exam_pa.FieldEligiblePost4:
		return m.EligiblePost4()
	case exam_pa.FieldEligiblePost5:
		return m.EligiblePost5()
	case exam_pa.FieldExamPost1:
		return m.ExamPost1()
	case exam_pa.FieldExamPost2:
		return m.ExamPost2()
	case exam_pa.FieldExamPost3:
		return m.ExamPost3()
	case exam_pa.FieldExamPost4:
		return m.ExamPost4()
	case exam_pa.FieldExamPost5:
		return m.ExamPost5()
	case exam_pa.FieldEducationCriteria:
		return m.EducationCriteria()
	case exam_pa.FieldCategoryAgeLimitGEN:
		return m.CategoryAgeLimitGEN()
	case exam_pa.FieldCategoryAgeLimitSC:
		return m.CategoryAgeLimitSC()
	case exam_pa.FieldCategoryAgeLimitST:
		return m.CategoryAgeLimitST()
	case exam_pa.FieldServiceYears:
		return m.ServiceYears()
	case exam_pa.FieldDrivingLicenseRequired:
		return m.DrivingLicenseRequired()
	case exam_pa.FieldExamPaperCode:
		return m.ExamPaperCode()
	case exam_pa.FieldExamPaper1:
		return m.ExamPaper1()
	case exam_pa.FieldExamPaper2:
		return m.ExamPaper2()
	case exam_pa.FieldExamPaper3:
		return m.ExamPaper3()
	case exam_pa.FieldExamPaper4:
		return m.ExamPaper4()
	case exam_pa.FieldExamPaper5:
		return m.ExamPaper5()
	case exam_pa.FieldExamPaper6:
		return m.ExamPaper6()
	case exam_pa.FieldPayLevelEligibilty:
		return m.PayLevelEligibilty()
	case exam_pa.FieldCategoryMinMarksSCSTPH:
		return m.CategoryMinMarksSCSTPH()
	case exam_pa.FieldCategoryMinMarksGENOBC:
		return m.CategoryMinMarksGENOBC()
	case exam_pa.FieldLocalLanguageAllowed:
		return m.LocalLanguageAllowed()
	case exam_pa.FieldUpdatedAt:
		return m.UpdatedAt()
	case exam_pa.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExamPAMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exam_pa.FieldExamNameCode:
		return m.OldExamNameCode(ctx)
	case exam_pa.FieldExamName:
		return m.OldExamName(ctx)
	case exam_pa.FieldExamType:
		return m.OldExamType(ctx)
	case exam_pa.FieldNotificationCode:
		return m.OldNotificationCode(ctx)
	case exam_pa.FieldConductedBy:
		return m.OldConductedBy(ctx)
	case exam_pa.FieldNodalOffice:
		return m.OldNodalOffice(ctx)
	case exam_pa.FieldCalendarCode:
		return m.OldCalendarCode(ctx)
	case exam_pa.FieldPaperCode:
		return m.OldPaperCode(ctx)
	case exam_pa.FieldEligibleCadre:
		return m.OldEligibleCadre(ctx)
	case exam_pa.FieldEligiblePost1:
		return m.OldEligiblePost1(ctx)
	case exam_pa.FieldEligiblePost2:
		return m.OldEligiblePost2(ctx)
	case exam_pa.FieldEligiblePost3:
		return m.OldEligiblePost3(ctx)
	case exam_pa.FieldEligiblePost4:
		return m.OldEligiblePost4(ctx)
	case exam_pa.FieldEligiblePost5:
		return m.OldEligiblePost5(ctx)
	case exam_pa.FieldExamPost1:
		return m.OldExamPost1(ctx)
	case exam_pa.FieldExamPost2:
		return m.OldExamPost2(ctx)
	case exam_pa.FieldExamPost3:
		return m.OldExamPost3(ctx)
	case exam_pa.FieldExamPost4:
		return m.OldExamPost4(ctx)
	case exam_pa.FieldExamPost5:
		return m.OldExamPost5(ctx)
	case exam_pa.FieldEducationCriteria:
		return m.OldEducationCriteria(ctx)
	case exam_pa.FieldCategoryAgeLimitGEN:
		return m.OldCategoryAgeLimitGEN(ctx)
	case exam_pa.FieldCategoryAgeLimitSC:
		return m.OldCategoryAgeLimitSC(ctx)
	case exam_pa.FieldCategoryAgeLimitST:
		return m.OldCategoryAgeLimitST(ctx)
	case exam_pa.FieldServiceYears:
		return m.OldServiceYears(ctx)
	case exam_pa.FieldDrivingLicenseRequired:
		return m.OldDrivingLicenseRequired(ctx)
	case exam_pa.FieldExamPaperCode:
		return m.OldExamPaperCode(ctx)
	case exam_pa.FieldExamPaper1:
		return m.OldExamPaper1(ctx)
	case exam_pa.FieldExamPaper2:
		return m.OldExamPaper2(ctx)
	case exam_pa.FieldExamPaper3:
		return m.OldExamPaper3(ctx)
	case exam_pa.FieldExamPaper4:
		return m.OldExamPaper4(ctx)
	case exam_pa.FieldExamPaper5:
		return m.OldExamPaper5(ctx)
	case exam_pa.FieldExamPaper6:
		return m.OldExamPaper6(ctx)
	case exam_pa.FieldPayLevelEligibilty:
		return m.OldPayLevelEligibilty(ctx)
	case exam_pa.FieldCategoryMinMarksSCSTPH:
		return m.OldCategoryMinMarksSCSTPH(ctx)
	case exam_pa.FieldCategoryMinMarksGENOBC:
		return m.OldCategoryMinMarksGENOBC(ctx)
	case exam_pa.FieldLocalLanguageAllowed:
		return m.OldLocalLanguageAllowed(ctx)
	case exam_pa.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case exam_pa.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Exam_PA field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamPAMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exam_pa.FieldExamNameCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamNameCode(v)
		return nil
	case exam_pa.FieldExamName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamName(v)
		return nil
	case exam_pa.FieldExamType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamType(v)
		return nil
	case exam_pa.FieldNotificationCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotificationCode(v)
		return nil
	case exam_pa.FieldConductedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConductedBy(v)
		return nil
	case exam_pa.FieldNodalOffice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodalOffice(v)
		return nil
	case exam_pa.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalendarCode(v)
		return nil
	case exam_pa.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperCode(v)
		return nil
	case exam_pa.FieldEligibleCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligibleCadre(v)
		return nil
	case exam_pa.FieldEligiblePost1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost1(v)
		return nil
	case exam_pa.FieldEligiblePost2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost2(v)
		return nil
	case exam_pa.FieldEligiblePost3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost3(v)
		return nil
	case exam_pa.FieldEligiblePost4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost4(v)
		return nil
	case exam_pa.FieldEligiblePost5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost5(v)
		return nil
	case exam_pa.FieldExamPost1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost1(v)
		return nil
	case exam_pa.FieldExamPost2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost2(v)
		return nil
	case exam_pa.FieldExamPost3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost3(v)
		return nil
	case exam_pa.FieldExamPost4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost4(v)
		return nil
	case exam_pa.FieldExamPost5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost5(v)
		return nil
	case exam_pa.FieldEducationCriteria:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducationCriteria(v)
		return nil
	case exam_pa.FieldCategoryAgeLimitGEN:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryAgeLimitGEN(v)
		return nil
	case exam_pa.FieldCategoryAgeLimitSC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryAgeLimitSC(v)
		return nil
	case exam_pa.FieldCategoryAgeLimitST:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryAgeLimitST(v)
		return nil
	case exam_pa.FieldServiceYears:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceYears(v)
		return nil
	case exam_pa.FieldDrivingLicenseRequired:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrivingLicenseRequired(v)
		return nil
	case exam_pa.FieldExamPaperCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaperCode(v)
		return nil
	case exam_pa.FieldExamPaper1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper1(v)
		return nil
	case exam_pa.FieldExamPaper2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper2(v)
		return nil
	case exam_pa.FieldExamPaper3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper3(v)
		return nil
	case exam_pa.FieldExamPaper4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper4(v)
		return nil
	case exam_pa.FieldExamPaper5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper5(v)
		return nil
	case exam_pa.FieldExamPaper6:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper6(v)
		return nil
	case exam_pa.FieldPayLevelEligibilty:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayLevelEligibilty(v)
		return nil
	case exam_pa.FieldCategoryMinMarksSCSTPH:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryMinMarksSCSTPH(v)
		return nil
	case exam_pa.FieldCategoryMinMarksGENOBC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryMinMarksGENOBC(v)
		return nil
	case exam_pa.FieldLocalLanguageAllowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalLanguageAllowed(v)
		return nil
	case exam_pa.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case exam_pa.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Exam_PA field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExamPAMutation) AddedFields() []string {
	var fields []string
	if m.add_NotificationCode != nil {
		fields = append(fields, exam_pa.FieldNotificationCode)
	}
	if m.add_CalendarCode != nil {
		fields = append(fields, exam_pa.FieldCalendarCode)
	}
	if m.add_PaperCode != nil {
		fields = append(fields, exam_pa.FieldPaperCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExamPAMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exam_pa.FieldNotificationCode:
		return m.AddedNotificationCode()
	case exam_pa.FieldCalendarCode:
		return m.AddedCalendarCode()
	case exam_pa.FieldPaperCode:
		return m.AddedPaperCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamPAMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exam_pa.FieldNotificationCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotificationCode(v)
		return nil
	case exam_pa.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalendarCode(v)
		return nil
	case exam_pa.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaperCode(v)
		return nil
	}
	return fmt.Errorf("unknown Exam_PA numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExamPAMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exam_pa.FieldExamNameCode) {
		fields = append(fields, exam_pa.FieldExamNameCode)
	}
	if m.FieldCleared(exam_pa.FieldNotificationCode) {
		fields = append(fields, exam_pa.FieldNotificationCode)
	}
	if m.FieldCleared(exam_pa.FieldNodalOffice) {
		fields = append(fields, exam_pa.FieldNodalOffice)
	}
	if m.FieldCleared(exam_pa.FieldCalendarCode) {
		fields = append(fields, exam_pa.FieldCalendarCode)
	}
	if m.FieldCleared(exam_pa.FieldPaperCode) {
		fields = append(fields, exam_pa.FieldPaperCode)
	}
	if m.FieldCleared(exam_pa.FieldEligibleCadre) {
		fields = append(fields, exam_pa.FieldEligibleCadre)
	}
	if m.FieldCleared(exam_pa.FieldEligiblePost1) {
		fields = append(fields, exam_pa.FieldEligiblePost1)
	}
	if m.FieldCleared(exam_pa.FieldEligiblePost2) {
		fields = append(fields, exam_pa.FieldEligiblePost2)
	}
	if m.FieldCleared(exam_pa.FieldEligiblePost3) {
		fields = append(fields, exam_pa.FieldEligiblePost3)
	}
	if m.FieldCleared(exam_pa.FieldEligiblePost4) {
		fields = append(fields, exam_pa.FieldEligiblePost4)
	}
	if m.FieldCleared(exam_pa.FieldEligiblePost5) {
		fields = append(fields, exam_pa.FieldEligiblePost5)
	}
	if m.FieldCleared(exam_pa.FieldExamPost1) {
		fields = append(fields, exam_pa.FieldExamPost1)
	}
	if m.FieldCleared(exam_pa.FieldExamPost2) {
		fields = append(fields, exam_pa.FieldExamPost2)
	}
	if m.FieldCleared(exam_pa.FieldExamPost3) {
		fields = append(fields, exam_pa.FieldExamPost3)
	}
	if m.FieldCleared(exam_pa.FieldExamPost4) {
		fields = append(fields, exam_pa.FieldExamPost4)
	}
	if m.FieldCleared(exam_pa.FieldExamPost5) {
		fields = append(fields, exam_pa.FieldExamPost5)
	}
	if m.FieldCleared(exam_pa.FieldEducationCriteria) {
		fields = append(fields, exam_pa.FieldEducationCriteria)
	}
	if m.FieldCleared(exam_pa.FieldCategoryAgeLimitGEN) {
		fields = append(fields, exam_pa.FieldCategoryAgeLimitGEN)
	}
	if m.FieldCleared(exam_pa.FieldCategoryAgeLimitSC) {
		fields = append(fields, exam_pa.FieldCategoryAgeLimitSC)
	}
	if m.FieldCleared(exam_pa.FieldCategoryAgeLimitST) {
		fields = append(fields, exam_pa.FieldCategoryAgeLimitST)
	}
	if m.FieldCleared(exam_pa.FieldServiceYears) {
		fields = append(fields, exam_pa.FieldServiceYears)
	}
	if m.FieldCleared(exam_pa.FieldDrivingLicenseRequired) {
		fields = append(fields, exam_pa.FieldDrivingLicenseRequired)
	}
	if m.FieldCleared(exam_pa.FieldExamPaperCode) {
		fields = append(fields, exam_pa.FieldExamPaperCode)
	}
	if m.FieldCleared(exam_pa.FieldExamPaper1) {
		fields = append(fields, exam_pa.FieldExamPaper1)
	}
	if m.FieldCleared(exam_pa.FieldExamPaper2) {
		fields = append(fields, exam_pa.FieldExamPaper2)
	}
	if m.FieldCleared(exam_pa.FieldExamPaper3) {
		fields = append(fields, exam_pa.FieldExamPaper3)
	}
	if m.FieldCleared(exam_pa.FieldExamPaper4) {
		fields = append(fields, exam_pa.FieldExamPaper4)
	}
	if m.FieldCleared(exam_pa.FieldExamPaper5) {
		fields = append(fields, exam_pa.FieldExamPaper5)
	}
	if m.FieldCleared(exam_pa.FieldExamPaper6) {
		fields = append(fields, exam_pa.FieldExamPaper6)
	}
	if m.FieldCleared(exam_pa.FieldPayLevelEligibilty) {
		fields = append(fields, exam_pa.FieldPayLevelEligibilty)
	}
	if m.FieldCleared(exam_pa.FieldCategoryMinMarksSCSTPH) {
		fields = append(fields, exam_pa.FieldCategoryMinMarksSCSTPH)
	}
	if m.FieldCleared(exam_pa.FieldCategoryMinMarksGENOBC) {
		fields = append(fields, exam_pa.FieldCategoryMinMarksGENOBC)
	}
	if m.FieldCleared(exam_pa.FieldLocalLanguageAllowed) {
		fields = append(fields, exam_pa.FieldLocalLanguageAllowed)
	}
	if m.FieldCleared(exam_pa.FieldUpdatedAt) {
		fields = append(fields, exam_pa.FieldUpdatedAt)
	}
	if m.FieldCleared(exam_pa.FieldUpdatedBy) {
		fields = append(fields, exam_pa.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExamPAMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExamPAMutation) ClearField(name string) error {
	switch name {
	case exam_pa.FieldExamNameCode:
		m.ClearExamNameCode()
		return nil
	case exam_pa.FieldNotificationCode:
		m.ClearNotificationCode()
		return nil
	case exam_pa.FieldNodalOffice:
		m.ClearNodalOffice()
		return nil
	case exam_pa.FieldCalendarCode:
		m.ClearCalendarCode()
		return nil
	case exam_pa.FieldPaperCode:
		m.ClearPaperCode()
		return nil
	case exam_pa.FieldEligibleCadre:
		m.ClearEligibleCadre()
		return nil
	case exam_pa.FieldEligiblePost1:
		m.ClearEligiblePost1()
		return nil
	case exam_pa.FieldEligiblePost2:
		m.ClearEligiblePost2()
		return nil
	case exam_pa.FieldEligiblePost3:
		m.ClearEligiblePost3()
		return nil
	case exam_pa.FieldEligiblePost4:
		m.ClearEligiblePost4()
		return nil
	case exam_pa.FieldEligiblePost5:
		m.ClearEligiblePost5()
		return nil
	case exam_pa.FieldExamPost1:
		m.ClearExamPost1()
		return nil
	case exam_pa.FieldExamPost2:
		m.ClearExamPost2()
		return nil
	case exam_pa.FieldExamPost3:
		m.ClearExamPost3()
		return nil
	case exam_pa.FieldExamPost4:
		m.ClearExamPost4()
		return nil
	case exam_pa.FieldExamPost5:
		m.ClearExamPost5()
		return nil
	case exam_pa.FieldEducationCriteria:
		m.ClearEducationCriteria()
		return nil
	case exam_pa.FieldCategoryAgeLimitGEN:
		m.ClearCategoryAgeLimitGEN()
		return nil
	case exam_pa.FieldCategoryAgeLimitSC:
		m.ClearCategoryAgeLimitSC()
		return nil
	case exam_pa.FieldCategoryAgeLimitST:
		m.ClearCategoryAgeLimitST()
		return nil
	case exam_pa.FieldServiceYears:
		m.ClearServiceYears()
		return nil
	case exam_pa.FieldDrivingLicenseRequired:
		m.ClearDrivingLicenseRequired()
		return nil
	case exam_pa.FieldExamPaperCode:
		m.ClearExamPaperCode()
		return nil
	case exam_pa.FieldExamPaper1:
		m.ClearExamPaper1()
		return nil
	case exam_pa.FieldExamPaper2:
		m.ClearExamPaper2()
		return nil
	case exam_pa.FieldExamPaper3:
		m.ClearExamPaper3()
		return nil
	case exam_pa.FieldExamPaper4:
		m.ClearExamPaper4()
		return nil
	case exam_pa.FieldExamPaper5:
		m.ClearExamPaper5()
		return nil
	case exam_pa.FieldExamPaper6:
		m.ClearExamPaper6()
		return nil
	case exam_pa.FieldPayLevelEligibilty:
		m.ClearPayLevelEligibilty()
		return nil
	case exam_pa.FieldCategoryMinMarksSCSTPH:
		m.ClearCategoryMinMarksSCSTPH()
		return nil
	case exam_pa.FieldCategoryMinMarksGENOBC:
		m.ClearCategoryMinMarksGENOBC()
		return nil
	case exam_pa.FieldLocalLanguageAllowed:
		m.ClearLocalLanguageAllowed()
		return nil
	case exam_pa.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case exam_pa.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Exam_PA nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExamPAMutation) ResetField(name string) error {
	switch name {
	case exam_pa.FieldExamNameCode:
		m.ResetExamNameCode()
		return nil
	case exam_pa.FieldExamName:
		m.ResetExamName()
		return nil
	case exam_pa.FieldExamType:
		m.ResetExamType()
		return nil
	case exam_pa.FieldNotificationCode:
		m.ResetNotificationCode()
		return nil
	case exam_pa.FieldConductedBy:
		m.ResetConductedBy()
		return nil
	case exam_pa.FieldNodalOffice:
		m.ResetNodalOffice()
		return nil
	case exam_pa.FieldCalendarCode:
		m.ResetCalendarCode()
		return nil
	case exam_pa.FieldPaperCode:
		m.ResetPaperCode()
		return nil
	case exam_pa.FieldEligibleCadre:
		m.ResetEligibleCadre()
		return nil
	case exam_pa.FieldEligiblePost1:
		m.ResetEligiblePost1()
		return nil
	case exam_pa.FieldEligiblePost2:
		m.ResetEligiblePost2()
		return nil
	case exam_pa.FieldEligiblePost3:
		m.ResetEligiblePost3()
		return nil
	case exam_pa.FieldEligiblePost4:
		m.ResetEligiblePost4()
		return nil
	case exam_pa.FieldEligiblePost5:
		m.ResetEligiblePost5()
		return nil
	case exam_pa.FieldExamPost1:
		m.ResetExamPost1()
		return nil
	case exam_pa.FieldExamPost2:
		m.ResetExamPost2()
		return nil
	case exam_pa.FieldExamPost3:
		m.ResetExamPost3()
		return nil
	case exam_pa.FieldExamPost4:
		m.ResetExamPost4()
		return nil
	case exam_pa.FieldExamPost5:
		m.ResetExamPost5()
		return nil
	case exam_pa.FieldEducationCriteria:
		m.ResetEducationCriteria()
		return nil
	case exam_pa.FieldCategoryAgeLimitGEN:
		m.ResetCategoryAgeLimitGEN()
		return nil
	case exam_pa.FieldCategoryAgeLimitSC:
		m.ResetCategoryAgeLimitSC()
		return nil
	case exam_pa.FieldCategoryAgeLimitST:
		m.ResetCategoryAgeLimitST()
		return nil
	case exam_pa.FieldServiceYears:
		m.ResetServiceYears()
		return nil
	case exam_pa.FieldDrivingLicenseRequired:
		m.ResetDrivingLicenseRequired()
		return nil
	case exam_pa.FieldExamPaperCode:
		m.ResetExamPaperCode()
		return nil
	case exam_pa.FieldExamPaper1:
		m.ResetExamPaper1()
		return nil
	case exam_pa.FieldExamPaper2:
		m.ResetExamPaper2()
		return nil
	case exam_pa.FieldExamPaper3:
		m.ResetExamPaper3()
		return nil
	case exam_pa.FieldExamPaper4:
		m.ResetExamPaper4()
		return nil
	case exam_pa.FieldExamPaper5:
		m.ResetExamPaper5()
		return nil
	case exam_pa.FieldExamPaper6:
		m.ResetExamPaper6()
		return nil
	case exam_pa.FieldPayLevelEligibilty:
		m.ResetPayLevelEligibilty()
		return nil
	case exam_pa.FieldCategoryMinMarksSCSTPH:
		m.ResetCategoryMinMarksSCSTPH()
		return nil
	case exam_pa.FieldCategoryMinMarksGENOBC:
		m.ResetCategoryMinMarksGENOBC()
		return nil
	case exam_pa.FieldLocalLanguageAllowed:
		m.ResetLocalLanguageAllowed()
		return nil
	case exam_pa.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case exam_pa.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Exam_PA field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExamPAMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.examcal_ps_ref != nil {
		edges = append(edges, exam_pa.EdgeExamcalPsRef)
	}
	if m.papers_ps_ref != nil {
		edges = append(edges, exam_pa.EdgePapersPsRef)
	}
	if m.users_ps_type != nil {
		edges = append(edges, exam_pa.EdgeUsersPsType)
	}
	if m._ExamAppln_PS_Ref != nil {
		edges = append(edges, exam_pa.EdgeExamApplnPSRef)
	}
	if m.notifications_ps != nil {
		edges = append(edges, exam_pa.EdgeNotificationsPs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExamPAMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exam_pa.EdgeExamcalPsRef:
		ids := make([]ent.Value, 0, len(m.examcal_ps_ref))
		for id := range m.examcal_ps_ref {
			ids = append(ids, id)
		}
		return ids
	case exam_pa.EdgePapersPsRef:
		ids := make([]ent.Value, 0, len(m.papers_ps_ref))
		for id := range m.papers_ps_ref {
			ids = append(ids, id)
		}
		return ids
	case exam_pa.EdgeUsersPsType:
		ids := make([]ent.Value, 0, len(m.users_ps_type))
		for id := range m.users_ps_type {
			ids = append(ids, id)
		}
		return ids
	case exam_pa.EdgeExamApplnPSRef:
		ids := make([]ent.Value, 0, len(m._ExamAppln_PS_Ref))
		for id := range m._ExamAppln_PS_Ref {
			ids = append(ids, id)
		}
		return ids
	case exam_pa.EdgeNotificationsPs:
		ids := make([]ent.Value, 0, len(m.notifications_ps))
		for id := range m.notifications_ps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExamPAMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedexamcal_ps_ref != nil {
		edges = append(edges, exam_pa.EdgeExamcalPsRef)
	}
	if m.removedpapers_ps_ref != nil {
		edges = append(edges, exam_pa.EdgePapersPsRef)
	}
	if m.removedusers_ps_type != nil {
		edges = append(edges, exam_pa.EdgeUsersPsType)
	}
	if m.removed_ExamAppln_PS_Ref != nil {
		edges = append(edges, exam_pa.EdgeExamApplnPSRef)
	}
	if m.removednotifications_ps != nil {
		edges = append(edges, exam_pa.EdgeNotificationsPs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExamPAMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exam_pa.EdgeExamcalPsRef:
		ids := make([]ent.Value, 0, len(m.removedexamcal_ps_ref))
		for id := range m.removedexamcal_ps_ref {
			ids = append(ids, id)
		}
		return ids
	case exam_pa.EdgePapersPsRef:
		ids := make([]ent.Value, 0, len(m.removedpapers_ps_ref))
		for id := range m.removedpapers_ps_ref {
			ids = append(ids, id)
		}
		return ids
	case exam_pa.EdgeUsersPsType:
		ids := make([]ent.Value, 0, len(m.removedusers_ps_type))
		for id := range m.removedusers_ps_type {
			ids = append(ids, id)
		}
		return ids
	case exam_pa.EdgeExamApplnPSRef:
		ids := make([]ent.Value, 0, len(m.removed_ExamAppln_PS_Ref))
		for id := range m.removed_ExamAppln_PS_Ref {
			ids = append(ids, id)
		}
		return ids
	case exam_pa.EdgeNotificationsPs:
		ids := make([]ent.Value, 0, len(m.removednotifications_ps))
		for id := range m.removednotifications_ps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExamPAMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedexamcal_ps_ref {
		edges = append(edges, exam_pa.EdgeExamcalPsRef)
	}
	if m.clearedpapers_ps_ref {
		edges = append(edges, exam_pa.EdgePapersPsRef)
	}
	if m.clearedusers_ps_type {
		edges = append(edges, exam_pa.EdgeUsersPsType)
	}
	if m.cleared_ExamAppln_PS_Ref {
		edges = append(edges, exam_pa.EdgeExamApplnPSRef)
	}
	if m.clearednotifications_ps {
		edges = append(edges, exam_pa.EdgeNotificationsPs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExamPAMutation) EdgeCleared(name string) bool {
	switch name {
	case exam_pa.EdgeExamcalPsRef:
		return m.clearedexamcal_ps_ref
	case exam_pa.EdgePapersPsRef:
		return m.clearedpapers_ps_ref
	case exam_pa.EdgeUsersPsType:
		return m.clearedusers_ps_type
	case exam_pa.EdgeExamApplnPSRef:
		return m.cleared_ExamAppln_PS_Ref
	case exam_pa.EdgeNotificationsPs:
		return m.clearednotifications_ps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExamPAMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Exam_PA unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExamPAMutation) ResetEdge(name string) error {
	switch name {
	case exam_pa.EdgeExamcalPsRef:
		m.ResetExamcalPsRef()
		return nil
	case exam_pa.EdgePapersPsRef:
		m.ResetPapersPsRef()
		return nil
	case exam_pa.EdgeUsersPsType:
		m.ResetUsersPsType()
		return nil
	case exam_pa.EdgeExamApplnPSRef:
		m.ResetExamApplnPSRef()
		return nil
	case exam_pa.EdgeNotificationsPs:
		m.ResetNotificationsPs()
		return nil
	}
	return fmt.Errorf("unknown Exam_PA edge %s", name)
}

// ExamPMMutation represents an operation that mutates the Exam_PM nodes in the graph.
type ExamPMMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int32
	_ExamNameCode           *string
	_ExamName               *string
	_ExamType               *string
	_NotificationCode       *int32
	add_NotificationCode    *int32
	_ConductedBy            *string
	_NodalOffice            *string
	_CalendarCode           *int32
	add_CalendarCode        *int32
	_PaperCode              *int32
	add_PaperCode           *int32
	_EligibleCadre          *string
	_EligiblePost1          *string
	_EligiblePost2          *string
	_EligiblePost3          *string
	_EligiblePost4          *string
	_EligiblePost5          *string
	_ExamPost1              *string
	_ExamPost2              *string
	_ExamPost3              *string
	_ExamPost4              *string
	_ExamPost5              *string
	_EducationCriteria      *string
	_CategoryAgeLimitGEN    *string
	_CategoryAgeLimitSC     *string
	_CategoryAgeLimitST     *string
	_ServiceYears           *string
	_DrivingLicenseRequired *string
	_ExamPaperCode          *string
	_ExamPaper1             *string
	_ExamPaper2             *string
	_ExamPaper3             *string
	_ExamPaper4             *string
	_ExamPaper5             *string
	_ExamPaper6             *string
	_PayLevelEligibilty     *bool
	_CategoryMinMarksSCSTPH *string
	_CategoryMinMarksGENOBC *string
	_LocalLanguageAllowed   *bool
	_UpdatedAt              *time.Time
	_UpdatedBy              *string
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*Exam_PM, error)
	predicates              []predicate.Exam_PM
}

var _ ent.Mutation = (*ExamPMMutation)(nil)

// examPMOption allows management of the mutation configuration using functional options.
type examPMOption func(*ExamPMMutation)

// newExamPMMutation creates new mutation for the Exam_PM entity.
func newExamPMMutation(c config, op Op, opts ...examPMOption) *ExamPMMutation {
	m := &ExamPMMutation{
		config:        c,
		op:            op,
		typ:           TypeExamPM,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExam_PMID sets the ID field of the mutation.
func withExam_PMID(id int32) examPMOption {
	return func(m *ExamPMMutation) {
		var (
			err   error
			once  sync.Once
			value *Exam_PM
		)
		m.oldValue = func(ctx context.Context) (*Exam_PM, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exam_PM.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExam_PM sets the old Exam_PM of the mutation.
func withExam_PM(node *Exam_PM) examPMOption {
	return func(m *ExamPMMutation) {
		m.oldValue = func(context.Context) (*Exam_PM, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExamPMMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExamPMMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exam_PM entities.
func (m *ExamPMMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExamPMMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExamPMMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exam_PM.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExamNameCode sets the "ExamNameCode" field.
func (m *ExamPMMutation) SetExamNameCode(s string) {
	m._ExamNameCode = &s
}

// ExamNameCode returns the value of the "ExamNameCode" field in the mutation.
func (m *ExamPMMutation) ExamNameCode() (r string, exists bool) {
	v := m._ExamNameCode
	if v == nil {
		return
	}
	return *v, true
}

// OldExamNameCode returns the old "ExamNameCode" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldExamNameCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamNameCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamNameCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamNameCode: %w", err)
	}
	return oldValue.ExamNameCode, nil
}

// ClearExamNameCode clears the value of the "ExamNameCode" field.
func (m *ExamPMMutation) ClearExamNameCode() {
	m._ExamNameCode = nil
	m.clearedFields[exam_pm.FieldExamNameCode] = struct{}{}
}

// ExamNameCodeCleared returns if the "ExamNameCode" field was cleared in this mutation.
func (m *ExamPMMutation) ExamNameCodeCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldExamNameCode]
	return ok
}

// ResetExamNameCode resets all changes to the "ExamNameCode" field.
func (m *ExamPMMutation) ResetExamNameCode() {
	m._ExamNameCode = nil
	delete(m.clearedFields, exam_pm.FieldExamNameCode)
}

// SetExamName sets the "ExamName" field.
func (m *ExamPMMutation) SetExamName(s string) {
	m._ExamName = &s
}

// ExamName returns the value of the "ExamName" field in the mutation.
func (m *ExamPMMutation) ExamName() (r string, exists bool) {
	v := m._ExamName
	if v == nil {
		return
	}
	return *v, true
}

// OldExamName returns the old "ExamName" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldExamName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamName: %w", err)
	}
	return oldValue.ExamName, nil
}

// ResetExamName resets all changes to the "ExamName" field.
func (m *ExamPMMutation) ResetExamName() {
	m._ExamName = nil
}

// SetExamType sets the "ExamType" field.
func (m *ExamPMMutation) SetExamType(s string) {
	m._ExamType = &s
}

// ExamType returns the value of the "ExamType" field in the mutation.
func (m *ExamPMMutation) ExamType() (r string, exists bool) {
	v := m._ExamType
	if v == nil {
		return
	}
	return *v, true
}

// OldExamType returns the old "ExamType" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldExamType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamType: %w", err)
	}
	return oldValue.ExamType, nil
}

// ResetExamType resets all changes to the "ExamType" field.
func (m *ExamPMMutation) ResetExamType() {
	m._ExamType = nil
}

// SetNotificationCode sets the "NotificationCode" field.
func (m *ExamPMMutation) SetNotificationCode(i int32) {
	m._NotificationCode = &i
	m.add_NotificationCode = nil
}

// NotificationCode returns the value of the "NotificationCode" field in the mutation.
func (m *ExamPMMutation) NotificationCode() (r int32, exists bool) {
	v := m._NotificationCode
	if v == nil {
		return
	}
	return *v, true
}

// OldNotificationCode returns the old "NotificationCode" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldNotificationCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotificationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotificationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotificationCode: %w", err)
	}
	return oldValue.NotificationCode, nil
}

// AddNotificationCode adds i to the "NotificationCode" field.
func (m *ExamPMMutation) AddNotificationCode(i int32) {
	if m.add_NotificationCode != nil {
		*m.add_NotificationCode += i
	} else {
		m.add_NotificationCode = &i
	}
}

// AddedNotificationCode returns the value that was added to the "NotificationCode" field in this mutation.
func (m *ExamPMMutation) AddedNotificationCode() (r int32, exists bool) {
	v := m.add_NotificationCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearNotificationCode clears the value of the "NotificationCode" field.
func (m *ExamPMMutation) ClearNotificationCode() {
	m._NotificationCode = nil
	m.add_NotificationCode = nil
	m.clearedFields[exam_pm.FieldNotificationCode] = struct{}{}
}

// NotificationCodeCleared returns if the "NotificationCode" field was cleared in this mutation.
func (m *ExamPMMutation) NotificationCodeCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldNotificationCode]
	return ok
}

// ResetNotificationCode resets all changes to the "NotificationCode" field.
func (m *ExamPMMutation) ResetNotificationCode() {
	m._NotificationCode = nil
	m.add_NotificationCode = nil
	delete(m.clearedFields, exam_pm.FieldNotificationCode)
}

// SetConductedBy sets the "ConductedBy" field.
func (m *ExamPMMutation) SetConductedBy(s string) {
	m._ConductedBy = &s
}

// ConductedBy returns the value of the "ConductedBy" field in the mutation.
func (m *ExamPMMutation) ConductedBy() (r string, exists bool) {
	v := m._ConductedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldConductedBy returns the old "ConductedBy" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldConductedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConductedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConductedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConductedBy: %w", err)
	}
	return oldValue.ConductedBy, nil
}

// ResetConductedBy resets all changes to the "ConductedBy" field.
func (m *ExamPMMutation) ResetConductedBy() {
	m._ConductedBy = nil
}

// SetNodalOffice sets the "NodalOffice" field.
func (m *ExamPMMutation) SetNodalOffice(s string) {
	m._NodalOffice = &s
}

// NodalOffice returns the value of the "NodalOffice" field in the mutation.
func (m *ExamPMMutation) NodalOffice() (r string, exists bool) {
	v := m._NodalOffice
	if v == nil {
		return
	}
	return *v, true
}

// OldNodalOffice returns the old "NodalOffice" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldNodalOffice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodalOffice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodalOffice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodalOffice: %w", err)
	}
	return oldValue.NodalOffice, nil
}

// ClearNodalOffice clears the value of the "NodalOffice" field.
func (m *ExamPMMutation) ClearNodalOffice() {
	m._NodalOffice = nil
	m.clearedFields[exam_pm.FieldNodalOffice] = struct{}{}
}

// NodalOfficeCleared returns if the "NodalOffice" field was cleared in this mutation.
func (m *ExamPMMutation) NodalOfficeCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldNodalOffice]
	return ok
}

// ResetNodalOffice resets all changes to the "NodalOffice" field.
func (m *ExamPMMutation) ResetNodalOffice() {
	m._NodalOffice = nil
	delete(m.clearedFields, exam_pm.FieldNodalOffice)
}

// SetCalendarCode sets the "CalendarCode" field.
func (m *ExamPMMutation) SetCalendarCode(i int32) {
	m._CalendarCode = &i
	m.add_CalendarCode = nil
}

// CalendarCode returns the value of the "CalendarCode" field in the mutation.
func (m *ExamPMMutation) CalendarCode() (r int32, exists bool) {
	v := m._CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCalendarCode returns the old "CalendarCode" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldCalendarCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalendarCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalendarCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalendarCode: %w", err)
	}
	return oldValue.CalendarCode, nil
}

// AddCalendarCode adds i to the "CalendarCode" field.
func (m *ExamPMMutation) AddCalendarCode(i int32) {
	if m.add_CalendarCode != nil {
		*m.add_CalendarCode += i
	} else {
		m.add_CalendarCode = &i
	}
}

// AddedCalendarCode returns the value that was added to the "CalendarCode" field in this mutation.
func (m *ExamPMMutation) AddedCalendarCode() (r int32, exists bool) {
	v := m.add_CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalendarCode clears the value of the "CalendarCode" field.
func (m *ExamPMMutation) ClearCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	m.clearedFields[exam_pm.FieldCalendarCode] = struct{}{}
}

// CalendarCodeCleared returns if the "CalendarCode" field was cleared in this mutation.
func (m *ExamPMMutation) CalendarCodeCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldCalendarCode]
	return ok
}

// ResetCalendarCode resets all changes to the "CalendarCode" field.
func (m *ExamPMMutation) ResetCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	delete(m.clearedFields, exam_pm.FieldCalendarCode)
}

// SetPaperCode sets the "PaperCode" field.
func (m *ExamPMMutation) SetPaperCode(i int32) {
	m._PaperCode = &i
	m.add_PaperCode = nil
}

// PaperCode returns the value of the "PaperCode" field in the mutation.
func (m *ExamPMMutation) PaperCode() (r int32, exists bool) {
	v := m._PaperCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperCode returns the old "PaperCode" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldPaperCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperCode: %w", err)
	}
	return oldValue.PaperCode, nil
}

// AddPaperCode adds i to the "PaperCode" field.
func (m *ExamPMMutation) AddPaperCode(i int32) {
	if m.add_PaperCode != nil {
		*m.add_PaperCode += i
	} else {
		m.add_PaperCode = &i
	}
}

// AddedPaperCode returns the value that was added to the "PaperCode" field in this mutation.
func (m *ExamPMMutation) AddedPaperCode() (r int32, exists bool) {
	v := m.add_PaperCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaperCode clears the value of the "PaperCode" field.
func (m *ExamPMMutation) ClearPaperCode() {
	m._PaperCode = nil
	m.add_PaperCode = nil
	m.clearedFields[exam_pm.FieldPaperCode] = struct{}{}
}

// PaperCodeCleared returns if the "PaperCode" field was cleared in this mutation.
func (m *ExamPMMutation) PaperCodeCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldPaperCode]
	return ok
}

// ResetPaperCode resets all changes to the "PaperCode" field.
func (m *ExamPMMutation) ResetPaperCode() {
	m._PaperCode = nil
	m.add_PaperCode = nil
	delete(m.clearedFields, exam_pm.FieldPaperCode)
}

// SetEligibleCadre sets the "EligibleCadre" field.
func (m *ExamPMMutation) SetEligibleCadre(s string) {
	m._EligibleCadre = &s
}

// EligibleCadre returns the value of the "EligibleCadre" field in the mutation.
func (m *ExamPMMutation) EligibleCadre() (r string, exists bool) {
	v := m._EligibleCadre
	if v == nil {
		return
	}
	return *v, true
}

// OldEligibleCadre returns the old "EligibleCadre" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldEligibleCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligibleCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligibleCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligibleCadre: %w", err)
	}
	return oldValue.EligibleCadre, nil
}

// ClearEligibleCadre clears the value of the "EligibleCadre" field.
func (m *ExamPMMutation) ClearEligibleCadre() {
	m._EligibleCadre = nil
	m.clearedFields[exam_pm.FieldEligibleCadre] = struct{}{}
}

// EligibleCadreCleared returns if the "EligibleCadre" field was cleared in this mutation.
func (m *ExamPMMutation) EligibleCadreCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldEligibleCadre]
	return ok
}

// ResetEligibleCadre resets all changes to the "EligibleCadre" field.
func (m *ExamPMMutation) ResetEligibleCadre() {
	m._EligibleCadre = nil
	delete(m.clearedFields, exam_pm.FieldEligibleCadre)
}

// SetEligiblePost1 sets the "EligiblePost1" field.
func (m *ExamPMMutation) SetEligiblePost1(s string) {
	m._EligiblePost1 = &s
}

// EligiblePost1 returns the value of the "EligiblePost1" field in the mutation.
func (m *ExamPMMutation) EligiblePost1() (r string, exists bool) {
	v := m._EligiblePost1
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost1 returns the old "EligiblePost1" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldEligiblePost1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost1: %w", err)
	}
	return oldValue.EligiblePost1, nil
}

// ClearEligiblePost1 clears the value of the "EligiblePost1" field.
func (m *ExamPMMutation) ClearEligiblePost1() {
	m._EligiblePost1 = nil
	m.clearedFields[exam_pm.FieldEligiblePost1] = struct{}{}
}

// EligiblePost1Cleared returns if the "EligiblePost1" field was cleared in this mutation.
func (m *ExamPMMutation) EligiblePost1Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldEligiblePost1]
	return ok
}

// ResetEligiblePost1 resets all changes to the "EligiblePost1" field.
func (m *ExamPMMutation) ResetEligiblePost1() {
	m._EligiblePost1 = nil
	delete(m.clearedFields, exam_pm.FieldEligiblePost1)
}

// SetEligiblePost2 sets the "EligiblePost2" field.
func (m *ExamPMMutation) SetEligiblePost2(s string) {
	m._EligiblePost2 = &s
}

// EligiblePost2 returns the value of the "EligiblePost2" field in the mutation.
func (m *ExamPMMutation) EligiblePost2() (r string, exists bool) {
	v := m._EligiblePost2
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost2 returns the old "EligiblePost2" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldEligiblePost2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost2: %w", err)
	}
	return oldValue.EligiblePost2, nil
}

// ClearEligiblePost2 clears the value of the "EligiblePost2" field.
func (m *ExamPMMutation) ClearEligiblePost2() {
	m._EligiblePost2 = nil
	m.clearedFields[exam_pm.FieldEligiblePost2] = struct{}{}
}

// EligiblePost2Cleared returns if the "EligiblePost2" field was cleared in this mutation.
func (m *ExamPMMutation) EligiblePost2Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldEligiblePost2]
	return ok
}

// ResetEligiblePost2 resets all changes to the "EligiblePost2" field.
func (m *ExamPMMutation) ResetEligiblePost2() {
	m._EligiblePost2 = nil
	delete(m.clearedFields, exam_pm.FieldEligiblePost2)
}

// SetEligiblePost3 sets the "EligiblePost3" field.
func (m *ExamPMMutation) SetEligiblePost3(s string) {
	m._EligiblePost3 = &s
}

// EligiblePost3 returns the value of the "EligiblePost3" field in the mutation.
func (m *ExamPMMutation) EligiblePost3() (r string, exists bool) {
	v := m._EligiblePost3
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost3 returns the old "EligiblePost3" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldEligiblePost3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost3: %w", err)
	}
	return oldValue.EligiblePost3, nil
}

// ClearEligiblePost3 clears the value of the "EligiblePost3" field.
func (m *ExamPMMutation) ClearEligiblePost3() {
	m._EligiblePost3 = nil
	m.clearedFields[exam_pm.FieldEligiblePost3] = struct{}{}
}

// EligiblePost3Cleared returns if the "EligiblePost3" field was cleared in this mutation.
func (m *ExamPMMutation) EligiblePost3Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldEligiblePost3]
	return ok
}

// ResetEligiblePost3 resets all changes to the "EligiblePost3" field.
func (m *ExamPMMutation) ResetEligiblePost3() {
	m._EligiblePost3 = nil
	delete(m.clearedFields, exam_pm.FieldEligiblePost3)
}

// SetEligiblePost4 sets the "EligiblePost4" field.
func (m *ExamPMMutation) SetEligiblePost4(s string) {
	m._EligiblePost4 = &s
}

// EligiblePost4 returns the value of the "EligiblePost4" field in the mutation.
func (m *ExamPMMutation) EligiblePost4() (r string, exists bool) {
	v := m._EligiblePost4
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost4 returns the old "EligiblePost4" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldEligiblePost4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost4: %w", err)
	}
	return oldValue.EligiblePost4, nil
}

// ClearEligiblePost4 clears the value of the "EligiblePost4" field.
func (m *ExamPMMutation) ClearEligiblePost4() {
	m._EligiblePost4 = nil
	m.clearedFields[exam_pm.FieldEligiblePost4] = struct{}{}
}

// EligiblePost4Cleared returns if the "EligiblePost4" field was cleared in this mutation.
func (m *ExamPMMutation) EligiblePost4Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldEligiblePost4]
	return ok
}

// ResetEligiblePost4 resets all changes to the "EligiblePost4" field.
func (m *ExamPMMutation) ResetEligiblePost4() {
	m._EligiblePost4 = nil
	delete(m.clearedFields, exam_pm.FieldEligiblePost4)
}

// SetEligiblePost5 sets the "EligiblePost5" field.
func (m *ExamPMMutation) SetEligiblePost5(s string) {
	m._EligiblePost5 = &s
}

// EligiblePost5 returns the value of the "EligiblePost5" field in the mutation.
func (m *ExamPMMutation) EligiblePost5() (r string, exists bool) {
	v := m._EligiblePost5
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost5 returns the old "EligiblePost5" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldEligiblePost5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost5: %w", err)
	}
	return oldValue.EligiblePost5, nil
}

// ClearEligiblePost5 clears the value of the "EligiblePost5" field.
func (m *ExamPMMutation) ClearEligiblePost5() {
	m._EligiblePost5 = nil
	m.clearedFields[exam_pm.FieldEligiblePost5] = struct{}{}
}

// EligiblePost5Cleared returns if the "EligiblePost5" field was cleared in this mutation.
func (m *ExamPMMutation) EligiblePost5Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldEligiblePost5]
	return ok
}

// ResetEligiblePost5 resets all changes to the "EligiblePost5" field.
func (m *ExamPMMutation) ResetEligiblePost5() {
	m._EligiblePost5 = nil
	delete(m.clearedFields, exam_pm.FieldEligiblePost5)
}

// SetExamPost1 sets the "ExamPost1" field.
func (m *ExamPMMutation) SetExamPost1(s string) {
	m._ExamPost1 = &s
}

// ExamPost1 returns the value of the "ExamPost1" field in the mutation.
func (m *ExamPMMutation) ExamPost1() (r string, exists bool) {
	v := m._ExamPost1
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost1 returns the old "ExamPost1" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldExamPost1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost1: %w", err)
	}
	return oldValue.ExamPost1, nil
}

// ClearExamPost1 clears the value of the "ExamPost1" field.
func (m *ExamPMMutation) ClearExamPost1() {
	m._ExamPost1 = nil
	m.clearedFields[exam_pm.FieldExamPost1] = struct{}{}
}

// ExamPost1Cleared returns if the "ExamPost1" field was cleared in this mutation.
func (m *ExamPMMutation) ExamPost1Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldExamPost1]
	return ok
}

// ResetExamPost1 resets all changes to the "ExamPost1" field.
func (m *ExamPMMutation) ResetExamPost1() {
	m._ExamPost1 = nil
	delete(m.clearedFields, exam_pm.FieldExamPost1)
}

// SetExamPost2 sets the "ExamPost2" field.
func (m *ExamPMMutation) SetExamPost2(s string) {
	m._ExamPost2 = &s
}

// ExamPost2 returns the value of the "ExamPost2" field in the mutation.
func (m *ExamPMMutation) ExamPost2() (r string, exists bool) {
	v := m._ExamPost2
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost2 returns the old "ExamPost2" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldExamPost2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost2: %w", err)
	}
	return oldValue.ExamPost2, nil
}

// ClearExamPost2 clears the value of the "ExamPost2" field.
func (m *ExamPMMutation) ClearExamPost2() {
	m._ExamPost2 = nil
	m.clearedFields[exam_pm.FieldExamPost2] = struct{}{}
}

// ExamPost2Cleared returns if the "ExamPost2" field was cleared in this mutation.
func (m *ExamPMMutation) ExamPost2Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldExamPost2]
	return ok
}

// ResetExamPost2 resets all changes to the "ExamPost2" field.
func (m *ExamPMMutation) ResetExamPost2() {
	m._ExamPost2 = nil
	delete(m.clearedFields, exam_pm.FieldExamPost2)
}

// SetExamPost3 sets the "ExamPost3" field.
func (m *ExamPMMutation) SetExamPost3(s string) {
	m._ExamPost3 = &s
}

// ExamPost3 returns the value of the "ExamPost3" field in the mutation.
func (m *ExamPMMutation) ExamPost3() (r string, exists bool) {
	v := m._ExamPost3
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost3 returns the old "ExamPost3" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldExamPost3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost3: %w", err)
	}
	return oldValue.ExamPost3, nil
}

// ClearExamPost3 clears the value of the "ExamPost3" field.
func (m *ExamPMMutation) ClearExamPost3() {
	m._ExamPost3 = nil
	m.clearedFields[exam_pm.FieldExamPost3] = struct{}{}
}

// ExamPost3Cleared returns if the "ExamPost3" field was cleared in this mutation.
func (m *ExamPMMutation) ExamPost3Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldExamPost3]
	return ok
}

// ResetExamPost3 resets all changes to the "ExamPost3" field.
func (m *ExamPMMutation) ResetExamPost3() {
	m._ExamPost3 = nil
	delete(m.clearedFields, exam_pm.FieldExamPost3)
}

// SetExamPost4 sets the "ExamPost4" field.
func (m *ExamPMMutation) SetExamPost4(s string) {
	m._ExamPost4 = &s
}

// ExamPost4 returns the value of the "ExamPost4" field in the mutation.
func (m *ExamPMMutation) ExamPost4() (r string, exists bool) {
	v := m._ExamPost4
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost4 returns the old "ExamPost4" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldExamPost4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost4: %w", err)
	}
	return oldValue.ExamPost4, nil
}

// ClearExamPost4 clears the value of the "ExamPost4" field.
func (m *ExamPMMutation) ClearExamPost4() {
	m._ExamPost4 = nil
	m.clearedFields[exam_pm.FieldExamPost4] = struct{}{}
}

// ExamPost4Cleared returns if the "ExamPost4" field was cleared in this mutation.
func (m *ExamPMMutation) ExamPost4Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldExamPost4]
	return ok
}

// ResetExamPost4 resets all changes to the "ExamPost4" field.
func (m *ExamPMMutation) ResetExamPost4() {
	m._ExamPost4 = nil
	delete(m.clearedFields, exam_pm.FieldExamPost4)
}

// SetExamPost5 sets the "ExamPost5" field.
func (m *ExamPMMutation) SetExamPost5(s string) {
	m._ExamPost5 = &s
}

// ExamPost5 returns the value of the "ExamPost5" field in the mutation.
func (m *ExamPMMutation) ExamPost5() (r string, exists bool) {
	v := m._ExamPost5
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost5 returns the old "ExamPost5" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldExamPost5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost5: %w", err)
	}
	return oldValue.ExamPost5, nil
}

// ClearExamPost5 clears the value of the "ExamPost5" field.
func (m *ExamPMMutation) ClearExamPost5() {
	m._ExamPost5 = nil
	m.clearedFields[exam_pm.FieldExamPost5] = struct{}{}
}

// ExamPost5Cleared returns if the "ExamPost5" field was cleared in this mutation.
func (m *ExamPMMutation) ExamPost5Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldExamPost5]
	return ok
}

// ResetExamPost5 resets all changes to the "ExamPost5" field.
func (m *ExamPMMutation) ResetExamPost5() {
	m._ExamPost5 = nil
	delete(m.clearedFields, exam_pm.FieldExamPost5)
}

// SetEducationCriteria sets the "EducationCriteria" field.
func (m *ExamPMMutation) SetEducationCriteria(s string) {
	m._EducationCriteria = &s
}

// EducationCriteria returns the value of the "EducationCriteria" field in the mutation.
func (m *ExamPMMutation) EducationCriteria() (r string, exists bool) {
	v := m._EducationCriteria
	if v == nil {
		return
	}
	return *v, true
}

// OldEducationCriteria returns the old "EducationCriteria" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldEducationCriteria(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducationCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducationCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducationCriteria: %w", err)
	}
	return oldValue.EducationCriteria, nil
}

// ClearEducationCriteria clears the value of the "EducationCriteria" field.
func (m *ExamPMMutation) ClearEducationCriteria() {
	m._EducationCriteria = nil
	m.clearedFields[exam_pm.FieldEducationCriteria] = struct{}{}
}

// EducationCriteriaCleared returns if the "EducationCriteria" field was cleared in this mutation.
func (m *ExamPMMutation) EducationCriteriaCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldEducationCriteria]
	return ok
}

// ResetEducationCriteria resets all changes to the "EducationCriteria" field.
func (m *ExamPMMutation) ResetEducationCriteria() {
	m._EducationCriteria = nil
	delete(m.clearedFields, exam_pm.FieldEducationCriteria)
}

// SetCategoryAgeLimitGEN sets the "CategoryAgeLimitGEN" field.
func (m *ExamPMMutation) SetCategoryAgeLimitGEN(s string) {
	m._CategoryAgeLimitGEN = &s
}

// CategoryAgeLimitGEN returns the value of the "CategoryAgeLimitGEN" field in the mutation.
func (m *ExamPMMutation) CategoryAgeLimitGEN() (r string, exists bool) {
	v := m._CategoryAgeLimitGEN
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryAgeLimitGEN returns the old "CategoryAgeLimitGEN" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldCategoryAgeLimitGEN(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryAgeLimitGEN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryAgeLimitGEN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryAgeLimitGEN: %w", err)
	}
	return oldValue.CategoryAgeLimitGEN, nil
}

// ClearCategoryAgeLimitGEN clears the value of the "CategoryAgeLimitGEN" field.
func (m *ExamPMMutation) ClearCategoryAgeLimitGEN() {
	m._CategoryAgeLimitGEN = nil
	m.clearedFields[exam_pm.FieldCategoryAgeLimitGEN] = struct{}{}
}

// CategoryAgeLimitGENCleared returns if the "CategoryAgeLimitGEN" field was cleared in this mutation.
func (m *ExamPMMutation) CategoryAgeLimitGENCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldCategoryAgeLimitGEN]
	return ok
}

// ResetCategoryAgeLimitGEN resets all changes to the "CategoryAgeLimitGEN" field.
func (m *ExamPMMutation) ResetCategoryAgeLimitGEN() {
	m._CategoryAgeLimitGEN = nil
	delete(m.clearedFields, exam_pm.FieldCategoryAgeLimitGEN)
}

// SetCategoryAgeLimitSC sets the "CategoryAgeLimitSC" field.
func (m *ExamPMMutation) SetCategoryAgeLimitSC(s string) {
	m._CategoryAgeLimitSC = &s
}

// CategoryAgeLimitSC returns the value of the "CategoryAgeLimitSC" field in the mutation.
func (m *ExamPMMutation) CategoryAgeLimitSC() (r string, exists bool) {
	v := m._CategoryAgeLimitSC
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryAgeLimitSC returns the old "CategoryAgeLimitSC" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldCategoryAgeLimitSC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryAgeLimitSC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryAgeLimitSC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryAgeLimitSC: %w", err)
	}
	return oldValue.CategoryAgeLimitSC, nil
}

// ClearCategoryAgeLimitSC clears the value of the "CategoryAgeLimitSC" field.
func (m *ExamPMMutation) ClearCategoryAgeLimitSC() {
	m._CategoryAgeLimitSC = nil
	m.clearedFields[exam_pm.FieldCategoryAgeLimitSC] = struct{}{}
}

// CategoryAgeLimitSCCleared returns if the "CategoryAgeLimitSC" field was cleared in this mutation.
func (m *ExamPMMutation) CategoryAgeLimitSCCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldCategoryAgeLimitSC]
	return ok
}

// ResetCategoryAgeLimitSC resets all changes to the "CategoryAgeLimitSC" field.
func (m *ExamPMMutation) ResetCategoryAgeLimitSC() {
	m._CategoryAgeLimitSC = nil
	delete(m.clearedFields, exam_pm.FieldCategoryAgeLimitSC)
}

// SetCategoryAgeLimitST sets the "CategoryAgeLimitST" field.
func (m *ExamPMMutation) SetCategoryAgeLimitST(s string) {
	m._CategoryAgeLimitST = &s
}

// CategoryAgeLimitST returns the value of the "CategoryAgeLimitST" field in the mutation.
func (m *ExamPMMutation) CategoryAgeLimitST() (r string, exists bool) {
	v := m._CategoryAgeLimitST
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryAgeLimitST returns the old "CategoryAgeLimitST" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldCategoryAgeLimitST(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryAgeLimitST is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryAgeLimitST requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryAgeLimitST: %w", err)
	}
	return oldValue.CategoryAgeLimitST, nil
}

// ClearCategoryAgeLimitST clears the value of the "CategoryAgeLimitST" field.
func (m *ExamPMMutation) ClearCategoryAgeLimitST() {
	m._CategoryAgeLimitST = nil
	m.clearedFields[exam_pm.FieldCategoryAgeLimitST] = struct{}{}
}

// CategoryAgeLimitSTCleared returns if the "CategoryAgeLimitST" field was cleared in this mutation.
func (m *ExamPMMutation) CategoryAgeLimitSTCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldCategoryAgeLimitST]
	return ok
}

// ResetCategoryAgeLimitST resets all changes to the "CategoryAgeLimitST" field.
func (m *ExamPMMutation) ResetCategoryAgeLimitST() {
	m._CategoryAgeLimitST = nil
	delete(m.clearedFields, exam_pm.FieldCategoryAgeLimitST)
}

// SetServiceYears sets the "ServiceYears" field.
func (m *ExamPMMutation) SetServiceYears(s string) {
	m._ServiceYears = &s
}

// ServiceYears returns the value of the "ServiceYears" field in the mutation.
func (m *ExamPMMutation) ServiceYears() (r string, exists bool) {
	v := m._ServiceYears
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceYears returns the old "ServiceYears" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldServiceYears(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceYears is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceYears requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceYears: %w", err)
	}
	return oldValue.ServiceYears, nil
}

// ClearServiceYears clears the value of the "ServiceYears" field.
func (m *ExamPMMutation) ClearServiceYears() {
	m._ServiceYears = nil
	m.clearedFields[exam_pm.FieldServiceYears] = struct{}{}
}

// ServiceYearsCleared returns if the "ServiceYears" field was cleared in this mutation.
func (m *ExamPMMutation) ServiceYearsCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldServiceYears]
	return ok
}

// ResetServiceYears resets all changes to the "ServiceYears" field.
func (m *ExamPMMutation) ResetServiceYears() {
	m._ServiceYears = nil
	delete(m.clearedFields, exam_pm.FieldServiceYears)
}

// SetDrivingLicenseRequired sets the "DrivingLicenseRequired" field.
func (m *ExamPMMutation) SetDrivingLicenseRequired(s string) {
	m._DrivingLicenseRequired = &s
}

// DrivingLicenseRequired returns the value of the "DrivingLicenseRequired" field in the mutation.
func (m *ExamPMMutation) DrivingLicenseRequired() (r string, exists bool) {
	v := m._DrivingLicenseRequired
	if v == nil {
		return
	}
	return *v, true
}

// OldDrivingLicenseRequired returns the old "DrivingLicenseRequired" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldDrivingLicenseRequired(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrivingLicenseRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrivingLicenseRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrivingLicenseRequired: %w", err)
	}
	return oldValue.DrivingLicenseRequired, nil
}

// ClearDrivingLicenseRequired clears the value of the "DrivingLicenseRequired" field.
func (m *ExamPMMutation) ClearDrivingLicenseRequired() {
	m._DrivingLicenseRequired = nil
	m.clearedFields[exam_pm.FieldDrivingLicenseRequired] = struct{}{}
}

// DrivingLicenseRequiredCleared returns if the "DrivingLicenseRequired" field was cleared in this mutation.
func (m *ExamPMMutation) DrivingLicenseRequiredCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldDrivingLicenseRequired]
	return ok
}

// ResetDrivingLicenseRequired resets all changes to the "DrivingLicenseRequired" field.
func (m *ExamPMMutation) ResetDrivingLicenseRequired() {
	m._DrivingLicenseRequired = nil
	delete(m.clearedFields, exam_pm.FieldDrivingLicenseRequired)
}

// SetExamPaperCode sets the "ExamPaperCode" field.
func (m *ExamPMMutation) SetExamPaperCode(s string) {
	m._ExamPaperCode = &s
}

// ExamPaperCode returns the value of the "ExamPaperCode" field in the mutation.
func (m *ExamPMMutation) ExamPaperCode() (r string, exists bool) {
	v := m._ExamPaperCode
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaperCode returns the old "ExamPaperCode" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldExamPaperCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaperCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaperCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaperCode: %w", err)
	}
	return oldValue.ExamPaperCode, nil
}

// ClearExamPaperCode clears the value of the "ExamPaperCode" field.
func (m *ExamPMMutation) ClearExamPaperCode() {
	m._ExamPaperCode = nil
	m.clearedFields[exam_pm.FieldExamPaperCode] = struct{}{}
}

// ExamPaperCodeCleared returns if the "ExamPaperCode" field was cleared in this mutation.
func (m *ExamPMMutation) ExamPaperCodeCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldExamPaperCode]
	return ok
}

// ResetExamPaperCode resets all changes to the "ExamPaperCode" field.
func (m *ExamPMMutation) ResetExamPaperCode() {
	m._ExamPaperCode = nil
	delete(m.clearedFields, exam_pm.FieldExamPaperCode)
}

// SetExamPaper1 sets the "ExamPaper1" field.
func (m *ExamPMMutation) SetExamPaper1(s string) {
	m._ExamPaper1 = &s
}

// ExamPaper1 returns the value of the "ExamPaper1" field in the mutation.
func (m *ExamPMMutation) ExamPaper1() (r string, exists bool) {
	v := m._ExamPaper1
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper1 returns the old "ExamPaper1" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldExamPaper1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper1: %w", err)
	}
	return oldValue.ExamPaper1, nil
}

// ClearExamPaper1 clears the value of the "ExamPaper1" field.
func (m *ExamPMMutation) ClearExamPaper1() {
	m._ExamPaper1 = nil
	m.clearedFields[exam_pm.FieldExamPaper1] = struct{}{}
}

// ExamPaper1Cleared returns if the "ExamPaper1" field was cleared in this mutation.
func (m *ExamPMMutation) ExamPaper1Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldExamPaper1]
	return ok
}

// ResetExamPaper1 resets all changes to the "ExamPaper1" field.
func (m *ExamPMMutation) ResetExamPaper1() {
	m._ExamPaper1 = nil
	delete(m.clearedFields, exam_pm.FieldExamPaper1)
}

// SetExamPaper2 sets the "ExamPaper2" field.
func (m *ExamPMMutation) SetExamPaper2(s string) {
	m._ExamPaper2 = &s
}

// ExamPaper2 returns the value of the "ExamPaper2" field in the mutation.
func (m *ExamPMMutation) ExamPaper2() (r string, exists bool) {
	v := m._ExamPaper2
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper2 returns the old "ExamPaper2" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldExamPaper2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper2: %w", err)
	}
	return oldValue.ExamPaper2, nil
}

// ClearExamPaper2 clears the value of the "ExamPaper2" field.
func (m *ExamPMMutation) ClearExamPaper2() {
	m._ExamPaper2 = nil
	m.clearedFields[exam_pm.FieldExamPaper2] = struct{}{}
}

// ExamPaper2Cleared returns if the "ExamPaper2" field was cleared in this mutation.
func (m *ExamPMMutation) ExamPaper2Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldExamPaper2]
	return ok
}

// ResetExamPaper2 resets all changes to the "ExamPaper2" field.
func (m *ExamPMMutation) ResetExamPaper2() {
	m._ExamPaper2 = nil
	delete(m.clearedFields, exam_pm.FieldExamPaper2)
}

// SetExamPaper3 sets the "ExamPaper3" field.
func (m *ExamPMMutation) SetExamPaper3(s string) {
	m._ExamPaper3 = &s
}

// ExamPaper3 returns the value of the "ExamPaper3" field in the mutation.
func (m *ExamPMMutation) ExamPaper3() (r string, exists bool) {
	v := m._ExamPaper3
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper3 returns the old "ExamPaper3" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldExamPaper3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper3: %w", err)
	}
	return oldValue.ExamPaper3, nil
}

// ClearExamPaper3 clears the value of the "ExamPaper3" field.
func (m *ExamPMMutation) ClearExamPaper3() {
	m._ExamPaper3 = nil
	m.clearedFields[exam_pm.FieldExamPaper3] = struct{}{}
}

// ExamPaper3Cleared returns if the "ExamPaper3" field was cleared in this mutation.
func (m *ExamPMMutation) ExamPaper3Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldExamPaper3]
	return ok
}

// ResetExamPaper3 resets all changes to the "ExamPaper3" field.
func (m *ExamPMMutation) ResetExamPaper3() {
	m._ExamPaper3 = nil
	delete(m.clearedFields, exam_pm.FieldExamPaper3)
}

// SetExamPaper4 sets the "ExamPaper4" field.
func (m *ExamPMMutation) SetExamPaper4(s string) {
	m._ExamPaper4 = &s
}

// ExamPaper4 returns the value of the "ExamPaper4" field in the mutation.
func (m *ExamPMMutation) ExamPaper4() (r string, exists bool) {
	v := m._ExamPaper4
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper4 returns the old "ExamPaper4" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldExamPaper4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper4: %w", err)
	}
	return oldValue.ExamPaper4, nil
}

// ClearExamPaper4 clears the value of the "ExamPaper4" field.
func (m *ExamPMMutation) ClearExamPaper4() {
	m._ExamPaper4 = nil
	m.clearedFields[exam_pm.FieldExamPaper4] = struct{}{}
}

// ExamPaper4Cleared returns if the "ExamPaper4" field was cleared in this mutation.
func (m *ExamPMMutation) ExamPaper4Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldExamPaper4]
	return ok
}

// ResetExamPaper4 resets all changes to the "ExamPaper4" field.
func (m *ExamPMMutation) ResetExamPaper4() {
	m._ExamPaper4 = nil
	delete(m.clearedFields, exam_pm.FieldExamPaper4)
}

// SetExamPaper5 sets the "ExamPaper5" field.
func (m *ExamPMMutation) SetExamPaper5(s string) {
	m._ExamPaper5 = &s
}

// ExamPaper5 returns the value of the "ExamPaper5" field in the mutation.
func (m *ExamPMMutation) ExamPaper5() (r string, exists bool) {
	v := m._ExamPaper5
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper5 returns the old "ExamPaper5" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldExamPaper5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper5: %w", err)
	}
	return oldValue.ExamPaper5, nil
}

// ClearExamPaper5 clears the value of the "ExamPaper5" field.
func (m *ExamPMMutation) ClearExamPaper5() {
	m._ExamPaper5 = nil
	m.clearedFields[exam_pm.FieldExamPaper5] = struct{}{}
}

// ExamPaper5Cleared returns if the "ExamPaper5" field was cleared in this mutation.
func (m *ExamPMMutation) ExamPaper5Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldExamPaper5]
	return ok
}

// ResetExamPaper5 resets all changes to the "ExamPaper5" field.
func (m *ExamPMMutation) ResetExamPaper5() {
	m._ExamPaper5 = nil
	delete(m.clearedFields, exam_pm.FieldExamPaper5)
}

// SetExamPaper6 sets the "ExamPaper6" field.
func (m *ExamPMMutation) SetExamPaper6(s string) {
	m._ExamPaper6 = &s
}

// ExamPaper6 returns the value of the "ExamPaper6" field in the mutation.
func (m *ExamPMMutation) ExamPaper6() (r string, exists bool) {
	v := m._ExamPaper6
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper6 returns the old "ExamPaper6" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldExamPaper6(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper6: %w", err)
	}
	return oldValue.ExamPaper6, nil
}

// ClearExamPaper6 clears the value of the "ExamPaper6" field.
func (m *ExamPMMutation) ClearExamPaper6() {
	m._ExamPaper6 = nil
	m.clearedFields[exam_pm.FieldExamPaper6] = struct{}{}
}

// ExamPaper6Cleared returns if the "ExamPaper6" field was cleared in this mutation.
func (m *ExamPMMutation) ExamPaper6Cleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldExamPaper6]
	return ok
}

// ResetExamPaper6 resets all changes to the "ExamPaper6" field.
func (m *ExamPMMutation) ResetExamPaper6() {
	m._ExamPaper6 = nil
	delete(m.clearedFields, exam_pm.FieldExamPaper6)
}

// SetPayLevelEligibilty sets the "PayLevelEligibilty" field.
func (m *ExamPMMutation) SetPayLevelEligibilty(b bool) {
	m._PayLevelEligibilty = &b
}

// PayLevelEligibilty returns the value of the "PayLevelEligibilty" field in the mutation.
func (m *ExamPMMutation) PayLevelEligibilty() (r bool, exists bool) {
	v := m._PayLevelEligibilty
	if v == nil {
		return
	}
	return *v, true
}

// OldPayLevelEligibilty returns the old "PayLevelEligibilty" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldPayLevelEligibilty(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayLevelEligibilty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayLevelEligibilty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayLevelEligibilty: %w", err)
	}
	return oldValue.PayLevelEligibilty, nil
}

// ClearPayLevelEligibilty clears the value of the "PayLevelEligibilty" field.
func (m *ExamPMMutation) ClearPayLevelEligibilty() {
	m._PayLevelEligibilty = nil
	m.clearedFields[exam_pm.FieldPayLevelEligibilty] = struct{}{}
}

// PayLevelEligibiltyCleared returns if the "PayLevelEligibilty" field was cleared in this mutation.
func (m *ExamPMMutation) PayLevelEligibiltyCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldPayLevelEligibilty]
	return ok
}

// ResetPayLevelEligibilty resets all changes to the "PayLevelEligibilty" field.
func (m *ExamPMMutation) ResetPayLevelEligibilty() {
	m._PayLevelEligibilty = nil
	delete(m.clearedFields, exam_pm.FieldPayLevelEligibilty)
}

// SetCategoryMinMarksSCSTPH sets the "CategoryMinMarksSCSTPH" field.
func (m *ExamPMMutation) SetCategoryMinMarksSCSTPH(s string) {
	m._CategoryMinMarksSCSTPH = &s
}

// CategoryMinMarksSCSTPH returns the value of the "CategoryMinMarksSCSTPH" field in the mutation.
func (m *ExamPMMutation) CategoryMinMarksSCSTPH() (r string, exists bool) {
	v := m._CategoryMinMarksSCSTPH
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryMinMarksSCSTPH returns the old "CategoryMinMarksSCSTPH" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldCategoryMinMarksSCSTPH(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryMinMarksSCSTPH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryMinMarksSCSTPH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryMinMarksSCSTPH: %w", err)
	}
	return oldValue.CategoryMinMarksSCSTPH, nil
}

// ClearCategoryMinMarksSCSTPH clears the value of the "CategoryMinMarksSCSTPH" field.
func (m *ExamPMMutation) ClearCategoryMinMarksSCSTPH() {
	m._CategoryMinMarksSCSTPH = nil
	m.clearedFields[exam_pm.FieldCategoryMinMarksSCSTPH] = struct{}{}
}

// CategoryMinMarksSCSTPHCleared returns if the "CategoryMinMarksSCSTPH" field was cleared in this mutation.
func (m *ExamPMMutation) CategoryMinMarksSCSTPHCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldCategoryMinMarksSCSTPH]
	return ok
}

// ResetCategoryMinMarksSCSTPH resets all changes to the "CategoryMinMarksSCSTPH" field.
func (m *ExamPMMutation) ResetCategoryMinMarksSCSTPH() {
	m._CategoryMinMarksSCSTPH = nil
	delete(m.clearedFields, exam_pm.FieldCategoryMinMarksSCSTPH)
}

// SetCategoryMinMarksGENOBC sets the "CategoryMinMarksGENOBC" field.
func (m *ExamPMMutation) SetCategoryMinMarksGENOBC(s string) {
	m._CategoryMinMarksGENOBC = &s
}

// CategoryMinMarksGENOBC returns the value of the "CategoryMinMarksGENOBC" field in the mutation.
func (m *ExamPMMutation) CategoryMinMarksGENOBC() (r string, exists bool) {
	v := m._CategoryMinMarksGENOBC
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryMinMarksGENOBC returns the old "CategoryMinMarksGENOBC" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldCategoryMinMarksGENOBC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryMinMarksGENOBC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryMinMarksGENOBC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryMinMarksGENOBC: %w", err)
	}
	return oldValue.CategoryMinMarksGENOBC, nil
}

// ClearCategoryMinMarksGENOBC clears the value of the "CategoryMinMarksGENOBC" field.
func (m *ExamPMMutation) ClearCategoryMinMarksGENOBC() {
	m._CategoryMinMarksGENOBC = nil
	m.clearedFields[exam_pm.FieldCategoryMinMarksGENOBC] = struct{}{}
}

// CategoryMinMarksGENOBCCleared returns if the "CategoryMinMarksGENOBC" field was cleared in this mutation.
func (m *ExamPMMutation) CategoryMinMarksGENOBCCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldCategoryMinMarksGENOBC]
	return ok
}

// ResetCategoryMinMarksGENOBC resets all changes to the "CategoryMinMarksGENOBC" field.
func (m *ExamPMMutation) ResetCategoryMinMarksGENOBC() {
	m._CategoryMinMarksGENOBC = nil
	delete(m.clearedFields, exam_pm.FieldCategoryMinMarksGENOBC)
}

// SetLocalLanguageAllowed sets the "LocalLanguageAllowed" field.
func (m *ExamPMMutation) SetLocalLanguageAllowed(b bool) {
	m._LocalLanguageAllowed = &b
}

// LocalLanguageAllowed returns the value of the "LocalLanguageAllowed" field in the mutation.
func (m *ExamPMMutation) LocalLanguageAllowed() (r bool, exists bool) {
	v := m._LocalLanguageAllowed
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalLanguageAllowed returns the old "LocalLanguageAllowed" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldLocalLanguageAllowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalLanguageAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalLanguageAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalLanguageAllowed: %w", err)
	}
	return oldValue.LocalLanguageAllowed, nil
}

// ClearLocalLanguageAllowed clears the value of the "LocalLanguageAllowed" field.
func (m *ExamPMMutation) ClearLocalLanguageAllowed() {
	m._LocalLanguageAllowed = nil
	m.clearedFields[exam_pm.FieldLocalLanguageAllowed] = struct{}{}
}

// LocalLanguageAllowedCleared returns if the "LocalLanguageAllowed" field was cleared in this mutation.
func (m *ExamPMMutation) LocalLanguageAllowedCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldLocalLanguageAllowed]
	return ok
}

// ResetLocalLanguageAllowed resets all changes to the "LocalLanguageAllowed" field.
func (m *ExamPMMutation) ResetLocalLanguageAllowed() {
	m._LocalLanguageAllowed = nil
	delete(m.clearedFields, exam_pm.FieldLocalLanguageAllowed)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *ExamPMMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *ExamPMMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *ExamPMMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[exam_pm.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *ExamPMMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *ExamPMMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, exam_pm.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *ExamPMMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *ExamPMMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the Exam_PM entity.
// If the Exam_PM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPMMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *ExamPMMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[exam_pm.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *ExamPMMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[exam_pm.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *ExamPMMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, exam_pm.FieldUpdatedBy)
}

// Where appends a list predicates to the ExamPMMutation builder.
func (m *ExamPMMutation) Where(ps ...predicate.Exam_PM) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExamPMMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExamPMMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exam_PM, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExamPMMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExamPMMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exam_PM).
func (m *ExamPMMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExamPMMutation) Fields() []string {
	fields := make([]string, 0, 38)
	if m._ExamNameCode != nil {
		fields = append(fields, exam_pm.FieldExamNameCode)
	}
	if m._ExamName != nil {
		fields = append(fields, exam_pm.FieldExamName)
	}
	if m._ExamType != nil {
		fields = append(fields, exam_pm.FieldExamType)
	}
	if m._NotificationCode != nil {
		fields = append(fields, exam_pm.FieldNotificationCode)
	}
	if m._ConductedBy != nil {
		fields = append(fields, exam_pm.FieldConductedBy)
	}
	if m._NodalOffice != nil {
		fields = append(fields, exam_pm.FieldNodalOffice)
	}
	if m._CalendarCode != nil {
		fields = append(fields, exam_pm.FieldCalendarCode)
	}
	if m._PaperCode != nil {
		fields = append(fields, exam_pm.FieldPaperCode)
	}
	if m._EligibleCadre != nil {
		fields = append(fields, exam_pm.FieldEligibleCadre)
	}
	if m._EligiblePost1 != nil {
		fields = append(fields, exam_pm.FieldEligiblePost1)
	}
	if m._EligiblePost2 != nil {
		fields = append(fields, exam_pm.FieldEligiblePost2)
	}
	if m._EligiblePost3 != nil {
		fields = append(fields, exam_pm.FieldEligiblePost3)
	}
	if m._EligiblePost4 != nil {
		fields = append(fields, exam_pm.FieldEligiblePost4)
	}
	if m._EligiblePost5 != nil {
		fields = append(fields, exam_pm.FieldEligiblePost5)
	}
	if m._ExamPost1 != nil {
		fields = append(fields, exam_pm.FieldExamPost1)
	}
	if m._ExamPost2 != nil {
		fields = append(fields, exam_pm.FieldExamPost2)
	}
	if m._ExamPost3 != nil {
		fields = append(fields, exam_pm.FieldExamPost3)
	}
	if m._ExamPost4 != nil {
		fields = append(fields, exam_pm.FieldExamPost4)
	}
	if m._ExamPost5 != nil {
		fields = append(fields, exam_pm.FieldExamPost5)
	}
	if m._EducationCriteria != nil {
		fields = append(fields, exam_pm.FieldEducationCriteria)
	}
	if m._CategoryAgeLimitGEN != nil {
		fields = append(fields, exam_pm.FieldCategoryAgeLimitGEN)
	}
	if m._CategoryAgeLimitSC != nil {
		fields = append(fields, exam_pm.FieldCategoryAgeLimitSC)
	}
	if m._CategoryAgeLimitST != nil {
		fields = append(fields, exam_pm.FieldCategoryAgeLimitST)
	}
	if m._ServiceYears != nil {
		fields = append(fields, exam_pm.FieldServiceYears)
	}
	if m._DrivingLicenseRequired != nil {
		fields = append(fields, exam_pm.FieldDrivingLicenseRequired)
	}
	if m._ExamPaperCode != nil {
		fields = append(fields, exam_pm.FieldExamPaperCode)
	}
	if m._ExamPaper1 != nil {
		fields = append(fields, exam_pm.FieldExamPaper1)
	}
	if m._ExamPaper2 != nil {
		fields = append(fields, exam_pm.FieldExamPaper2)
	}
	if m._ExamPaper3 != nil {
		fields = append(fields, exam_pm.FieldExamPaper3)
	}
	if m._ExamPaper4 != nil {
		fields = append(fields, exam_pm.FieldExamPaper4)
	}
	if m._ExamPaper5 != nil {
		fields = append(fields, exam_pm.FieldExamPaper5)
	}
	if m._ExamPaper6 != nil {
		fields = append(fields, exam_pm.FieldExamPaper6)
	}
	if m._PayLevelEligibilty != nil {
		fields = append(fields, exam_pm.FieldPayLevelEligibilty)
	}
	if m._CategoryMinMarksSCSTPH != nil {
		fields = append(fields, exam_pm.FieldCategoryMinMarksSCSTPH)
	}
	if m._CategoryMinMarksGENOBC != nil {
		fields = append(fields, exam_pm.FieldCategoryMinMarksGENOBC)
	}
	if m._LocalLanguageAllowed != nil {
		fields = append(fields, exam_pm.FieldLocalLanguageAllowed)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, exam_pm.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, exam_pm.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExamPMMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exam_pm.FieldExamNameCode:
		return m.ExamNameCode()
	case exam_pm.FieldExamName:
		return m.ExamName()
	case exam_pm.FieldExamType:
		return m.ExamType()
	case exam_pm.FieldNotificationCode:
		return m.NotificationCode()
	case exam_pm.FieldConductedBy:
		return m.ConductedBy()
	case exam_pm.FieldNodalOffice:
		return m.NodalOffice()
	case exam_pm.FieldCalendarCode:
		return m.CalendarCode()
	case exam_pm.FieldPaperCode:
		return m.PaperCode()
	case exam_pm.FieldEligibleCadre:
		return m.EligibleCadre()
	case exam_pm.FieldEligiblePost1:
		return m.EligiblePost1()
	case exam_pm.FieldEligiblePost2:
		return m.EligiblePost2()
	case exam_pm.FieldEligiblePost3:
		return m.EligiblePost3()
	case exam_pm.FieldEligiblePost4:
		return m.EligiblePost4()
	case exam_pm.FieldEligiblePost5:
		return m.EligiblePost5()
	case exam_pm.FieldExamPost1:
		return m.ExamPost1()
	case exam_pm.FieldExamPost2:
		return m.ExamPost2()
	case exam_pm.FieldExamPost3:
		return m.ExamPost3()
	case exam_pm.FieldExamPost4:
		return m.ExamPost4()
	case exam_pm.FieldExamPost5:
		return m.ExamPost5()
	case exam_pm.FieldEducationCriteria:
		return m.EducationCriteria()
	case exam_pm.FieldCategoryAgeLimitGEN:
		return m.CategoryAgeLimitGEN()
	case exam_pm.FieldCategoryAgeLimitSC:
		return m.CategoryAgeLimitSC()
	case exam_pm.FieldCategoryAgeLimitST:
		return m.CategoryAgeLimitST()
	case exam_pm.FieldServiceYears:
		return m.ServiceYears()
	case exam_pm.FieldDrivingLicenseRequired:
		return m.DrivingLicenseRequired()
	case exam_pm.FieldExamPaperCode:
		return m.ExamPaperCode()
	case exam_pm.FieldExamPaper1:
		return m.ExamPaper1()
	case exam_pm.FieldExamPaper2:
		return m.ExamPaper2()
	case exam_pm.FieldExamPaper3:
		return m.ExamPaper3()
	case exam_pm.FieldExamPaper4:
		return m.ExamPaper4()
	case exam_pm.FieldExamPaper5:
		return m.ExamPaper5()
	case exam_pm.FieldExamPaper6:
		return m.ExamPaper6()
	case exam_pm.FieldPayLevelEligibilty:
		return m.PayLevelEligibilty()
	case exam_pm.FieldCategoryMinMarksSCSTPH:
		return m.CategoryMinMarksSCSTPH()
	case exam_pm.FieldCategoryMinMarksGENOBC:
		return m.CategoryMinMarksGENOBC()
	case exam_pm.FieldLocalLanguageAllowed:
		return m.LocalLanguageAllowed()
	case exam_pm.FieldUpdatedAt:
		return m.UpdatedAt()
	case exam_pm.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExamPMMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exam_pm.FieldExamNameCode:
		return m.OldExamNameCode(ctx)
	case exam_pm.FieldExamName:
		return m.OldExamName(ctx)
	case exam_pm.FieldExamType:
		return m.OldExamType(ctx)
	case exam_pm.FieldNotificationCode:
		return m.OldNotificationCode(ctx)
	case exam_pm.FieldConductedBy:
		return m.OldConductedBy(ctx)
	case exam_pm.FieldNodalOffice:
		return m.OldNodalOffice(ctx)
	case exam_pm.FieldCalendarCode:
		return m.OldCalendarCode(ctx)
	case exam_pm.FieldPaperCode:
		return m.OldPaperCode(ctx)
	case exam_pm.FieldEligibleCadre:
		return m.OldEligibleCadre(ctx)
	case exam_pm.FieldEligiblePost1:
		return m.OldEligiblePost1(ctx)
	case exam_pm.FieldEligiblePost2:
		return m.OldEligiblePost2(ctx)
	case exam_pm.FieldEligiblePost3:
		return m.OldEligiblePost3(ctx)
	case exam_pm.FieldEligiblePost4:
		return m.OldEligiblePost4(ctx)
	case exam_pm.FieldEligiblePost5:
		return m.OldEligiblePost5(ctx)
	case exam_pm.FieldExamPost1:
		return m.OldExamPost1(ctx)
	case exam_pm.FieldExamPost2:
		return m.OldExamPost2(ctx)
	case exam_pm.FieldExamPost3:
		return m.OldExamPost3(ctx)
	case exam_pm.FieldExamPost4:
		return m.OldExamPost4(ctx)
	case exam_pm.FieldExamPost5:
		return m.OldExamPost5(ctx)
	case exam_pm.FieldEducationCriteria:
		return m.OldEducationCriteria(ctx)
	case exam_pm.FieldCategoryAgeLimitGEN:
		return m.OldCategoryAgeLimitGEN(ctx)
	case exam_pm.FieldCategoryAgeLimitSC:
		return m.OldCategoryAgeLimitSC(ctx)
	case exam_pm.FieldCategoryAgeLimitST:
		return m.OldCategoryAgeLimitST(ctx)
	case exam_pm.FieldServiceYears:
		return m.OldServiceYears(ctx)
	case exam_pm.FieldDrivingLicenseRequired:
		return m.OldDrivingLicenseRequired(ctx)
	case exam_pm.FieldExamPaperCode:
		return m.OldExamPaperCode(ctx)
	case exam_pm.FieldExamPaper1:
		return m.OldExamPaper1(ctx)
	case exam_pm.FieldExamPaper2:
		return m.OldExamPaper2(ctx)
	case exam_pm.FieldExamPaper3:
		return m.OldExamPaper3(ctx)
	case exam_pm.FieldExamPaper4:
		return m.OldExamPaper4(ctx)
	case exam_pm.FieldExamPaper5:
		return m.OldExamPaper5(ctx)
	case exam_pm.FieldExamPaper6:
		return m.OldExamPaper6(ctx)
	case exam_pm.FieldPayLevelEligibilty:
		return m.OldPayLevelEligibilty(ctx)
	case exam_pm.FieldCategoryMinMarksSCSTPH:
		return m.OldCategoryMinMarksSCSTPH(ctx)
	case exam_pm.FieldCategoryMinMarksGENOBC:
		return m.OldCategoryMinMarksGENOBC(ctx)
	case exam_pm.FieldLocalLanguageAllowed:
		return m.OldLocalLanguageAllowed(ctx)
	case exam_pm.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case exam_pm.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Exam_PM field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamPMMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exam_pm.FieldExamNameCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamNameCode(v)
		return nil
	case exam_pm.FieldExamName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamName(v)
		return nil
	case exam_pm.FieldExamType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamType(v)
		return nil
	case exam_pm.FieldNotificationCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotificationCode(v)
		return nil
	case exam_pm.FieldConductedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConductedBy(v)
		return nil
	case exam_pm.FieldNodalOffice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodalOffice(v)
		return nil
	case exam_pm.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalendarCode(v)
		return nil
	case exam_pm.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperCode(v)
		return nil
	case exam_pm.FieldEligibleCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligibleCadre(v)
		return nil
	case exam_pm.FieldEligiblePost1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost1(v)
		return nil
	case exam_pm.FieldEligiblePost2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost2(v)
		return nil
	case exam_pm.FieldEligiblePost3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost3(v)
		return nil
	case exam_pm.FieldEligiblePost4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost4(v)
		return nil
	case exam_pm.FieldEligiblePost5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost5(v)
		return nil
	case exam_pm.FieldExamPost1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost1(v)
		return nil
	case exam_pm.FieldExamPost2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost2(v)
		return nil
	case exam_pm.FieldExamPost3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost3(v)
		return nil
	case exam_pm.FieldExamPost4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost4(v)
		return nil
	case exam_pm.FieldExamPost5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost5(v)
		return nil
	case exam_pm.FieldEducationCriteria:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducationCriteria(v)
		return nil
	case exam_pm.FieldCategoryAgeLimitGEN:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryAgeLimitGEN(v)
		return nil
	case exam_pm.FieldCategoryAgeLimitSC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryAgeLimitSC(v)
		return nil
	case exam_pm.FieldCategoryAgeLimitST:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryAgeLimitST(v)
		return nil
	case exam_pm.FieldServiceYears:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceYears(v)
		return nil
	case exam_pm.FieldDrivingLicenseRequired:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrivingLicenseRequired(v)
		return nil
	case exam_pm.FieldExamPaperCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaperCode(v)
		return nil
	case exam_pm.FieldExamPaper1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper1(v)
		return nil
	case exam_pm.FieldExamPaper2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper2(v)
		return nil
	case exam_pm.FieldExamPaper3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper3(v)
		return nil
	case exam_pm.FieldExamPaper4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper4(v)
		return nil
	case exam_pm.FieldExamPaper5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper5(v)
		return nil
	case exam_pm.FieldExamPaper6:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper6(v)
		return nil
	case exam_pm.FieldPayLevelEligibilty:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayLevelEligibilty(v)
		return nil
	case exam_pm.FieldCategoryMinMarksSCSTPH:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryMinMarksSCSTPH(v)
		return nil
	case exam_pm.FieldCategoryMinMarksGENOBC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryMinMarksGENOBC(v)
		return nil
	case exam_pm.FieldLocalLanguageAllowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalLanguageAllowed(v)
		return nil
	case exam_pm.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case exam_pm.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Exam_PM field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExamPMMutation) AddedFields() []string {
	var fields []string
	if m.add_NotificationCode != nil {
		fields = append(fields, exam_pm.FieldNotificationCode)
	}
	if m.add_CalendarCode != nil {
		fields = append(fields, exam_pm.FieldCalendarCode)
	}
	if m.add_PaperCode != nil {
		fields = append(fields, exam_pm.FieldPaperCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExamPMMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exam_pm.FieldNotificationCode:
		return m.AddedNotificationCode()
	case exam_pm.FieldCalendarCode:
		return m.AddedCalendarCode()
	case exam_pm.FieldPaperCode:
		return m.AddedPaperCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamPMMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exam_pm.FieldNotificationCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotificationCode(v)
		return nil
	case exam_pm.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalendarCode(v)
		return nil
	case exam_pm.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaperCode(v)
		return nil
	}
	return fmt.Errorf("unknown Exam_PM numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExamPMMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exam_pm.FieldExamNameCode) {
		fields = append(fields, exam_pm.FieldExamNameCode)
	}
	if m.FieldCleared(exam_pm.FieldNotificationCode) {
		fields = append(fields, exam_pm.FieldNotificationCode)
	}
	if m.FieldCleared(exam_pm.FieldNodalOffice) {
		fields = append(fields, exam_pm.FieldNodalOffice)
	}
	if m.FieldCleared(exam_pm.FieldCalendarCode) {
		fields = append(fields, exam_pm.FieldCalendarCode)
	}
	if m.FieldCleared(exam_pm.FieldPaperCode) {
		fields = append(fields, exam_pm.FieldPaperCode)
	}
	if m.FieldCleared(exam_pm.FieldEligibleCadre) {
		fields = append(fields, exam_pm.FieldEligibleCadre)
	}
	if m.FieldCleared(exam_pm.FieldEligiblePost1) {
		fields = append(fields, exam_pm.FieldEligiblePost1)
	}
	if m.FieldCleared(exam_pm.FieldEligiblePost2) {
		fields = append(fields, exam_pm.FieldEligiblePost2)
	}
	if m.FieldCleared(exam_pm.FieldEligiblePost3) {
		fields = append(fields, exam_pm.FieldEligiblePost3)
	}
	if m.FieldCleared(exam_pm.FieldEligiblePost4) {
		fields = append(fields, exam_pm.FieldEligiblePost4)
	}
	if m.FieldCleared(exam_pm.FieldEligiblePost5) {
		fields = append(fields, exam_pm.FieldEligiblePost5)
	}
	if m.FieldCleared(exam_pm.FieldExamPost1) {
		fields = append(fields, exam_pm.FieldExamPost1)
	}
	if m.FieldCleared(exam_pm.FieldExamPost2) {
		fields = append(fields, exam_pm.FieldExamPost2)
	}
	if m.FieldCleared(exam_pm.FieldExamPost3) {
		fields = append(fields, exam_pm.FieldExamPost3)
	}
	if m.FieldCleared(exam_pm.FieldExamPost4) {
		fields = append(fields, exam_pm.FieldExamPost4)
	}
	if m.FieldCleared(exam_pm.FieldExamPost5) {
		fields = append(fields, exam_pm.FieldExamPost5)
	}
	if m.FieldCleared(exam_pm.FieldEducationCriteria) {
		fields = append(fields, exam_pm.FieldEducationCriteria)
	}
	if m.FieldCleared(exam_pm.FieldCategoryAgeLimitGEN) {
		fields = append(fields, exam_pm.FieldCategoryAgeLimitGEN)
	}
	if m.FieldCleared(exam_pm.FieldCategoryAgeLimitSC) {
		fields = append(fields, exam_pm.FieldCategoryAgeLimitSC)
	}
	if m.FieldCleared(exam_pm.FieldCategoryAgeLimitST) {
		fields = append(fields, exam_pm.FieldCategoryAgeLimitST)
	}
	if m.FieldCleared(exam_pm.FieldServiceYears) {
		fields = append(fields, exam_pm.FieldServiceYears)
	}
	if m.FieldCleared(exam_pm.FieldDrivingLicenseRequired) {
		fields = append(fields, exam_pm.FieldDrivingLicenseRequired)
	}
	if m.FieldCleared(exam_pm.FieldExamPaperCode) {
		fields = append(fields, exam_pm.FieldExamPaperCode)
	}
	if m.FieldCleared(exam_pm.FieldExamPaper1) {
		fields = append(fields, exam_pm.FieldExamPaper1)
	}
	if m.FieldCleared(exam_pm.FieldExamPaper2) {
		fields = append(fields, exam_pm.FieldExamPaper2)
	}
	if m.FieldCleared(exam_pm.FieldExamPaper3) {
		fields = append(fields, exam_pm.FieldExamPaper3)
	}
	if m.FieldCleared(exam_pm.FieldExamPaper4) {
		fields = append(fields, exam_pm.FieldExamPaper4)
	}
	if m.FieldCleared(exam_pm.FieldExamPaper5) {
		fields = append(fields, exam_pm.FieldExamPaper5)
	}
	if m.FieldCleared(exam_pm.FieldExamPaper6) {
		fields = append(fields, exam_pm.FieldExamPaper6)
	}
	if m.FieldCleared(exam_pm.FieldPayLevelEligibilty) {
		fields = append(fields, exam_pm.FieldPayLevelEligibilty)
	}
	if m.FieldCleared(exam_pm.FieldCategoryMinMarksSCSTPH) {
		fields = append(fields, exam_pm.FieldCategoryMinMarksSCSTPH)
	}
	if m.FieldCleared(exam_pm.FieldCategoryMinMarksGENOBC) {
		fields = append(fields, exam_pm.FieldCategoryMinMarksGENOBC)
	}
	if m.FieldCleared(exam_pm.FieldLocalLanguageAllowed) {
		fields = append(fields, exam_pm.FieldLocalLanguageAllowed)
	}
	if m.FieldCleared(exam_pm.FieldUpdatedAt) {
		fields = append(fields, exam_pm.FieldUpdatedAt)
	}
	if m.FieldCleared(exam_pm.FieldUpdatedBy) {
		fields = append(fields, exam_pm.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExamPMMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExamPMMutation) ClearField(name string) error {
	switch name {
	case exam_pm.FieldExamNameCode:
		m.ClearExamNameCode()
		return nil
	case exam_pm.FieldNotificationCode:
		m.ClearNotificationCode()
		return nil
	case exam_pm.FieldNodalOffice:
		m.ClearNodalOffice()
		return nil
	case exam_pm.FieldCalendarCode:
		m.ClearCalendarCode()
		return nil
	case exam_pm.FieldPaperCode:
		m.ClearPaperCode()
		return nil
	case exam_pm.FieldEligibleCadre:
		m.ClearEligibleCadre()
		return nil
	case exam_pm.FieldEligiblePost1:
		m.ClearEligiblePost1()
		return nil
	case exam_pm.FieldEligiblePost2:
		m.ClearEligiblePost2()
		return nil
	case exam_pm.FieldEligiblePost3:
		m.ClearEligiblePost3()
		return nil
	case exam_pm.FieldEligiblePost4:
		m.ClearEligiblePost4()
		return nil
	case exam_pm.FieldEligiblePost5:
		m.ClearEligiblePost5()
		return nil
	case exam_pm.FieldExamPost1:
		m.ClearExamPost1()
		return nil
	case exam_pm.FieldExamPost2:
		m.ClearExamPost2()
		return nil
	case exam_pm.FieldExamPost3:
		m.ClearExamPost3()
		return nil
	case exam_pm.FieldExamPost4:
		m.ClearExamPost4()
		return nil
	case exam_pm.FieldExamPost5:
		m.ClearExamPost5()
		return nil
	case exam_pm.FieldEducationCriteria:
		m.ClearEducationCriteria()
		return nil
	case exam_pm.FieldCategoryAgeLimitGEN:
		m.ClearCategoryAgeLimitGEN()
		return nil
	case exam_pm.FieldCategoryAgeLimitSC:
		m.ClearCategoryAgeLimitSC()
		return nil
	case exam_pm.FieldCategoryAgeLimitST:
		m.ClearCategoryAgeLimitST()
		return nil
	case exam_pm.FieldServiceYears:
		m.ClearServiceYears()
		return nil
	case exam_pm.FieldDrivingLicenseRequired:
		m.ClearDrivingLicenseRequired()
		return nil
	case exam_pm.FieldExamPaperCode:
		m.ClearExamPaperCode()
		return nil
	case exam_pm.FieldExamPaper1:
		m.ClearExamPaper1()
		return nil
	case exam_pm.FieldExamPaper2:
		m.ClearExamPaper2()
		return nil
	case exam_pm.FieldExamPaper3:
		m.ClearExamPaper3()
		return nil
	case exam_pm.FieldExamPaper4:
		m.ClearExamPaper4()
		return nil
	case exam_pm.FieldExamPaper5:
		m.ClearExamPaper5()
		return nil
	case exam_pm.FieldExamPaper6:
		m.ClearExamPaper6()
		return nil
	case exam_pm.FieldPayLevelEligibilty:
		m.ClearPayLevelEligibilty()
		return nil
	case exam_pm.FieldCategoryMinMarksSCSTPH:
		m.ClearCategoryMinMarksSCSTPH()
		return nil
	case exam_pm.FieldCategoryMinMarksGENOBC:
		m.ClearCategoryMinMarksGENOBC()
		return nil
	case exam_pm.FieldLocalLanguageAllowed:
		m.ClearLocalLanguageAllowed()
		return nil
	case exam_pm.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case exam_pm.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Exam_PM nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExamPMMutation) ResetField(name string) error {
	switch name {
	case exam_pm.FieldExamNameCode:
		m.ResetExamNameCode()
		return nil
	case exam_pm.FieldExamName:
		m.ResetExamName()
		return nil
	case exam_pm.FieldExamType:
		m.ResetExamType()
		return nil
	case exam_pm.FieldNotificationCode:
		m.ResetNotificationCode()
		return nil
	case exam_pm.FieldConductedBy:
		m.ResetConductedBy()
		return nil
	case exam_pm.FieldNodalOffice:
		m.ResetNodalOffice()
		return nil
	case exam_pm.FieldCalendarCode:
		m.ResetCalendarCode()
		return nil
	case exam_pm.FieldPaperCode:
		m.ResetPaperCode()
		return nil
	case exam_pm.FieldEligibleCadre:
		m.ResetEligibleCadre()
		return nil
	case exam_pm.FieldEligiblePost1:
		m.ResetEligiblePost1()
		return nil
	case exam_pm.FieldEligiblePost2:
		m.ResetEligiblePost2()
		return nil
	case exam_pm.FieldEligiblePost3:
		m.ResetEligiblePost3()
		return nil
	case exam_pm.FieldEligiblePost4:
		m.ResetEligiblePost4()
		return nil
	case exam_pm.FieldEligiblePost5:
		m.ResetEligiblePost5()
		return nil
	case exam_pm.FieldExamPost1:
		m.ResetExamPost1()
		return nil
	case exam_pm.FieldExamPost2:
		m.ResetExamPost2()
		return nil
	case exam_pm.FieldExamPost3:
		m.ResetExamPost3()
		return nil
	case exam_pm.FieldExamPost4:
		m.ResetExamPost4()
		return nil
	case exam_pm.FieldExamPost5:
		m.ResetExamPost5()
		return nil
	case exam_pm.FieldEducationCriteria:
		m.ResetEducationCriteria()
		return nil
	case exam_pm.FieldCategoryAgeLimitGEN:
		m.ResetCategoryAgeLimitGEN()
		return nil
	case exam_pm.FieldCategoryAgeLimitSC:
		m.ResetCategoryAgeLimitSC()
		return nil
	case exam_pm.FieldCategoryAgeLimitST:
		m.ResetCategoryAgeLimitST()
		return nil
	case exam_pm.FieldServiceYears:
		m.ResetServiceYears()
		return nil
	case exam_pm.FieldDrivingLicenseRequired:
		m.ResetDrivingLicenseRequired()
		return nil
	case exam_pm.FieldExamPaperCode:
		m.ResetExamPaperCode()
		return nil
	case exam_pm.FieldExamPaper1:
		m.ResetExamPaper1()
		return nil
	case exam_pm.FieldExamPaper2:
		m.ResetExamPaper2()
		return nil
	case exam_pm.FieldExamPaper3:
		m.ResetExamPaper3()
		return nil
	case exam_pm.FieldExamPaper4:
		m.ResetExamPaper4()
		return nil
	case exam_pm.FieldExamPaper5:
		m.ResetExamPaper5()
		return nil
	case exam_pm.FieldExamPaper6:
		m.ResetExamPaper6()
		return nil
	case exam_pm.FieldPayLevelEligibilty:
		m.ResetPayLevelEligibilty()
		return nil
	case exam_pm.FieldCategoryMinMarksSCSTPH:
		m.ResetCategoryMinMarksSCSTPH()
		return nil
	case exam_pm.FieldCategoryMinMarksGENOBC:
		m.ResetCategoryMinMarksGENOBC()
		return nil
	case exam_pm.FieldLocalLanguageAllowed:
		m.ResetLocalLanguageAllowed()
		return nil
	case exam_pm.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case exam_pm.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Exam_PM field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExamPMMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExamPMMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExamPMMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExamPMMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExamPMMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExamPMMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExamPMMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Exam_PM unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExamPMMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Exam_PM edge %s", name)
}

// ExamPSMutation represents an operation that mutates the Exam_PS nodes in the graph.
type ExamPSMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int32
	_ExamNameCode            *string
	_ExamName                *string
	_ExamType                *string
	_NotificationCode        *int32
	add_NotificationCode     *int32
	_ConductedBy             *string
	_NodalOffice             *string
	_CalendarCode            *int32
	add_CalendarCode         *int32
	_PaperCode               *int32
	add_PaperCode            *int32
	_EligibleCadre           *string
	_EligiblePost1           *string
	_EligiblePost2           *string
	_EligiblePost3           *string
	_EligiblePost4           *string
	_EligiblePost5           *string
	_ExamPost1               *string
	_ExamPost2               *string
	_ExamPost3               *string
	_ExamPost4               *string
	_ExamPost5               *string
	_EducationCriteria       *string
	_CategoryAgeLimitGEN     *string
	_CategoryAgeLimitSC      *string
	_CategoryAgeLimitST      *string
	_ServiceYears            *string
	_DrivingLicenseRequired  *string
	_ExamPaperCode           *string
	_ExamPaper1              *string
	_ExamPaper2              *string
	_ExamPaper3              *string
	_ExamPaper4              *string
	_ExamPaper5              *string
	_ExamPaper6              *string
	_PayLevelEligibilty      *string
	_CategoryMinMarksSCSTPH  *string
	_CategoryMinMarksGENOBC  *string
	_LocalLanguageAllowed    *string
	_UpdatedAt               *time.Time
	_UpdatedBy               *string
	clearedFields            map[string]struct{}
	examcal_ps_ref           map[int32]struct{}
	removedexamcal_ps_ref    map[int32]struct{}
	clearedexamcal_ps_ref    bool
	papers_ps_ref            map[int32]struct{}
	removedpapers_ps_ref     map[int32]struct{}
	clearedpapers_ps_ref     bool
	users_ps_type            map[int64]struct{}
	removedusers_ps_type     map[int64]struct{}
	clearedusers_ps_type     bool
	_ExamAppln_PS_Ref        map[int64]struct{}
	removed_ExamAppln_PS_Ref map[int64]struct{}
	cleared_ExamAppln_PS_Ref bool
	notifications_ps         map[int32]struct{}
	removednotifications_ps  map[int32]struct{}
	clearednotifications_ps  bool
	done                     bool
	oldValue                 func(context.Context) (*Exam_PS, error)
	predicates               []predicate.Exam_PS
}

var _ ent.Mutation = (*ExamPSMutation)(nil)

// examPSOption allows management of the mutation configuration using functional options.
type examPSOption func(*ExamPSMutation)

// newExamPSMutation creates new mutation for the Exam_PS entity.
func newExamPSMutation(c config, op Op, opts ...examPSOption) *ExamPSMutation {
	m := &ExamPSMutation{
		config:        c,
		op:            op,
		typ:           TypeExamPS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExam_PSID sets the ID field of the mutation.
func withExam_PSID(id int32) examPSOption {
	return func(m *ExamPSMutation) {
		var (
			err   error
			once  sync.Once
			value *Exam_PS
		)
		m.oldValue = func(ctx context.Context) (*Exam_PS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exam_PS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExam_PS sets the old Exam_PS of the mutation.
func withExam_PS(node *Exam_PS) examPSOption {
	return func(m *ExamPSMutation) {
		m.oldValue = func(context.Context) (*Exam_PS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExamPSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExamPSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exam_PS entities.
func (m *ExamPSMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExamPSMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExamPSMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exam_PS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExamNameCode sets the "ExamNameCode" field.
func (m *ExamPSMutation) SetExamNameCode(s string) {
	m._ExamNameCode = &s
}

// ExamNameCode returns the value of the "ExamNameCode" field in the mutation.
func (m *ExamPSMutation) ExamNameCode() (r string, exists bool) {
	v := m._ExamNameCode
	if v == nil {
		return
	}
	return *v, true
}

// OldExamNameCode returns the old "ExamNameCode" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldExamNameCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamNameCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamNameCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamNameCode: %w", err)
	}
	return oldValue.ExamNameCode, nil
}

// ClearExamNameCode clears the value of the "ExamNameCode" field.
func (m *ExamPSMutation) ClearExamNameCode() {
	m._ExamNameCode = nil
	m.clearedFields[exam_ps.FieldExamNameCode] = struct{}{}
}

// ExamNameCodeCleared returns if the "ExamNameCode" field was cleared in this mutation.
func (m *ExamPSMutation) ExamNameCodeCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldExamNameCode]
	return ok
}

// ResetExamNameCode resets all changes to the "ExamNameCode" field.
func (m *ExamPSMutation) ResetExamNameCode() {
	m._ExamNameCode = nil
	delete(m.clearedFields, exam_ps.FieldExamNameCode)
}

// SetExamName sets the "ExamName" field.
func (m *ExamPSMutation) SetExamName(s string) {
	m._ExamName = &s
}

// ExamName returns the value of the "ExamName" field in the mutation.
func (m *ExamPSMutation) ExamName() (r string, exists bool) {
	v := m._ExamName
	if v == nil {
		return
	}
	return *v, true
}

// OldExamName returns the old "ExamName" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldExamName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamName: %w", err)
	}
	return oldValue.ExamName, nil
}

// ResetExamName resets all changes to the "ExamName" field.
func (m *ExamPSMutation) ResetExamName() {
	m._ExamName = nil
}

// SetExamType sets the "ExamType" field.
func (m *ExamPSMutation) SetExamType(s string) {
	m._ExamType = &s
}

// ExamType returns the value of the "ExamType" field in the mutation.
func (m *ExamPSMutation) ExamType() (r string, exists bool) {
	v := m._ExamType
	if v == nil {
		return
	}
	return *v, true
}

// OldExamType returns the old "ExamType" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldExamType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamType: %w", err)
	}
	return oldValue.ExamType, nil
}

// ResetExamType resets all changes to the "ExamType" field.
func (m *ExamPSMutation) ResetExamType() {
	m._ExamType = nil
}

// SetNotificationCode sets the "NotificationCode" field.
func (m *ExamPSMutation) SetNotificationCode(i int32) {
	m._NotificationCode = &i
	m.add_NotificationCode = nil
}

// NotificationCode returns the value of the "NotificationCode" field in the mutation.
func (m *ExamPSMutation) NotificationCode() (r int32, exists bool) {
	v := m._NotificationCode
	if v == nil {
		return
	}
	return *v, true
}

// OldNotificationCode returns the old "NotificationCode" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldNotificationCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotificationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotificationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotificationCode: %w", err)
	}
	return oldValue.NotificationCode, nil
}

// AddNotificationCode adds i to the "NotificationCode" field.
func (m *ExamPSMutation) AddNotificationCode(i int32) {
	if m.add_NotificationCode != nil {
		*m.add_NotificationCode += i
	} else {
		m.add_NotificationCode = &i
	}
}

// AddedNotificationCode returns the value that was added to the "NotificationCode" field in this mutation.
func (m *ExamPSMutation) AddedNotificationCode() (r int32, exists bool) {
	v := m.add_NotificationCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearNotificationCode clears the value of the "NotificationCode" field.
func (m *ExamPSMutation) ClearNotificationCode() {
	m._NotificationCode = nil
	m.add_NotificationCode = nil
	m.clearedFields[exam_ps.FieldNotificationCode] = struct{}{}
}

// NotificationCodeCleared returns if the "NotificationCode" field was cleared in this mutation.
func (m *ExamPSMutation) NotificationCodeCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldNotificationCode]
	return ok
}

// ResetNotificationCode resets all changes to the "NotificationCode" field.
func (m *ExamPSMutation) ResetNotificationCode() {
	m._NotificationCode = nil
	m.add_NotificationCode = nil
	delete(m.clearedFields, exam_ps.FieldNotificationCode)
}

// SetConductedBy sets the "ConductedBy" field.
func (m *ExamPSMutation) SetConductedBy(s string) {
	m._ConductedBy = &s
}

// ConductedBy returns the value of the "ConductedBy" field in the mutation.
func (m *ExamPSMutation) ConductedBy() (r string, exists bool) {
	v := m._ConductedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldConductedBy returns the old "ConductedBy" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldConductedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConductedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConductedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConductedBy: %w", err)
	}
	return oldValue.ConductedBy, nil
}

// ResetConductedBy resets all changes to the "ConductedBy" field.
func (m *ExamPSMutation) ResetConductedBy() {
	m._ConductedBy = nil
}

// SetNodalOffice sets the "NodalOffice" field.
func (m *ExamPSMutation) SetNodalOffice(s string) {
	m._NodalOffice = &s
}

// NodalOffice returns the value of the "NodalOffice" field in the mutation.
func (m *ExamPSMutation) NodalOffice() (r string, exists bool) {
	v := m._NodalOffice
	if v == nil {
		return
	}
	return *v, true
}

// OldNodalOffice returns the old "NodalOffice" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldNodalOffice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodalOffice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodalOffice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodalOffice: %w", err)
	}
	return oldValue.NodalOffice, nil
}

// ClearNodalOffice clears the value of the "NodalOffice" field.
func (m *ExamPSMutation) ClearNodalOffice() {
	m._NodalOffice = nil
	m.clearedFields[exam_ps.FieldNodalOffice] = struct{}{}
}

// NodalOfficeCleared returns if the "NodalOffice" field was cleared in this mutation.
func (m *ExamPSMutation) NodalOfficeCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldNodalOffice]
	return ok
}

// ResetNodalOffice resets all changes to the "NodalOffice" field.
func (m *ExamPSMutation) ResetNodalOffice() {
	m._NodalOffice = nil
	delete(m.clearedFields, exam_ps.FieldNodalOffice)
}

// SetCalendarCode sets the "CalendarCode" field.
func (m *ExamPSMutation) SetCalendarCode(i int32) {
	m._CalendarCode = &i
	m.add_CalendarCode = nil
}

// CalendarCode returns the value of the "CalendarCode" field in the mutation.
func (m *ExamPSMutation) CalendarCode() (r int32, exists bool) {
	v := m._CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCalendarCode returns the old "CalendarCode" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldCalendarCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalendarCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalendarCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalendarCode: %w", err)
	}
	return oldValue.CalendarCode, nil
}

// AddCalendarCode adds i to the "CalendarCode" field.
func (m *ExamPSMutation) AddCalendarCode(i int32) {
	if m.add_CalendarCode != nil {
		*m.add_CalendarCode += i
	} else {
		m.add_CalendarCode = &i
	}
}

// AddedCalendarCode returns the value that was added to the "CalendarCode" field in this mutation.
func (m *ExamPSMutation) AddedCalendarCode() (r int32, exists bool) {
	v := m.add_CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalendarCode clears the value of the "CalendarCode" field.
func (m *ExamPSMutation) ClearCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	m.clearedFields[exam_ps.FieldCalendarCode] = struct{}{}
}

// CalendarCodeCleared returns if the "CalendarCode" field was cleared in this mutation.
func (m *ExamPSMutation) CalendarCodeCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldCalendarCode]
	return ok
}

// ResetCalendarCode resets all changes to the "CalendarCode" field.
func (m *ExamPSMutation) ResetCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	delete(m.clearedFields, exam_ps.FieldCalendarCode)
}

// SetPaperCode sets the "PaperCode" field.
func (m *ExamPSMutation) SetPaperCode(i int32) {
	m._PaperCode = &i
	m.add_PaperCode = nil
}

// PaperCode returns the value of the "PaperCode" field in the mutation.
func (m *ExamPSMutation) PaperCode() (r int32, exists bool) {
	v := m._PaperCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperCode returns the old "PaperCode" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldPaperCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperCode: %w", err)
	}
	return oldValue.PaperCode, nil
}

// AddPaperCode adds i to the "PaperCode" field.
func (m *ExamPSMutation) AddPaperCode(i int32) {
	if m.add_PaperCode != nil {
		*m.add_PaperCode += i
	} else {
		m.add_PaperCode = &i
	}
}

// AddedPaperCode returns the value that was added to the "PaperCode" field in this mutation.
func (m *ExamPSMutation) AddedPaperCode() (r int32, exists bool) {
	v := m.add_PaperCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaperCode clears the value of the "PaperCode" field.
func (m *ExamPSMutation) ClearPaperCode() {
	m._PaperCode = nil
	m.add_PaperCode = nil
	m.clearedFields[exam_ps.FieldPaperCode] = struct{}{}
}

// PaperCodeCleared returns if the "PaperCode" field was cleared in this mutation.
func (m *ExamPSMutation) PaperCodeCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldPaperCode]
	return ok
}

// ResetPaperCode resets all changes to the "PaperCode" field.
func (m *ExamPSMutation) ResetPaperCode() {
	m._PaperCode = nil
	m.add_PaperCode = nil
	delete(m.clearedFields, exam_ps.FieldPaperCode)
}

// SetEligibleCadre sets the "EligibleCadre" field.
func (m *ExamPSMutation) SetEligibleCadre(s string) {
	m._EligibleCadre = &s
}

// EligibleCadre returns the value of the "EligibleCadre" field in the mutation.
func (m *ExamPSMutation) EligibleCadre() (r string, exists bool) {
	v := m._EligibleCadre
	if v == nil {
		return
	}
	return *v, true
}

// OldEligibleCadre returns the old "EligibleCadre" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldEligibleCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligibleCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligibleCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligibleCadre: %w", err)
	}
	return oldValue.EligibleCadre, nil
}

// ClearEligibleCadre clears the value of the "EligibleCadre" field.
func (m *ExamPSMutation) ClearEligibleCadre() {
	m._EligibleCadre = nil
	m.clearedFields[exam_ps.FieldEligibleCadre] = struct{}{}
}

// EligibleCadreCleared returns if the "EligibleCadre" field was cleared in this mutation.
func (m *ExamPSMutation) EligibleCadreCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldEligibleCadre]
	return ok
}

// ResetEligibleCadre resets all changes to the "EligibleCadre" field.
func (m *ExamPSMutation) ResetEligibleCadre() {
	m._EligibleCadre = nil
	delete(m.clearedFields, exam_ps.FieldEligibleCadre)
}

// SetEligiblePost1 sets the "EligiblePost1" field.
func (m *ExamPSMutation) SetEligiblePost1(s string) {
	m._EligiblePost1 = &s
}

// EligiblePost1 returns the value of the "EligiblePost1" field in the mutation.
func (m *ExamPSMutation) EligiblePost1() (r string, exists bool) {
	v := m._EligiblePost1
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost1 returns the old "EligiblePost1" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldEligiblePost1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost1: %w", err)
	}
	return oldValue.EligiblePost1, nil
}

// ClearEligiblePost1 clears the value of the "EligiblePost1" field.
func (m *ExamPSMutation) ClearEligiblePost1() {
	m._EligiblePost1 = nil
	m.clearedFields[exam_ps.FieldEligiblePost1] = struct{}{}
}

// EligiblePost1Cleared returns if the "EligiblePost1" field was cleared in this mutation.
func (m *ExamPSMutation) EligiblePost1Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldEligiblePost1]
	return ok
}

// ResetEligiblePost1 resets all changes to the "EligiblePost1" field.
func (m *ExamPSMutation) ResetEligiblePost1() {
	m._EligiblePost1 = nil
	delete(m.clearedFields, exam_ps.FieldEligiblePost1)
}

// SetEligiblePost2 sets the "EligiblePost2" field.
func (m *ExamPSMutation) SetEligiblePost2(s string) {
	m._EligiblePost2 = &s
}

// EligiblePost2 returns the value of the "EligiblePost2" field in the mutation.
func (m *ExamPSMutation) EligiblePost2() (r string, exists bool) {
	v := m._EligiblePost2
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost2 returns the old "EligiblePost2" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldEligiblePost2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost2: %w", err)
	}
	return oldValue.EligiblePost2, nil
}

// ClearEligiblePost2 clears the value of the "EligiblePost2" field.
func (m *ExamPSMutation) ClearEligiblePost2() {
	m._EligiblePost2 = nil
	m.clearedFields[exam_ps.FieldEligiblePost2] = struct{}{}
}

// EligiblePost2Cleared returns if the "EligiblePost2" field was cleared in this mutation.
func (m *ExamPSMutation) EligiblePost2Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldEligiblePost2]
	return ok
}

// ResetEligiblePost2 resets all changes to the "EligiblePost2" field.
func (m *ExamPSMutation) ResetEligiblePost2() {
	m._EligiblePost2 = nil
	delete(m.clearedFields, exam_ps.FieldEligiblePost2)
}

// SetEligiblePost3 sets the "EligiblePost3" field.
func (m *ExamPSMutation) SetEligiblePost3(s string) {
	m._EligiblePost3 = &s
}

// EligiblePost3 returns the value of the "EligiblePost3" field in the mutation.
func (m *ExamPSMutation) EligiblePost3() (r string, exists bool) {
	v := m._EligiblePost3
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost3 returns the old "EligiblePost3" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldEligiblePost3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost3: %w", err)
	}
	return oldValue.EligiblePost3, nil
}

// ClearEligiblePost3 clears the value of the "EligiblePost3" field.
func (m *ExamPSMutation) ClearEligiblePost3() {
	m._EligiblePost3 = nil
	m.clearedFields[exam_ps.FieldEligiblePost3] = struct{}{}
}

// EligiblePost3Cleared returns if the "EligiblePost3" field was cleared in this mutation.
func (m *ExamPSMutation) EligiblePost3Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldEligiblePost3]
	return ok
}

// ResetEligiblePost3 resets all changes to the "EligiblePost3" field.
func (m *ExamPSMutation) ResetEligiblePost3() {
	m._EligiblePost3 = nil
	delete(m.clearedFields, exam_ps.FieldEligiblePost3)
}

// SetEligiblePost4 sets the "EligiblePost4" field.
func (m *ExamPSMutation) SetEligiblePost4(s string) {
	m._EligiblePost4 = &s
}

// EligiblePost4 returns the value of the "EligiblePost4" field in the mutation.
func (m *ExamPSMutation) EligiblePost4() (r string, exists bool) {
	v := m._EligiblePost4
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost4 returns the old "EligiblePost4" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldEligiblePost4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost4: %w", err)
	}
	return oldValue.EligiblePost4, nil
}

// ClearEligiblePost4 clears the value of the "EligiblePost4" field.
func (m *ExamPSMutation) ClearEligiblePost4() {
	m._EligiblePost4 = nil
	m.clearedFields[exam_ps.FieldEligiblePost4] = struct{}{}
}

// EligiblePost4Cleared returns if the "EligiblePost4" field was cleared in this mutation.
func (m *ExamPSMutation) EligiblePost4Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldEligiblePost4]
	return ok
}

// ResetEligiblePost4 resets all changes to the "EligiblePost4" field.
func (m *ExamPSMutation) ResetEligiblePost4() {
	m._EligiblePost4 = nil
	delete(m.clearedFields, exam_ps.FieldEligiblePost4)
}

// SetEligiblePost5 sets the "EligiblePost5" field.
func (m *ExamPSMutation) SetEligiblePost5(s string) {
	m._EligiblePost5 = &s
}

// EligiblePost5 returns the value of the "EligiblePost5" field in the mutation.
func (m *ExamPSMutation) EligiblePost5() (r string, exists bool) {
	v := m._EligiblePost5
	if v == nil {
		return
	}
	return *v, true
}

// OldEligiblePost5 returns the old "EligiblePost5" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldEligiblePost5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligiblePost5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligiblePost5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligiblePost5: %w", err)
	}
	return oldValue.EligiblePost5, nil
}

// ClearEligiblePost5 clears the value of the "EligiblePost5" field.
func (m *ExamPSMutation) ClearEligiblePost5() {
	m._EligiblePost5 = nil
	m.clearedFields[exam_ps.FieldEligiblePost5] = struct{}{}
}

// EligiblePost5Cleared returns if the "EligiblePost5" field was cleared in this mutation.
func (m *ExamPSMutation) EligiblePost5Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldEligiblePost5]
	return ok
}

// ResetEligiblePost5 resets all changes to the "EligiblePost5" field.
func (m *ExamPSMutation) ResetEligiblePost5() {
	m._EligiblePost5 = nil
	delete(m.clearedFields, exam_ps.FieldEligiblePost5)
}

// SetExamPost1 sets the "ExamPost1" field.
func (m *ExamPSMutation) SetExamPost1(s string) {
	m._ExamPost1 = &s
}

// ExamPost1 returns the value of the "ExamPost1" field in the mutation.
func (m *ExamPSMutation) ExamPost1() (r string, exists bool) {
	v := m._ExamPost1
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost1 returns the old "ExamPost1" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldExamPost1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost1: %w", err)
	}
	return oldValue.ExamPost1, nil
}

// ClearExamPost1 clears the value of the "ExamPost1" field.
func (m *ExamPSMutation) ClearExamPost1() {
	m._ExamPost1 = nil
	m.clearedFields[exam_ps.FieldExamPost1] = struct{}{}
}

// ExamPost1Cleared returns if the "ExamPost1" field was cleared in this mutation.
func (m *ExamPSMutation) ExamPost1Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldExamPost1]
	return ok
}

// ResetExamPost1 resets all changes to the "ExamPost1" field.
func (m *ExamPSMutation) ResetExamPost1() {
	m._ExamPost1 = nil
	delete(m.clearedFields, exam_ps.FieldExamPost1)
}

// SetExamPost2 sets the "ExamPost2" field.
func (m *ExamPSMutation) SetExamPost2(s string) {
	m._ExamPost2 = &s
}

// ExamPost2 returns the value of the "ExamPost2" field in the mutation.
func (m *ExamPSMutation) ExamPost2() (r string, exists bool) {
	v := m._ExamPost2
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost2 returns the old "ExamPost2" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldExamPost2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost2: %w", err)
	}
	return oldValue.ExamPost2, nil
}

// ClearExamPost2 clears the value of the "ExamPost2" field.
func (m *ExamPSMutation) ClearExamPost2() {
	m._ExamPost2 = nil
	m.clearedFields[exam_ps.FieldExamPost2] = struct{}{}
}

// ExamPost2Cleared returns if the "ExamPost2" field was cleared in this mutation.
func (m *ExamPSMutation) ExamPost2Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldExamPost2]
	return ok
}

// ResetExamPost2 resets all changes to the "ExamPost2" field.
func (m *ExamPSMutation) ResetExamPost2() {
	m._ExamPost2 = nil
	delete(m.clearedFields, exam_ps.FieldExamPost2)
}

// SetExamPost3 sets the "ExamPost3" field.
func (m *ExamPSMutation) SetExamPost3(s string) {
	m._ExamPost3 = &s
}

// ExamPost3 returns the value of the "ExamPost3" field in the mutation.
func (m *ExamPSMutation) ExamPost3() (r string, exists bool) {
	v := m._ExamPost3
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost3 returns the old "ExamPost3" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldExamPost3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost3: %w", err)
	}
	return oldValue.ExamPost3, nil
}

// ClearExamPost3 clears the value of the "ExamPost3" field.
func (m *ExamPSMutation) ClearExamPost3() {
	m._ExamPost3 = nil
	m.clearedFields[exam_ps.FieldExamPost3] = struct{}{}
}

// ExamPost3Cleared returns if the "ExamPost3" field was cleared in this mutation.
func (m *ExamPSMutation) ExamPost3Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldExamPost3]
	return ok
}

// ResetExamPost3 resets all changes to the "ExamPost3" field.
func (m *ExamPSMutation) ResetExamPost3() {
	m._ExamPost3 = nil
	delete(m.clearedFields, exam_ps.FieldExamPost3)
}

// SetExamPost4 sets the "ExamPost4" field.
func (m *ExamPSMutation) SetExamPost4(s string) {
	m._ExamPost4 = &s
}

// ExamPost4 returns the value of the "ExamPost4" field in the mutation.
func (m *ExamPSMutation) ExamPost4() (r string, exists bool) {
	v := m._ExamPost4
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost4 returns the old "ExamPost4" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldExamPost4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost4: %w", err)
	}
	return oldValue.ExamPost4, nil
}

// ClearExamPost4 clears the value of the "ExamPost4" field.
func (m *ExamPSMutation) ClearExamPost4() {
	m._ExamPost4 = nil
	m.clearedFields[exam_ps.FieldExamPost4] = struct{}{}
}

// ExamPost4Cleared returns if the "ExamPost4" field was cleared in this mutation.
func (m *ExamPSMutation) ExamPost4Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldExamPost4]
	return ok
}

// ResetExamPost4 resets all changes to the "ExamPost4" field.
func (m *ExamPSMutation) ResetExamPost4() {
	m._ExamPost4 = nil
	delete(m.clearedFields, exam_ps.FieldExamPost4)
}

// SetExamPost5 sets the "ExamPost5" field.
func (m *ExamPSMutation) SetExamPost5(s string) {
	m._ExamPost5 = &s
}

// ExamPost5 returns the value of the "ExamPost5" field in the mutation.
func (m *ExamPSMutation) ExamPost5() (r string, exists bool) {
	v := m._ExamPost5
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPost5 returns the old "ExamPost5" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldExamPost5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPost5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPost5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPost5: %w", err)
	}
	return oldValue.ExamPost5, nil
}

// ClearExamPost5 clears the value of the "ExamPost5" field.
func (m *ExamPSMutation) ClearExamPost5() {
	m._ExamPost5 = nil
	m.clearedFields[exam_ps.FieldExamPost5] = struct{}{}
}

// ExamPost5Cleared returns if the "ExamPost5" field was cleared in this mutation.
func (m *ExamPSMutation) ExamPost5Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldExamPost5]
	return ok
}

// ResetExamPost5 resets all changes to the "ExamPost5" field.
func (m *ExamPSMutation) ResetExamPost5() {
	m._ExamPost5 = nil
	delete(m.clearedFields, exam_ps.FieldExamPost5)
}

// SetEducationCriteria sets the "EducationCriteria" field.
func (m *ExamPSMutation) SetEducationCriteria(s string) {
	m._EducationCriteria = &s
}

// EducationCriteria returns the value of the "EducationCriteria" field in the mutation.
func (m *ExamPSMutation) EducationCriteria() (r string, exists bool) {
	v := m._EducationCriteria
	if v == nil {
		return
	}
	return *v, true
}

// OldEducationCriteria returns the old "EducationCriteria" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldEducationCriteria(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducationCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducationCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducationCriteria: %w", err)
	}
	return oldValue.EducationCriteria, nil
}

// ClearEducationCriteria clears the value of the "EducationCriteria" field.
func (m *ExamPSMutation) ClearEducationCriteria() {
	m._EducationCriteria = nil
	m.clearedFields[exam_ps.FieldEducationCriteria] = struct{}{}
}

// EducationCriteriaCleared returns if the "EducationCriteria" field was cleared in this mutation.
func (m *ExamPSMutation) EducationCriteriaCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldEducationCriteria]
	return ok
}

// ResetEducationCriteria resets all changes to the "EducationCriteria" field.
func (m *ExamPSMutation) ResetEducationCriteria() {
	m._EducationCriteria = nil
	delete(m.clearedFields, exam_ps.FieldEducationCriteria)
}

// SetCategoryAgeLimitGEN sets the "CategoryAgeLimitGEN" field.
func (m *ExamPSMutation) SetCategoryAgeLimitGEN(s string) {
	m._CategoryAgeLimitGEN = &s
}

// CategoryAgeLimitGEN returns the value of the "CategoryAgeLimitGEN" field in the mutation.
func (m *ExamPSMutation) CategoryAgeLimitGEN() (r string, exists bool) {
	v := m._CategoryAgeLimitGEN
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryAgeLimitGEN returns the old "CategoryAgeLimitGEN" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldCategoryAgeLimitGEN(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryAgeLimitGEN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryAgeLimitGEN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryAgeLimitGEN: %w", err)
	}
	return oldValue.CategoryAgeLimitGEN, nil
}

// ClearCategoryAgeLimitGEN clears the value of the "CategoryAgeLimitGEN" field.
func (m *ExamPSMutation) ClearCategoryAgeLimitGEN() {
	m._CategoryAgeLimitGEN = nil
	m.clearedFields[exam_ps.FieldCategoryAgeLimitGEN] = struct{}{}
}

// CategoryAgeLimitGENCleared returns if the "CategoryAgeLimitGEN" field was cleared in this mutation.
func (m *ExamPSMutation) CategoryAgeLimitGENCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldCategoryAgeLimitGEN]
	return ok
}

// ResetCategoryAgeLimitGEN resets all changes to the "CategoryAgeLimitGEN" field.
func (m *ExamPSMutation) ResetCategoryAgeLimitGEN() {
	m._CategoryAgeLimitGEN = nil
	delete(m.clearedFields, exam_ps.FieldCategoryAgeLimitGEN)
}

// SetCategoryAgeLimitSC sets the "CategoryAgeLimitSC" field.
func (m *ExamPSMutation) SetCategoryAgeLimitSC(s string) {
	m._CategoryAgeLimitSC = &s
}

// CategoryAgeLimitSC returns the value of the "CategoryAgeLimitSC" field in the mutation.
func (m *ExamPSMutation) CategoryAgeLimitSC() (r string, exists bool) {
	v := m._CategoryAgeLimitSC
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryAgeLimitSC returns the old "CategoryAgeLimitSC" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldCategoryAgeLimitSC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryAgeLimitSC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryAgeLimitSC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryAgeLimitSC: %w", err)
	}
	return oldValue.CategoryAgeLimitSC, nil
}

// ClearCategoryAgeLimitSC clears the value of the "CategoryAgeLimitSC" field.
func (m *ExamPSMutation) ClearCategoryAgeLimitSC() {
	m._CategoryAgeLimitSC = nil
	m.clearedFields[exam_ps.FieldCategoryAgeLimitSC] = struct{}{}
}

// CategoryAgeLimitSCCleared returns if the "CategoryAgeLimitSC" field was cleared in this mutation.
func (m *ExamPSMutation) CategoryAgeLimitSCCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldCategoryAgeLimitSC]
	return ok
}

// ResetCategoryAgeLimitSC resets all changes to the "CategoryAgeLimitSC" field.
func (m *ExamPSMutation) ResetCategoryAgeLimitSC() {
	m._CategoryAgeLimitSC = nil
	delete(m.clearedFields, exam_ps.FieldCategoryAgeLimitSC)
}

// SetCategoryAgeLimitST sets the "CategoryAgeLimitST" field.
func (m *ExamPSMutation) SetCategoryAgeLimitST(s string) {
	m._CategoryAgeLimitST = &s
}

// CategoryAgeLimitST returns the value of the "CategoryAgeLimitST" field in the mutation.
func (m *ExamPSMutation) CategoryAgeLimitST() (r string, exists bool) {
	v := m._CategoryAgeLimitST
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryAgeLimitST returns the old "CategoryAgeLimitST" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldCategoryAgeLimitST(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryAgeLimitST is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryAgeLimitST requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryAgeLimitST: %w", err)
	}
	return oldValue.CategoryAgeLimitST, nil
}

// ClearCategoryAgeLimitST clears the value of the "CategoryAgeLimitST" field.
func (m *ExamPSMutation) ClearCategoryAgeLimitST() {
	m._CategoryAgeLimitST = nil
	m.clearedFields[exam_ps.FieldCategoryAgeLimitST] = struct{}{}
}

// CategoryAgeLimitSTCleared returns if the "CategoryAgeLimitST" field was cleared in this mutation.
func (m *ExamPSMutation) CategoryAgeLimitSTCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldCategoryAgeLimitST]
	return ok
}

// ResetCategoryAgeLimitST resets all changes to the "CategoryAgeLimitST" field.
func (m *ExamPSMutation) ResetCategoryAgeLimitST() {
	m._CategoryAgeLimitST = nil
	delete(m.clearedFields, exam_ps.FieldCategoryAgeLimitST)
}

// SetServiceYears sets the "ServiceYears" field.
func (m *ExamPSMutation) SetServiceYears(s string) {
	m._ServiceYears = &s
}

// ServiceYears returns the value of the "ServiceYears" field in the mutation.
func (m *ExamPSMutation) ServiceYears() (r string, exists bool) {
	v := m._ServiceYears
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceYears returns the old "ServiceYears" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldServiceYears(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceYears is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceYears requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceYears: %w", err)
	}
	return oldValue.ServiceYears, nil
}

// ClearServiceYears clears the value of the "ServiceYears" field.
func (m *ExamPSMutation) ClearServiceYears() {
	m._ServiceYears = nil
	m.clearedFields[exam_ps.FieldServiceYears] = struct{}{}
}

// ServiceYearsCleared returns if the "ServiceYears" field was cleared in this mutation.
func (m *ExamPSMutation) ServiceYearsCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldServiceYears]
	return ok
}

// ResetServiceYears resets all changes to the "ServiceYears" field.
func (m *ExamPSMutation) ResetServiceYears() {
	m._ServiceYears = nil
	delete(m.clearedFields, exam_ps.FieldServiceYears)
}

// SetDrivingLicenseRequired sets the "DrivingLicenseRequired" field.
func (m *ExamPSMutation) SetDrivingLicenseRequired(s string) {
	m._DrivingLicenseRequired = &s
}

// DrivingLicenseRequired returns the value of the "DrivingLicenseRequired" field in the mutation.
func (m *ExamPSMutation) DrivingLicenseRequired() (r string, exists bool) {
	v := m._DrivingLicenseRequired
	if v == nil {
		return
	}
	return *v, true
}

// OldDrivingLicenseRequired returns the old "DrivingLicenseRequired" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldDrivingLicenseRequired(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrivingLicenseRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrivingLicenseRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrivingLicenseRequired: %w", err)
	}
	return oldValue.DrivingLicenseRequired, nil
}

// ClearDrivingLicenseRequired clears the value of the "DrivingLicenseRequired" field.
func (m *ExamPSMutation) ClearDrivingLicenseRequired() {
	m._DrivingLicenseRequired = nil
	m.clearedFields[exam_ps.FieldDrivingLicenseRequired] = struct{}{}
}

// DrivingLicenseRequiredCleared returns if the "DrivingLicenseRequired" field was cleared in this mutation.
func (m *ExamPSMutation) DrivingLicenseRequiredCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldDrivingLicenseRequired]
	return ok
}

// ResetDrivingLicenseRequired resets all changes to the "DrivingLicenseRequired" field.
func (m *ExamPSMutation) ResetDrivingLicenseRequired() {
	m._DrivingLicenseRequired = nil
	delete(m.clearedFields, exam_ps.FieldDrivingLicenseRequired)
}

// SetExamPaperCode sets the "ExamPaperCode" field.
func (m *ExamPSMutation) SetExamPaperCode(s string) {
	m._ExamPaperCode = &s
}

// ExamPaperCode returns the value of the "ExamPaperCode" field in the mutation.
func (m *ExamPSMutation) ExamPaperCode() (r string, exists bool) {
	v := m._ExamPaperCode
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaperCode returns the old "ExamPaperCode" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldExamPaperCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaperCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaperCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaperCode: %w", err)
	}
	return oldValue.ExamPaperCode, nil
}

// ClearExamPaperCode clears the value of the "ExamPaperCode" field.
func (m *ExamPSMutation) ClearExamPaperCode() {
	m._ExamPaperCode = nil
	m.clearedFields[exam_ps.FieldExamPaperCode] = struct{}{}
}

// ExamPaperCodeCleared returns if the "ExamPaperCode" field was cleared in this mutation.
func (m *ExamPSMutation) ExamPaperCodeCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldExamPaperCode]
	return ok
}

// ResetExamPaperCode resets all changes to the "ExamPaperCode" field.
func (m *ExamPSMutation) ResetExamPaperCode() {
	m._ExamPaperCode = nil
	delete(m.clearedFields, exam_ps.FieldExamPaperCode)
}

// SetExamPaper1 sets the "ExamPaper1" field.
func (m *ExamPSMutation) SetExamPaper1(s string) {
	m._ExamPaper1 = &s
}

// ExamPaper1 returns the value of the "ExamPaper1" field in the mutation.
func (m *ExamPSMutation) ExamPaper1() (r string, exists bool) {
	v := m._ExamPaper1
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper1 returns the old "ExamPaper1" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldExamPaper1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper1: %w", err)
	}
	return oldValue.ExamPaper1, nil
}

// ClearExamPaper1 clears the value of the "ExamPaper1" field.
func (m *ExamPSMutation) ClearExamPaper1() {
	m._ExamPaper1 = nil
	m.clearedFields[exam_ps.FieldExamPaper1] = struct{}{}
}

// ExamPaper1Cleared returns if the "ExamPaper1" field was cleared in this mutation.
func (m *ExamPSMutation) ExamPaper1Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldExamPaper1]
	return ok
}

// ResetExamPaper1 resets all changes to the "ExamPaper1" field.
func (m *ExamPSMutation) ResetExamPaper1() {
	m._ExamPaper1 = nil
	delete(m.clearedFields, exam_ps.FieldExamPaper1)
}

// SetExamPaper2 sets the "ExamPaper2" field.
func (m *ExamPSMutation) SetExamPaper2(s string) {
	m._ExamPaper2 = &s
}

// ExamPaper2 returns the value of the "ExamPaper2" field in the mutation.
func (m *ExamPSMutation) ExamPaper2() (r string, exists bool) {
	v := m._ExamPaper2
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper2 returns the old "ExamPaper2" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldExamPaper2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper2: %w", err)
	}
	return oldValue.ExamPaper2, nil
}

// ClearExamPaper2 clears the value of the "ExamPaper2" field.
func (m *ExamPSMutation) ClearExamPaper2() {
	m._ExamPaper2 = nil
	m.clearedFields[exam_ps.FieldExamPaper2] = struct{}{}
}

// ExamPaper2Cleared returns if the "ExamPaper2" field was cleared in this mutation.
func (m *ExamPSMutation) ExamPaper2Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldExamPaper2]
	return ok
}

// ResetExamPaper2 resets all changes to the "ExamPaper2" field.
func (m *ExamPSMutation) ResetExamPaper2() {
	m._ExamPaper2 = nil
	delete(m.clearedFields, exam_ps.FieldExamPaper2)
}

// SetExamPaper3 sets the "ExamPaper3" field.
func (m *ExamPSMutation) SetExamPaper3(s string) {
	m._ExamPaper3 = &s
}

// ExamPaper3 returns the value of the "ExamPaper3" field in the mutation.
func (m *ExamPSMutation) ExamPaper3() (r string, exists bool) {
	v := m._ExamPaper3
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper3 returns the old "ExamPaper3" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldExamPaper3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper3: %w", err)
	}
	return oldValue.ExamPaper3, nil
}

// ClearExamPaper3 clears the value of the "ExamPaper3" field.
func (m *ExamPSMutation) ClearExamPaper3() {
	m._ExamPaper3 = nil
	m.clearedFields[exam_ps.FieldExamPaper3] = struct{}{}
}

// ExamPaper3Cleared returns if the "ExamPaper3" field was cleared in this mutation.
func (m *ExamPSMutation) ExamPaper3Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldExamPaper3]
	return ok
}

// ResetExamPaper3 resets all changes to the "ExamPaper3" field.
func (m *ExamPSMutation) ResetExamPaper3() {
	m._ExamPaper3 = nil
	delete(m.clearedFields, exam_ps.FieldExamPaper3)
}

// SetExamPaper4 sets the "ExamPaper4" field.
func (m *ExamPSMutation) SetExamPaper4(s string) {
	m._ExamPaper4 = &s
}

// ExamPaper4 returns the value of the "ExamPaper4" field in the mutation.
func (m *ExamPSMutation) ExamPaper4() (r string, exists bool) {
	v := m._ExamPaper4
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper4 returns the old "ExamPaper4" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldExamPaper4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper4: %w", err)
	}
	return oldValue.ExamPaper4, nil
}

// ClearExamPaper4 clears the value of the "ExamPaper4" field.
func (m *ExamPSMutation) ClearExamPaper4() {
	m._ExamPaper4 = nil
	m.clearedFields[exam_ps.FieldExamPaper4] = struct{}{}
}

// ExamPaper4Cleared returns if the "ExamPaper4" field was cleared in this mutation.
func (m *ExamPSMutation) ExamPaper4Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldExamPaper4]
	return ok
}

// ResetExamPaper4 resets all changes to the "ExamPaper4" field.
func (m *ExamPSMutation) ResetExamPaper4() {
	m._ExamPaper4 = nil
	delete(m.clearedFields, exam_ps.FieldExamPaper4)
}

// SetExamPaper5 sets the "ExamPaper5" field.
func (m *ExamPSMutation) SetExamPaper5(s string) {
	m._ExamPaper5 = &s
}

// ExamPaper5 returns the value of the "ExamPaper5" field in the mutation.
func (m *ExamPSMutation) ExamPaper5() (r string, exists bool) {
	v := m._ExamPaper5
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper5 returns the old "ExamPaper5" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldExamPaper5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper5: %w", err)
	}
	return oldValue.ExamPaper5, nil
}

// ClearExamPaper5 clears the value of the "ExamPaper5" field.
func (m *ExamPSMutation) ClearExamPaper5() {
	m._ExamPaper5 = nil
	m.clearedFields[exam_ps.FieldExamPaper5] = struct{}{}
}

// ExamPaper5Cleared returns if the "ExamPaper5" field was cleared in this mutation.
func (m *ExamPSMutation) ExamPaper5Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldExamPaper5]
	return ok
}

// ResetExamPaper5 resets all changes to the "ExamPaper5" field.
func (m *ExamPSMutation) ResetExamPaper5() {
	m._ExamPaper5 = nil
	delete(m.clearedFields, exam_ps.FieldExamPaper5)
}

// SetExamPaper6 sets the "ExamPaper6" field.
func (m *ExamPSMutation) SetExamPaper6(s string) {
	m._ExamPaper6 = &s
}

// ExamPaper6 returns the value of the "ExamPaper6" field in the mutation.
func (m *ExamPSMutation) ExamPaper6() (r string, exists bool) {
	v := m._ExamPaper6
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaper6 returns the old "ExamPaper6" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldExamPaper6(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamPaper6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamPaper6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaper6: %w", err)
	}
	return oldValue.ExamPaper6, nil
}

// ClearExamPaper6 clears the value of the "ExamPaper6" field.
func (m *ExamPSMutation) ClearExamPaper6() {
	m._ExamPaper6 = nil
	m.clearedFields[exam_ps.FieldExamPaper6] = struct{}{}
}

// ExamPaper6Cleared returns if the "ExamPaper6" field was cleared in this mutation.
func (m *ExamPSMutation) ExamPaper6Cleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldExamPaper6]
	return ok
}

// ResetExamPaper6 resets all changes to the "ExamPaper6" field.
func (m *ExamPSMutation) ResetExamPaper6() {
	m._ExamPaper6 = nil
	delete(m.clearedFields, exam_ps.FieldExamPaper6)
}

// SetPayLevelEligibilty sets the "PayLevelEligibilty" field.
func (m *ExamPSMutation) SetPayLevelEligibilty(s string) {
	m._PayLevelEligibilty = &s
}

// PayLevelEligibilty returns the value of the "PayLevelEligibilty" field in the mutation.
func (m *ExamPSMutation) PayLevelEligibilty() (r string, exists bool) {
	v := m._PayLevelEligibilty
	if v == nil {
		return
	}
	return *v, true
}

// OldPayLevelEligibilty returns the old "PayLevelEligibilty" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldPayLevelEligibilty(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayLevelEligibilty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayLevelEligibilty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayLevelEligibilty: %w", err)
	}
	return oldValue.PayLevelEligibilty, nil
}

// ClearPayLevelEligibilty clears the value of the "PayLevelEligibilty" field.
func (m *ExamPSMutation) ClearPayLevelEligibilty() {
	m._PayLevelEligibilty = nil
	m.clearedFields[exam_ps.FieldPayLevelEligibilty] = struct{}{}
}

// PayLevelEligibiltyCleared returns if the "PayLevelEligibilty" field was cleared in this mutation.
func (m *ExamPSMutation) PayLevelEligibiltyCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldPayLevelEligibilty]
	return ok
}

// ResetPayLevelEligibilty resets all changes to the "PayLevelEligibilty" field.
func (m *ExamPSMutation) ResetPayLevelEligibilty() {
	m._PayLevelEligibilty = nil
	delete(m.clearedFields, exam_ps.FieldPayLevelEligibilty)
}

// SetCategoryMinMarksSCSTPH sets the "CategoryMinMarksSCSTPH" field.
func (m *ExamPSMutation) SetCategoryMinMarksSCSTPH(s string) {
	m._CategoryMinMarksSCSTPH = &s
}

// CategoryMinMarksSCSTPH returns the value of the "CategoryMinMarksSCSTPH" field in the mutation.
func (m *ExamPSMutation) CategoryMinMarksSCSTPH() (r string, exists bool) {
	v := m._CategoryMinMarksSCSTPH
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryMinMarksSCSTPH returns the old "CategoryMinMarksSCSTPH" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldCategoryMinMarksSCSTPH(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryMinMarksSCSTPH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryMinMarksSCSTPH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryMinMarksSCSTPH: %w", err)
	}
	return oldValue.CategoryMinMarksSCSTPH, nil
}

// ClearCategoryMinMarksSCSTPH clears the value of the "CategoryMinMarksSCSTPH" field.
func (m *ExamPSMutation) ClearCategoryMinMarksSCSTPH() {
	m._CategoryMinMarksSCSTPH = nil
	m.clearedFields[exam_ps.FieldCategoryMinMarksSCSTPH] = struct{}{}
}

// CategoryMinMarksSCSTPHCleared returns if the "CategoryMinMarksSCSTPH" field was cleared in this mutation.
func (m *ExamPSMutation) CategoryMinMarksSCSTPHCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldCategoryMinMarksSCSTPH]
	return ok
}

// ResetCategoryMinMarksSCSTPH resets all changes to the "CategoryMinMarksSCSTPH" field.
func (m *ExamPSMutation) ResetCategoryMinMarksSCSTPH() {
	m._CategoryMinMarksSCSTPH = nil
	delete(m.clearedFields, exam_ps.FieldCategoryMinMarksSCSTPH)
}

// SetCategoryMinMarksGENOBC sets the "CategoryMinMarksGENOBC" field.
func (m *ExamPSMutation) SetCategoryMinMarksGENOBC(s string) {
	m._CategoryMinMarksGENOBC = &s
}

// CategoryMinMarksGENOBC returns the value of the "CategoryMinMarksGENOBC" field in the mutation.
func (m *ExamPSMutation) CategoryMinMarksGENOBC() (r string, exists bool) {
	v := m._CategoryMinMarksGENOBC
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryMinMarksGENOBC returns the old "CategoryMinMarksGENOBC" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldCategoryMinMarksGENOBC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryMinMarksGENOBC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryMinMarksGENOBC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryMinMarksGENOBC: %w", err)
	}
	return oldValue.CategoryMinMarksGENOBC, nil
}

// ClearCategoryMinMarksGENOBC clears the value of the "CategoryMinMarksGENOBC" field.
func (m *ExamPSMutation) ClearCategoryMinMarksGENOBC() {
	m._CategoryMinMarksGENOBC = nil
	m.clearedFields[exam_ps.FieldCategoryMinMarksGENOBC] = struct{}{}
}

// CategoryMinMarksGENOBCCleared returns if the "CategoryMinMarksGENOBC" field was cleared in this mutation.
func (m *ExamPSMutation) CategoryMinMarksGENOBCCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldCategoryMinMarksGENOBC]
	return ok
}

// ResetCategoryMinMarksGENOBC resets all changes to the "CategoryMinMarksGENOBC" field.
func (m *ExamPSMutation) ResetCategoryMinMarksGENOBC() {
	m._CategoryMinMarksGENOBC = nil
	delete(m.clearedFields, exam_ps.FieldCategoryMinMarksGENOBC)
}

// SetLocalLanguageAllowed sets the "LocalLanguageAllowed" field.
func (m *ExamPSMutation) SetLocalLanguageAllowed(s string) {
	m._LocalLanguageAllowed = &s
}

// LocalLanguageAllowed returns the value of the "LocalLanguageAllowed" field in the mutation.
func (m *ExamPSMutation) LocalLanguageAllowed() (r string, exists bool) {
	v := m._LocalLanguageAllowed
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalLanguageAllowed returns the old "LocalLanguageAllowed" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldLocalLanguageAllowed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalLanguageAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalLanguageAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalLanguageAllowed: %w", err)
	}
	return oldValue.LocalLanguageAllowed, nil
}

// ClearLocalLanguageAllowed clears the value of the "LocalLanguageAllowed" field.
func (m *ExamPSMutation) ClearLocalLanguageAllowed() {
	m._LocalLanguageAllowed = nil
	m.clearedFields[exam_ps.FieldLocalLanguageAllowed] = struct{}{}
}

// LocalLanguageAllowedCleared returns if the "LocalLanguageAllowed" field was cleared in this mutation.
func (m *ExamPSMutation) LocalLanguageAllowedCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldLocalLanguageAllowed]
	return ok
}

// ResetLocalLanguageAllowed resets all changes to the "LocalLanguageAllowed" field.
func (m *ExamPSMutation) ResetLocalLanguageAllowed() {
	m._LocalLanguageAllowed = nil
	delete(m.clearedFields, exam_ps.FieldLocalLanguageAllowed)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *ExamPSMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *ExamPSMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *ExamPSMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[exam_ps.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *ExamPSMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *ExamPSMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, exam_ps.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *ExamPSMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *ExamPSMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the Exam_PS entity.
// If the Exam_PS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExamPSMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *ExamPSMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[exam_ps.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *ExamPSMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[exam_ps.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *ExamPSMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, exam_ps.FieldUpdatedBy)
}

// AddExamcalPsRefIDs adds the "examcal_ps_ref" edge to the ExamCalendar entity by ids.
func (m *ExamPSMutation) AddExamcalPsRefIDs(ids ...int32) {
	if m.examcal_ps_ref == nil {
		m.examcal_ps_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.examcal_ps_ref[ids[i]] = struct{}{}
	}
}

// ClearExamcalPsRef clears the "examcal_ps_ref" edge to the ExamCalendar entity.
func (m *ExamPSMutation) ClearExamcalPsRef() {
	m.clearedexamcal_ps_ref = true
}

// ExamcalPsRefCleared reports if the "examcal_ps_ref" edge to the ExamCalendar entity was cleared.
func (m *ExamPSMutation) ExamcalPsRefCleared() bool {
	return m.clearedexamcal_ps_ref
}

// RemoveExamcalPsRefIDs removes the "examcal_ps_ref" edge to the ExamCalendar entity by IDs.
func (m *ExamPSMutation) RemoveExamcalPsRefIDs(ids ...int32) {
	if m.removedexamcal_ps_ref == nil {
		m.removedexamcal_ps_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.examcal_ps_ref, ids[i])
		m.removedexamcal_ps_ref[ids[i]] = struct{}{}
	}
}

// RemovedExamcalPsRef returns the removed IDs of the "examcal_ps_ref" edge to the ExamCalendar entity.
func (m *ExamPSMutation) RemovedExamcalPsRefIDs() (ids []int32) {
	for id := range m.removedexamcal_ps_ref {
		ids = append(ids, id)
	}
	return
}

// ExamcalPsRefIDs returns the "examcal_ps_ref" edge IDs in the mutation.
func (m *ExamPSMutation) ExamcalPsRefIDs() (ids []int32) {
	for id := range m.examcal_ps_ref {
		ids = append(ids, id)
	}
	return
}

// ResetExamcalPsRef resets all changes to the "examcal_ps_ref" edge.
func (m *ExamPSMutation) ResetExamcalPsRef() {
	m.examcal_ps_ref = nil
	m.clearedexamcal_ps_ref = false
	m.removedexamcal_ps_ref = nil
}

// AddPapersPsRefIDs adds the "papers_ps_ref" edge to the ExamPapers entity by ids.
func (m *ExamPSMutation) AddPapersPsRefIDs(ids ...int32) {
	if m.papers_ps_ref == nil {
		m.papers_ps_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.papers_ps_ref[ids[i]] = struct{}{}
	}
}

// ClearPapersPsRef clears the "papers_ps_ref" edge to the ExamPapers entity.
func (m *ExamPSMutation) ClearPapersPsRef() {
	m.clearedpapers_ps_ref = true
}

// PapersPsRefCleared reports if the "papers_ps_ref" edge to the ExamPapers entity was cleared.
func (m *ExamPSMutation) PapersPsRefCleared() bool {
	return m.clearedpapers_ps_ref
}

// RemovePapersPsRefIDs removes the "papers_ps_ref" edge to the ExamPapers entity by IDs.
func (m *ExamPSMutation) RemovePapersPsRefIDs(ids ...int32) {
	if m.removedpapers_ps_ref == nil {
		m.removedpapers_ps_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.papers_ps_ref, ids[i])
		m.removedpapers_ps_ref[ids[i]] = struct{}{}
	}
}

// RemovedPapersPsRef returns the removed IDs of the "papers_ps_ref" edge to the ExamPapers entity.
func (m *ExamPSMutation) RemovedPapersPsRefIDs() (ids []int32) {
	for id := range m.removedpapers_ps_ref {
		ids = append(ids, id)
	}
	return
}

// PapersPsRefIDs returns the "papers_ps_ref" edge IDs in the mutation.
func (m *ExamPSMutation) PapersPsRefIDs() (ids []int32) {
	for id := range m.papers_ps_ref {
		ids = append(ids, id)
	}
	return
}

// ResetPapersPsRef resets all changes to the "papers_ps_ref" edge.
func (m *ExamPSMutation) ResetPapersPsRef() {
	m.papers_ps_ref = nil
	m.clearedpapers_ps_ref = false
	m.removedpapers_ps_ref = nil
}

// AddUsersPsTypeIDs adds the "users_ps_type" edge to the UserMaster entity by ids.
func (m *ExamPSMutation) AddUsersPsTypeIDs(ids ...int64) {
	if m.users_ps_type == nil {
		m.users_ps_type = make(map[int64]struct{})
	}
	for i := range ids {
		m.users_ps_type[ids[i]] = struct{}{}
	}
}

// ClearUsersPsType clears the "users_ps_type" edge to the UserMaster entity.
func (m *ExamPSMutation) ClearUsersPsType() {
	m.clearedusers_ps_type = true
}

// UsersPsTypeCleared reports if the "users_ps_type" edge to the UserMaster entity was cleared.
func (m *ExamPSMutation) UsersPsTypeCleared() bool {
	return m.clearedusers_ps_type
}

// RemoveUsersPsTypeIDs removes the "users_ps_type" edge to the UserMaster entity by IDs.
func (m *ExamPSMutation) RemoveUsersPsTypeIDs(ids ...int64) {
	if m.removedusers_ps_type == nil {
		m.removedusers_ps_type = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users_ps_type, ids[i])
		m.removedusers_ps_type[ids[i]] = struct{}{}
	}
}

// RemovedUsersPsType returns the removed IDs of the "users_ps_type" edge to the UserMaster entity.
func (m *ExamPSMutation) RemovedUsersPsTypeIDs() (ids []int64) {
	for id := range m.removedusers_ps_type {
		ids = append(ids, id)
	}
	return
}

// UsersPsTypeIDs returns the "users_ps_type" edge IDs in the mutation.
func (m *ExamPSMutation) UsersPsTypeIDs() (ids []int64) {
	for id := range m.users_ps_type {
		ids = append(ids, id)
	}
	return
}

// ResetUsersPsType resets all changes to the "users_ps_type" edge.
func (m *ExamPSMutation) ResetUsersPsType() {
	m.users_ps_type = nil
	m.clearedusers_ps_type = false
	m.removedusers_ps_type = nil
}

// AddExamApplnPSRefIDs adds the "ExamAppln_PS_Ref" edge to the Exam_Applications_PS entity by ids.
func (m *ExamPSMutation) AddExamApplnPSRefIDs(ids ...int64) {
	if m._ExamAppln_PS_Ref == nil {
		m._ExamAppln_PS_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		m._ExamAppln_PS_Ref[ids[i]] = struct{}{}
	}
}

// ClearExamApplnPSRef clears the "ExamAppln_PS_Ref" edge to the Exam_Applications_PS entity.
func (m *ExamPSMutation) ClearExamApplnPSRef() {
	m.cleared_ExamAppln_PS_Ref = true
}

// ExamApplnPSRefCleared reports if the "ExamAppln_PS_Ref" edge to the Exam_Applications_PS entity was cleared.
func (m *ExamPSMutation) ExamApplnPSRefCleared() bool {
	return m.cleared_ExamAppln_PS_Ref
}

// RemoveExamApplnPSRefIDs removes the "ExamAppln_PS_Ref" edge to the Exam_Applications_PS entity by IDs.
func (m *ExamPSMutation) RemoveExamApplnPSRefIDs(ids ...int64) {
	if m.removed_ExamAppln_PS_Ref == nil {
		m.removed_ExamAppln_PS_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._ExamAppln_PS_Ref, ids[i])
		m.removed_ExamAppln_PS_Ref[ids[i]] = struct{}{}
	}
}

// RemovedExamApplnPSRef returns the removed IDs of the "ExamAppln_PS_Ref" edge to the Exam_Applications_PS entity.
func (m *ExamPSMutation) RemovedExamApplnPSRefIDs() (ids []int64) {
	for id := range m.removed_ExamAppln_PS_Ref {
		ids = append(ids, id)
	}
	return
}

// ExamApplnPSRefIDs returns the "ExamAppln_PS_Ref" edge IDs in the mutation.
func (m *ExamPSMutation) ExamApplnPSRefIDs() (ids []int64) {
	for id := range m._ExamAppln_PS_Ref {
		ids = append(ids, id)
	}
	return
}

// ResetExamApplnPSRef resets all changes to the "ExamAppln_PS_Ref" edge.
func (m *ExamPSMutation) ResetExamApplnPSRef() {
	m._ExamAppln_PS_Ref = nil
	m.cleared_ExamAppln_PS_Ref = false
	m.removed_ExamAppln_PS_Ref = nil
}

// AddNotificationsPIDs adds the "notifications_ps" edge to the Notification entity by ids.
func (m *ExamPSMutation) AddNotificationsPIDs(ids ...int32) {
	if m.notifications_ps == nil {
		m.notifications_ps = make(map[int32]struct{})
	}
	for i := range ids {
		m.notifications_ps[ids[i]] = struct{}{}
	}
}

// ClearNotificationsPs clears the "notifications_ps" edge to the Notification entity.
func (m *ExamPSMutation) ClearNotificationsPs() {
	m.clearednotifications_ps = true
}

// NotificationsPsCleared reports if the "notifications_ps" edge to the Notification entity was cleared.
func (m *ExamPSMutation) NotificationsPsCleared() bool {
	return m.clearednotifications_ps
}

// RemoveNotificationsPIDs removes the "notifications_ps" edge to the Notification entity by IDs.
func (m *ExamPSMutation) RemoveNotificationsPIDs(ids ...int32) {
	if m.removednotifications_ps == nil {
		m.removednotifications_ps = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.notifications_ps, ids[i])
		m.removednotifications_ps[ids[i]] = struct{}{}
	}
}

// RemovedNotificationsPs returns the removed IDs of the "notifications_ps" edge to the Notification entity.
func (m *ExamPSMutation) RemovedNotificationsPsIDs() (ids []int32) {
	for id := range m.removednotifications_ps {
		ids = append(ids, id)
	}
	return
}

// NotificationsPsIDs returns the "notifications_ps" edge IDs in the mutation.
func (m *ExamPSMutation) NotificationsPsIDs() (ids []int32) {
	for id := range m.notifications_ps {
		ids = append(ids, id)
	}
	return
}

// ResetNotificationsPs resets all changes to the "notifications_ps" edge.
func (m *ExamPSMutation) ResetNotificationsPs() {
	m.notifications_ps = nil
	m.clearednotifications_ps = false
	m.removednotifications_ps = nil
}

// Where appends a list predicates to the ExamPSMutation builder.
func (m *ExamPSMutation) Where(ps ...predicate.Exam_PS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExamPSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExamPSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exam_PS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExamPSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExamPSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exam_PS).
func (m *ExamPSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExamPSMutation) Fields() []string {
	fields := make([]string, 0, 38)
	if m._ExamNameCode != nil {
		fields = append(fields, exam_ps.FieldExamNameCode)
	}
	if m._ExamName != nil {
		fields = append(fields, exam_ps.FieldExamName)
	}
	if m._ExamType != nil {
		fields = append(fields, exam_ps.FieldExamType)
	}
	if m._NotificationCode != nil {
		fields = append(fields, exam_ps.FieldNotificationCode)
	}
	if m._ConductedBy != nil {
		fields = append(fields, exam_ps.FieldConductedBy)
	}
	if m._NodalOffice != nil {
		fields = append(fields, exam_ps.FieldNodalOffice)
	}
	if m._CalendarCode != nil {
		fields = append(fields, exam_ps.FieldCalendarCode)
	}
	if m._PaperCode != nil {
		fields = append(fields, exam_ps.FieldPaperCode)
	}
	if m._EligibleCadre != nil {
		fields = append(fields, exam_ps.FieldEligibleCadre)
	}
	if m._EligiblePost1 != nil {
		fields = append(fields, exam_ps.FieldEligiblePost1)
	}
	if m._EligiblePost2 != nil {
		fields = append(fields, exam_ps.FieldEligiblePost2)
	}
	if m._EligiblePost3 != nil {
		fields = append(fields, exam_ps.FieldEligiblePost3)
	}
	if m._EligiblePost4 != nil {
		fields = append(fields, exam_ps.FieldEligiblePost4)
	}
	if m._EligiblePost5 != nil {
		fields = append(fields, exam_ps.FieldEligiblePost5)
	}
	if m._ExamPost1 != nil {
		fields = append(fields, exam_ps.FieldExamPost1)
	}
	if m._ExamPost2 != nil {
		fields = append(fields, exam_ps.FieldExamPost2)
	}
	if m._ExamPost3 != nil {
		fields = append(fields, exam_ps.FieldExamPost3)
	}
	if m._ExamPost4 != nil {
		fields = append(fields, exam_ps.FieldExamPost4)
	}
	if m._ExamPost5 != nil {
		fields = append(fields, exam_ps.FieldExamPost5)
	}
	if m._EducationCriteria != nil {
		fields = append(fields, exam_ps.FieldEducationCriteria)
	}
	if m._CategoryAgeLimitGEN != nil {
		fields = append(fields, exam_ps.FieldCategoryAgeLimitGEN)
	}
	if m._CategoryAgeLimitSC != nil {
		fields = append(fields, exam_ps.FieldCategoryAgeLimitSC)
	}
	if m._CategoryAgeLimitST != nil {
		fields = append(fields, exam_ps.FieldCategoryAgeLimitST)
	}
	if m._ServiceYears != nil {
		fields = append(fields, exam_ps.FieldServiceYears)
	}
	if m._DrivingLicenseRequired != nil {
		fields = append(fields, exam_ps.FieldDrivingLicenseRequired)
	}
	if m._ExamPaperCode != nil {
		fields = append(fields, exam_ps.FieldExamPaperCode)
	}
	if m._ExamPaper1 != nil {
		fields = append(fields, exam_ps.FieldExamPaper1)
	}
	if m._ExamPaper2 != nil {
		fields = append(fields, exam_ps.FieldExamPaper2)
	}
	if m._ExamPaper3 != nil {
		fields = append(fields, exam_ps.FieldExamPaper3)
	}
	if m._ExamPaper4 != nil {
		fields = append(fields, exam_ps.FieldExamPaper4)
	}
	if m._ExamPaper5 != nil {
		fields = append(fields, exam_ps.FieldExamPaper5)
	}
	if m._ExamPaper6 != nil {
		fields = append(fields, exam_ps.FieldExamPaper6)
	}
	if m._PayLevelEligibilty != nil {
		fields = append(fields, exam_ps.FieldPayLevelEligibilty)
	}
	if m._CategoryMinMarksSCSTPH != nil {
		fields = append(fields, exam_ps.FieldCategoryMinMarksSCSTPH)
	}
	if m._CategoryMinMarksGENOBC != nil {
		fields = append(fields, exam_ps.FieldCategoryMinMarksGENOBC)
	}
	if m._LocalLanguageAllowed != nil {
		fields = append(fields, exam_ps.FieldLocalLanguageAllowed)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, exam_ps.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, exam_ps.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExamPSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exam_ps.FieldExamNameCode:
		return m.ExamNameCode()
	case exam_ps.FieldExamName:
		return m.ExamName()
	case exam_ps.FieldExamType:
		return m.ExamType()
	case exam_ps.FieldNotificationCode:
		return m.NotificationCode()
	case exam_ps.FieldConductedBy:
		return m.ConductedBy()
	case exam_ps.FieldNodalOffice:
		return m.NodalOffice()
	case exam_ps.FieldCalendarCode:
		return m.CalendarCode()
	case exam_ps.FieldPaperCode:
		return m.PaperCode()
	case exam_ps.FieldEligibleCadre:
		return m.EligibleCadre()
	case exam_ps.FieldEligiblePost1:
		return m.EligiblePost1()
	case exam_ps.FieldEligiblePost2:
		return m.EligiblePost2()
	case exam_ps.FieldEligiblePost3:
		return m.EligiblePost3()
	case exam_ps.FieldEligiblePost4:
		return m.EligiblePost4()
	case exam_ps.FieldEligiblePost5:
		return m.EligiblePost5()
	case exam_ps.FieldExamPost1:
		return m.ExamPost1()
	case exam_ps.FieldExamPost2:
		return m.ExamPost2()
	case exam_ps.FieldExamPost3:
		return m.ExamPost3()
	case exam_ps.FieldExamPost4:
		return m.ExamPost4()
	case exam_ps.FieldExamPost5:
		return m.ExamPost5()
	case exam_ps.FieldEducationCriteria:
		return m.EducationCriteria()
	case exam_ps.FieldCategoryAgeLimitGEN:
		return m.CategoryAgeLimitGEN()
	case exam_ps.FieldCategoryAgeLimitSC:
		return m.CategoryAgeLimitSC()
	case exam_ps.FieldCategoryAgeLimitST:
		return m.CategoryAgeLimitST()
	case exam_ps.FieldServiceYears:
		return m.ServiceYears()
	case exam_ps.FieldDrivingLicenseRequired:
		return m.DrivingLicenseRequired()
	case exam_ps.FieldExamPaperCode:
		return m.ExamPaperCode()
	case exam_ps.FieldExamPaper1:
		return m.ExamPaper1()
	case exam_ps.FieldExamPaper2:
		return m.ExamPaper2()
	case exam_ps.FieldExamPaper3:
		return m.ExamPaper3()
	case exam_ps.FieldExamPaper4:
		return m.ExamPaper4()
	case exam_ps.FieldExamPaper5:
		return m.ExamPaper5()
	case exam_ps.FieldExamPaper6:
		return m.ExamPaper6()
	case exam_ps.FieldPayLevelEligibilty:
		return m.PayLevelEligibilty()
	case exam_ps.FieldCategoryMinMarksSCSTPH:
		return m.CategoryMinMarksSCSTPH()
	case exam_ps.FieldCategoryMinMarksGENOBC:
		return m.CategoryMinMarksGENOBC()
	case exam_ps.FieldLocalLanguageAllowed:
		return m.LocalLanguageAllowed()
	case exam_ps.FieldUpdatedAt:
		return m.UpdatedAt()
	case exam_ps.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExamPSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exam_ps.FieldExamNameCode:
		return m.OldExamNameCode(ctx)
	case exam_ps.FieldExamName:
		return m.OldExamName(ctx)
	case exam_ps.FieldExamType:
		return m.OldExamType(ctx)
	case exam_ps.FieldNotificationCode:
		return m.OldNotificationCode(ctx)
	case exam_ps.FieldConductedBy:
		return m.OldConductedBy(ctx)
	case exam_ps.FieldNodalOffice:
		return m.OldNodalOffice(ctx)
	case exam_ps.FieldCalendarCode:
		return m.OldCalendarCode(ctx)
	case exam_ps.FieldPaperCode:
		return m.OldPaperCode(ctx)
	case exam_ps.FieldEligibleCadre:
		return m.OldEligibleCadre(ctx)
	case exam_ps.FieldEligiblePost1:
		return m.OldEligiblePost1(ctx)
	case exam_ps.FieldEligiblePost2:
		return m.OldEligiblePost2(ctx)
	case exam_ps.FieldEligiblePost3:
		return m.OldEligiblePost3(ctx)
	case exam_ps.FieldEligiblePost4:
		return m.OldEligiblePost4(ctx)
	case exam_ps.FieldEligiblePost5:
		return m.OldEligiblePost5(ctx)
	case exam_ps.FieldExamPost1:
		return m.OldExamPost1(ctx)
	case exam_ps.FieldExamPost2:
		return m.OldExamPost2(ctx)
	case exam_ps.FieldExamPost3:
		return m.OldExamPost3(ctx)
	case exam_ps.FieldExamPost4:
		return m.OldExamPost4(ctx)
	case exam_ps.FieldExamPost5:
		return m.OldExamPost5(ctx)
	case exam_ps.FieldEducationCriteria:
		return m.OldEducationCriteria(ctx)
	case exam_ps.FieldCategoryAgeLimitGEN:
		return m.OldCategoryAgeLimitGEN(ctx)
	case exam_ps.FieldCategoryAgeLimitSC:
		return m.OldCategoryAgeLimitSC(ctx)
	case exam_ps.FieldCategoryAgeLimitST:
		return m.OldCategoryAgeLimitST(ctx)
	case exam_ps.FieldServiceYears:
		return m.OldServiceYears(ctx)
	case exam_ps.FieldDrivingLicenseRequired:
		return m.OldDrivingLicenseRequired(ctx)
	case exam_ps.FieldExamPaperCode:
		return m.OldExamPaperCode(ctx)
	case exam_ps.FieldExamPaper1:
		return m.OldExamPaper1(ctx)
	case exam_ps.FieldExamPaper2:
		return m.OldExamPaper2(ctx)
	case exam_ps.FieldExamPaper3:
		return m.OldExamPaper3(ctx)
	case exam_ps.FieldExamPaper4:
		return m.OldExamPaper4(ctx)
	case exam_ps.FieldExamPaper5:
		return m.OldExamPaper5(ctx)
	case exam_ps.FieldExamPaper6:
		return m.OldExamPaper6(ctx)
	case exam_ps.FieldPayLevelEligibilty:
		return m.OldPayLevelEligibilty(ctx)
	case exam_ps.FieldCategoryMinMarksSCSTPH:
		return m.OldCategoryMinMarksSCSTPH(ctx)
	case exam_ps.FieldCategoryMinMarksGENOBC:
		return m.OldCategoryMinMarksGENOBC(ctx)
	case exam_ps.FieldLocalLanguageAllowed:
		return m.OldLocalLanguageAllowed(ctx)
	case exam_ps.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case exam_ps.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Exam_PS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamPSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exam_ps.FieldExamNameCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamNameCode(v)
		return nil
	case exam_ps.FieldExamName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamName(v)
		return nil
	case exam_ps.FieldExamType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamType(v)
		return nil
	case exam_ps.FieldNotificationCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotificationCode(v)
		return nil
	case exam_ps.FieldConductedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConductedBy(v)
		return nil
	case exam_ps.FieldNodalOffice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodalOffice(v)
		return nil
	case exam_ps.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalendarCode(v)
		return nil
	case exam_ps.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperCode(v)
		return nil
	case exam_ps.FieldEligibleCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligibleCadre(v)
		return nil
	case exam_ps.FieldEligiblePost1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost1(v)
		return nil
	case exam_ps.FieldEligiblePost2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost2(v)
		return nil
	case exam_ps.FieldEligiblePost3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost3(v)
		return nil
	case exam_ps.FieldEligiblePost4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost4(v)
		return nil
	case exam_ps.FieldEligiblePost5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligiblePost5(v)
		return nil
	case exam_ps.FieldExamPost1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost1(v)
		return nil
	case exam_ps.FieldExamPost2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost2(v)
		return nil
	case exam_ps.FieldExamPost3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost3(v)
		return nil
	case exam_ps.FieldExamPost4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost4(v)
		return nil
	case exam_ps.FieldExamPost5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPost5(v)
		return nil
	case exam_ps.FieldEducationCriteria:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducationCriteria(v)
		return nil
	case exam_ps.FieldCategoryAgeLimitGEN:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryAgeLimitGEN(v)
		return nil
	case exam_ps.FieldCategoryAgeLimitSC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryAgeLimitSC(v)
		return nil
	case exam_ps.FieldCategoryAgeLimitST:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryAgeLimitST(v)
		return nil
	case exam_ps.FieldServiceYears:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceYears(v)
		return nil
	case exam_ps.FieldDrivingLicenseRequired:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrivingLicenseRequired(v)
		return nil
	case exam_ps.FieldExamPaperCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaperCode(v)
		return nil
	case exam_ps.FieldExamPaper1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper1(v)
		return nil
	case exam_ps.FieldExamPaper2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper2(v)
		return nil
	case exam_ps.FieldExamPaper3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper3(v)
		return nil
	case exam_ps.FieldExamPaper4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper4(v)
		return nil
	case exam_ps.FieldExamPaper5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper5(v)
		return nil
	case exam_ps.FieldExamPaper6:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaper6(v)
		return nil
	case exam_ps.FieldPayLevelEligibilty:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayLevelEligibilty(v)
		return nil
	case exam_ps.FieldCategoryMinMarksSCSTPH:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryMinMarksSCSTPH(v)
		return nil
	case exam_ps.FieldCategoryMinMarksGENOBC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryMinMarksGENOBC(v)
		return nil
	case exam_ps.FieldLocalLanguageAllowed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalLanguageAllowed(v)
		return nil
	case exam_ps.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case exam_ps.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Exam_PS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExamPSMutation) AddedFields() []string {
	var fields []string
	if m.add_NotificationCode != nil {
		fields = append(fields, exam_ps.FieldNotificationCode)
	}
	if m.add_CalendarCode != nil {
		fields = append(fields, exam_ps.FieldCalendarCode)
	}
	if m.add_PaperCode != nil {
		fields = append(fields, exam_ps.FieldPaperCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExamPSMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exam_ps.FieldNotificationCode:
		return m.AddedNotificationCode()
	case exam_ps.FieldCalendarCode:
		return m.AddedCalendarCode()
	case exam_ps.FieldPaperCode:
		return m.AddedPaperCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExamPSMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exam_ps.FieldNotificationCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotificationCode(v)
		return nil
	case exam_ps.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalendarCode(v)
		return nil
	case exam_ps.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaperCode(v)
		return nil
	}
	return fmt.Errorf("unknown Exam_PS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExamPSMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exam_ps.FieldExamNameCode) {
		fields = append(fields, exam_ps.FieldExamNameCode)
	}
	if m.FieldCleared(exam_ps.FieldNotificationCode) {
		fields = append(fields, exam_ps.FieldNotificationCode)
	}
	if m.FieldCleared(exam_ps.FieldNodalOffice) {
		fields = append(fields, exam_ps.FieldNodalOffice)
	}
	if m.FieldCleared(exam_ps.FieldCalendarCode) {
		fields = append(fields, exam_ps.FieldCalendarCode)
	}
	if m.FieldCleared(exam_ps.FieldPaperCode) {
		fields = append(fields, exam_ps.FieldPaperCode)
	}
	if m.FieldCleared(exam_ps.FieldEligibleCadre) {
		fields = append(fields, exam_ps.FieldEligibleCadre)
	}
	if m.FieldCleared(exam_ps.FieldEligiblePost1) {
		fields = append(fields, exam_ps.FieldEligiblePost1)
	}
	if m.FieldCleared(exam_ps.FieldEligiblePost2) {
		fields = append(fields, exam_ps.FieldEligiblePost2)
	}
	if m.FieldCleared(exam_ps.FieldEligiblePost3) {
		fields = append(fields, exam_ps.FieldEligiblePost3)
	}
	if m.FieldCleared(exam_ps.FieldEligiblePost4) {
		fields = append(fields, exam_ps.FieldEligiblePost4)
	}
	if m.FieldCleared(exam_ps.FieldEligiblePost5) {
		fields = append(fields, exam_ps.FieldEligiblePost5)
	}
	if m.FieldCleared(exam_ps.FieldExamPost1) {
		fields = append(fields, exam_ps.FieldExamPost1)
	}
	if m.FieldCleared(exam_ps.FieldExamPost2) {
		fields = append(fields, exam_ps.FieldExamPost2)
	}
	if m.FieldCleared(exam_ps.FieldExamPost3) {
		fields = append(fields, exam_ps.FieldExamPost3)
	}
	if m.FieldCleared(exam_ps.FieldExamPost4) {
		fields = append(fields, exam_ps.FieldExamPost4)
	}
	if m.FieldCleared(exam_ps.FieldExamPost5) {
		fields = append(fields, exam_ps.FieldExamPost5)
	}
	if m.FieldCleared(exam_ps.FieldEducationCriteria) {
		fields = append(fields, exam_ps.FieldEducationCriteria)
	}
	if m.FieldCleared(exam_ps.FieldCategoryAgeLimitGEN) {
		fields = append(fields, exam_ps.FieldCategoryAgeLimitGEN)
	}
	if m.FieldCleared(exam_ps.FieldCategoryAgeLimitSC) {
		fields = append(fields, exam_ps.FieldCategoryAgeLimitSC)
	}
	if m.FieldCleared(exam_ps.FieldCategoryAgeLimitST) {
		fields = append(fields, exam_ps.FieldCategoryAgeLimitST)
	}
	if m.FieldCleared(exam_ps.FieldServiceYears) {
		fields = append(fields, exam_ps.FieldServiceYears)
	}
	if m.FieldCleared(exam_ps.FieldDrivingLicenseRequired) {
		fields = append(fields, exam_ps.FieldDrivingLicenseRequired)
	}
	if m.FieldCleared(exam_ps.FieldExamPaperCode) {
		fields = append(fields, exam_ps.FieldExamPaperCode)
	}
	if m.FieldCleared(exam_ps.FieldExamPaper1) {
		fields = append(fields, exam_ps.FieldExamPaper1)
	}
	if m.FieldCleared(exam_ps.FieldExamPaper2) {
		fields = append(fields, exam_ps.FieldExamPaper2)
	}
	if m.FieldCleared(exam_ps.FieldExamPaper3) {
		fields = append(fields, exam_ps.FieldExamPaper3)
	}
	if m.FieldCleared(exam_ps.FieldExamPaper4) {
		fields = append(fields, exam_ps.FieldExamPaper4)
	}
	if m.FieldCleared(exam_ps.FieldExamPaper5) {
		fields = append(fields, exam_ps.FieldExamPaper5)
	}
	if m.FieldCleared(exam_ps.FieldExamPaper6) {
		fields = append(fields, exam_ps.FieldExamPaper6)
	}
	if m.FieldCleared(exam_ps.FieldPayLevelEligibilty) {
		fields = append(fields, exam_ps.FieldPayLevelEligibilty)
	}
	if m.FieldCleared(exam_ps.FieldCategoryMinMarksSCSTPH) {
		fields = append(fields, exam_ps.FieldCategoryMinMarksSCSTPH)
	}
	if m.FieldCleared(exam_ps.FieldCategoryMinMarksGENOBC) {
		fields = append(fields, exam_ps.FieldCategoryMinMarksGENOBC)
	}
	if m.FieldCleared(exam_ps.FieldLocalLanguageAllowed) {
		fields = append(fields, exam_ps.FieldLocalLanguageAllowed)
	}
	if m.FieldCleared(exam_ps.FieldUpdatedAt) {
		fields = append(fields, exam_ps.FieldUpdatedAt)
	}
	if m.FieldCleared(exam_ps.FieldUpdatedBy) {
		fields = append(fields, exam_ps.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExamPSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExamPSMutation) ClearField(name string) error {
	switch name {
	case exam_ps.FieldExamNameCode:
		m.ClearExamNameCode()
		return nil
	case exam_ps.FieldNotificationCode:
		m.ClearNotificationCode()
		return nil
	case exam_ps.FieldNodalOffice:
		m.ClearNodalOffice()
		return nil
	case exam_ps.FieldCalendarCode:
		m.ClearCalendarCode()
		return nil
	case exam_ps.FieldPaperCode:
		m.ClearPaperCode()
		return nil
	case exam_ps.FieldEligibleCadre:
		m.ClearEligibleCadre()
		return nil
	case exam_ps.FieldEligiblePost1:
		m.ClearEligiblePost1()
		return nil
	case exam_ps.FieldEligiblePost2:
		m.ClearEligiblePost2()
		return nil
	case exam_ps.FieldEligiblePost3:
		m.ClearEligiblePost3()
		return nil
	case exam_ps.FieldEligiblePost4:
		m.ClearEligiblePost4()
		return nil
	case exam_ps.FieldEligiblePost5:
		m.ClearEligiblePost5()
		return nil
	case exam_ps.FieldExamPost1:
		m.ClearExamPost1()
		return nil
	case exam_ps.FieldExamPost2:
		m.ClearExamPost2()
		return nil
	case exam_ps.FieldExamPost3:
		m.ClearExamPost3()
		return nil
	case exam_ps.FieldExamPost4:
		m.ClearExamPost4()
		return nil
	case exam_ps.FieldExamPost5:
		m.ClearExamPost5()
		return nil
	case exam_ps.FieldEducationCriteria:
		m.ClearEducationCriteria()
		return nil
	case exam_ps.FieldCategoryAgeLimitGEN:
		m.ClearCategoryAgeLimitGEN()
		return nil
	case exam_ps.FieldCategoryAgeLimitSC:
		m.ClearCategoryAgeLimitSC()
		return nil
	case exam_ps.FieldCategoryAgeLimitST:
		m.ClearCategoryAgeLimitST()
		return nil
	case exam_ps.FieldServiceYears:
		m.ClearServiceYears()
		return nil
	case exam_ps.FieldDrivingLicenseRequired:
		m.ClearDrivingLicenseRequired()
		return nil
	case exam_ps.FieldExamPaperCode:
		m.ClearExamPaperCode()
		return nil
	case exam_ps.FieldExamPaper1:
		m.ClearExamPaper1()
		return nil
	case exam_ps.FieldExamPaper2:
		m.ClearExamPaper2()
		return nil
	case exam_ps.FieldExamPaper3:
		m.ClearExamPaper3()
		return nil
	case exam_ps.FieldExamPaper4:
		m.ClearExamPaper4()
		return nil
	case exam_ps.FieldExamPaper5:
		m.ClearExamPaper5()
		return nil
	case exam_ps.FieldExamPaper6:
		m.ClearExamPaper6()
		return nil
	case exam_ps.FieldPayLevelEligibilty:
		m.ClearPayLevelEligibilty()
		return nil
	case exam_ps.FieldCategoryMinMarksSCSTPH:
		m.ClearCategoryMinMarksSCSTPH()
		return nil
	case exam_ps.FieldCategoryMinMarksGENOBC:
		m.ClearCategoryMinMarksGENOBC()
		return nil
	case exam_ps.FieldLocalLanguageAllowed:
		m.ClearLocalLanguageAllowed()
		return nil
	case exam_ps.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case exam_ps.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Exam_PS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExamPSMutation) ResetField(name string) error {
	switch name {
	case exam_ps.FieldExamNameCode:
		m.ResetExamNameCode()
		return nil
	case exam_ps.FieldExamName:
		m.ResetExamName()
		return nil
	case exam_ps.FieldExamType:
		m.ResetExamType()
		return nil
	case exam_ps.FieldNotificationCode:
		m.ResetNotificationCode()
		return nil
	case exam_ps.FieldConductedBy:
		m.ResetConductedBy()
		return nil
	case exam_ps.FieldNodalOffice:
		m.ResetNodalOffice()
		return nil
	case exam_ps.FieldCalendarCode:
		m.ResetCalendarCode()
		return nil
	case exam_ps.FieldPaperCode:
		m.ResetPaperCode()
		return nil
	case exam_ps.FieldEligibleCadre:
		m.ResetEligibleCadre()
		return nil
	case exam_ps.FieldEligiblePost1:
		m.ResetEligiblePost1()
		return nil
	case exam_ps.FieldEligiblePost2:
		m.ResetEligiblePost2()
		return nil
	case exam_ps.FieldEligiblePost3:
		m.ResetEligiblePost3()
		return nil
	case exam_ps.FieldEligiblePost4:
		m.ResetEligiblePost4()
		return nil
	case exam_ps.FieldEligiblePost5:
		m.ResetEligiblePost5()
		return nil
	case exam_ps.FieldExamPost1:
		m.ResetExamPost1()
		return nil
	case exam_ps.FieldExamPost2:
		m.ResetExamPost2()
		return nil
	case exam_ps.FieldExamPost3:
		m.ResetExamPost3()
		return nil
	case exam_ps.FieldExamPost4:
		m.ResetExamPost4()
		return nil
	case exam_ps.FieldExamPost5:
		m.ResetExamPost5()
		return nil
	case exam_ps.FieldEducationCriteria:
		m.ResetEducationCriteria()
		return nil
	case exam_ps.FieldCategoryAgeLimitGEN:
		m.ResetCategoryAgeLimitGEN()
		return nil
	case exam_ps.FieldCategoryAgeLimitSC:
		m.ResetCategoryAgeLimitSC()
		return nil
	case exam_ps.FieldCategoryAgeLimitST:
		m.ResetCategoryAgeLimitST()
		return nil
	case exam_ps.FieldServiceYears:
		m.ResetServiceYears()
		return nil
	case exam_ps.FieldDrivingLicenseRequired:
		m.ResetDrivingLicenseRequired()
		return nil
	case exam_ps.FieldExamPaperCode:
		m.ResetExamPaperCode()
		return nil
	case exam_ps.FieldExamPaper1:
		m.ResetExamPaper1()
		return nil
	case exam_ps.FieldExamPaper2:
		m.ResetExamPaper2()
		return nil
	case exam_ps.FieldExamPaper3:
		m.ResetExamPaper3()
		return nil
	case exam_ps.FieldExamPaper4:
		m.ResetExamPaper4()
		return nil
	case exam_ps.FieldExamPaper5:
		m.ResetExamPaper5()
		return nil
	case exam_ps.FieldExamPaper6:
		m.ResetExamPaper6()
		return nil
	case exam_ps.FieldPayLevelEligibilty:
		m.ResetPayLevelEligibilty()
		return nil
	case exam_ps.FieldCategoryMinMarksSCSTPH:
		m.ResetCategoryMinMarksSCSTPH()
		return nil
	case exam_ps.FieldCategoryMinMarksGENOBC:
		m.ResetCategoryMinMarksGENOBC()
		return nil
	case exam_ps.FieldLocalLanguageAllowed:
		m.ResetLocalLanguageAllowed()
		return nil
	case exam_ps.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case exam_ps.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Exam_PS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExamPSMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.examcal_ps_ref != nil {
		edges = append(edges, exam_ps.EdgeExamcalPsRef)
	}
	if m.papers_ps_ref != nil {
		edges = append(edges, exam_ps.EdgePapersPsRef)
	}
	if m.users_ps_type != nil {
		edges = append(edges, exam_ps.EdgeUsersPsType)
	}
	if m._ExamAppln_PS_Ref != nil {
		edges = append(edges, exam_ps.EdgeExamApplnPSRef)
	}
	if m.notifications_ps != nil {
		edges = append(edges, exam_ps.EdgeNotificationsPs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExamPSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exam_ps.EdgeExamcalPsRef:
		ids := make([]ent.Value, 0, len(m.examcal_ps_ref))
		for id := range m.examcal_ps_ref {
			ids = append(ids, id)
		}
		return ids
	case exam_ps.EdgePapersPsRef:
		ids := make([]ent.Value, 0, len(m.papers_ps_ref))
		for id := range m.papers_ps_ref {
			ids = append(ids, id)
		}
		return ids
	case exam_ps.EdgeUsersPsType:
		ids := make([]ent.Value, 0, len(m.users_ps_type))
		for id := range m.users_ps_type {
			ids = append(ids, id)
		}
		return ids
	case exam_ps.EdgeExamApplnPSRef:
		ids := make([]ent.Value, 0, len(m._ExamAppln_PS_Ref))
		for id := range m._ExamAppln_PS_Ref {
			ids = append(ids, id)
		}
		return ids
	case exam_ps.EdgeNotificationsPs:
		ids := make([]ent.Value, 0, len(m.notifications_ps))
		for id := range m.notifications_ps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExamPSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedexamcal_ps_ref != nil {
		edges = append(edges, exam_ps.EdgeExamcalPsRef)
	}
	if m.removedpapers_ps_ref != nil {
		edges = append(edges, exam_ps.EdgePapersPsRef)
	}
	if m.removedusers_ps_type != nil {
		edges = append(edges, exam_ps.EdgeUsersPsType)
	}
	if m.removed_ExamAppln_PS_Ref != nil {
		edges = append(edges, exam_ps.EdgeExamApplnPSRef)
	}
	if m.removednotifications_ps != nil {
		edges = append(edges, exam_ps.EdgeNotificationsPs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExamPSMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exam_ps.EdgeExamcalPsRef:
		ids := make([]ent.Value, 0, len(m.removedexamcal_ps_ref))
		for id := range m.removedexamcal_ps_ref {
			ids = append(ids, id)
		}
		return ids
	case exam_ps.EdgePapersPsRef:
		ids := make([]ent.Value, 0, len(m.removedpapers_ps_ref))
		for id := range m.removedpapers_ps_ref {
			ids = append(ids, id)
		}
		return ids
	case exam_ps.EdgeUsersPsType:
		ids := make([]ent.Value, 0, len(m.removedusers_ps_type))
		for id := range m.removedusers_ps_type {
			ids = append(ids, id)
		}
		return ids
	case exam_ps.EdgeExamApplnPSRef:
		ids := make([]ent.Value, 0, len(m.removed_ExamAppln_PS_Ref))
		for id := range m.removed_ExamAppln_PS_Ref {
			ids = append(ids, id)
		}
		return ids
	case exam_ps.EdgeNotificationsPs:
		ids := make([]ent.Value, 0, len(m.removednotifications_ps))
		for id := range m.removednotifications_ps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExamPSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedexamcal_ps_ref {
		edges = append(edges, exam_ps.EdgeExamcalPsRef)
	}
	if m.clearedpapers_ps_ref {
		edges = append(edges, exam_ps.EdgePapersPsRef)
	}
	if m.clearedusers_ps_type {
		edges = append(edges, exam_ps.EdgeUsersPsType)
	}
	if m.cleared_ExamAppln_PS_Ref {
		edges = append(edges, exam_ps.EdgeExamApplnPSRef)
	}
	if m.clearednotifications_ps {
		edges = append(edges, exam_ps.EdgeNotificationsPs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExamPSMutation) EdgeCleared(name string) bool {
	switch name {
	case exam_ps.EdgeExamcalPsRef:
		return m.clearedexamcal_ps_ref
	case exam_ps.EdgePapersPsRef:
		return m.clearedpapers_ps_ref
	case exam_ps.EdgeUsersPsType:
		return m.clearedusers_ps_type
	case exam_ps.EdgeExamApplnPSRef:
		return m.cleared_ExamAppln_PS_Ref
	case exam_ps.EdgeNotificationsPs:
		return m.clearednotifications_ps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExamPSMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Exam_PS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExamPSMutation) ResetEdge(name string) error {
	switch name {
	case exam_ps.EdgeExamcalPsRef:
		m.ResetExamcalPsRef()
		return nil
	case exam_ps.EdgePapersPsRef:
		m.ResetPapersPsRef()
		return nil
	case exam_ps.EdgeUsersPsType:
		m.ResetUsersPsType()
		return nil
	case exam_ps.EdgeExamApplnPSRef:
		m.ResetExamApplnPSRef()
		return nil
	case exam_ps.EdgeNotificationsPs:
		m.ResetNotificationsPs()
		return nil
	}
	return fmt.Errorf("unknown Exam_PS edge %s", name)
}

// FacilityMutation represents an operation that mutates the Facility nodes in the graph.
type FacilityMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int32
	_FacilityCode         *int32
	add_FacilityCode      *int32
	_OfficeType           *string
	_FacilityOfficeID     *string
	_FacilityName         *string
	_ReportingOfficeType  *string
	_ReportingOfficeCode  *string
	_EmailID              *string
	_MobileNumber         *int64
	add_MobileNumber      *int64
	_DivisionCode         *int32
	add_DivisionCode      *int32
	_DivisionName         *string
	_RegionCode           *int32
	add_RegionCode        *int32
	_RegionName           *string
	_CircleCode           *int32
	add_CircleCode        *int32
	_CircleName           *string
	_ReportingOfficeID    *string
	_ReportingOfficeName  *string
	clearedFields         map[string]struct{}
	divisions             *int32
	cleareddivisions      bool
	regions               *int32
	clearedregions        bool
	circles               *int32
	clearedcircles        bool
	circle_ref            map[int32]struct{}
	removedcircle_ref     map[int32]struct{}
	clearedcircle_ref     bool
	_Office_PS_Ref        map[int64]struct{}
	removed_Office_PS_Ref map[int64]struct{}
	cleared_Office_PS_Ref bool
	_Office_IP_Ref        map[int64]struct{}
	removed_Office_IP_Ref map[int64]struct{}
	cleared_Office_IP_Ref bool
	done                  bool
	oldValue              func(context.Context) (*Facility, error)
	predicates            []predicate.Facility
}

var _ ent.Mutation = (*FacilityMutation)(nil)

// facilityOption allows management of the mutation configuration using functional options.
type facilityOption func(*FacilityMutation)

// newFacilityMutation creates new mutation for the Facility entity.
func newFacilityMutation(c config, op Op, opts ...facilityOption) *FacilityMutation {
	m := &FacilityMutation{
		config:        c,
		op:            op,
		typ:           TypeFacility,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFacilityID sets the ID field of the mutation.
func withFacilityID(id int32) facilityOption {
	return func(m *FacilityMutation) {
		var (
			err   error
			once  sync.Once
			value *Facility
		)
		m.oldValue = func(ctx context.Context) (*Facility, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Facility.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFacility sets the old Facility of the mutation.
func withFacility(node *Facility) facilityOption {
	return func(m *FacilityMutation) {
		m.oldValue = func(context.Context) (*Facility, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FacilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FacilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Facility entities.
func (m *FacilityMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FacilityMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FacilityMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Facility.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFacilityCode sets the "FacilityCode" field.
func (m *FacilityMutation) SetFacilityCode(i int32) {
	m._FacilityCode = &i
	m.add_FacilityCode = nil
}

// FacilityCode returns the value of the "FacilityCode" field in the mutation.
func (m *FacilityMutation) FacilityCode() (r int32, exists bool) {
	v := m._FacilityCode
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityCode returns the old "FacilityCode" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldFacilityCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacilityCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacilityCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityCode: %w", err)
	}
	return oldValue.FacilityCode, nil
}

// AddFacilityCode adds i to the "FacilityCode" field.
func (m *FacilityMutation) AddFacilityCode(i int32) {
	if m.add_FacilityCode != nil {
		*m.add_FacilityCode += i
	} else {
		m.add_FacilityCode = &i
	}
}

// AddedFacilityCode returns the value that was added to the "FacilityCode" field in this mutation.
func (m *FacilityMutation) AddedFacilityCode() (r int32, exists bool) {
	v := m.add_FacilityCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearFacilityCode clears the value of the "FacilityCode" field.
func (m *FacilityMutation) ClearFacilityCode() {
	m._FacilityCode = nil
	m.add_FacilityCode = nil
	m.clearedFields[facility.FieldFacilityCode] = struct{}{}
}

// FacilityCodeCleared returns if the "FacilityCode" field was cleared in this mutation.
func (m *FacilityMutation) FacilityCodeCleared() bool {
	_, ok := m.clearedFields[facility.FieldFacilityCode]
	return ok
}

// ResetFacilityCode resets all changes to the "FacilityCode" field.
func (m *FacilityMutation) ResetFacilityCode() {
	m._FacilityCode = nil
	m.add_FacilityCode = nil
	delete(m.clearedFields, facility.FieldFacilityCode)
}

// SetOfficeType sets the "OfficeType" field.
func (m *FacilityMutation) SetOfficeType(s string) {
	m._OfficeType = &s
}

// OfficeType returns the value of the "OfficeType" field in the mutation.
func (m *FacilityMutation) OfficeType() (r string, exists bool) {
	v := m._OfficeType
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeType returns the old "OfficeType" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldOfficeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeType: %w", err)
	}
	return oldValue.OfficeType, nil
}

// ResetOfficeType resets all changes to the "OfficeType" field.
func (m *FacilityMutation) ResetOfficeType() {
	m._OfficeType = nil
}

// SetFacilityOfficeID sets the "FacilityOfficeID" field.
func (m *FacilityMutation) SetFacilityOfficeID(s string) {
	m._FacilityOfficeID = &s
}

// FacilityOfficeID returns the value of the "FacilityOfficeID" field in the mutation.
func (m *FacilityMutation) FacilityOfficeID() (r string, exists bool) {
	v := m._FacilityOfficeID
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityOfficeID returns the old "FacilityOfficeID" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldFacilityOfficeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacilityOfficeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacilityOfficeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityOfficeID: %w", err)
	}
	return oldValue.FacilityOfficeID, nil
}

// ResetFacilityOfficeID resets all changes to the "FacilityOfficeID" field.
func (m *FacilityMutation) ResetFacilityOfficeID() {
	m._FacilityOfficeID = nil
}

// SetFacilityName sets the "FacilityName" field.
func (m *FacilityMutation) SetFacilityName(s string) {
	m._FacilityName = &s
}

// FacilityName returns the value of the "FacilityName" field in the mutation.
func (m *FacilityMutation) FacilityName() (r string, exists bool) {
	v := m._FacilityName
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityName returns the old "FacilityName" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldFacilityName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacilityName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacilityName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityName: %w", err)
	}
	return oldValue.FacilityName, nil
}

// ResetFacilityName resets all changes to the "FacilityName" field.
func (m *FacilityMutation) ResetFacilityName() {
	m._FacilityName = nil
}

// SetReportingOfficeType sets the "ReportingOfficeType" field.
func (m *FacilityMutation) SetReportingOfficeType(s string) {
	m._ReportingOfficeType = &s
}

// ReportingOfficeType returns the value of the "ReportingOfficeType" field in the mutation.
func (m *FacilityMutation) ReportingOfficeType() (r string, exists bool) {
	v := m._ReportingOfficeType
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingOfficeType returns the old "ReportingOfficeType" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldReportingOfficeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingOfficeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingOfficeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingOfficeType: %w", err)
	}
	return oldValue.ReportingOfficeType, nil
}

// ClearReportingOfficeType clears the value of the "ReportingOfficeType" field.
func (m *FacilityMutation) ClearReportingOfficeType() {
	m._ReportingOfficeType = nil
	m.clearedFields[facility.FieldReportingOfficeType] = struct{}{}
}

// ReportingOfficeTypeCleared returns if the "ReportingOfficeType" field was cleared in this mutation.
func (m *FacilityMutation) ReportingOfficeTypeCleared() bool {
	_, ok := m.clearedFields[facility.FieldReportingOfficeType]
	return ok
}

// ResetReportingOfficeType resets all changes to the "ReportingOfficeType" field.
func (m *FacilityMutation) ResetReportingOfficeType() {
	m._ReportingOfficeType = nil
	delete(m.clearedFields, facility.FieldReportingOfficeType)
}

// SetReportingOfficeCode sets the "ReportingOfficeCode" field.
func (m *FacilityMutation) SetReportingOfficeCode(s string) {
	m._ReportingOfficeCode = &s
}

// ReportingOfficeCode returns the value of the "ReportingOfficeCode" field in the mutation.
func (m *FacilityMutation) ReportingOfficeCode() (r string, exists bool) {
	v := m._ReportingOfficeCode
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingOfficeCode returns the old "ReportingOfficeCode" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldReportingOfficeCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingOfficeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingOfficeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingOfficeCode: %w", err)
	}
	return oldValue.ReportingOfficeCode, nil
}

// ClearReportingOfficeCode clears the value of the "ReportingOfficeCode" field.
func (m *FacilityMutation) ClearReportingOfficeCode() {
	m._ReportingOfficeCode = nil
	m.clearedFields[facility.FieldReportingOfficeCode] = struct{}{}
}

// ReportingOfficeCodeCleared returns if the "ReportingOfficeCode" field was cleared in this mutation.
func (m *FacilityMutation) ReportingOfficeCodeCleared() bool {
	_, ok := m.clearedFields[facility.FieldReportingOfficeCode]
	return ok
}

// ResetReportingOfficeCode resets all changes to the "ReportingOfficeCode" field.
func (m *FacilityMutation) ResetReportingOfficeCode() {
	m._ReportingOfficeCode = nil
	delete(m.clearedFields, facility.FieldReportingOfficeCode)
}

// SetEmailID sets the "EmailID" field.
func (m *FacilityMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *FacilityMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ClearEmailID clears the value of the "EmailID" field.
func (m *FacilityMutation) ClearEmailID() {
	m._EmailID = nil
	m.clearedFields[facility.FieldEmailID] = struct{}{}
}

// EmailIDCleared returns if the "EmailID" field was cleared in this mutation.
func (m *FacilityMutation) EmailIDCleared() bool {
	_, ok := m.clearedFields[facility.FieldEmailID]
	return ok
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *FacilityMutation) ResetEmailID() {
	m._EmailID = nil
	delete(m.clearedFields, facility.FieldEmailID)
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *FacilityMutation) SetMobileNumber(i int64) {
	m._MobileNumber = &i
	m.add_MobileNumber = nil
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *FacilityMutation) MobileNumber() (r int64, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldMobileNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// AddMobileNumber adds i to the "MobileNumber" field.
func (m *FacilityMutation) AddMobileNumber(i int64) {
	if m.add_MobileNumber != nil {
		*m.add_MobileNumber += i
	} else {
		m.add_MobileNumber = &i
	}
}

// AddedMobileNumber returns the value that was added to the "MobileNumber" field in this mutation.
func (m *FacilityMutation) AddedMobileNumber() (r int64, exists bool) {
	v := m.add_MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearMobileNumber clears the value of the "MobileNumber" field.
func (m *FacilityMutation) ClearMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	m.clearedFields[facility.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "MobileNumber" field was cleared in this mutation.
func (m *FacilityMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[facility.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *FacilityMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	delete(m.clearedFields, facility.FieldMobileNumber)
}

// SetDivisionCode sets the "DivisionCode" field.
func (m *FacilityMutation) SetDivisionCode(i int32) {
	m._DivisionCode = &i
	m.add_DivisionCode = nil
}

// DivisionCode returns the value of the "DivisionCode" field in the mutation.
func (m *FacilityMutation) DivisionCode() (r int32, exists bool) {
	v := m._DivisionCode
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionCode returns the old "DivisionCode" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldDivisionCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionCode: %w", err)
	}
	return oldValue.DivisionCode, nil
}

// AddDivisionCode adds i to the "DivisionCode" field.
func (m *FacilityMutation) AddDivisionCode(i int32) {
	if m.add_DivisionCode != nil {
		*m.add_DivisionCode += i
	} else {
		m.add_DivisionCode = &i
	}
}

// AddedDivisionCode returns the value that was added to the "DivisionCode" field in this mutation.
func (m *FacilityMutation) AddedDivisionCode() (r int32, exists bool) {
	v := m.add_DivisionCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearDivisionCode clears the value of the "DivisionCode" field.
func (m *FacilityMutation) ClearDivisionCode() {
	m._DivisionCode = nil
	m.add_DivisionCode = nil
	m.clearedFields[facility.FieldDivisionCode] = struct{}{}
}

// DivisionCodeCleared returns if the "DivisionCode" field was cleared in this mutation.
func (m *FacilityMutation) DivisionCodeCleared() bool {
	_, ok := m.clearedFields[facility.FieldDivisionCode]
	return ok
}

// ResetDivisionCode resets all changes to the "DivisionCode" field.
func (m *FacilityMutation) ResetDivisionCode() {
	m._DivisionCode = nil
	m.add_DivisionCode = nil
	delete(m.clearedFields, facility.FieldDivisionCode)
}

// SetDivisionName sets the "DivisionName" field.
func (m *FacilityMutation) SetDivisionName(s string) {
	m._DivisionName = &s
}

// DivisionName returns the value of the "DivisionName" field in the mutation.
func (m *FacilityMutation) DivisionName() (r string, exists bool) {
	v := m._DivisionName
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionName returns the old "DivisionName" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldDivisionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionName: %w", err)
	}
	return oldValue.DivisionName, nil
}

// ClearDivisionName clears the value of the "DivisionName" field.
func (m *FacilityMutation) ClearDivisionName() {
	m._DivisionName = nil
	m.clearedFields[facility.FieldDivisionName] = struct{}{}
}

// DivisionNameCleared returns if the "DivisionName" field was cleared in this mutation.
func (m *FacilityMutation) DivisionNameCleared() bool {
	_, ok := m.clearedFields[facility.FieldDivisionName]
	return ok
}

// ResetDivisionName resets all changes to the "DivisionName" field.
func (m *FacilityMutation) ResetDivisionName() {
	m._DivisionName = nil
	delete(m.clearedFields, facility.FieldDivisionName)
}

// SetDivisionID sets the "DivisionID" field.
func (m *FacilityMutation) SetDivisionID(i int32) {
	m.divisions = &i
}

// DivisionID returns the value of the "DivisionID" field in the mutation.
func (m *FacilityMutation) DivisionID() (r int32, exists bool) {
	v := m.divisions
	if v == nil {
		return
	}
	return *v, true
}

// OldDivisionID returns the old "DivisionID" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldDivisionID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivisionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivisionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivisionID: %w", err)
	}
	return oldValue.DivisionID, nil
}

// ClearDivisionID clears the value of the "DivisionID" field.
func (m *FacilityMutation) ClearDivisionID() {
	m.divisions = nil
	m.clearedFields[facility.FieldDivisionID] = struct{}{}
}

// DivisionIDCleared returns if the "DivisionID" field was cleared in this mutation.
func (m *FacilityMutation) DivisionIDCleared() bool {
	_, ok := m.clearedFields[facility.FieldDivisionID]
	return ok
}

// ResetDivisionID resets all changes to the "DivisionID" field.
func (m *FacilityMutation) ResetDivisionID() {
	m.divisions = nil
	delete(m.clearedFields, facility.FieldDivisionID)
}

// SetRegionCode sets the "RegionCode" field.
func (m *FacilityMutation) SetRegionCode(i int32) {
	m._RegionCode = &i
	m.add_RegionCode = nil
}

// RegionCode returns the value of the "RegionCode" field in the mutation.
func (m *FacilityMutation) RegionCode() (r int32, exists bool) {
	v := m._RegionCode
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionCode returns the old "RegionCode" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldRegionCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionCode: %w", err)
	}
	return oldValue.RegionCode, nil
}

// AddRegionCode adds i to the "RegionCode" field.
func (m *FacilityMutation) AddRegionCode(i int32) {
	if m.add_RegionCode != nil {
		*m.add_RegionCode += i
	} else {
		m.add_RegionCode = &i
	}
}

// AddedRegionCode returns the value that was added to the "RegionCode" field in this mutation.
func (m *FacilityMutation) AddedRegionCode() (r int32, exists bool) {
	v := m.add_RegionCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearRegionCode clears the value of the "RegionCode" field.
func (m *FacilityMutation) ClearRegionCode() {
	m._RegionCode = nil
	m.add_RegionCode = nil
	m.clearedFields[facility.FieldRegionCode] = struct{}{}
}

// RegionCodeCleared returns if the "RegionCode" field was cleared in this mutation.
func (m *FacilityMutation) RegionCodeCleared() bool {
	_, ok := m.clearedFields[facility.FieldRegionCode]
	return ok
}

// ResetRegionCode resets all changes to the "RegionCode" field.
func (m *FacilityMutation) ResetRegionCode() {
	m._RegionCode = nil
	m.add_RegionCode = nil
	delete(m.clearedFields, facility.FieldRegionCode)
}

// SetRegionID sets the "RegionID" field.
func (m *FacilityMutation) SetRegionID(i int32) {
	m.regions = &i
}

// RegionID returns the value of the "RegionID" field in the mutation.
func (m *FacilityMutation) RegionID() (r int32, exists bool) {
	v := m.regions
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionID returns the old "RegionID" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldRegionID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionID: %w", err)
	}
	return oldValue.RegionID, nil
}

// ClearRegionID clears the value of the "RegionID" field.
func (m *FacilityMutation) ClearRegionID() {
	m.regions = nil
	m.clearedFields[facility.FieldRegionID] = struct{}{}
}

// RegionIDCleared returns if the "RegionID" field was cleared in this mutation.
func (m *FacilityMutation) RegionIDCleared() bool {
	_, ok := m.clearedFields[facility.FieldRegionID]
	return ok
}

// ResetRegionID resets all changes to the "RegionID" field.
func (m *FacilityMutation) ResetRegionID() {
	m.regions = nil
	delete(m.clearedFields, facility.FieldRegionID)
}

// SetRegionName sets the "RegionName" field.
func (m *FacilityMutation) SetRegionName(s string) {
	m._RegionName = &s
}

// RegionName returns the value of the "RegionName" field in the mutation.
func (m *FacilityMutation) RegionName() (r string, exists bool) {
	v := m._RegionName
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionName returns the old "RegionName" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldRegionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionName: %w", err)
	}
	return oldValue.RegionName, nil
}

// ClearRegionName clears the value of the "RegionName" field.
func (m *FacilityMutation) ClearRegionName() {
	m._RegionName = nil
	m.clearedFields[facility.FieldRegionName] = struct{}{}
}

// RegionNameCleared returns if the "RegionName" field was cleared in this mutation.
func (m *FacilityMutation) RegionNameCleared() bool {
	_, ok := m.clearedFields[facility.FieldRegionName]
	return ok
}

// ResetRegionName resets all changes to the "RegionName" field.
func (m *FacilityMutation) ResetRegionName() {
	m._RegionName = nil
	delete(m.clearedFields, facility.FieldRegionName)
}

// SetCircleCode sets the "CircleCode" field.
func (m *FacilityMutation) SetCircleCode(i int32) {
	m._CircleCode = &i
	m.add_CircleCode = nil
}

// CircleCode returns the value of the "CircleCode" field in the mutation.
func (m *FacilityMutation) CircleCode() (r int32, exists bool) {
	v := m._CircleCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleCode returns the old "CircleCode" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldCircleCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleCode: %w", err)
	}
	return oldValue.CircleCode, nil
}

// AddCircleCode adds i to the "CircleCode" field.
func (m *FacilityMutation) AddCircleCode(i int32) {
	if m.add_CircleCode != nil {
		*m.add_CircleCode += i
	} else {
		m.add_CircleCode = &i
	}
}

// AddedCircleCode returns the value that was added to the "CircleCode" field in this mutation.
func (m *FacilityMutation) AddedCircleCode() (r int32, exists bool) {
	v := m.add_CircleCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearCircleCode clears the value of the "CircleCode" field.
func (m *FacilityMutation) ClearCircleCode() {
	m._CircleCode = nil
	m.add_CircleCode = nil
	m.clearedFields[facility.FieldCircleCode] = struct{}{}
}

// CircleCodeCleared returns if the "CircleCode" field was cleared in this mutation.
func (m *FacilityMutation) CircleCodeCleared() bool {
	_, ok := m.clearedFields[facility.FieldCircleCode]
	return ok
}

// ResetCircleCode resets all changes to the "CircleCode" field.
func (m *FacilityMutation) ResetCircleCode() {
	m._CircleCode = nil
	m.add_CircleCode = nil
	delete(m.clearedFields, facility.FieldCircleCode)
}

// SetCircleID sets the "CircleID" field.
func (m *FacilityMutation) SetCircleID(i int32) {
	m.circles = &i
}

// CircleID returns the value of the "CircleID" field in the mutation.
func (m *FacilityMutation) CircleID() (r int32, exists bool) {
	v := m.circles
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleID returns the old "CircleID" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldCircleID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleID: %w", err)
	}
	return oldValue.CircleID, nil
}

// ClearCircleID clears the value of the "CircleID" field.
func (m *FacilityMutation) ClearCircleID() {
	m.circles = nil
	m.clearedFields[facility.FieldCircleID] = struct{}{}
}

// CircleIDCleared returns if the "CircleID" field was cleared in this mutation.
func (m *FacilityMutation) CircleIDCleared() bool {
	_, ok := m.clearedFields[facility.FieldCircleID]
	return ok
}

// ResetCircleID resets all changes to the "CircleID" field.
func (m *FacilityMutation) ResetCircleID() {
	m.circles = nil
	delete(m.clearedFields, facility.FieldCircleID)
}

// SetCircleName sets the "CircleName" field.
func (m *FacilityMutation) SetCircleName(s string) {
	m._CircleName = &s
}

// CircleName returns the value of the "CircleName" field in the mutation.
func (m *FacilityMutation) CircleName() (r string, exists bool) {
	v := m._CircleName
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleName returns the old "CircleName" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldCircleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleName: %w", err)
	}
	return oldValue.CircleName, nil
}

// ClearCircleName clears the value of the "CircleName" field.
func (m *FacilityMutation) ClearCircleName() {
	m._CircleName = nil
	m.clearedFields[facility.FieldCircleName] = struct{}{}
}

// CircleNameCleared returns if the "CircleName" field was cleared in this mutation.
func (m *FacilityMutation) CircleNameCleared() bool {
	_, ok := m.clearedFields[facility.FieldCircleName]
	return ok
}

// ResetCircleName resets all changes to the "CircleName" field.
func (m *FacilityMutation) ResetCircleName() {
	m._CircleName = nil
	delete(m.clearedFields, facility.FieldCircleName)
}

// SetReportingOfficeID sets the "ReportingOfficeID" field.
func (m *FacilityMutation) SetReportingOfficeID(s string) {
	m._ReportingOfficeID = &s
}

// ReportingOfficeID returns the value of the "ReportingOfficeID" field in the mutation.
func (m *FacilityMutation) ReportingOfficeID() (r string, exists bool) {
	v := m._ReportingOfficeID
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingOfficeID returns the old "ReportingOfficeID" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldReportingOfficeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingOfficeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingOfficeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingOfficeID: %w", err)
	}
	return oldValue.ReportingOfficeID, nil
}

// ClearReportingOfficeID clears the value of the "ReportingOfficeID" field.
func (m *FacilityMutation) ClearReportingOfficeID() {
	m._ReportingOfficeID = nil
	m.clearedFields[facility.FieldReportingOfficeID] = struct{}{}
}

// ReportingOfficeIDCleared returns if the "ReportingOfficeID" field was cleared in this mutation.
func (m *FacilityMutation) ReportingOfficeIDCleared() bool {
	_, ok := m.clearedFields[facility.FieldReportingOfficeID]
	return ok
}

// ResetReportingOfficeID resets all changes to the "ReportingOfficeID" field.
func (m *FacilityMutation) ResetReportingOfficeID() {
	m._ReportingOfficeID = nil
	delete(m.clearedFields, facility.FieldReportingOfficeID)
}

// SetReportingOfficeName sets the "ReportingOfficeName" field.
func (m *FacilityMutation) SetReportingOfficeName(s string) {
	m._ReportingOfficeName = &s
}

// ReportingOfficeName returns the value of the "ReportingOfficeName" field in the mutation.
func (m *FacilityMutation) ReportingOfficeName() (r string, exists bool) {
	v := m._ReportingOfficeName
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingOfficeName returns the old "ReportingOfficeName" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldReportingOfficeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingOfficeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingOfficeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingOfficeName: %w", err)
	}
	return oldValue.ReportingOfficeName, nil
}

// ClearReportingOfficeName clears the value of the "ReportingOfficeName" field.
func (m *FacilityMutation) ClearReportingOfficeName() {
	m._ReportingOfficeName = nil
	m.clearedFields[facility.FieldReportingOfficeName] = struct{}{}
}

// ReportingOfficeNameCleared returns if the "ReportingOfficeName" field was cleared in this mutation.
func (m *FacilityMutation) ReportingOfficeNameCleared() bool {
	_, ok := m.clearedFields[facility.FieldReportingOfficeName]
	return ok
}

// ResetReportingOfficeName resets all changes to the "ReportingOfficeName" field.
func (m *FacilityMutation) ResetReportingOfficeName() {
	m._ReportingOfficeName = nil
	delete(m.clearedFields, facility.FieldReportingOfficeName)
}

// SetDivisionsID sets the "divisions" edge to the DivisionMaster entity by id.
func (m *FacilityMutation) SetDivisionsID(id int32) {
	m.divisions = &id
}

// ClearDivisions clears the "divisions" edge to the DivisionMaster entity.
func (m *FacilityMutation) ClearDivisions() {
	m.cleareddivisions = true
}

// DivisionsCleared reports if the "divisions" edge to the DivisionMaster entity was cleared.
func (m *FacilityMutation) DivisionsCleared() bool {
	return m.DivisionIDCleared() || m.cleareddivisions
}

// DivisionsID returns the "divisions" edge ID in the mutation.
func (m *FacilityMutation) DivisionsID() (id int32, exists bool) {
	if m.divisions != nil {
		return *m.divisions, true
	}
	return
}

// DivisionsIDs returns the "divisions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DivisionsID instead. It exists only for internal usage by the builders.
func (m *FacilityMutation) DivisionsIDs() (ids []int32) {
	if id := m.divisions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDivisions resets all changes to the "divisions" edge.
func (m *FacilityMutation) ResetDivisions() {
	m.divisions = nil
	m.cleareddivisions = false
}

// SetRegionsID sets the "regions" edge to the RegionMaster entity by id.
func (m *FacilityMutation) SetRegionsID(id int32) {
	m.regions = &id
}

// ClearRegions clears the "regions" edge to the RegionMaster entity.
func (m *FacilityMutation) ClearRegions() {
	m.clearedregions = true
}

// RegionsCleared reports if the "regions" edge to the RegionMaster entity was cleared.
func (m *FacilityMutation) RegionsCleared() bool {
	return m.RegionIDCleared() || m.clearedregions
}

// RegionsID returns the "regions" edge ID in the mutation.
func (m *FacilityMutation) RegionsID() (id int32, exists bool) {
	if m.regions != nil {
		return *m.regions, true
	}
	return
}

// RegionsIDs returns the "regions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegionsID instead. It exists only for internal usage by the builders.
func (m *FacilityMutation) RegionsIDs() (ids []int32) {
	if id := m.regions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegions resets all changes to the "regions" edge.
func (m *FacilityMutation) ResetRegions() {
	m.regions = nil
	m.clearedregions = false
}

// SetCirclesID sets the "circles" edge to the CircleMaster entity by id.
func (m *FacilityMutation) SetCirclesID(id int32) {
	m.circles = &id
}

// ClearCircles clears the "circles" edge to the CircleMaster entity.
func (m *FacilityMutation) ClearCircles() {
	m.clearedcircles = true
}

// CirclesCleared reports if the "circles" edge to the CircleMaster entity was cleared.
func (m *FacilityMutation) CirclesCleared() bool {
	return m.CircleIDCleared() || m.clearedcircles
}

// CirclesID returns the "circles" edge ID in the mutation.
func (m *FacilityMutation) CirclesID() (id int32, exists bool) {
	if m.circles != nil {
		return *m.circles, true
	}
	return
}

// CirclesIDs returns the "circles" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CirclesID instead. It exists only for internal usage by the builders.
func (m *FacilityMutation) CirclesIDs() (ids []int32) {
	if id := m.circles; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCircles resets all changes to the "circles" edge.
func (m *FacilityMutation) ResetCircles() {
	m.circles = nil
	m.clearedcircles = false
}

// AddCircleRefIDs adds the "circle_ref" edge to the CircleMaster entity by ids.
func (m *FacilityMutation) AddCircleRefIDs(ids ...int32) {
	if m.circle_ref == nil {
		m.circle_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.circle_ref[ids[i]] = struct{}{}
	}
}

// ClearCircleRef clears the "circle_ref" edge to the CircleMaster entity.
func (m *FacilityMutation) ClearCircleRef() {
	m.clearedcircle_ref = true
}

// CircleRefCleared reports if the "circle_ref" edge to the CircleMaster entity was cleared.
func (m *FacilityMutation) CircleRefCleared() bool {
	return m.clearedcircle_ref
}

// RemoveCircleRefIDs removes the "circle_ref" edge to the CircleMaster entity by IDs.
func (m *FacilityMutation) RemoveCircleRefIDs(ids ...int32) {
	if m.removedcircle_ref == nil {
		m.removedcircle_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.circle_ref, ids[i])
		m.removedcircle_ref[ids[i]] = struct{}{}
	}
}

// RemovedCircleRef returns the removed IDs of the "circle_ref" edge to the CircleMaster entity.
func (m *FacilityMutation) RemovedCircleRefIDs() (ids []int32) {
	for id := range m.removedcircle_ref {
		ids = append(ids, id)
	}
	return
}

// CircleRefIDs returns the "circle_ref" edge IDs in the mutation.
func (m *FacilityMutation) CircleRefIDs() (ids []int32) {
	for id := range m.circle_ref {
		ids = append(ids, id)
	}
	return
}

// ResetCircleRef resets all changes to the "circle_ref" edge.
func (m *FacilityMutation) ResetCircleRef() {
	m.circle_ref = nil
	m.clearedcircle_ref = false
	m.removedcircle_ref = nil
}

// AddOfficePSRefIDs adds the "Office_PS_Ref" edge to the Exam_Applications_PS entity by ids.
func (m *FacilityMutation) AddOfficePSRefIDs(ids ...int64) {
	if m._Office_PS_Ref == nil {
		m._Office_PS_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		m._Office_PS_Ref[ids[i]] = struct{}{}
	}
}

// ClearOfficePSRef clears the "Office_PS_Ref" edge to the Exam_Applications_PS entity.
func (m *FacilityMutation) ClearOfficePSRef() {
	m.cleared_Office_PS_Ref = true
}

// OfficePSRefCleared reports if the "Office_PS_Ref" edge to the Exam_Applications_PS entity was cleared.
func (m *FacilityMutation) OfficePSRefCleared() bool {
	return m.cleared_Office_PS_Ref
}

// RemoveOfficePSRefIDs removes the "Office_PS_Ref" edge to the Exam_Applications_PS entity by IDs.
func (m *FacilityMutation) RemoveOfficePSRefIDs(ids ...int64) {
	if m.removed_Office_PS_Ref == nil {
		m.removed_Office_PS_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._Office_PS_Ref, ids[i])
		m.removed_Office_PS_Ref[ids[i]] = struct{}{}
	}
}

// RemovedOfficePSRef returns the removed IDs of the "Office_PS_Ref" edge to the Exam_Applications_PS entity.
func (m *FacilityMutation) RemovedOfficePSRefIDs() (ids []int64) {
	for id := range m.removed_Office_PS_Ref {
		ids = append(ids, id)
	}
	return
}

// OfficePSRefIDs returns the "Office_PS_Ref" edge IDs in the mutation.
func (m *FacilityMutation) OfficePSRefIDs() (ids []int64) {
	for id := range m._Office_PS_Ref {
		ids = append(ids, id)
	}
	return
}

// ResetOfficePSRef resets all changes to the "Office_PS_Ref" edge.
func (m *FacilityMutation) ResetOfficePSRef() {
	m._Office_PS_Ref = nil
	m.cleared_Office_PS_Ref = false
	m.removed_Office_PS_Ref = nil
}

// AddOfficeIPRefIDs adds the "Office_IP_Ref" edge to the Exam_Applications_IP entity by ids.
func (m *FacilityMutation) AddOfficeIPRefIDs(ids ...int64) {
	if m._Office_IP_Ref == nil {
		m._Office_IP_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		m._Office_IP_Ref[ids[i]] = struct{}{}
	}
}

// ClearOfficeIPRef clears the "Office_IP_Ref" edge to the Exam_Applications_IP entity.
func (m *FacilityMutation) ClearOfficeIPRef() {
	m.cleared_Office_IP_Ref = true
}

// OfficeIPRefCleared reports if the "Office_IP_Ref" edge to the Exam_Applications_IP entity was cleared.
func (m *FacilityMutation) OfficeIPRefCleared() bool {
	return m.cleared_Office_IP_Ref
}

// RemoveOfficeIPRefIDs removes the "Office_IP_Ref" edge to the Exam_Applications_IP entity by IDs.
func (m *FacilityMutation) RemoveOfficeIPRefIDs(ids ...int64) {
	if m.removed_Office_IP_Ref == nil {
		m.removed_Office_IP_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._Office_IP_Ref, ids[i])
		m.removed_Office_IP_Ref[ids[i]] = struct{}{}
	}
}

// RemovedOfficeIPRef returns the removed IDs of the "Office_IP_Ref" edge to the Exam_Applications_IP entity.
func (m *FacilityMutation) RemovedOfficeIPRefIDs() (ids []int64) {
	for id := range m.removed_Office_IP_Ref {
		ids = append(ids, id)
	}
	return
}

// OfficeIPRefIDs returns the "Office_IP_Ref" edge IDs in the mutation.
func (m *FacilityMutation) OfficeIPRefIDs() (ids []int64) {
	for id := range m._Office_IP_Ref {
		ids = append(ids, id)
	}
	return
}

// ResetOfficeIPRef resets all changes to the "Office_IP_Ref" edge.
func (m *FacilityMutation) ResetOfficeIPRef() {
	m._Office_IP_Ref = nil
	m.cleared_Office_IP_Ref = false
	m.removed_Office_IP_Ref = nil
}

// Where appends a list predicates to the FacilityMutation builder.
func (m *FacilityMutation) Where(ps ...predicate.Facility) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FacilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FacilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Facility, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FacilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FacilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Facility).
func (m *FacilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FacilityMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m._FacilityCode != nil {
		fields = append(fields, facility.FieldFacilityCode)
	}
	if m._OfficeType != nil {
		fields = append(fields, facility.FieldOfficeType)
	}
	if m._FacilityOfficeID != nil {
		fields = append(fields, facility.FieldFacilityOfficeID)
	}
	if m._FacilityName != nil {
		fields = append(fields, facility.FieldFacilityName)
	}
	if m._ReportingOfficeType != nil {
		fields = append(fields, facility.FieldReportingOfficeType)
	}
	if m._ReportingOfficeCode != nil {
		fields = append(fields, facility.FieldReportingOfficeCode)
	}
	if m._EmailID != nil {
		fields = append(fields, facility.FieldEmailID)
	}
	if m._MobileNumber != nil {
		fields = append(fields, facility.FieldMobileNumber)
	}
	if m._DivisionCode != nil {
		fields = append(fields, facility.FieldDivisionCode)
	}
	if m._DivisionName != nil {
		fields = append(fields, facility.FieldDivisionName)
	}
	if m.divisions != nil {
		fields = append(fields, facility.FieldDivisionID)
	}
	if m._RegionCode != nil {
		fields = append(fields, facility.FieldRegionCode)
	}
	if m.regions != nil {
		fields = append(fields, facility.FieldRegionID)
	}
	if m._RegionName != nil {
		fields = append(fields, facility.FieldRegionName)
	}
	if m._CircleCode != nil {
		fields = append(fields, facility.FieldCircleCode)
	}
	if m.circles != nil {
		fields = append(fields, facility.FieldCircleID)
	}
	if m._CircleName != nil {
		fields = append(fields, facility.FieldCircleName)
	}
	if m._ReportingOfficeID != nil {
		fields = append(fields, facility.FieldReportingOfficeID)
	}
	if m._ReportingOfficeName != nil {
		fields = append(fields, facility.FieldReportingOfficeName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FacilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case facility.FieldFacilityCode:
		return m.FacilityCode()
	case facility.FieldOfficeType:
		return m.OfficeType()
	case facility.FieldFacilityOfficeID:
		return m.FacilityOfficeID()
	case facility.FieldFacilityName:
		return m.FacilityName()
	case facility.FieldReportingOfficeType:
		return m.ReportingOfficeType()
	case facility.FieldReportingOfficeCode:
		return m.ReportingOfficeCode()
	case facility.FieldEmailID:
		return m.EmailID()
	case facility.FieldMobileNumber:
		return m.MobileNumber()
	case facility.FieldDivisionCode:
		return m.DivisionCode()
	case facility.FieldDivisionName:
		return m.DivisionName()
	case facility.FieldDivisionID:
		return m.DivisionID()
	case facility.FieldRegionCode:
		return m.RegionCode()
	case facility.FieldRegionID:
		return m.RegionID()
	case facility.FieldRegionName:
		return m.RegionName()
	case facility.FieldCircleCode:
		return m.CircleCode()
	case facility.FieldCircleID:
		return m.CircleID()
	case facility.FieldCircleName:
		return m.CircleName()
	case facility.FieldReportingOfficeID:
		return m.ReportingOfficeID()
	case facility.FieldReportingOfficeName:
		return m.ReportingOfficeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FacilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case facility.FieldFacilityCode:
		return m.OldFacilityCode(ctx)
	case facility.FieldOfficeType:
		return m.OldOfficeType(ctx)
	case facility.FieldFacilityOfficeID:
		return m.OldFacilityOfficeID(ctx)
	case facility.FieldFacilityName:
		return m.OldFacilityName(ctx)
	case facility.FieldReportingOfficeType:
		return m.OldReportingOfficeType(ctx)
	case facility.FieldReportingOfficeCode:
		return m.OldReportingOfficeCode(ctx)
	case facility.FieldEmailID:
		return m.OldEmailID(ctx)
	case facility.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case facility.FieldDivisionCode:
		return m.OldDivisionCode(ctx)
	case facility.FieldDivisionName:
		return m.OldDivisionName(ctx)
	case facility.FieldDivisionID:
		return m.OldDivisionID(ctx)
	case facility.FieldRegionCode:
		return m.OldRegionCode(ctx)
	case facility.FieldRegionID:
		return m.OldRegionID(ctx)
	case facility.FieldRegionName:
		return m.OldRegionName(ctx)
	case facility.FieldCircleCode:
		return m.OldCircleCode(ctx)
	case facility.FieldCircleID:
		return m.OldCircleID(ctx)
	case facility.FieldCircleName:
		return m.OldCircleName(ctx)
	case facility.FieldReportingOfficeID:
		return m.OldReportingOfficeID(ctx)
	case facility.FieldReportingOfficeName:
		return m.OldReportingOfficeName(ctx)
	}
	return nil, fmt.Errorf("unknown Facility field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case facility.FieldFacilityCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityCode(v)
		return nil
	case facility.FieldOfficeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeType(v)
		return nil
	case facility.FieldFacilityOfficeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityOfficeID(v)
		return nil
	case facility.FieldFacilityName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityName(v)
		return nil
	case facility.FieldReportingOfficeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingOfficeType(v)
		return nil
	case facility.FieldReportingOfficeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingOfficeCode(v)
		return nil
	case facility.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case facility.FieldMobileNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case facility.FieldDivisionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionCode(v)
		return nil
	case facility.FieldDivisionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionName(v)
		return nil
	case facility.FieldDivisionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivisionID(v)
		return nil
	case facility.FieldRegionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionCode(v)
		return nil
	case facility.FieldRegionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionID(v)
		return nil
	case facility.FieldRegionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionName(v)
		return nil
	case facility.FieldCircleCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleCode(v)
		return nil
	case facility.FieldCircleID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleID(v)
		return nil
	case facility.FieldCircleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleName(v)
		return nil
	case facility.FieldReportingOfficeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingOfficeID(v)
		return nil
	case facility.FieldReportingOfficeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingOfficeName(v)
		return nil
	}
	return fmt.Errorf("unknown Facility field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FacilityMutation) AddedFields() []string {
	var fields []string
	if m.add_FacilityCode != nil {
		fields = append(fields, facility.FieldFacilityCode)
	}
	if m.add_MobileNumber != nil {
		fields = append(fields, facility.FieldMobileNumber)
	}
	if m.add_DivisionCode != nil {
		fields = append(fields, facility.FieldDivisionCode)
	}
	if m.add_RegionCode != nil {
		fields = append(fields, facility.FieldRegionCode)
	}
	if m.add_CircleCode != nil {
		fields = append(fields, facility.FieldCircleCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FacilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case facility.FieldFacilityCode:
		return m.AddedFacilityCode()
	case facility.FieldMobileNumber:
		return m.AddedMobileNumber()
	case facility.FieldDivisionCode:
		return m.AddedDivisionCode()
	case facility.FieldRegionCode:
		return m.AddedRegionCode()
	case facility.FieldCircleCode:
		return m.AddedCircleCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case facility.FieldFacilityCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFacilityCode(v)
		return nil
	case facility.FieldMobileNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMobileNumber(v)
		return nil
	case facility.FieldDivisionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDivisionCode(v)
		return nil
	case facility.FieldRegionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegionCode(v)
		return nil
	case facility.FieldCircleCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCircleCode(v)
		return nil
	}
	return fmt.Errorf("unknown Facility numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FacilityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(facility.FieldFacilityCode) {
		fields = append(fields, facility.FieldFacilityCode)
	}
	if m.FieldCleared(facility.FieldReportingOfficeType) {
		fields = append(fields, facility.FieldReportingOfficeType)
	}
	if m.FieldCleared(facility.FieldReportingOfficeCode) {
		fields = append(fields, facility.FieldReportingOfficeCode)
	}
	if m.FieldCleared(facility.FieldEmailID) {
		fields = append(fields, facility.FieldEmailID)
	}
	if m.FieldCleared(facility.FieldMobileNumber) {
		fields = append(fields, facility.FieldMobileNumber)
	}
	if m.FieldCleared(facility.FieldDivisionCode) {
		fields = append(fields, facility.FieldDivisionCode)
	}
	if m.FieldCleared(facility.FieldDivisionName) {
		fields = append(fields, facility.FieldDivisionName)
	}
	if m.FieldCleared(facility.FieldDivisionID) {
		fields = append(fields, facility.FieldDivisionID)
	}
	if m.FieldCleared(facility.FieldRegionCode) {
		fields = append(fields, facility.FieldRegionCode)
	}
	if m.FieldCleared(facility.FieldRegionID) {
		fields = append(fields, facility.FieldRegionID)
	}
	if m.FieldCleared(facility.FieldRegionName) {
		fields = append(fields, facility.FieldRegionName)
	}
	if m.FieldCleared(facility.FieldCircleCode) {
		fields = append(fields, facility.FieldCircleCode)
	}
	if m.FieldCleared(facility.FieldCircleID) {
		fields = append(fields, facility.FieldCircleID)
	}
	if m.FieldCleared(facility.FieldCircleName) {
		fields = append(fields, facility.FieldCircleName)
	}
	if m.FieldCleared(facility.FieldReportingOfficeID) {
		fields = append(fields, facility.FieldReportingOfficeID)
	}
	if m.FieldCleared(facility.FieldReportingOfficeName) {
		fields = append(fields, facility.FieldReportingOfficeName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FacilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FacilityMutation) ClearField(name string) error {
	switch name {
	case facility.FieldFacilityCode:
		m.ClearFacilityCode()
		return nil
	case facility.FieldReportingOfficeType:
		m.ClearReportingOfficeType()
		return nil
	case facility.FieldReportingOfficeCode:
		m.ClearReportingOfficeCode()
		return nil
	case facility.FieldEmailID:
		m.ClearEmailID()
		return nil
	case facility.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	case facility.FieldDivisionCode:
		m.ClearDivisionCode()
		return nil
	case facility.FieldDivisionName:
		m.ClearDivisionName()
		return nil
	case facility.FieldDivisionID:
		m.ClearDivisionID()
		return nil
	case facility.FieldRegionCode:
		m.ClearRegionCode()
		return nil
	case facility.FieldRegionID:
		m.ClearRegionID()
		return nil
	case facility.FieldRegionName:
		m.ClearRegionName()
		return nil
	case facility.FieldCircleCode:
		m.ClearCircleCode()
		return nil
	case facility.FieldCircleID:
		m.ClearCircleID()
		return nil
	case facility.FieldCircleName:
		m.ClearCircleName()
		return nil
	case facility.FieldReportingOfficeID:
		m.ClearReportingOfficeID()
		return nil
	case facility.FieldReportingOfficeName:
		m.ClearReportingOfficeName()
		return nil
	}
	return fmt.Errorf("unknown Facility nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FacilityMutation) ResetField(name string) error {
	switch name {
	case facility.FieldFacilityCode:
		m.ResetFacilityCode()
		return nil
	case facility.FieldOfficeType:
		m.ResetOfficeType()
		return nil
	case facility.FieldFacilityOfficeID:
		m.ResetFacilityOfficeID()
		return nil
	case facility.FieldFacilityName:
		m.ResetFacilityName()
		return nil
	case facility.FieldReportingOfficeType:
		m.ResetReportingOfficeType()
		return nil
	case facility.FieldReportingOfficeCode:
		m.ResetReportingOfficeCode()
		return nil
	case facility.FieldEmailID:
		m.ResetEmailID()
		return nil
	case facility.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case facility.FieldDivisionCode:
		m.ResetDivisionCode()
		return nil
	case facility.FieldDivisionName:
		m.ResetDivisionName()
		return nil
	case facility.FieldDivisionID:
		m.ResetDivisionID()
		return nil
	case facility.FieldRegionCode:
		m.ResetRegionCode()
		return nil
	case facility.FieldRegionID:
		m.ResetRegionID()
		return nil
	case facility.FieldRegionName:
		m.ResetRegionName()
		return nil
	case facility.FieldCircleCode:
		m.ResetCircleCode()
		return nil
	case facility.FieldCircleID:
		m.ResetCircleID()
		return nil
	case facility.FieldCircleName:
		m.ResetCircleName()
		return nil
	case facility.FieldReportingOfficeID:
		m.ResetReportingOfficeID()
		return nil
	case facility.FieldReportingOfficeName:
		m.ResetReportingOfficeName()
		return nil
	}
	return fmt.Errorf("unknown Facility field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FacilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.divisions != nil {
		edges = append(edges, facility.EdgeDivisions)
	}
	if m.regions != nil {
		edges = append(edges, facility.EdgeRegions)
	}
	if m.circles != nil {
		edges = append(edges, facility.EdgeCircles)
	}
	if m.circle_ref != nil {
		edges = append(edges, facility.EdgeCircleRef)
	}
	if m._Office_PS_Ref != nil {
		edges = append(edges, facility.EdgeOfficePSRef)
	}
	if m._Office_IP_Ref != nil {
		edges = append(edges, facility.EdgeOfficeIPRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FacilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case facility.EdgeDivisions:
		if id := m.divisions; id != nil {
			return []ent.Value{*id}
		}
	case facility.EdgeRegions:
		if id := m.regions; id != nil {
			return []ent.Value{*id}
		}
	case facility.EdgeCircles:
		if id := m.circles; id != nil {
			return []ent.Value{*id}
		}
	case facility.EdgeCircleRef:
		ids := make([]ent.Value, 0, len(m.circle_ref))
		for id := range m.circle_ref {
			ids = append(ids, id)
		}
		return ids
	case facility.EdgeOfficePSRef:
		ids := make([]ent.Value, 0, len(m._Office_PS_Ref))
		for id := range m._Office_PS_Ref {
			ids = append(ids, id)
		}
		return ids
	case facility.EdgeOfficeIPRef:
		ids := make([]ent.Value, 0, len(m._Office_IP_Ref))
		for id := range m._Office_IP_Ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FacilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedcircle_ref != nil {
		edges = append(edges, facility.EdgeCircleRef)
	}
	if m.removed_Office_PS_Ref != nil {
		edges = append(edges, facility.EdgeOfficePSRef)
	}
	if m.removed_Office_IP_Ref != nil {
		edges = append(edges, facility.EdgeOfficeIPRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FacilityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case facility.EdgeCircleRef:
		ids := make([]ent.Value, 0, len(m.removedcircle_ref))
		for id := range m.removedcircle_ref {
			ids = append(ids, id)
		}
		return ids
	case facility.EdgeOfficePSRef:
		ids := make([]ent.Value, 0, len(m.removed_Office_PS_Ref))
		for id := range m.removed_Office_PS_Ref {
			ids = append(ids, id)
		}
		return ids
	case facility.EdgeOfficeIPRef:
		ids := make([]ent.Value, 0, len(m.removed_Office_IP_Ref))
		for id := range m.removed_Office_IP_Ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FacilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleareddivisions {
		edges = append(edges, facility.EdgeDivisions)
	}
	if m.clearedregions {
		edges = append(edges, facility.EdgeRegions)
	}
	if m.clearedcircles {
		edges = append(edges, facility.EdgeCircles)
	}
	if m.clearedcircle_ref {
		edges = append(edges, facility.EdgeCircleRef)
	}
	if m.cleared_Office_PS_Ref {
		edges = append(edges, facility.EdgeOfficePSRef)
	}
	if m.cleared_Office_IP_Ref {
		edges = append(edges, facility.EdgeOfficeIPRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FacilityMutation) EdgeCleared(name string) bool {
	switch name {
	case facility.EdgeDivisions:
		return m.cleareddivisions
	case facility.EdgeRegions:
		return m.clearedregions
	case facility.EdgeCircles:
		return m.clearedcircles
	case facility.EdgeCircleRef:
		return m.clearedcircle_ref
	case facility.EdgeOfficePSRef:
		return m.cleared_Office_PS_Ref
	case facility.EdgeOfficeIPRef:
		return m.cleared_Office_IP_Ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FacilityMutation) ClearEdge(name string) error {
	switch name {
	case facility.EdgeDivisions:
		m.ClearDivisions()
		return nil
	case facility.EdgeRegions:
		m.ClearRegions()
		return nil
	case facility.EdgeCircles:
		m.ClearCircles()
		return nil
	}
	return fmt.Errorf("unknown Facility unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FacilityMutation) ResetEdge(name string) error {
	switch name {
	case facility.EdgeDivisions:
		m.ResetDivisions()
		return nil
	case facility.EdgeRegions:
		m.ResetRegions()
		return nil
	case facility.EdgeCircles:
		m.ResetCircles()
		return nil
	case facility.EdgeCircleRef:
		m.ResetCircleRef()
		return nil
	case facility.EdgeOfficePSRef:
		m.ResetOfficePSRef()
		return nil
	case facility.EdgeOfficeIPRef:
		m.ResetOfficeIPRef()
		return nil
	}
	return fmt.Errorf("unknown Facility edge %s", name)
}

// LoginMutation represents an operation that mutates the Login nodes in the graph.
type LoginMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	loginID                     *uuid.UUID
	username                    *string
	password                    *string
	_EmployeedID                *int32
	add_EmployeedID             *int32
	expiremins_token            *int32
	addexpiremins_token         *int32
	expiremins_refresh_token    *int32
	addexpiremins_refresh_token *int32
	role                        *int32
	addrole                     *int32
	token                       *string
	_VerifyRemarks              *string
	clearedFields               map[string]struct{}
	done                        bool
	oldValue                    func(context.Context) (*Login, error)
	predicates                  []predicate.Login
}

var _ ent.Mutation = (*LoginMutation)(nil)

// loginOption allows management of the mutation configuration using functional options.
type loginOption func(*LoginMutation)

// newLoginMutation creates new mutation for the Login entity.
func newLoginMutation(c config, op Op, opts ...loginOption) *LoginMutation {
	m := &LoginMutation{
		config:        c,
		op:            op,
		typ:           TypeLogin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoginID sets the ID field of the mutation.
func withLoginID(id int) loginOption {
	return func(m *LoginMutation) {
		var (
			err   error
			once  sync.Once
			value *Login
		)
		m.oldValue = func(ctx context.Context) (*Login, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Login.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogin sets the old Login of the mutation.
func withLogin(node *Login) loginOption {
	return func(m *LoginMutation) {
		m.oldValue = func(context.Context) (*Login, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoginMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoginMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoginMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoginMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Login.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLoginID sets the "loginID" field.
func (m *LoginMutation) SetLoginID(u uuid.UUID) {
	m.loginID = &u
}

// LoginID returns the value of the "loginID" field in the mutation.
func (m *LoginMutation) LoginID() (r uuid.UUID, exists bool) {
	v := m.loginID
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginID returns the old "loginID" field's value of the Login entity.
// If the Login object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginMutation) OldLoginID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginID: %w", err)
	}
	return oldValue.LoginID, nil
}

// ResetLoginID resets all changes to the "loginID" field.
func (m *LoginMutation) ResetLoginID() {
	m.loginID = nil
}

// SetUsername sets the "username" field.
func (m *LoginMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *LoginMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Login entity.
// If the Login object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *LoginMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *LoginMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *LoginMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Login entity.
// If the Login object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *LoginMutation) ResetPassword() {
	m.password = nil
}

// SetEmployeedID sets the "EmployeedID" field.
func (m *LoginMutation) SetEmployeedID(i int32) {
	m._EmployeedID = &i
	m.add_EmployeedID = nil
}

// EmployeedID returns the value of the "EmployeedID" field in the mutation.
func (m *LoginMutation) EmployeedID() (r int32, exists bool) {
	v := m._EmployeedID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeedID returns the old "EmployeedID" field's value of the Login entity.
// If the Login object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginMutation) OldEmployeedID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeedID: %w", err)
	}
	return oldValue.EmployeedID, nil
}

// AddEmployeedID adds i to the "EmployeedID" field.
func (m *LoginMutation) AddEmployeedID(i int32) {
	if m.add_EmployeedID != nil {
		*m.add_EmployeedID += i
	} else {
		m.add_EmployeedID = &i
	}
}

// AddedEmployeedID returns the value that was added to the "EmployeedID" field in this mutation.
func (m *LoginMutation) AddedEmployeedID() (r int32, exists bool) {
	v := m.add_EmployeedID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeedID clears the value of the "EmployeedID" field.
func (m *LoginMutation) ClearEmployeedID() {
	m._EmployeedID = nil
	m.add_EmployeedID = nil
	m.clearedFields[login.FieldEmployeedID] = struct{}{}
}

// EmployeedIDCleared returns if the "EmployeedID" field was cleared in this mutation.
func (m *LoginMutation) EmployeedIDCleared() bool {
	_, ok := m.clearedFields[login.FieldEmployeedID]
	return ok
}

// ResetEmployeedID resets all changes to the "EmployeedID" field.
func (m *LoginMutation) ResetEmployeedID() {
	m._EmployeedID = nil
	m.add_EmployeedID = nil
	delete(m.clearedFields, login.FieldEmployeedID)
}

// SetExpireminsToken sets the "expiremins_token" field.
func (m *LoginMutation) SetExpireminsToken(i int32) {
	m.expiremins_token = &i
	m.addexpiremins_token = nil
}

// ExpireminsToken returns the value of the "expiremins_token" field in the mutation.
func (m *LoginMutation) ExpireminsToken() (r int32, exists bool) {
	v := m.expiremins_token
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireminsToken returns the old "expiremins_token" field's value of the Login entity.
// If the Login object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginMutation) OldExpireminsToken(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireminsToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireminsToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireminsToken: %w", err)
	}
	return oldValue.ExpireminsToken, nil
}

// AddExpireminsToken adds i to the "expiremins_token" field.
func (m *LoginMutation) AddExpireminsToken(i int32) {
	if m.addexpiremins_token != nil {
		*m.addexpiremins_token += i
	} else {
		m.addexpiremins_token = &i
	}
}

// AddedExpireminsToken returns the value that was added to the "expiremins_token" field in this mutation.
func (m *LoginMutation) AddedExpireminsToken() (r int32, exists bool) {
	v := m.addexpiremins_token
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpireminsToken resets all changes to the "expiremins_token" field.
func (m *LoginMutation) ResetExpireminsToken() {
	m.expiremins_token = nil
	m.addexpiremins_token = nil
}

// SetExpireminsRefreshToken sets the "expiremins_refresh_token" field.
func (m *LoginMutation) SetExpireminsRefreshToken(i int32) {
	m.expiremins_refresh_token = &i
	m.addexpiremins_refresh_token = nil
}

// ExpireminsRefreshToken returns the value of the "expiremins_refresh_token" field in the mutation.
func (m *LoginMutation) ExpireminsRefreshToken() (r int32, exists bool) {
	v := m.expiremins_refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireminsRefreshToken returns the old "expiremins_refresh_token" field's value of the Login entity.
// If the Login object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginMutation) OldExpireminsRefreshToken(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireminsRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireminsRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireminsRefreshToken: %w", err)
	}
	return oldValue.ExpireminsRefreshToken, nil
}

// AddExpireminsRefreshToken adds i to the "expiremins_refresh_token" field.
func (m *LoginMutation) AddExpireminsRefreshToken(i int32) {
	if m.addexpiremins_refresh_token != nil {
		*m.addexpiremins_refresh_token += i
	} else {
		m.addexpiremins_refresh_token = &i
	}
}

// AddedExpireminsRefreshToken returns the value that was added to the "expiremins_refresh_token" field in this mutation.
func (m *LoginMutation) AddedExpireminsRefreshToken() (r int32, exists bool) {
	v := m.addexpiremins_refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpireminsRefreshToken resets all changes to the "expiremins_refresh_token" field.
func (m *LoginMutation) ResetExpireminsRefreshToken() {
	m.expiremins_refresh_token = nil
	m.addexpiremins_refresh_token = nil
}

// SetRole sets the "role" field.
func (m *LoginMutation) SetRole(i int32) {
	m.role = &i
	m.addrole = nil
}

// Role returns the value of the "role" field in the mutation.
func (m *LoginMutation) Role() (r int32, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Login entity.
// If the Login object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginMutation) OldRole(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// AddRole adds i to the "role" field.
func (m *LoginMutation) AddRole(i int32) {
	if m.addrole != nil {
		*m.addrole += i
	} else {
		m.addrole = &i
	}
}

// AddedRole returns the value that was added to the "role" field in this mutation.
func (m *LoginMutation) AddedRole() (r int32, exists bool) {
	v := m.addrole
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole resets all changes to the "role" field.
func (m *LoginMutation) ResetRole() {
	m.role = nil
	m.addrole = nil
}

// SetToken sets the "token" field.
func (m *LoginMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *LoginMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Login entity.
// If the Login object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *LoginMutation) ResetToken() {
	m.token = nil
}

// SetVerifyRemarks sets the "VerifyRemarks" field.
func (m *LoginMutation) SetVerifyRemarks(s string) {
	m._VerifyRemarks = &s
}

// VerifyRemarks returns the value of the "VerifyRemarks" field in the mutation.
func (m *LoginMutation) VerifyRemarks() (r string, exists bool) {
	v := m._VerifyRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifyRemarks returns the old "VerifyRemarks" field's value of the Login entity.
// If the Login object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginMutation) OldVerifyRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifyRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifyRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifyRemarks: %w", err)
	}
	return oldValue.VerifyRemarks, nil
}

// ClearVerifyRemarks clears the value of the "VerifyRemarks" field.
func (m *LoginMutation) ClearVerifyRemarks() {
	m._VerifyRemarks = nil
	m.clearedFields[login.FieldVerifyRemarks] = struct{}{}
}

// VerifyRemarksCleared returns if the "VerifyRemarks" field was cleared in this mutation.
func (m *LoginMutation) VerifyRemarksCleared() bool {
	_, ok := m.clearedFields[login.FieldVerifyRemarks]
	return ok
}

// ResetVerifyRemarks resets all changes to the "VerifyRemarks" field.
func (m *LoginMutation) ResetVerifyRemarks() {
	m._VerifyRemarks = nil
	delete(m.clearedFields, login.FieldVerifyRemarks)
}

// Where appends a list predicates to the LoginMutation builder.
func (m *LoginMutation) Where(ps ...predicate.Login) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LoginMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LoginMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Login, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LoginMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LoginMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Login).
func (m *LoginMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoginMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.loginID != nil {
		fields = append(fields, login.FieldLoginID)
	}
	if m.username != nil {
		fields = append(fields, login.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, login.FieldPassword)
	}
	if m._EmployeedID != nil {
		fields = append(fields, login.FieldEmployeedID)
	}
	if m.expiremins_token != nil {
		fields = append(fields, login.FieldExpireminsToken)
	}
	if m.expiremins_refresh_token != nil {
		fields = append(fields, login.FieldExpireminsRefreshToken)
	}
	if m.role != nil {
		fields = append(fields, login.FieldRole)
	}
	if m.token != nil {
		fields = append(fields, login.FieldToken)
	}
	if m._VerifyRemarks != nil {
		fields = append(fields, login.FieldVerifyRemarks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoginMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case login.FieldLoginID:
		return m.LoginID()
	case login.FieldUsername:
		return m.Username()
	case login.FieldPassword:
		return m.Password()
	case login.FieldEmployeedID:
		return m.EmployeedID()
	case login.FieldExpireminsToken:
		return m.ExpireminsToken()
	case login.FieldExpireminsRefreshToken:
		return m.ExpireminsRefreshToken()
	case login.FieldRole:
		return m.Role()
	case login.FieldToken:
		return m.Token()
	case login.FieldVerifyRemarks:
		return m.VerifyRemarks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoginMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case login.FieldLoginID:
		return m.OldLoginID(ctx)
	case login.FieldUsername:
		return m.OldUsername(ctx)
	case login.FieldPassword:
		return m.OldPassword(ctx)
	case login.FieldEmployeedID:
		return m.OldEmployeedID(ctx)
	case login.FieldExpireminsToken:
		return m.OldExpireminsToken(ctx)
	case login.FieldExpireminsRefreshToken:
		return m.OldExpireminsRefreshToken(ctx)
	case login.FieldRole:
		return m.OldRole(ctx)
	case login.FieldToken:
		return m.OldToken(ctx)
	case login.FieldVerifyRemarks:
		return m.OldVerifyRemarks(ctx)
	}
	return nil, fmt.Errorf("unknown Login field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginMutation) SetField(name string, value ent.Value) error {
	switch name {
	case login.FieldLoginID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginID(v)
		return nil
	case login.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case login.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case login.FieldEmployeedID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeedID(v)
		return nil
	case login.FieldExpireminsToken:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireminsToken(v)
		return nil
	case login.FieldExpireminsRefreshToken:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireminsRefreshToken(v)
		return nil
	case login.FieldRole:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case login.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case login.FieldVerifyRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifyRemarks(v)
		return nil
	}
	return fmt.Errorf("unknown Login field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoginMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeedID != nil {
		fields = append(fields, login.FieldEmployeedID)
	}
	if m.addexpiremins_token != nil {
		fields = append(fields, login.FieldExpireminsToken)
	}
	if m.addexpiremins_refresh_token != nil {
		fields = append(fields, login.FieldExpireminsRefreshToken)
	}
	if m.addrole != nil {
		fields = append(fields, login.FieldRole)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoginMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case login.FieldEmployeedID:
		return m.AddedEmployeedID()
	case login.FieldExpireminsToken:
		return m.AddedExpireminsToken()
	case login.FieldExpireminsRefreshToken:
		return m.AddedExpireminsRefreshToken()
	case login.FieldRole:
		return m.AddedRole()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginMutation) AddField(name string, value ent.Value) error {
	switch name {
	case login.FieldEmployeedID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeedID(v)
		return nil
	case login.FieldExpireminsToken:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpireminsToken(v)
		return nil
	case login.FieldExpireminsRefreshToken:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpireminsRefreshToken(v)
		return nil
	case login.FieldRole:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRole(v)
		return nil
	}
	return fmt.Errorf("unknown Login numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoginMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(login.FieldEmployeedID) {
		fields = append(fields, login.FieldEmployeedID)
	}
	if m.FieldCleared(login.FieldVerifyRemarks) {
		fields = append(fields, login.FieldVerifyRemarks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoginMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoginMutation) ClearField(name string) error {
	switch name {
	case login.FieldEmployeedID:
		m.ClearEmployeedID()
		return nil
	case login.FieldVerifyRemarks:
		m.ClearVerifyRemarks()
		return nil
	}
	return fmt.Errorf("unknown Login nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoginMutation) ResetField(name string) error {
	switch name {
	case login.FieldLoginID:
		m.ResetLoginID()
		return nil
	case login.FieldUsername:
		m.ResetUsername()
		return nil
	case login.FieldPassword:
		m.ResetPassword()
		return nil
	case login.FieldEmployeedID:
		m.ResetEmployeedID()
		return nil
	case login.FieldExpireminsToken:
		m.ResetExpireminsToken()
		return nil
	case login.FieldExpireminsRefreshToken:
		m.ResetExpireminsRefreshToken()
		return nil
	case login.FieldRole:
		m.ResetRole()
		return nil
	case login.FieldToken:
		m.ResetToken()
		return nil
	case login.FieldVerifyRemarks:
		m.ResetVerifyRemarks()
		return nil
	}
	return fmt.Errorf("unknown Login field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoginMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoginMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoginMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoginMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoginMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoginMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoginMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Login unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoginMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Login edge %s", name)
}

// NodalOfficerMutation represents an operation that mutates the NodalOfficer nodes in the graph.
type NodalOfficerMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int32
	_NodalOfficerName   *string
	_DesignationID      *int32
	add_DesignationID   *int32
	_EmailID            *string
	_MobileNumber       *string
	_HallTicketApproved *string
	clearedFields       map[string]struct{}
	centers             map[int32]struct{}
	removedcenters      map[int32]struct{}
	clearedcenters      bool
	exam                *int32
	clearedexam         bool
	notification        *int32
	clearednotification bool
	done                bool
	oldValue            func(context.Context) (*NodalOfficer, error)
	predicates          []predicate.NodalOfficer
}

var _ ent.Mutation = (*NodalOfficerMutation)(nil)

// nodalofficerOption allows management of the mutation configuration using functional options.
type nodalofficerOption func(*NodalOfficerMutation)

// newNodalOfficerMutation creates new mutation for the NodalOfficer entity.
func newNodalOfficerMutation(c config, op Op, opts ...nodalofficerOption) *NodalOfficerMutation {
	m := &NodalOfficerMutation{
		config:        c,
		op:            op,
		typ:           TypeNodalOfficer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNodalOfficerID sets the ID field of the mutation.
func withNodalOfficerID(id int32) nodalofficerOption {
	return func(m *NodalOfficerMutation) {
		var (
			err   error
			once  sync.Once
			value *NodalOfficer
		)
		m.oldValue = func(ctx context.Context) (*NodalOfficer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NodalOfficer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNodalOfficer sets the old NodalOfficer of the mutation.
func withNodalOfficer(node *NodalOfficer) nodalofficerOption {
	return func(m *NodalOfficerMutation) {
		m.oldValue = func(context.Context) (*NodalOfficer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NodalOfficerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NodalOfficerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NodalOfficer entities.
func (m *NodalOfficerMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NodalOfficerMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NodalOfficerMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NodalOfficer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNodalOfficerName sets the "NodalOfficerName" field.
func (m *NodalOfficerMutation) SetNodalOfficerName(s string) {
	m._NodalOfficerName = &s
}

// NodalOfficerName returns the value of the "NodalOfficerName" field in the mutation.
func (m *NodalOfficerMutation) NodalOfficerName() (r string, exists bool) {
	v := m._NodalOfficerName
	if v == nil {
		return
	}
	return *v, true
}

// OldNodalOfficerName returns the old "NodalOfficerName" field's value of the NodalOfficer entity.
// If the NodalOfficer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodalOfficerMutation) OldNodalOfficerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodalOfficerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodalOfficerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodalOfficerName: %w", err)
	}
	return oldValue.NodalOfficerName, nil
}

// ResetNodalOfficerName resets all changes to the "NodalOfficerName" field.
func (m *NodalOfficerMutation) ResetNodalOfficerName() {
	m._NodalOfficerName = nil
}

// SetDesignationID sets the "DesignationID" field.
func (m *NodalOfficerMutation) SetDesignationID(i int32) {
	m._DesignationID = &i
	m.add_DesignationID = nil
}

// DesignationID returns the value of the "DesignationID" field in the mutation.
func (m *NodalOfficerMutation) DesignationID() (r int32, exists bool) {
	v := m._DesignationID
	if v == nil {
		return
	}
	return *v, true
}

// OldDesignationID returns the old "DesignationID" field's value of the NodalOfficer entity.
// If the NodalOfficer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodalOfficerMutation) OldDesignationID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesignationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesignationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesignationID: %w", err)
	}
	return oldValue.DesignationID, nil
}

// AddDesignationID adds i to the "DesignationID" field.
func (m *NodalOfficerMutation) AddDesignationID(i int32) {
	if m.add_DesignationID != nil {
		*m.add_DesignationID += i
	} else {
		m.add_DesignationID = &i
	}
}

// AddedDesignationID returns the value that was added to the "DesignationID" field in this mutation.
func (m *NodalOfficerMutation) AddedDesignationID() (r int32, exists bool) {
	v := m.add_DesignationID
	if v == nil {
		return
	}
	return *v, true
}

// ResetDesignationID resets all changes to the "DesignationID" field.
func (m *NodalOfficerMutation) ResetDesignationID() {
	m._DesignationID = nil
	m.add_DesignationID = nil
}

// SetEmailID sets the "EmailID" field.
func (m *NodalOfficerMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *NodalOfficerMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the NodalOfficer entity.
// If the NodalOfficer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodalOfficerMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *NodalOfficerMutation) ResetEmailID() {
	m._EmailID = nil
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *NodalOfficerMutation) SetMobileNumber(s string) {
	m._MobileNumber = &s
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *NodalOfficerMutation) MobileNumber() (r string, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the NodalOfficer entity.
// If the NodalOfficer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodalOfficerMutation) OldMobileNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *NodalOfficerMutation) ResetMobileNumber() {
	m._MobileNumber = nil
}

// SetNotifyCode sets the "NotifyCode" field.
func (m *NodalOfficerMutation) SetNotifyCode(i int32) {
	m.notification = &i
}

// NotifyCode returns the value of the "NotifyCode" field in the mutation.
func (m *NodalOfficerMutation) NotifyCode() (r int32, exists bool) {
	v := m.notification
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyCode returns the old "NotifyCode" field's value of the NodalOfficer entity.
// If the NodalOfficer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodalOfficerMutation) OldNotifyCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyCode: %w", err)
	}
	return oldValue.NotifyCode, nil
}

// ClearNotifyCode clears the value of the "NotifyCode" field.
func (m *NodalOfficerMutation) ClearNotifyCode() {
	m.notification = nil
	m.clearedFields[nodalofficer.FieldNotifyCode] = struct{}{}
}

// NotifyCodeCleared returns if the "NotifyCode" field was cleared in this mutation.
func (m *NodalOfficerMutation) NotifyCodeCleared() bool {
	_, ok := m.clearedFields[nodalofficer.FieldNotifyCode]
	return ok
}

// ResetNotifyCode resets all changes to the "NotifyCode" field.
func (m *NodalOfficerMutation) ResetNotifyCode() {
	m.notification = nil
	delete(m.clearedFields, nodalofficer.FieldNotifyCode)
}

// SetExamCode sets the "ExamCode" field.
func (m *NodalOfficerMutation) SetExamCode(i int32) {
	m.exam = &i
}

// ExamCode returns the value of the "ExamCode" field in the mutation.
func (m *NodalOfficerMutation) ExamCode() (r int32, exists bool) {
	v := m.exam
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCode returns the old "ExamCode" field's value of the NodalOfficer entity.
// If the NodalOfficer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodalOfficerMutation) OldExamCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCode: %w", err)
	}
	return oldValue.ExamCode, nil
}

// ClearExamCode clears the value of the "ExamCode" field.
func (m *NodalOfficerMutation) ClearExamCode() {
	m.exam = nil
	m.clearedFields[nodalofficer.FieldExamCode] = struct{}{}
}

// ExamCodeCleared returns if the "ExamCode" field was cleared in this mutation.
func (m *NodalOfficerMutation) ExamCodeCleared() bool {
	_, ok := m.clearedFields[nodalofficer.FieldExamCode]
	return ok
}

// ResetExamCode resets all changes to the "ExamCode" field.
func (m *NodalOfficerMutation) ResetExamCode() {
	m.exam = nil
	delete(m.clearedFields, nodalofficer.FieldExamCode)
}

// SetHallTicketApproved sets the "HallTicketApproved" field.
func (m *NodalOfficerMutation) SetHallTicketApproved(s string) {
	m._HallTicketApproved = &s
}

// HallTicketApproved returns the value of the "HallTicketApproved" field in the mutation.
func (m *NodalOfficerMutation) HallTicketApproved() (r string, exists bool) {
	v := m._HallTicketApproved
	if v == nil {
		return
	}
	return *v, true
}

// OldHallTicketApproved returns the old "HallTicketApproved" field's value of the NodalOfficer entity.
// If the NodalOfficer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodalOfficerMutation) OldHallTicketApproved(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHallTicketApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHallTicketApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHallTicketApproved: %w", err)
	}
	return oldValue.HallTicketApproved, nil
}

// ClearHallTicketApproved clears the value of the "HallTicketApproved" field.
func (m *NodalOfficerMutation) ClearHallTicketApproved() {
	m._HallTicketApproved = nil
	m.clearedFields[nodalofficer.FieldHallTicketApproved] = struct{}{}
}

// HallTicketApprovedCleared returns if the "HallTicketApproved" field was cleared in this mutation.
func (m *NodalOfficerMutation) HallTicketApprovedCleared() bool {
	_, ok := m.clearedFields[nodalofficer.FieldHallTicketApproved]
	return ok
}

// ResetHallTicketApproved resets all changes to the "HallTicketApproved" field.
func (m *NodalOfficerMutation) ResetHallTicketApproved() {
	m._HallTicketApproved = nil
	delete(m.clearedFields, nodalofficer.FieldHallTicketApproved)
}

// AddCenterIDs adds the "centers" edge to the Center entity by ids.
func (m *NodalOfficerMutation) AddCenterIDs(ids ...int32) {
	if m.centers == nil {
		m.centers = make(map[int32]struct{})
	}
	for i := range ids {
		m.centers[ids[i]] = struct{}{}
	}
}

// ClearCenters clears the "centers" edge to the Center entity.
func (m *NodalOfficerMutation) ClearCenters() {
	m.clearedcenters = true
}

// CentersCleared reports if the "centers" edge to the Center entity was cleared.
func (m *NodalOfficerMutation) CentersCleared() bool {
	return m.clearedcenters
}

// RemoveCenterIDs removes the "centers" edge to the Center entity by IDs.
func (m *NodalOfficerMutation) RemoveCenterIDs(ids ...int32) {
	if m.removedcenters == nil {
		m.removedcenters = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.centers, ids[i])
		m.removedcenters[ids[i]] = struct{}{}
	}
}

// RemovedCenters returns the removed IDs of the "centers" edge to the Center entity.
func (m *NodalOfficerMutation) RemovedCentersIDs() (ids []int32) {
	for id := range m.removedcenters {
		ids = append(ids, id)
	}
	return
}

// CentersIDs returns the "centers" edge IDs in the mutation.
func (m *NodalOfficerMutation) CentersIDs() (ids []int32) {
	for id := range m.centers {
		ids = append(ids, id)
	}
	return
}

// ResetCenters resets all changes to the "centers" edge.
func (m *NodalOfficerMutation) ResetCenters() {
	m.centers = nil
	m.clearedcenters = false
	m.removedcenters = nil
}

// SetExamID sets the "exam" edge to the Exam entity by id.
func (m *NodalOfficerMutation) SetExamID(id int32) {
	m.exam = &id
}

// ClearExam clears the "exam" edge to the Exam entity.
func (m *NodalOfficerMutation) ClearExam() {
	m.clearedexam = true
}

// ExamCleared reports if the "exam" edge to the Exam entity was cleared.
func (m *NodalOfficerMutation) ExamCleared() bool {
	return m.ExamCodeCleared() || m.clearedexam
}

// ExamID returns the "exam" edge ID in the mutation.
func (m *NodalOfficerMutation) ExamID() (id int32, exists bool) {
	if m.exam != nil {
		return *m.exam, true
	}
	return
}

// ExamIDs returns the "exam" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamID instead. It exists only for internal usage by the builders.
func (m *NodalOfficerMutation) ExamIDs() (ids []int32) {
	if id := m.exam; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExam resets all changes to the "exam" edge.
func (m *NodalOfficerMutation) ResetExam() {
	m.exam = nil
	m.clearedexam = false
}

// SetNotificationID sets the "notification" edge to the Notification entity by id.
func (m *NodalOfficerMutation) SetNotificationID(id int32) {
	m.notification = &id
}

// ClearNotification clears the "notification" edge to the Notification entity.
func (m *NodalOfficerMutation) ClearNotification() {
	m.clearednotification = true
}

// NotificationCleared reports if the "notification" edge to the Notification entity was cleared.
func (m *NodalOfficerMutation) NotificationCleared() bool {
	return m.NotifyCodeCleared() || m.clearednotification
}

// NotificationID returns the "notification" edge ID in the mutation.
func (m *NodalOfficerMutation) NotificationID() (id int32, exists bool) {
	if m.notification != nil {
		return *m.notification, true
	}
	return
}

// NotificationIDs returns the "notification" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotificationID instead. It exists only for internal usage by the builders.
func (m *NodalOfficerMutation) NotificationIDs() (ids []int32) {
	if id := m.notification; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotification resets all changes to the "notification" edge.
func (m *NodalOfficerMutation) ResetNotification() {
	m.notification = nil
	m.clearednotification = false
}

// Where appends a list predicates to the NodalOfficerMutation builder.
func (m *NodalOfficerMutation) Where(ps ...predicate.NodalOfficer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NodalOfficerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NodalOfficerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NodalOfficer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NodalOfficerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NodalOfficerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NodalOfficer).
func (m *NodalOfficerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NodalOfficerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._NodalOfficerName != nil {
		fields = append(fields, nodalofficer.FieldNodalOfficerName)
	}
	if m._DesignationID != nil {
		fields = append(fields, nodalofficer.FieldDesignationID)
	}
	if m._EmailID != nil {
		fields = append(fields, nodalofficer.FieldEmailID)
	}
	if m._MobileNumber != nil {
		fields = append(fields, nodalofficer.FieldMobileNumber)
	}
	if m.notification != nil {
		fields = append(fields, nodalofficer.FieldNotifyCode)
	}
	if m.exam != nil {
		fields = append(fields, nodalofficer.FieldExamCode)
	}
	if m._HallTicketApproved != nil {
		fields = append(fields, nodalofficer.FieldHallTicketApproved)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NodalOfficerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nodalofficer.FieldNodalOfficerName:
		return m.NodalOfficerName()
	case nodalofficer.FieldDesignationID:
		return m.DesignationID()
	case nodalofficer.FieldEmailID:
		return m.EmailID()
	case nodalofficer.FieldMobileNumber:
		return m.MobileNumber()
	case nodalofficer.FieldNotifyCode:
		return m.NotifyCode()
	case nodalofficer.FieldExamCode:
		return m.ExamCode()
	case nodalofficer.FieldHallTicketApproved:
		return m.HallTicketApproved()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NodalOfficerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nodalofficer.FieldNodalOfficerName:
		return m.OldNodalOfficerName(ctx)
	case nodalofficer.FieldDesignationID:
		return m.OldDesignationID(ctx)
	case nodalofficer.FieldEmailID:
		return m.OldEmailID(ctx)
	case nodalofficer.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case nodalofficer.FieldNotifyCode:
		return m.OldNotifyCode(ctx)
	case nodalofficer.FieldExamCode:
		return m.OldExamCode(ctx)
	case nodalofficer.FieldHallTicketApproved:
		return m.OldHallTicketApproved(ctx)
	}
	return nil, fmt.Errorf("unknown NodalOfficer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodalOfficerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nodalofficer.FieldNodalOfficerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodalOfficerName(v)
		return nil
	case nodalofficer.FieldDesignationID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesignationID(v)
		return nil
	case nodalofficer.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case nodalofficer.FieldMobileNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case nodalofficer.FieldNotifyCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyCode(v)
		return nil
	case nodalofficer.FieldExamCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCode(v)
		return nil
	case nodalofficer.FieldHallTicketApproved:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHallTicketApproved(v)
		return nil
	}
	return fmt.Errorf("unknown NodalOfficer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NodalOfficerMutation) AddedFields() []string {
	var fields []string
	if m.add_DesignationID != nil {
		fields = append(fields, nodalofficer.FieldDesignationID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NodalOfficerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case nodalofficer.FieldDesignationID:
		return m.AddedDesignationID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodalOfficerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case nodalofficer.FieldDesignationID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDesignationID(v)
		return nil
	}
	return fmt.Errorf("unknown NodalOfficer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NodalOfficerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(nodalofficer.FieldNotifyCode) {
		fields = append(fields, nodalofficer.FieldNotifyCode)
	}
	if m.FieldCleared(nodalofficer.FieldExamCode) {
		fields = append(fields, nodalofficer.FieldExamCode)
	}
	if m.FieldCleared(nodalofficer.FieldHallTicketApproved) {
		fields = append(fields, nodalofficer.FieldHallTicketApproved)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NodalOfficerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NodalOfficerMutation) ClearField(name string) error {
	switch name {
	case nodalofficer.FieldNotifyCode:
		m.ClearNotifyCode()
		return nil
	case nodalofficer.FieldExamCode:
		m.ClearExamCode()
		return nil
	case nodalofficer.FieldHallTicketApproved:
		m.ClearHallTicketApproved()
		return nil
	}
	return fmt.Errorf("unknown NodalOfficer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NodalOfficerMutation) ResetField(name string) error {
	switch name {
	case nodalofficer.FieldNodalOfficerName:
		m.ResetNodalOfficerName()
		return nil
	case nodalofficer.FieldDesignationID:
		m.ResetDesignationID()
		return nil
	case nodalofficer.FieldEmailID:
		m.ResetEmailID()
		return nil
	case nodalofficer.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case nodalofficer.FieldNotifyCode:
		m.ResetNotifyCode()
		return nil
	case nodalofficer.FieldExamCode:
		m.ResetExamCode()
		return nil
	case nodalofficer.FieldHallTicketApproved:
		m.ResetHallTicketApproved()
		return nil
	}
	return fmt.Errorf("unknown NodalOfficer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NodalOfficerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.centers != nil {
		edges = append(edges, nodalofficer.EdgeCenters)
	}
	if m.exam != nil {
		edges = append(edges, nodalofficer.EdgeExam)
	}
	if m.notification != nil {
		edges = append(edges, nodalofficer.EdgeNotification)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NodalOfficerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nodalofficer.EdgeCenters:
		ids := make([]ent.Value, 0, len(m.centers))
		for id := range m.centers {
			ids = append(ids, id)
		}
		return ids
	case nodalofficer.EdgeExam:
		if id := m.exam; id != nil {
			return []ent.Value{*id}
		}
	case nodalofficer.EdgeNotification:
		if id := m.notification; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NodalOfficerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcenters != nil {
		edges = append(edges, nodalofficer.EdgeCenters)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NodalOfficerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nodalofficer.EdgeCenters:
		ids := make([]ent.Value, 0, len(m.removedcenters))
		for id := range m.removedcenters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NodalOfficerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcenters {
		edges = append(edges, nodalofficer.EdgeCenters)
	}
	if m.clearedexam {
		edges = append(edges, nodalofficer.EdgeExam)
	}
	if m.clearednotification {
		edges = append(edges, nodalofficer.EdgeNotification)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NodalOfficerMutation) EdgeCleared(name string) bool {
	switch name {
	case nodalofficer.EdgeCenters:
		return m.clearedcenters
	case nodalofficer.EdgeExam:
		return m.clearedexam
	case nodalofficer.EdgeNotification:
		return m.clearednotification
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NodalOfficerMutation) ClearEdge(name string) error {
	switch name {
	case nodalofficer.EdgeExam:
		m.ClearExam()
		return nil
	case nodalofficer.EdgeNotification:
		m.ClearNotification()
		return nil
	}
	return fmt.Errorf("unknown NodalOfficer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NodalOfficerMutation) ResetEdge(name string) error {
	switch name {
	case nodalofficer.EdgeCenters:
		m.ResetCenters()
		return nil
	case nodalofficer.EdgeExam:
		m.ResetExam()
		return nil
	case nodalofficer.EdgeNotification:
		m.ResetNotification()
		return nil
	}
	return fmt.Errorf("unknown NodalOfficer edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *int32
	_ExamYear                              *int32
	add_ExamYear                           *int32
	_ApplicationStartDate                  *time.Time
	_ApplicationEndDate                    *time.Time
	_VerificationDateByController          *time.Time
	_CorrectionDateByCandidate             *time.Time
	_CorrectionVeriyDateByController       *time.Time
	_HallTicketAllotmentDateByNodalOfficer *time.Time
	_HallTicketDownloadDate                *time.Time
	_NotifyFile                            *string
	_SyllabusFile                          *string
	_VacanciesFile                         *string
	_ExamCodePS                            *int32
	add_ExamCodePS                         *int32
	clearedFields                          map[string]struct{}
	applications                           map[int32]struct{}
	removedapplications                    map[int32]struct{}
	clearedapplications                    bool
	centers                                map[int32]struct{}
	removedcenters                         map[int32]struct{}
	clearedcenters                         bool
	nodal_officers                         map[int32]struct{}
	removednodal_officers                  map[int32]struct{}
	clearednodal_officers                  bool
	exam                                   *int32
	clearedexam                            bool
	vacancy_years                          map[int32]struct{}
	removedvacancy_years                   map[int32]struct{}
	clearedvacancy_years                   bool
	notify_ref                             map[int32]struct{}
	removednotify_ref                      map[int32]struct{}
	clearednotify_ref                      bool
	notifications_ps                       map[int32]struct{}
	removednotifications_ps                map[int32]struct{}
	clearednotifications_ps                bool
	notifications_ip                       map[int32]struct{}
	removednotifications_ip                map[int32]struct{}
	clearednotifications_ip                bool
	done                                   bool
	oldValue                               func(context.Context) (*Notification, error)
	predicates                             []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id int32) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notification entities.
func (m *NotificationMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExamCode sets the "ExamCode" field.
func (m *NotificationMutation) SetExamCode(i int32) {
	m.exam = &i
}

// ExamCode returns the value of the "ExamCode" field in the mutation.
func (m *NotificationMutation) ExamCode() (r int32, exists bool) {
	v := m.exam
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCode returns the old "ExamCode" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldExamCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCode: %w", err)
	}
	return oldValue.ExamCode, nil
}

// ClearExamCode clears the value of the "ExamCode" field.
func (m *NotificationMutation) ClearExamCode() {
	m.exam = nil
	m.clearedFields[notification.FieldExamCode] = struct{}{}
}

// ExamCodeCleared returns if the "ExamCode" field was cleared in this mutation.
func (m *NotificationMutation) ExamCodeCleared() bool {
	_, ok := m.clearedFields[notification.FieldExamCode]
	return ok
}

// ResetExamCode resets all changes to the "ExamCode" field.
func (m *NotificationMutation) ResetExamCode() {
	m.exam = nil
	delete(m.clearedFields, notification.FieldExamCode)
}

// SetExamYear sets the "ExamYear" field.
func (m *NotificationMutation) SetExamYear(i int32) {
	m._ExamYear = &i
	m.add_ExamYear = nil
}

// ExamYear returns the value of the "ExamYear" field in the mutation.
func (m *NotificationMutation) ExamYear() (r int32, exists bool) {
	v := m._ExamYear
	if v == nil {
		return
	}
	return *v, true
}

// OldExamYear returns the old "ExamYear" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldExamYear(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamYear: %w", err)
	}
	return oldValue.ExamYear, nil
}

// AddExamYear adds i to the "ExamYear" field.
func (m *NotificationMutation) AddExamYear(i int32) {
	if m.add_ExamYear != nil {
		*m.add_ExamYear += i
	} else {
		m.add_ExamYear = &i
	}
}

// AddedExamYear returns the value that was added to the "ExamYear" field in this mutation.
func (m *NotificationMutation) AddedExamYear() (r int32, exists bool) {
	v := m.add_ExamYear
	if v == nil {
		return
	}
	return *v, true
}

// ResetExamYear resets all changes to the "ExamYear" field.
func (m *NotificationMutation) ResetExamYear() {
	m._ExamYear = nil
	m.add_ExamYear = nil
}

// SetApplicationStartDate sets the "ApplicationStartDate" field.
func (m *NotificationMutation) SetApplicationStartDate(t time.Time) {
	m._ApplicationStartDate = &t
}

// ApplicationStartDate returns the value of the "ApplicationStartDate" field in the mutation.
func (m *NotificationMutation) ApplicationStartDate() (r time.Time, exists bool) {
	v := m._ApplicationStartDate
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationStartDate returns the old "ApplicationStartDate" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldApplicationStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationStartDate: %w", err)
	}
	return oldValue.ApplicationStartDate, nil
}

// ResetApplicationStartDate resets all changes to the "ApplicationStartDate" field.
func (m *NotificationMutation) ResetApplicationStartDate() {
	m._ApplicationStartDate = nil
}

// SetApplicationEndDate sets the "ApplicationEndDate" field.
func (m *NotificationMutation) SetApplicationEndDate(t time.Time) {
	m._ApplicationEndDate = &t
}

// ApplicationEndDate returns the value of the "ApplicationEndDate" field in the mutation.
func (m *NotificationMutation) ApplicationEndDate() (r time.Time, exists bool) {
	v := m._ApplicationEndDate
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationEndDate returns the old "ApplicationEndDate" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldApplicationEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationEndDate: %w", err)
	}
	return oldValue.ApplicationEndDate, nil
}

// ResetApplicationEndDate resets all changes to the "ApplicationEndDate" field.
func (m *NotificationMutation) ResetApplicationEndDate() {
	m._ApplicationEndDate = nil
}

// SetVerificationDateByController sets the "VerificationDateByController" field.
func (m *NotificationMutation) SetVerificationDateByController(t time.Time) {
	m._VerificationDateByController = &t
}

// VerificationDateByController returns the value of the "VerificationDateByController" field in the mutation.
func (m *NotificationMutation) VerificationDateByController() (r time.Time, exists bool) {
	v := m._VerificationDateByController
	if v == nil {
		return
	}
	return *v, true
}

// OldVerificationDateByController returns the old "VerificationDateByController" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldVerificationDateByController(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerificationDateByController is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerificationDateByController requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerificationDateByController: %w", err)
	}
	return oldValue.VerificationDateByController, nil
}

// ResetVerificationDateByController resets all changes to the "VerificationDateByController" field.
func (m *NotificationMutation) ResetVerificationDateByController() {
	m._VerificationDateByController = nil
}

// SetCorrectionDateByCandidate sets the "CorrectionDateByCandidate" field.
func (m *NotificationMutation) SetCorrectionDateByCandidate(t time.Time) {
	m._CorrectionDateByCandidate = &t
}

// CorrectionDateByCandidate returns the value of the "CorrectionDateByCandidate" field in the mutation.
func (m *NotificationMutation) CorrectionDateByCandidate() (r time.Time, exists bool) {
	v := m._CorrectionDateByCandidate
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrectionDateByCandidate returns the old "CorrectionDateByCandidate" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCorrectionDateByCandidate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrectionDateByCandidate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrectionDateByCandidate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrectionDateByCandidate: %w", err)
	}
	return oldValue.CorrectionDateByCandidate, nil
}

// ResetCorrectionDateByCandidate resets all changes to the "CorrectionDateByCandidate" field.
func (m *NotificationMutation) ResetCorrectionDateByCandidate() {
	m._CorrectionDateByCandidate = nil
}

// SetCorrectionVeriyDateByController sets the "CorrectionVeriyDateByController" field.
func (m *NotificationMutation) SetCorrectionVeriyDateByController(t time.Time) {
	m._CorrectionVeriyDateByController = &t
}

// CorrectionVeriyDateByController returns the value of the "CorrectionVeriyDateByController" field in the mutation.
func (m *NotificationMutation) CorrectionVeriyDateByController() (r time.Time, exists bool) {
	v := m._CorrectionVeriyDateByController
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrectionVeriyDateByController returns the old "CorrectionVeriyDateByController" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCorrectionVeriyDateByController(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrectionVeriyDateByController is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrectionVeriyDateByController requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrectionVeriyDateByController: %w", err)
	}
	return oldValue.CorrectionVeriyDateByController, nil
}

// ResetCorrectionVeriyDateByController resets all changes to the "CorrectionVeriyDateByController" field.
func (m *NotificationMutation) ResetCorrectionVeriyDateByController() {
	m._CorrectionVeriyDateByController = nil
}

// SetHallTicketAllotmentDateByNodalOfficer sets the "HallTicketAllotmentDateByNodalOfficer" field.
func (m *NotificationMutation) SetHallTicketAllotmentDateByNodalOfficer(t time.Time) {
	m._HallTicketAllotmentDateByNodalOfficer = &t
}

// HallTicketAllotmentDateByNodalOfficer returns the value of the "HallTicketAllotmentDateByNodalOfficer" field in the mutation.
func (m *NotificationMutation) HallTicketAllotmentDateByNodalOfficer() (r time.Time, exists bool) {
	v := m._HallTicketAllotmentDateByNodalOfficer
	if v == nil {
		return
	}
	return *v, true
}

// OldHallTicketAllotmentDateByNodalOfficer returns the old "HallTicketAllotmentDateByNodalOfficer" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldHallTicketAllotmentDateByNodalOfficer(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHallTicketAllotmentDateByNodalOfficer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHallTicketAllotmentDateByNodalOfficer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHallTicketAllotmentDateByNodalOfficer: %w", err)
	}
	return oldValue.HallTicketAllotmentDateByNodalOfficer, nil
}

// ResetHallTicketAllotmentDateByNodalOfficer resets all changes to the "HallTicketAllotmentDateByNodalOfficer" field.
func (m *NotificationMutation) ResetHallTicketAllotmentDateByNodalOfficer() {
	m._HallTicketAllotmentDateByNodalOfficer = nil
}

// SetHallTicketDownloadDate sets the "HallTicketDownloadDate" field.
func (m *NotificationMutation) SetHallTicketDownloadDate(t time.Time) {
	m._HallTicketDownloadDate = &t
}

// HallTicketDownloadDate returns the value of the "HallTicketDownloadDate" field in the mutation.
func (m *NotificationMutation) HallTicketDownloadDate() (r time.Time, exists bool) {
	v := m._HallTicketDownloadDate
	if v == nil {
		return
	}
	return *v, true
}

// OldHallTicketDownloadDate returns the old "HallTicketDownloadDate" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldHallTicketDownloadDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHallTicketDownloadDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHallTicketDownloadDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHallTicketDownloadDate: %w", err)
	}
	return oldValue.HallTicketDownloadDate, nil
}

// ClearHallTicketDownloadDate clears the value of the "HallTicketDownloadDate" field.
func (m *NotificationMutation) ClearHallTicketDownloadDate() {
	m._HallTicketDownloadDate = nil
	m.clearedFields[notification.FieldHallTicketDownloadDate] = struct{}{}
}

// HallTicketDownloadDateCleared returns if the "HallTicketDownloadDate" field was cleared in this mutation.
func (m *NotificationMutation) HallTicketDownloadDateCleared() bool {
	_, ok := m.clearedFields[notification.FieldHallTicketDownloadDate]
	return ok
}

// ResetHallTicketDownloadDate resets all changes to the "HallTicketDownloadDate" field.
func (m *NotificationMutation) ResetHallTicketDownloadDate() {
	m._HallTicketDownloadDate = nil
	delete(m.clearedFields, notification.FieldHallTicketDownloadDate)
}

// SetNotifyFile sets the "NotifyFile" field.
func (m *NotificationMutation) SetNotifyFile(s string) {
	m._NotifyFile = &s
}

// NotifyFile returns the value of the "NotifyFile" field in the mutation.
func (m *NotificationMutation) NotifyFile() (r string, exists bool) {
	v := m._NotifyFile
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyFile returns the old "NotifyFile" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldNotifyFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyFile: %w", err)
	}
	return oldValue.NotifyFile, nil
}

// ClearNotifyFile clears the value of the "NotifyFile" field.
func (m *NotificationMutation) ClearNotifyFile() {
	m._NotifyFile = nil
	m.clearedFields[notification.FieldNotifyFile] = struct{}{}
}

// NotifyFileCleared returns if the "NotifyFile" field was cleared in this mutation.
func (m *NotificationMutation) NotifyFileCleared() bool {
	_, ok := m.clearedFields[notification.FieldNotifyFile]
	return ok
}

// ResetNotifyFile resets all changes to the "NotifyFile" field.
func (m *NotificationMutation) ResetNotifyFile() {
	m._NotifyFile = nil
	delete(m.clearedFields, notification.FieldNotifyFile)
}

// SetSyllabusFile sets the "SyllabusFile" field.
func (m *NotificationMutation) SetSyllabusFile(s string) {
	m._SyllabusFile = &s
}

// SyllabusFile returns the value of the "SyllabusFile" field in the mutation.
func (m *NotificationMutation) SyllabusFile() (r string, exists bool) {
	v := m._SyllabusFile
	if v == nil {
		return
	}
	return *v, true
}

// OldSyllabusFile returns the old "SyllabusFile" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldSyllabusFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyllabusFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyllabusFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyllabusFile: %w", err)
	}
	return oldValue.SyllabusFile, nil
}

// ClearSyllabusFile clears the value of the "SyllabusFile" field.
func (m *NotificationMutation) ClearSyllabusFile() {
	m._SyllabusFile = nil
	m.clearedFields[notification.FieldSyllabusFile] = struct{}{}
}

// SyllabusFileCleared returns if the "SyllabusFile" field was cleared in this mutation.
func (m *NotificationMutation) SyllabusFileCleared() bool {
	_, ok := m.clearedFields[notification.FieldSyllabusFile]
	return ok
}

// ResetSyllabusFile resets all changes to the "SyllabusFile" field.
func (m *NotificationMutation) ResetSyllabusFile() {
	m._SyllabusFile = nil
	delete(m.clearedFields, notification.FieldSyllabusFile)
}

// SetVacanciesFile sets the "VacanciesFile" field.
func (m *NotificationMutation) SetVacanciesFile(s string) {
	m._VacanciesFile = &s
}

// VacanciesFile returns the value of the "VacanciesFile" field in the mutation.
func (m *NotificationMutation) VacanciesFile() (r string, exists bool) {
	v := m._VacanciesFile
	if v == nil {
		return
	}
	return *v, true
}

// OldVacanciesFile returns the old "VacanciesFile" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldVacanciesFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVacanciesFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVacanciesFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVacanciesFile: %w", err)
	}
	return oldValue.VacanciesFile, nil
}

// ClearVacanciesFile clears the value of the "VacanciesFile" field.
func (m *NotificationMutation) ClearVacanciesFile() {
	m._VacanciesFile = nil
	m.clearedFields[notification.FieldVacanciesFile] = struct{}{}
}

// VacanciesFileCleared returns if the "VacanciesFile" field was cleared in this mutation.
func (m *NotificationMutation) VacanciesFileCleared() bool {
	_, ok := m.clearedFields[notification.FieldVacanciesFile]
	return ok
}

// ResetVacanciesFile resets all changes to the "VacanciesFile" field.
func (m *NotificationMutation) ResetVacanciesFile() {
	m._VacanciesFile = nil
	delete(m.clearedFields, notification.FieldVacanciesFile)
}

// SetExamCodePS sets the "ExamCodePS" field.
func (m *NotificationMutation) SetExamCodePS(i int32) {
	m._ExamCodePS = &i
	m.add_ExamCodePS = nil
}

// ExamCodePS returns the value of the "ExamCodePS" field in the mutation.
func (m *NotificationMutation) ExamCodePS() (r int32, exists bool) {
	v := m._ExamCodePS
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCodePS returns the old "ExamCodePS" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldExamCodePS(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCodePS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCodePS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCodePS: %w", err)
	}
	return oldValue.ExamCodePS, nil
}

// AddExamCodePS adds i to the "ExamCodePS" field.
func (m *NotificationMutation) AddExamCodePS(i int32) {
	if m.add_ExamCodePS != nil {
		*m.add_ExamCodePS += i
	} else {
		m.add_ExamCodePS = &i
	}
}

// AddedExamCodePS returns the value that was added to the "ExamCodePS" field in this mutation.
func (m *NotificationMutation) AddedExamCodePS() (r int32, exists bool) {
	v := m.add_ExamCodePS
	if v == nil {
		return
	}
	return *v, true
}

// ClearExamCodePS clears the value of the "ExamCodePS" field.
func (m *NotificationMutation) ClearExamCodePS() {
	m._ExamCodePS = nil
	m.add_ExamCodePS = nil
	m.clearedFields[notification.FieldExamCodePS] = struct{}{}
}

// ExamCodePSCleared returns if the "ExamCodePS" field was cleared in this mutation.
func (m *NotificationMutation) ExamCodePSCleared() bool {
	_, ok := m.clearedFields[notification.FieldExamCodePS]
	return ok
}

// ResetExamCodePS resets all changes to the "ExamCodePS" field.
func (m *NotificationMutation) ResetExamCodePS() {
	m._ExamCodePS = nil
	m.add_ExamCodePS = nil
	delete(m.clearedFields, notification.FieldExamCodePS)
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *NotificationMutation) AddApplicationIDs(ids ...int32) {
	if m.applications == nil {
		m.applications = make(map[int32]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *NotificationMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *NotificationMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *NotificationMutation) RemoveApplicationIDs(ids ...int32) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *NotificationMutation) RemovedApplicationsIDs() (ids []int32) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *NotificationMutation) ApplicationsIDs() (ids []int32) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *NotificationMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// AddCenterIDs adds the "centers" edge to the Center entity by ids.
func (m *NotificationMutation) AddCenterIDs(ids ...int32) {
	if m.centers == nil {
		m.centers = make(map[int32]struct{})
	}
	for i := range ids {
		m.centers[ids[i]] = struct{}{}
	}
}

// ClearCenters clears the "centers" edge to the Center entity.
func (m *NotificationMutation) ClearCenters() {
	m.clearedcenters = true
}

// CentersCleared reports if the "centers" edge to the Center entity was cleared.
func (m *NotificationMutation) CentersCleared() bool {
	return m.clearedcenters
}

// RemoveCenterIDs removes the "centers" edge to the Center entity by IDs.
func (m *NotificationMutation) RemoveCenterIDs(ids ...int32) {
	if m.removedcenters == nil {
		m.removedcenters = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.centers, ids[i])
		m.removedcenters[ids[i]] = struct{}{}
	}
}

// RemovedCenters returns the removed IDs of the "centers" edge to the Center entity.
func (m *NotificationMutation) RemovedCentersIDs() (ids []int32) {
	for id := range m.removedcenters {
		ids = append(ids, id)
	}
	return
}

// CentersIDs returns the "centers" edge IDs in the mutation.
func (m *NotificationMutation) CentersIDs() (ids []int32) {
	for id := range m.centers {
		ids = append(ids, id)
	}
	return
}

// ResetCenters resets all changes to the "centers" edge.
func (m *NotificationMutation) ResetCenters() {
	m.centers = nil
	m.clearedcenters = false
	m.removedcenters = nil
}

// AddNodalOfficerIDs adds the "nodal_officers" edge to the NodalOfficer entity by ids.
func (m *NotificationMutation) AddNodalOfficerIDs(ids ...int32) {
	if m.nodal_officers == nil {
		m.nodal_officers = make(map[int32]struct{})
	}
	for i := range ids {
		m.nodal_officers[ids[i]] = struct{}{}
	}
}

// ClearNodalOfficers clears the "nodal_officers" edge to the NodalOfficer entity.
func (m *NotificationMutation) ClearNodalOfficers() {
	m.clearednodal_officers = true
}

// NodalOfficersCleared reports if the "nodal_officers" edge to the NodalOfficer entity was cleared.
func (m *NotificationMutation) NodalOfficersCleared() bool {
	return m.clearednodal_officers
}

// RemoveNodalOfficerIDs removes the "nodal_officers" edge to the NodalOfficer entity by IDs.
func (m *NotificationMutation) RemoveNodalOfficerIDs(ids ...int32) {
	if m.removednodal_officers == nil {
		m.removednodal_officers = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.nodal_officers, ids[i])
		m.removednodal_officers[ids[i]] = struct{}{}
	}
}

// RemovedNodalOfficers returns the removed IDs of the "nodal_officers" edge to the NodalOfficer entity.
func (m *NotificationMutation) RemovedNodalOfficersIDs() (ids []int32) {
	for id := range m.removednodal_officers {
		ids = append(ids, id)
	}
	return
}

// NodalOfficersIDs returns the "nodal_officers" edge IDs in the mutation.
func (m *NotificationMutation) NodalOfficersIDs() (ids []int32) {
	for id := range m.nodal_officers {
		ids = append(ids, id)
	}
	return
}

// ResetNodalOfficers resets all changes to the "nodal_officers" edge.
func (m *NotificationMutation) ResetNodalOfficers() {
	m.nodal_officers = nil
	m.clearednodal_officers = false
	m.removednodal_officers = nil
}

// SetExamID sets the "exam" edge to the Exam entity by id.
func (m *NotificationMutation) SetExamID(id int32) {
	m.exam = &id
}

// ClearExam clears the "exam" edge to the Exam entity.
func (m *NotificationMutation) ClearExam() {
	m.clearedexam = true
}

// ExamCleared reports if the "exam" edge to the Exam entity was cleared.
func (m *NotificationMutation) ExamCleared() bool {
	return m.ExamCodeCleared() || m.clearedexam
}

// ExamID returns the "exam" edge ID in the mutation.
func (m *NotificationMutation) ExamID() (id int32, exists bool) {
	if m.exam != nil {
		return *m.exam, true
	}
	return
}

// ExamIDs returns the "exam" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) ExamIDs() (ids []int32) {
	if id := m.exam; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExam resets all changes to the "exam" edge.
func (m *NotificationMutation) ResetExam() {
	m.exam = nil
	m.clearedexam = false
}

// AddVacancyYearIDs adds the "vacancy_years" edge to the VacancyYear entity by ids.
func (m *NotificationMutation) AddVacancyYearIDs(ids ...int32) {
	if m.vacancy_years == nil {
		m.vacancy_years = make(map[int32]struct{})
	}
	for i := range ids {
		m.vacancy_years[ids[i]] = struct{}{}
	}
}

// ClearVacancyYears clears the "vacancy_years" edge to the VacancyYear entity.
func (m *NotificationMutation) ClearVacancyYears() {
	m.clearedvacancy_years = true
}

// VacancyYearsCleared reports if the "vacancy_years" edge to the VacancyYear entity was cleared.
func (m *NotificationMutation) VacancyYearsCleared() bool {
	return m.clearedvacancy_years
}

// RemoveVacancyYearIDs removes the "vacancy_years" edge to the VacancyYear entity by IDs.
func (m *NotificationMutation) RemoveVacancyYearIDs(ids ...int32) {
	if m.removedvacancy_years == nil {
		m.removedvacancy_years = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.vacancy_years, ids[i])
		m.removedvacancy_years[ids[i]] = struct{}{}
	}
}

// RemovedVacancyYears returns the removed IDs of the "vacancy_years" edge to the VacancyYear entity.
func (m *NotificationMutation) RemovedVacancyYearsIDs() (ids []int32) {
	for id := range m.removedvacancy_years {
		ids = append(ids, id)
	}
	return
}

// VacancyYearsIDs returns the "vacancy_years" edge IDs in the mutation.
func (m *NotificationMutation) VacancyYearsIDs() (ids []int32) {
	for id := range m.vacancy_years {
		ids = append(ids, id)
	}
	return
}

// ResetVacancyYears resets all changes to the "vacancy_years" edge.
func (m *NotificationMutation) ResetVacancyYears() {
	m.vacancy_years = nil
	m.clearedvacancy_years = false
	m.removedvacancy_years = nil
}

// AddNotifyRefIDs adds the "notify_ref" edge to the Notification entity by ids.
func (m *NotificationMutation) AddNotifyRefIDs(ids ...int32) {
	if m.notify_ref == nil {
		m.notify_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.notify_ref[ids[i]] = struct{}{}
	}
}

// ClearNotifyRef clears the "notify_ref" edge to the Notification entity.
func (m *NotificationMutation) ClearNotifyRef() {
	m.clearednotify_ref = true
}

// NotifyRefCleared reports if the "notify_ref" edge to the Notification entity was cleared.
func (m *NotificationMutation) NotifyRefCleared() bool {
	return m.clearednotify_ref
}

// RemoveNotifyRefIDs removes the "notify_ref" edge to the Notification entity by IDs.
func (m *NotificationMutation) RemoveNotifyRefIDs(ids ...int32) {
	if m.removednotify_ref == nil {
		m.removednotify_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.notify_ref, ids[i])
		m.removednotify_ref[ids[i]] = struct{}{}
	}
}

// RemovedNotifyRef returns the removed IDs of the "notify_ref" edge to the Notification entity.
func (m *NotificationMutation) RemovedNotifyRefIDs() (ids []int32) {
	for id := range m.removednotify_ref {
		ids = append(ids, id)
	}
	return
}

// NotifyRefIDs returns the "notify_ref" edge IDs in the mutation.
func (m *NotificationMutation) NotifyRefIDs() (ids []int32) {
	for id := range m.notify_ref {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyRef resets all changes to the "notify_ref" edge.
func (m *NotificationMutation) ResetNotifyRef() {
	m.notify_ref = nil
	m.clearednotify_ref = false
	m.removednotify_ref = nil
}

// AddNotificationsPIDs adds the "notifications_ps" edge to the Exam_PS entity by ids.
func (m *NotificationMutation) AddNotificationsPIDs(ids ...int32) {
	if m.notifications_ps == nil {
		m.notifications_ps = make(map[int32]struct{})
	}
	for i := range ids {
		m.notifications_ps[ids[i]] = struct{}{}
	}
}

// ClearNotificationsPs clears the "notifications_ps" edge to the Exam_PS entity.
func (m *NotificationMutation) ClearNotificationsPs() {
	m.clearednotifications_ps = true
}

// NotificationsPsCleared reports if the "notifications_ps" edge to the Exam_PS entity was cleared.
func (m *NotificationMutation) NotificationsPsCleared() bool {
	return m.clearednotifications_ps
}

// RemoveNotificationsPIDs removes the "notifications_ps" edge to the Exam_PS entity by IDs.
func (m *NotificationMutation) RemoveNotificationsPIDs(ids ...int32) {
	if m.removednotifications_ps == nil {
		m.removednotifications_ps = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.notifications_ps, ids[i])
		m.removednotifications_ps[ids[i]] = struct{}{}
	}
}

// RemovedNotificationsPs returns the removed IDs of the "notifications_ps" edge to the Exam_PS entity.
func (m *NotificationMutation) RemovedNotificationsPsIDs() (ids []int32) {
	for id := range m.removednotifications_ps {
		ids = append(ids, id)
	}
	return
}

// NotificationsPsIDs returns the "notifications_ps" edge IDs in the mutation.
func (m *NotificationMutation) NotificationsPsIDs() (ids []int32) {
	for id := range m.notifications_ps {
		ids = append(ids, id)
	}
	return
}

// ResetNotificationsPs resets all changes to the "notifications_ps" edge.
func (m *NotificationMutation) ResetNotificationsPs() {
	m.notifications_ps = nil
	m.clearednotifications_ps = false
	m.removednotifications_ps = nil
}

// AddNotificationsIPIDs adds the "notifications_ip" edge to the Exam_IP entity by ids.
func (m *NotificationMutation) AddNotificationsIPIDs(ids ...int32) {
	if m.notifications_ip == nil {
		m.notifications_ip = make(map[int32]struct{})
	}
	for i := range ids {
		m.notifications_ip[ids[i]] = struct{}{}
	}
}

// ClearNotificationsIP clears the "notifications_ip" edge to the Exam_IP entity.
func (m *NotificationMutation) ClearNotificationsIP() {
	m.clearednotifications_ip = true
}

// NotificationsIPCleared reports if the "notifications_ip" edge to the Exam_IP entity was cleared.
func (m *NotificationMutation) NotificationsIPCleared() bool {
	return m.clearednotifications_ip
}

// RemoveNotificationsIPIDs removes the "notifications_ip" edge to the Exam_IP entity by IDs.
func (m *NotificationMutation) RemoveNotificationsIPIDs(ids ...int32) {
	if m.removednotifications_ip == nil {
		m.removednotifications_ip = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.notifications_ip, ids[i])
		m.removednotifications_ip[ids[i]] = struct{}{}
	}
}

// RemovedNotificationsIP returns the removed IDs of the "notifications_ip" edge to the Exam_IP entity.
func (m *NotificationMutation) RemovedNotificationsIPIDs() (ids []int32) {
	for id := range m.removednotifications_ip {
		ids = append(ids, id)
	}
	return
}

// NotificationsIPIDs returns the "notifications_ip" edge IDs in the mutation.
func (m *NotificationMutation) NotificationsIPIDs() (ids []int32) {
	for id := range m.notifications_ip {
		ids = append(ids, id)
	}
	return
}

// ResetNotificationsIP resets all changes to the "notifications_ip" edge.
func (m *NotificationMutation) ResetNotificationsIP() {
	m.notifications_ip = nil
	m.clearednotifications_ip = false
	m.removednotifications_ip = nil
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.exam != nil {
		fields = append(fields, notification.FieldExamCode)
	}
	if m._ExamYear != nil {
		fields = append(fields, notification.FieldExamYear)
	}
	if m._ApplicationStartDate != nil {
		fields = append(fields, notification.FieldApplicationStartDate)
	}
	if m._ApplicationEndDate != nil {
		fields = append(fields, notification.FieldApplicationEndDate)
	}
	if m._VerificationDateByController != nil {
		fields = append(fields, notification.FieldVerificationDateByController)
	}
	if m._CorrectionDateByCandidate != nil {
		fields = append(fields, notification.FieldCorrectionDateByCandidate)
	}
	if m._CorrectionVeriyDateByController != nil {
		fields = append(fields, notification.FieldCorrectionVeriyDateByController)
	}
	if m._HallTicketAllotmentDateByNodalOfficer != nil {
		fields = append(fields, notification.FieldHallTicketAllotmentDateByNodalOfficer)
	}
	if m._HallTicketDownloadDate != nil {
		fields = append(fields, notification.FieldHallTicketDownloadDate)
	}
	if m._NotifyFile != nil {
		fields = append(fields, notification.FieldNotifyFile)
	}
	if m._SyllabusFile != nil {
		fields = append(fields, notification.FieldSyllabusFile)
	}
	if m._VacanciesFile != nil {
		fields = append(fields, notification.FieldVacanciesFile)
	}
	if m._ExamCodePS != nil {
		fields = append(fields, notification.FieldExamCodePS)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldExamCode:
		return m.ExamCode()
	case notification.FieldExamYear:
		return m.ExamYear()
	case notification.FieldApplicationStartDate:
		return m.ApplicationStartDate()
	case notification.FieldApplicationEndDate:
		return m.ApplicationEndDate()
	case notification.FieldVerificationDateByController:
		return m.VerificationDateByController()
	case notification.FieldCorrectionDateByCandidate:
		return m.CorrectionDateByCandidate()
	case notification.FieldCorrectionVeriyDateByController:
		return m.CorrectionVeriyDateByController()
	case notification.FieldHallTicketAllotmentDateByNodalOfficer:
		return m.HallTicketAllotmentDateByNodalOfficer()
	case notification.FieldHallTicketDownloadDate:
		return m.HallTicketDownloadDate()
	case notification.FieldNotifyFile:
		return m.NotifyFile()
	case notification.FieldSyllabusFile:
		return m.SyllabusFile()
	case notification.FieldVacanciesFile:
		return m.VacanciesFile()
	case notification.FieldExamCodePS:
		return m.ExamCodePS()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldExamCode:
		return m.OldExamCode(ctx)
	case notification.FieldExamYear:
		return m.OldExamYear(ctx)
	case notification.FieldApplicationStartDate:
		return m.OldApplicationStartDate(ctx)
	case notification.FieldApplicationEndDate:
		return m.OldApplicationEndDate(ctx)
	case notification.FieldVerificationDateByController:
		return m.OldVerificationDateByController(ctx)
	case notification.FieldCorrectionDateByCandidate:
		return m.OldCorrectionDateByCandidate(ctx)
	case notification.FieldCorrectionVeriyDateByController:
		return m.OldCorrectionVeriyDateByController(ctx)
	case notification.FieldHallTicketAllotmentDateByNodalOfficer:
		return m.OldHallTicketAllotmentDateByNodalOfficer(ctx)
	case notification.FieldHallTicketDownloadDate:
		return m.OldHallTicketDownloadDate(ctx)
	case notification.FieldNotifyFile:
		return m.OldNotifyFile(ctx)
	case notification.FieldSyllabusFile:
		return m.OldSyllabusFile(ctx)
	case notification.FieldVacanciesFile:
		return m.OldVacanciesFile(ctx)
	case notification.FieldExamCodePS:
		return m.OldExamCodePS(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldExamCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCode(v)
		return nil
	case notification.FieldExamYear:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamYear(v)
		return nil
	case notification.FieldApplicationStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationStartDate(v)
		return nil
	case notification.FieldApplicationEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationEndDate(v)
		return nil
	case notification.FieldVerificationDateByController:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerificationDateByController(v)
		return nil
	case notification.FieldCorrectionDateByCandidate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrectionDateByCandidate(v)
		return nil
	case notification.FieldCorrectionVeriyDateByController:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrectionVeriyDateByController(v)
		return nil
	case notification.FieldHallTicketAllotmentDateByNodalOfficer:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHallTicketAllotmentDateByNodalOfficer(v)
		return nil
	case notification.FieldHallTicketDownloadDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHallTicketDownloadDate(v)
		return nil
	case notification.FieldNotifyFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyFile(v)
		return nil
	case notification.FieldSyllabusFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyllabusFile(v)
		return nil
	case notification.FieldVacanciesFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVacanciesFile(v)
		return nil
	case notification.FieldExamCodePS:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCodePS(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	var fields []string
	if m.add_ExamYear != nil {
		fields = append(fields, notification.FieldExamYear)
	}
	if m.add_ExamCodePS != nil {
		fields = append(fields, notification.FieldExamCodePS)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldExamYear:
		return m.AddedExamYear()
	case notification.FieldExamCodePS:
		return m.AddedExamCodePS()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notification.FieldExamYear:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamYear(v)
		return nil
	case notification.FieldExamCodePS:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamCodePS(v)
		return nil
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldExamCode) {
		fields = append(fields, notification.FieldExamCode)
	}
	if m.FieldCleared(notification.FieldHallTicketDownloadDate) {
		fields = append(fields, notification.FieldHallTicketDownloadDate)
	}
	if m.FieldCleared(notification.FieldNotifyFile) {
		fields = append(fields, notification.FieldNotifyFile)
	}
	if m.FieldCleared(notification.FieldSyllabusFile) {
		fields = append(fields, notification.FieldSyllabusFile)
	}
	if m.FieldCleared(notification.FieldVacanciesFile) {
		fields = append(fields, notification.FieldVacanciesFile)
	}
	if m.FieldCleared(notification.FieldExamCodePS) {
		fields = append(fields, notification.FieldExamCodePS)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldExamCode:
		m.ClearExamCode()
		return nil
	case notification.FieldHallTicketDownloadDate:
		m.ClearHallTicketDownloadDate()
		return nil
	case notification.FieldNotifyFile:
		m.ClearNotifyFile()
		return nil
	case notification.FieldSyllabusFile:
		m.ClearSyllabusFile()
		return nil
	case notification.FieldVacanciesFile:
		m.ClearVacanciesFile()
		return nil
	case notification.FieldExamCodePS:
		m.ClearExamCodePS()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldExamCode:
		m.ResetExamCode()
		return nil
	case notification.FieldExamYear:
		m.ResetExamYear()
		return nil
	case notification.FieldApplicationStartDate:
		m.ResetApplicationStartDate()
		return nil
	case notification.FieldApplicationEndDate:
		m.ResetApplicationEndDate()
		return nil
	case notification.FieldVerificationDateByController:
		m.ResetVerificationDateByController()
		return nil
	case notification.FieldCorrectionDateByCandidate:
		m.ResetCorrectionDateByCandidate()
		return nil
	case notification.FieldCorrectionVeriyDateByController:
		m.ResetCorrectionVeriyDateByController()
		return nil
	case notification.FieldHallTicketAllotmentDateByNodalOfficer:
		m.ResetHallTicketAllotmentDateByNodalOfficer()
		return nil
	case notification.FieldHallTicketDownloadDate:
		m.ResetHallTicketDownloadDate()
		return nil
	case notification.FieldNotifyFile:
		m.ResetNotifyFile()
		return nil
	case notification.FieldSyllabusFile:
		m.ResetSyllabusFile()
		return nil
	case notification.FieldVacanciesFile:
		m.ResetVacanciesFile()
		return nil
	case notification.FieldExamCodePS:
		m.ResetExamCodePS()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.applications != nil {
		edges = append(edges, notification.EdgeApplications)
	}
	if m.centers != nil {
		edges = append(edges, notification.EdgeCenters)
	}
	if m.nodal_officers != nil {
		edges = append(edges, notification.EdgeNodalOfficers)
	}
	if m.exam != nil {
		edges = append(edges, notification.EdgeExam)
	}
	if m.vacancy_years != nil {
		edges = append(edges, notification.EdgeVacancyYears)
	}
	if m.notify_ref != nil {
		edges = append(edges, notification.EdgeNotifyRef)
	}
	if m.notifications_ps != nil {
		edges = append(edges, notification.EdgeNotificationsPs)
	}
	if m.notifications_ip != nil {
		edges = append(edges, notification.EdgeNotificationsIP)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeCenters:
		ids := make([]ent.Value, 0, len(m.centers))
		for id := range m.centers {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeNodalOfficers:
		ids := make([]ent.Value, 0, len(m.nodal_officers))
		for id := range m.nodal_officers {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeExam:
		if id := m.exam; id != nil {
			return []ent.Value{*id}
		}
	case notification.EdgeVacancyYears:
		ids := make([]ent.Value, 0, len(m.vacancy_years))
		for id := range m.vacancy_years {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeNotifyRef:
		ids := make([]ent.Value, 0, len(m.notify_ref))
		for id := range m.notify_ref {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeNotificationsPs:
		ids := make([]ent.Value, 0, len(m.notifications_ps))
		for id := range m.notifications_ps {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeNotificationsIP:
		ids := make([]ent.Value, 0, len(m.notifications_ip))
		for id := range m.notifications_ip {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedapplications != nil {
		edges = append(edges, notification.EdgeApplications)
	}
	if m.removedcenters != nil {
		edges = append(edges, notification.EdgeCenters)
	}
	if m.removednodal_officers != nil {
		edges = append(edges, notification.EdgeNodalOfficers)
	}
	if m.removedvacancy_years != nil {
		edges = append(edges, notification.EdgeVacancyYears)
	}
	if m.removednotify_ref != nil {
		edges = append(edges, notification.EdgeNotifyRef)
	}
	if m.removednotifications_ps != nil {
		edges = append(edges, notification.EdgeNotificationsPs)
	}
	if m.removednotifications_ip != nil {
		edges = append(edges, notification.EdgeNotificationsIP)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeCenters:
		ids := make([]ent.Value, 0, len(m.removedcenters))
		for id := range m.removedcenters {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeNodalOfficers:
		ids := make([]ent.Value, 0, len(m.removednodal_officers))
		for id := range m.removednodal_officers {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeVacancyYears:
		ids := make([]ent.Value, 0, len(m.removedvacancy_years))
		for id := range m.removedvacancy_years {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeNotifyRef:
		ids := make([]ent.Value, 0, len(m.removednotify_ref))
		for id := range m.removednotify_ref {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeNotificationsPs:
		ids := make([]ent.Value, 0, len(m.removednotifications_ps))
		for id := range m.removednotifications_ps {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeNotificationsIP:
		ids := make([]ent.Value, 0, len(m.removednotifications_ip))
		for id := range m.removednotifications_ip {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedapplications {
		edges = append(edges, notification.EdgeApplications)
	}
	if m.clearedcenters {
		edges = append(edges, notification.EdgeCenters)
	}
	if m.clearednodal_officers {
		edges = append(edges, notification.EdgeNodalOfficers)
	}
	if m.clearedexam {
		edges = append(edges, notification.EdgeExam)
	}
	if m.clearedvacancy_years {
		edges = append(edges, notification.EdgeVacancyYears)
	}
	if m.clearednotify_ref {
		edges = append(edges, notification.EdgeNotifyRef)
	}
	if m.clearednotifications_ps {
		edges = append(edges, notification.EdgeNotificationsPs)
	}
	if m.clearednotifications_ip {
		edges = append(edges, notification.EdgeNotificationsIP)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case notification.EdgeApplications:
		return m.clearedapplications
	case notification.EdgeCenters:
		return m.clearedcenters
	case notification.EdgeNodalOfficers:
		return m.clearednodal_officers
	case notification.EdgeExam:
		return m.clearedexam
	case notification.EdgeVacancyYears:
		return m.clearedvacancy_years
	case notification.EdgeNotifyRef:
		return m.clearednotify_ref
	case notification.EdgeNotificationsPs:
		return m.clearednotifications_ps
	case notification.EdgeNotificationsIP:
		return m.clearednotifications_ip
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	switch name {
	case notification.EdgeExam:
		m.ClearExam()
		return nil
	}
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	switch name {
	case notification.EdgeApplications:
		m.ResetApplications()
		return nil
	case notification.EdgeCenters:
		m.ResetCenters()
		return nil
	case notification.EdgeNodalOfficers:
		m.ResetNodalOfficers()
		return nil
	case notification.EdgeExam:
		m.ResetExam()
		return nil
	case notification.EdgeVacancyYears:
		m.ResetVacancyYears()
		return nil
	case notification.EdgeNotifyRef:
		m.ResetNotifyRef()
		return nil
	case notification.EdgeNotificationsPs:
		m.ResetNotificationsPs()
		return nil
	case notification.EdgeNotificationsIP:
		m.ResetNotificationsIP()
		return nil
	}
	return fmt.Errorf("unknown Notification edge %s", name)
}

// PaperTypesMutation represents an operation that mutates the PaperTypes nodes in the graph.
type PaperTypesMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int32
	_PaperTypeDescription *string
	_OrderNumber          *string
	_SequenceNumber       *int32
	add_SequenceNumber    *int32
	_CreatedDate          *time.Time
	clearedFields         map[string]struct{}
	papercode             *int32
	clearedpapercode      bool
	done                  bool
	oldValue              func(context.Context) (*PaperTypes, error)
	predicates            []predicate.PaperTypes
}

var _ ent.Mutation = (*PaperTypesMutation)(nil)

// papertypesOption allows management of the mutation configuration using functional options.
type papertypesOption func(*PaperTypesMutation)

// newPaperTypesMutation creates new mutation for the PaperTypes entity.
func newPaperTypesMutation(c config, op Op, opts ...papertypesOption) *PaperTypesMutation {
	m := &PaperTypesMutation{
		config:        c,
		op:            op,
		typ:           TypePaperTypes,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaperTypesID sets the ID field of the mutation.
func withPaperTypesID(id int32) papertypesOption {
	return func(m *PaperTypesMutation) {
		var (
			err   error
			once  sync.Once
			value *PaperTypes
		)
		m.oldValue = func(ctx context.Context) (*PaperTypes, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaperTypes.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaperTypes sets the old PaperTypes of the mutation.
func withPaperTypes(node *PaperTypes) papertypesOption {
	return func(m *PaperTypesMutation) {
		m.oldValue = func(context.Context) (*PaperTypes, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaperTypesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaperTypesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaperTypes entities.
func (m *PaperTypesMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaperTypesMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaperTypesMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaperTypes.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPaperCode sets the "PaperCode" field.
func (m *PaperTypesMutation) SetPaperCode(i int32) {
	m.papercode = &i
}

// PaperCode returns the value of the "PaperCode" field in the mutation.
func (m *PaperTypesMutation) PaperCode() (r int32, exists bool) {
	v := m.papercode
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperCode returns the old "PaperCode" field's value of the PaperTypes entity.
// If the PaperTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaperTypesMutation) OldPaperCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperCode: %w", err)
	}
	return oldValue.PaperCode, nil
}

// ClearPaperCode clears the value of the "PaperCode" field.
func (m *PaperTypesMutation) ClearPaperCode() {
	m.papercode = nil
	m.clearedFields[papertypes.FieldPaperCode] = struct{}{}
}

// PaperCodeCleared returns if the "PaperCode" field was cleared in this mutation.
func (m *PaperTypesMutation) PaperCodeCleared() bool {
	_, ok := m.clearedFields[papertypes.FieldPaperCode]
	return ok
}

// ResetPaperCode resets all changes to the "PaperCode" field.
func (m *PaperTypesMutation) ResetPaperCode() {
	m.papercode = nil
	delete(m.clearedFields, papertypes.FieldPaperCode)
}

// SetPaperTypeDescription sets the "PaperTypeDescription" field.
func (m *PaperTypesMutation) SetPaperTypeDescription(s string) {
	m._PaperTypeDescription = &s
}

// PaperTypeDescription returns the value of the "PaperTypeDescription" field in the mutation.
func (m *PaperTypesMutation) PaperTypeDescription() (r string, exists bool) {
	v := m._PaperTypeDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperTypeDescription returns the old "PaperTypeDescription" field's value of the PaperTypes entity.
// If the PaperTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaperTypesMutation) OldPaperTypeDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperTypeDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperTypeDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperTypeDescription: %w", err)
	}
	return oldValue.PaperTypeDescription, nil
}

// ResetPaperTypeDescription resets all changes to the "PaperTypeDescription" field.
func (m *PaperTypesMutation) ResetPaperTypeDescription() {
	m._PaperTypeDescription = nil
}

// SetOrderNumber sets the "OrderNumber" field.
func (m *PaperTypesMutation) SetOrderNumber(s string) {
	m._OrderNumber = &s
}

// OrderNumber returns the value of the "OrderNumber" field in the mutation.
func (m *PaperTypesMutation) OrderNumber() (r string, exists bool) {
	v := m._OrderNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNumber returns the old "OrderNumber" field's value of the PaperTypes entity.
// If the PaperTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaperTypesMutation) OldOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNumber: %w", err)
	}
	return oldValue.OrderNumber, nil
}

// ResetOrderNumber resets all changes to the "OrderNumber" field.
func (m *PaperTypesMutation) ResetOrderNumber() {
	m._OrderNumber = nil
}

// SetSequenceNumber sets the "SequenceNumber" field.
func (m *PaperTypesMutation) SetSequenceNumber(i int32) {
	m._SequenceNumber = &i
	m.add_SequenceNumber = nil
}

// SequenceNumber returns the value of the "SequenceNumber" field in the mutation.
func (m *PaperTypesMutation) SequenceNumber() (r int32, exists bool) {
	v := m._SequenceNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceNumber returns the old "SequenceNumber" field's value of the PaperTypes entity.
// If the PaperTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaperTypesMutation) OldSequenceNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequenceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequenceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceNumber: %w", err)
	}
	return oldValue.SequenceNumber, nil
}

// AddSequenceNumber adds i to the "SequenceNumber" field.
func (m *PaperTypesMutation) AddSequenceNumber(i int32) {
	if m.add_SequenceNumber != nil {
		*m.add_SequenceNumber += i
	} else {
		m.add_SequenceNumber = &i
	}
}

// AddedSequenceNumber returns the value that was added to the "SequenceNumber" field in this mutation.
func (m *PaperTypesMutation) AddedSequenceNumber() (r int32, exists bool) {
	v := m.add_SequenceNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearSequenceNumber clears the value of the "SequenceNumber" field.
func (m *PaperTypesMutation) ClearSequenceNumber() {
	m._SequenceNumber = nil
	m.add_SequenceNumber = nil
	m.clearedFields[papertypes.FieldSequenceNumber] = struct{}{}
}

// SequenceNumberCleared returns if the "SequenceNumber" field was cleared in this mutation.
func (m *PaperTypesMutation) SequenceNumberCleared() bool {
	_, ok := m.clearedFields[papertypes.FieldSequenceNumber]
	return ok
}

// ResetSequenceNumber resets all changes to the "SequenceNumber" field.
func (m *PaperTypesMutation) ResetSequenceNumber() {
	m._SequenceNumber = nil
	m.add_SequenceNumber = nil
	delete(m.clearedFields, papertypes.FieldSequenceNumber)
}

// SetCreatedDate sets the "CreatedDate" field.
func (m *PaperTypesMutation) SetCreatedDate(t time.Time) {
	m._CreatedDate = &t
}

// CreatedDate returns the value of the "CreatedDate" field in the mutation.
func (m *PaperTypesMutation) CreatedDate() (r time.Time, exists bool) {
	v := m._CreatedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "CreatedDate" field's value of the PaperTypes entity.
// If the PaperTypes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaperTypesMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ClearCreatedDate clears the value of the "CreatedDate" field.
func (m *PaperTypesMutation) ClearCreatedDate() {
	m._CreatedDate = nil
	m.clearedFields[papertypes.FieldCreatedDate] = struct{}{}
}

// CreatedDateCleared returns if the "CreatedDate" field was cleared in this mutation.
func (m *PaperTypesMutation) CreatedDateCleared() bool {
	_, ok := m.clearedFields[papertypes.FieldCreatedDate]
	return ok
}

// ResetCreatedDate resets all changes to the "CreatedDate" field.
func (m *PaperTypesMutation) ResetCreatedDate() {
	m._CreatedDate = nil
	delete(m.clearedFields, papertypes.FieldCreatedDate)
}

// SetPapercodeID sets the "papercode" edge to the ExamPapers entity by id.
func (m *PaperTypesMutation) SetPapercodeID(id int32) {
	m.papercode = &id
}

// ClearPapercode clears the "papercode" edge to the ExamPapers entity.
func (m *PaperTypesMutation) ClearPapercode() {
	m.clearedpapercode = true
}

// PapercodeCleared reports if the "papercode" edge to the ExamPapers entity was cleared.
func (m *PaperTypesMutation) PapercodeCleared() bool {
	return m.PaperCodeCleared() || m.clearedpapercode
}

// PapercodeID returns the "papercode" edge ID in the mutation.
func (m *PaperTypesMutation) PapercodeID() (id int32, exists bool) {
	if m.papercode != nil {
		return *m.papercode, true
	}
	return
}

// PapercodeIDs returns the "papercode" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PapercodeID instead. It exists only for internal usage by the builders.
func (m *PaperTypesMutation) PapercodeIDs() (ids []int32) {
	if id := m.papercode; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPapercode resets all changes to the "papercode" edge.
func (m *PaperTypesMutation) ResetPapercode() {
	m.papercode = nil
	m.clearedpapercode = false
}

// Where appends a list predicates to the PaperTypesMutation builder.
func (m *PaperTypesMutation) Where(ps ...predicate.PaperTypes) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaperTypesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaperTypesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaperTypes, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaperTypesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaperTypesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaperTypes).
func (m *PaperTypesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaperTypesMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.papercode != nil {
		fields = append(fields, papertypes.FieldPaperCode)
	}
	if m._PaperTypeDescription != nil {
		fields = append(fields, papertypes.FieldPaperTypeDescription)
	}
	if m._OrderNumber != nil {
		fields = append(fields, papertypes.FieldOrderNumber)
	}
	if m._SequenceNumber != nil {
		fields = append(fields, papertypes.FieldSequenceNumber)
	}
	if m._CreatedDate != nil {
		fields = append(fields, papertypes.FieldCreatedDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaperTypesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case papertypes.FieldPaperCode:
		return m.PaperCode()
	case papertypes.FieldPaperTypeDescription:
		return m.PaperTypeDescription()
	case papertypes.FieldOrderNumber:
		return m.OrderNumber()
	case papertypes.FieldSequenceNumber:
		return m.SequenceNumber()
	case papertypes.FieldCreatedDate:
		return m.CreatedDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaperTypesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case papertypes.FieldPaperCode:
		return m.OldPaperCode(ctx)
	case papertypes.FieldPaperTypeDescription:
		return m.OldPaperTypeDescription(ctx)
	case papertypes.FieldOrderNumber:
		return m.OldOrderNumber(ctx)
	case papertypes.FieldSequenceNumber:
		return m.OldSequenceNumber(ctx)
	case papertypes.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	}
	return nil, fmt.Errorf("unknown PaperTypes field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaperTypesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case papertypes.FieldPaperCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperCode(v)
		return nil
	case papertypes.FieldPaperTypeDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperTypeDescription(v)
		return nil
	case papertypes.FieldOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNumber(v)
		return nil
	case papertypes.FieldSequenceNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceNumber(v)
		return nil
	case papertypes.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	}
	return fmt.Errorf("unknown PaperTypes field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaperTypesMutation) AddedFields() []string {
	var fields []string
	if m.add_SequenceNumber != nil {
		fields = append(fields, papertypes.FieldSequenceNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaperTypesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case papertypes.FieldSequenceNumber:
		return m.AddedSequenceNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaperTypesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case papertypes.FieldSequenceNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequenceNumber(v)
		return nil
	}
	return fmt.Errorf("unknown PaperTypes numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaperTypesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(papertypes.FieldPaperCode) {
		fields = append(fields, papertypes.FieldPaperCode)
	}
	if m.FieldCleared(papertypes.FieldSequenceNumber) {
		fields = append(fields, papertypes.FieldSequenceNumber)
	}
	if m.FieldCleared(papertypes.FieldCreatedDate) {
		fields = append(fields, papertypes.FieldCreatedDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaperTypesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaperTypesMutation) ClearField(name string) error {
	switch name {
	case papertypes.FieldPaperCode:
		m.ClearPaperCode()
		return nil
	case papertypes.FieldSequenceNumber:
		m.ClearSequenceNumber()
		return nil
	case papertypes.FieldCreatedDate:
		m.ClearCreatedDate()
		return nil
	}
	return fmt.Errorf("unknown PaperTypes nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaperTypesMutation) ResetField(name string) error {
	switch name {
	case papertypes.FieldPaperCode:
		m.ResetPaperCode()
		return nil
	case papertypes.FieldPaperTypeDescription:
		m.ResetPaperTypeDescription()
		return nil
	case papertypes.FieldOrderNumber:
		m.ResetOrderNumber()
		return nil
	case papertypes.FieldSequenceNumber:
		m.ResetSequenceNumber()
		return nil
	case papertypes.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	}
	return fmt.Errorf("unknown PaperTypes field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaperTypesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.papercode != nil {
		edges = append(edges, papertypes.EdgePapercode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaperTypesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case papertypes.EdgePapercode:
		if id := m.papercode; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaperTypesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaperTypesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaperTypesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpapercode {
		edges = append(edges, papertypes.EdgePapercode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaperTypesMutation) EdgeCleared(name string) bool {
	switch name {
	case papertypes.EdgePapercode:
		return m.clearedpapercode
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaperTypesMutation) ClearEdge(name string) error {
	switch name {
	case papertypes.EdgePapercode:
		m.ClearPapercode()
		return nil
	}
	return fmt.Errorf("unknown PaperTypes unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaperTypesMutation) ResetEdge(name string) error {
	switch name {
	case papertypes.EdgePapercode:
		m.ResetPapercode()
		return nil
	}
	return fmt.Errorf("unknown PaperTypes edge %s", name)
}

// PlaceOfPreferenceIPMutation represents an operation that mutates the PlaceOfPreferenceIP nodes in the graph.
type PlaceOfPreferenceIPMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int32
	_PlacePrefNo        *int32
	add_PlacePrefNo     *int32
	_PlacePrefValue     *string
	_EmployeeID         *int64
	add_EmployeeID      *int64
	_UpdatedAt          *time.Time
	_UpdatedBy          *string
	clearedFields       map[string]struct{}
	_ApplnIP_Ref        *int64
	cleared_ApplnIP_Ref bool
	done                bool
	oldValue            func(context.Context) (*PlaceOfPreferenceIP, error)
	predicates          []predicate.PlaceOfPreferenceIP
}

var _ ent.Mutation = (*PlaceOfPreferenceIPMutation)(nil)

// placeofpreferenceipOption allows management of the mutation configuration using functional options.
type placeofpreferenceipOption func(*PlaceOfPreferenceIPMutation)

// newPlaceOfPreferenceIPMutation creates new mutation for the PlaceOfPreferenceIP entity.
func newPlaceOfPreferenceIPMutation(c config, op Op, opts ...placeofpreferenceipOption) *PlaceOfPreferenceIPMutation {
	m := &PlaceOfPreferenceIPMutation{
		config:        c,
		op:            op,
		typ:           TypePlaceOfPreferenceIP,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaceOfPreferenceIPID sets the ID field of the mutation.
func withPlaceOfPreferenceIPID(id int32) placeofpreferenceipOption {
	return func(m *PlaceOfPreferenceIPMutation) {
		var (
			err   error
			once  sync.Once
			value *PlaceOfPreferenceIP
		)
		m.oldValue = func(ctx context.Context) (*PlaceOfPreferenceIP, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlaceOfPreferenceIP.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlaceOfPreferenceIP sets the old PlaceOfPreferenceIP of the mutation.
func withPlaceOfPreferenceIP(node *PlaceOfPreferenceIP) placeofpreferenceipOption {
	return func(m *PlaceOfPreferenceIPMutation) {
		m.oldValue = func(context.Context) (*PlaceOfPreferenceIP, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaceOfPreferenceIPMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaceOfPreferenceIPMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlaceOfPreferenceIP entities.
func (m *PlaceOfPreferenceIPMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaceOfPreferenceIPMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaceOfPreferenceIPMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlaceOfPreferenceIP.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApplicationID sets the "ApplicationID" field.
func (m *PlaceOfPreferenceIPMutation) SetApplicationID(i int64) {
	m._ApplnIP_Ref = &i
}

// ApplicationID returns the value of the "ApplicationID" field in the mutation.
func (m *PlaceOfPreferenceIPMutation) ApplicationID() (r int64, exists bool) {
	v := m._ApplnIP_Ref
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationID returns the old "ApplicationID" field's value of the PlaceOfPreferenceIP entity.
// If the PlaceOfPreferenceIP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceOfPreferenceIPMutation) OldApplicationID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationID: %w", err)
	}
	return oldValue.ApplicationID, nil
}

// ClearApplicationID clears the value of the "ApplicationID" field.
func (m *PlaceOfPreferenceIPMutation) ClearApplicationID() {
	m._ApplnIP_Ref = nil
	m.clearedFields[placeofpreferenceip.FieldApplicationID] = struct{}{}
}

// ApplicationIDCleared returns if the "ApplicationID" field was cleared in this mutation.
func (m *PlaceOfPreferenceIPMutation) ApplicationIDCleared() bool {
	_, ok := m.clearedFields[placeofpreferenceip.FieldApplicationID]
	return ok
}

// ResetApplicationID resets all changes to the "ApplicationID" field.
func (m *PlaceOfPreferenceIPMutation) ResetApplicationID() {
	m._ApplnIP_Ref = nil
	delete(m.clearedFields, placeofpreferenceip.FieldApplicationID)
}

// SetPlacePrefNo sets the "PlacePrefNo" field.
func (m *PlaceOfPreferenceIPMutation) SetPlacePrefNo(i int32) {
	m._PlacePrefNo = &i
	m.add_PlacePrefNo = nil
}

// PlacePrefNo returns the value of the "PlacePrefNo" field in the mutation.
func (m *PlaceOfPreferenceIPMutation) PlacePrefNo() (r int32, exists bool) {
	v := m._PlacePrefNo
	if v == nil {
		return
	}
	return *v, true
}

// OldPlacePrefNo returns the old "PlacePrefNo" field's value of the PlaceOfPreferenceIP entity.
// If the PlaceOfPreferenceIP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceOfPreferenceIPMutation) OldPlacePrefNo(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlacePrefNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlacePrefNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlacePrefNo: %w", err)
	}
	return oldValue.PlacePrefNo, nil
}

// AddPlacePrefNo adds i to the "PlacePrefNo" field.
func (m *PlaceOfPreferenceIPMutation) AddPlacePrefNo(i int32) {
	if m.add_PlacePrefNo != nil {
		*m.add_PlacePrefNo += i
	} else {
		m.add_PlacePrefNo = &i
	}
}

// AddedPlacePrefNo returns the value that was added to the "PlacePrefNo" field in this mutation.
func (m *PlaceOfPreferenceIPMutation) AddedPlacePrefNo() (r int32, exists bool) {
	v := m.add_PlacePrefNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearPlacePrefNo clears the value of the "PlacePrefNo" field.
func (m *PlaceOfPreferenceIPMutation) ClearPlacePrefNo() {
	m._PlacePrefNo = nil
	m.add_PlacePrefNo = nil
	m.clearedFields[placeofpreferenceip.FieldPlacePrefNo] = struct{}{}
}

// PlacePrefNoCleared returns if the "PlacePrefNo" field was cleared in this mutation.
func (m *PlaceOfPreferenceIPMutation) PlacePrefNoCleared() bool {
	_, ok := m.clearedFields[placeofpreferenceip.FieldPlacePrefNo]
	return ok
}

// ResetPlacePrefNo resets all changes to the "PlacePrefNo" field.
func (m *PlaceOfPreferenceIPMutation) ResetPlacePrefNo() {
	m._PlacePrefNo = nil
	m.add_PlacePrefNo = nil
	delete(m.clearedFields, placeofpreferenceip.FieldPlacePrefNo)
}

// SetPlacePrefValue sets the "PlacePrefValue" field.
func (m *PlaceOfPreferenceIPMutation) SetPlacePrefValue(s string) {
	m._PlacePrefValue = &s
}

// PlacePrefValue returns the value of the "PlacePrefValue" field in the mutation.
func (m *PlaceOfPreferenceIPMutation) PlacePrefValue() (r string, exists bool) {
	v := m._PlacePrefValue
	if v == nil {
		return
	}
	return *v, true
}

// OldPlacePrefValue returns the old "PlacePrefValue" field's value of the PlaceOfPreferenceIP entity.
// If the PlaceOfPreferenceIP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceOfPreferenceIPMutation) OldPlacePrefValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlacePrefValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlacePrefValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlacePrefValue: %w", err)
	}
	return oldValue.PlacePrefValue, nil
}

// ClearPlacePrefValue clears the value of the "PlacePrefValue" field.
func (m *PlaceOfPreferenceIPMutation) ClearPlacePrefValue() {
	m._PlacePrefValue = nil
	m.clearedFields[placeofpreferenceip.FieldPlacePrefValue] = struct{}{}
}

// PlacePrefValueCleared returns if the "PlacePrefValue" field was cleared in this mutation.
func (m *PlaceOfPreferenceIPMutation) PlacePrefValueCleared() bool {
	_, ok := m.clearedFields[placeofpreferenceip.FieldPlacePrefValue]
	return ok
}

// ResetPlacePrefValue resets all changes to the "PlacePrefValue" field.
func (m *PlaceOfPreferenceIPMutation) ResetPlacePrefValue() {
	m._PlacePrefValue = nil
	delete(m.clearedFields, placeofpreferenceip.FieldPlacePrefValue)
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *PlaceOfPreferenceIPMutation) SetEmployeeID(i int64) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *PlaceOfPreferenceIPMutation) EmployeeID() (r int64, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the PlaceOfPreferenceIP entity.
// If the PlaceOfPreferenceIP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceOfPreferenceIPMutation) OldEmployeeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *PlaceOfPreferenceIPMutation) AddEmployeeID(i int64) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *PlaceOfPreferenceIPMutation) AddedEmployeeID() (r int64, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeeID clears the value of the "EmployeeID" field.
func (m *PlaceOfPreferenceIPMutation) ClearEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	m.clearedFields[placeofpreferenceip.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "EmployeeID" field was cleared in this mutation.
func (m *PlaceOfPreferenceIPMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[placeofpreferenceip.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *PlaceOfPreferenceIPMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	delete(m.clearedFields, placeofpreferenceip.FieldEmployeeID)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *PlaceOfPreferenceIPMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *PlaceOfPreferenceIPMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the PlaceOfPreferenceIP entity.
// If the PlaceOfPreferenceIP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceOfPreferenceIPMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *PlaceOfPreferenceIPMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[placeofpreferenceip.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *PlaceOfPreferenceIPMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[placeofpreferenceip.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *PlaceOfPreferenceIPMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, placeofpreferenceip.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *PlaceOfPreferenceIPMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *PlaceOfPreferenceIPMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the PlaceOfPreferenceIP entity.
// If the PlaceOfPreferenceIP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceOfPreferenceIPMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *PlaceOfPreferenceIPMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[placeofpreferenceip.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *PlaceOfPreferenceIPMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[placeofpreferenceip.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *PlaceOfPreferenceIPMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, placeofpreferenceip.FieldUpdatedBy)
}

// SetApplnIPRefID sets the "ApplnIP_Ref" edge to the Exam_Applications_IP entity by id.
func (m *PlaceOfPreferenceIPMutation) SetApplnIPRefID(id int64) {
	m._ApplnIP_Ref = &id
}

// ClearApplnIPRef clears the "ApplnIP_Ref" edge to the Exam_Applications_IP entity.
func (m *PlaceOfPreferenceIPMutation) ClearApplnIPRef() {
	m.cleared_ApplnIP_Ref = true
}

// ApplnIPRefCleared reports if the "ApplnIP_Ref" edge to the Exam_Applications_IP entity was cleared.
func (m *PlaceOfPreferenceIPMutation) ApplnIPRefCleared() bool {
	return m.ApplicationIDCleared() || m.cleared_ApplnIP_Ref
}

// ApplnIPRefID returns the "ApplnIP_Ref" edge ID in the mutation.
func (m *PlaceOfPreferenceIPMutation) ApplnIPRefID() (id int64, exists bool) {
	if m._ApplnIP_Ref != nil {
		return *m._ApplnIP_Ref, true
	}
	return
}

// ApplnIPRefIDs returns the "ApplnIP_Ref" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplnIPRefID instead. It exists only for internal usage by the builders.
func (m *PlaceOfPreferenceIPMutation) ApplnIPRefIDs() (ids []int64) {
	if id := m._ApplnIP_Ref; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplnIPRef resets all changes to the "ApplnIP_Ref" edge.
func (m *PlaceOfPreferenceIPMutation) ResetApplnIPRef() {
	m._ApplnIP_Ref = nil
	m.cleared_ApplnIP_Ref = false
}

// Where appends a list predicates to the PlaceOfPreferenceIPMutation builder.
func (m *PlaceOfPreferenceIPMutation) Where(ps ...predicate.PlaceOfPreferenceIP) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaceOfPreferenceIPMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaceOfPreferenceIPMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlaceOfPreferenceIP, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaceOfPreferenceIPMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaceOfPreferenceIPMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlaceOfPreferenceIP).
func (m *PlaceOfPreferenceIPMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaceOfPreferenceIPMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._ApplnIP_Ref != nil {
		fields = append(fields, placeofpreferenceip.FieldApplicationID)
	}
	if m._PlacePrefNo != nil {
		fields = append(fields, placeofpreferenceip.FieldPlacePrefNo)
	}
	if m._PlacePrefValue != nil {
		fields = append(fields, placeofpreferenceip.FieldPlacePrefValue)
	}
	if m._EmployeeID != nil {
		fields = append(fields, placeofpreferenceip.FieldEmployeeID)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, placeofpreferenceip.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, placeofpreferenceip.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaceOfPreferenceIPMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case placeofpreferenceip.FieldApplicationID:
		return m.ApplicationID()
	case placeofpreferenceip.FieldPlacePrefNo:
		return m.PlacePrefNo()
	case placeofpreferenceip.FieldPlacePrefValue:
		return m.PlacePrefValue()
	case placeofpreferenceip.FieldEmployeeID:
		return m.EmployeeID()
	case placeofpreferenceip.FieldUpdatedAt:
		return m.UpdatedAt()
	case placeofpreferenceip.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaceOfPreferenceIPMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case placeofpreferenceip.FieldApplicationID:
		return m.OldApplicationID(ctx)
	case placeofpreferenceip.FieldPlacePrefNo:
		return m.OldPlacePrefNo(ctx)
	case placeofpreferenceip.FieldPlacePrefValue:
		return m.OldPlacePrefValue(ctx)
	case placeofpreferenceip.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case placeofpreferenceip.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case placeofpreferenceip.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown PlaceOfPreferenceIP field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceOfPreferenceIPMutation) SetField(name string, value ent.Value) error {
	switch name {
	case placeofpreferenceip.FieldApplicationID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationID(v)
		return nil
	case placeofpreferenceip.FieldPlacePrefNo:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlacePrefNo(v)
		return nil
	case placeofpreferenceip.FieldPlacePrefValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlacePrefValue(v)
		return nil
	case placeofpreferenceip.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case placeofpreferenceip.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case placeofpreferenceip.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown PlaceOfPreferenceIP field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaceOfPreferenceIPMutation) AddedFields() []string {
	var fields []string
	if m.add_PlacePrefNo != nil {
		fields = append(fields, placeofpreferenceip.FieldPlacePrefNo)
	}
	if m.add_EmployeeID != nil {
		fields = append(fields, placeofpreferenceip.FieldEmployeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaceOfPreferenceIPMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case placeofpreferenceip.FieldPlacePrefNo:
		return m.AddedPlacePrefNo()
	case placeofpreferenceip.FieldEmployeeID:
		return m.AddedEmployeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceOfPreferenceIPMutation) AddField(name string, value ent.Value) error {
	switch name {
	case placeofpreferenceip.FieldPlacePrefNo:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlacePrefNo(v)
		return nil
	case placeofpreferenceip.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown PlaceOfPreferenceIP numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaceOfPreferenceIPMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(placeofpreferenceip.FieldApplicationID) {
		fields = append(fields, placeofpreferenceip.FieldApplicationID)
	}
	if m.FieldCleared(placeofpreferenceip.FieldPlacePrefNo) {
		fields = append(fields, placeofpreferenceip.FieldPlacePrefNo)
	}
	if m.FieldCleared(placeofpreferenceip.FieldPlacePrefValue) {
		fields = append(fields, placeofpreferenceip.FieldPlacePrefValue)
	}
	if m.FieldCleared(placeofpreferenceip.FieldEmployeeID) {
		fields = append(fields, placeofpreferenceip.FieldEmployeeID)
	}
	if m.FieldCleared(placeofpreferenceip.FieldUpdatedAt) {
		fields = append(fields, placeofpreferenceip.FieldUpdatedAt)
	}
	if m.FieldCleared(placeofpreferenceip.FieldUpdatedBy) {
		fields = append(fields, placeofpreferenceip.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaceOfPreferenceIPMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaceOfPreferenceIPMutation) ClearField(name string) error {
	switch name {
	case placeofpreferenceip.FieldApplicationID:
		m.ClearApplicationID()
		return nil
	case placeofpreferenceip.FieldPlacePrefNo:
		m.ClearPlacePrefNo()
		return nil
	case placeofpreferenceip.FieldPlacePrefValue:
		m.ClearPlacePrefValue()
		return nil
	case placeofpreferenceip.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case placeofpreferenceip.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case placeofpreferenceip.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown PlaceOfPreferenceIP nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaceOfPreferenceIPMutation) ResetField(name string) error {
	switch name {
	case placeofpreferenceip.FieldApplicationID:
		m.ResetApplicationID()
		return nil
	case placeofpreferenceip.FieldPlacePrefNo:
		m.ResetPlacePrefNo()
		return nil
	case placeofpreferenceip.FieldPlacePrefValue:
		m.ResetPlacePrefValue()
		return nil
	case placeofpreferenceip.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case placeofpreferenceip.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case placeofpreferenceip.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown PlaceOfPreferenceIP field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaceOfPreferenceIPMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._ApplnIP_Ref != nil {
		edges = append(edges, placeofpreferenceip.EdgeApplnIPRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaceOfPreferenceIPMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case placeofpreferenceip.EdgeApplnIPRef:
		if id := m._ApplnIP_Ref; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaceOfPreferenceIPMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaceOfPreferenceIPMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaceOfPreferenceIPMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_ApplnIP_Ref {
		edges = append(edges, placeofpreferenceip.EdgeApplnIPRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaceOfPreferenceIPMutation) EdgeCleared(name string) bool {
	switch name {
	case placeofpreferenceip.EdgeApplnIPRef:
		return m.cleared_ApplnIP_Ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaceOfPreferenceIPMutation) ClearEdge(name string) error {
	switch name {
	case placeofpreferenceip.EdgeApplnIPRef:
		m.ClearApplnIPRef()
		return nil
	}
	return fmt.Errorf("unknown PlaceOfPreferenceIP unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaceOfPreferenceIPMutation) ResetEdge(name string) error {
	switch name {
	case placeofpreferenceip.EdgeApplnIPRef:
		m.ResetApplnIPRef()
		return nil
	}
	return fmt.Errorf("unknown PlaceOfPreferenceIP edge %s", name)
}

// RecommendationsIPApplicationsMutation represents an operation that mutates the RecommendationsIPApplications nodes in the graph.
type RecommendationsIPApplicationsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	_EmployeeID         *int64
	add_EmployeeID      *int64
	_ExamNameCode       *string
	_ExamYear           *string
	_VacancyYear        *int32
	add_VacancyYear     *int32
	_CA_Recommendations *string
	_CA_UpdatedAt       *string
	_CA_UserName        *string
	_CA_Remarks         *string
	_NO_Recommendations *string
	_NO_UpdatedAt       *string
	_NO_UserName        *string
	_NO_Remarks         *string
	_ApplicationStatus  *string
	_UpdatedAt          *time.Time
	_UpdatedBy          *string
	clearedFields       map[string]struct{}
	_ApplnRef           *int64
	cleared_ApplnRef    bool
	done                bool
	oldValue            func(context.Context) (*RecommendationsIPApplications, error)
	predicates          []predicate.RecommendationsIPApplications
}

var _ ent.Mutation = (*RecommendationsIPApplicationsMutation)(nil)

// recommendationsipapplicationsOption allows management of the mutation configuration using functional options.
type recommendationsipapplicationsOption func(*RecommendationsIPApplicationsMutation)

// newRecommendationsIPApplicationsMutation creates new mutation for the RecommendationsIPApplications entity.
func newRecommendationsIPApplicationsMutation(c config, op Op, opts ...recommendationsipapplicationsOption) *RecommendationsIPApplicationsMutation {
	m := &RecommendationsIPApplicationsMutation{
		config:        c,
		op:            op,
		typ:           TypeRecommendationsIPApplications,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecommendationsIPApplicationsID sets the ID field of the mutation.
func withRecommendationsIPApplicationsID(id int64) recommendationsipapplicationsOption {
	return func(m *RecommendationsIPApplicationsMutation) {
		var (
			err   error
			once  sync.Once
			value *RecommendationsIPApplications
		)
		m.oldValue = func(ctx context.Context) (*RecommendationsIPApplications, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecommendationsIPApplications.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecommendationsIPApplications sets the old RecommendationsIPApplications of the mutation.
func withRecommendationsIPApplications(node *RecommendationsIPApplications) recommendationsipapplicationsOption {
	return func(m *RecommendationsIPApplicationsMutation) {
		m.oldValue = func(context.Context) (*RecommendationsIPApplications, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecommendationsIPApplicationsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecommendationsIPApplicationsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RecommendationsIPApplications entities.
func (m *RecommendationsIPApplicationsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecommendationsIPApplicationsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecommendationsIPApplicationsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RecommendationsIPApplications.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApplicationID sets the "ApplicationID" field.
func (m *RecommendationsIPApplicationsMutation) SetApplicationID(i int64) {
	m._ApplnRef = &i
}

// ApplicationID returns the value of the "ApplicationID" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) ApplicationID() (r int64, exists bool) {
	v := m._ApplnRef
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationID returns the old "ApplicationID" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldApplicationID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationID: %w", err)
	}
	return oldValue.ApplicationID, nil
}

// ClearApplicationID clears the value of the "ApplicationID" field.
func (m *RecommendationsIPApplicationsMutation) ClearApplicationID() {
	m._ApplnRef = nil
	m.clearedFields[recommendationsipapplications.FieldApplicationID] = struct{}{}
}

// ApplicationIDCleared returns if the "ApplicationID" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) ApplicationIDCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldApplicationID]
	return ok
}

// ResetApplicationID resets all changes to the "ApplicationID" field.
func (m *RecommendationsIPApplicationsMutation) ResetApplicationID() {
	m._ApplnRef = nil
	delete(m.clearedFields, recommendationsipapplications.FieldApplicationID)
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *RecommendationsIPApplicationsMutation) SetEmployeeID(i int64) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) EmployeeID() (r int64, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldEmployeeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *RecommendationsIPApplicationsMutation) AddEmployeeID(i int64) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *RecommendationsIPApplicationsMutation) AddedEmployeeID() (r int64, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeeID clears the value of the "EmployeeID" field.
func (m *RecommendationsIPApplicationsMutation) ClearEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	m.clearedFields[recommendationsipapplications.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "EmployeeID" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *RecommendationsIPApplicationsMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	delete(m.clearedFields, recommendationsipapplications.FieldEmployeeID)
}

// SetExamNameCode sets the "ExamNameCode" field.
func (m *RecommendationsIPApplicationsMutation) SetExamNameCode(s string) {
	m._ExamNameCode = &s
}

// ExamNameCode returns the value of the "ExamNameCode" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) ExamNameCode() (r string, exists bool) {
	v := m._ExamNameCode
	if v == nil {
		return
	}
	return *v, true
}

// OldExamNameCode returns the old "ExamNameCode" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldExamNameCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamNameCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamNameCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamNameCode: %w", err)
	}
	return oldValue.ExamNameCode, nil
}

// ClearExamNameCode clears the value of the "ExamNameCode" field.
func (m *RecommendationsIPApplicationsMutation) ClearExamNameCode() {
	m._ExamNameCode = nil
	m.clearedFields[recommendationsipapplications.FieldExamNameCode] = struct{}{}
}

// ExamNameCodeCleared returns if the "ExamNameCode" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) ExamNameCodeCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldExamNameCode]
	return ok
}

// ResetExamNameCode resets all changes to the "ExamNameCode" field.
func (m *RecommendationsIPApplicationsMutation) ResetExamNameCode() {
	m._ExamNameCode = nil
	delete(m.clearedFields, recommendationsipapplications.FieldExamNameCode)
}

// SetExamYear sets the "ExamYear" field.
func (m *RecommendationsIPApplicationsMutation) SetExamYear(s string) {
	m._ExamYear = &s
}

// ExamYear returns the value of the "ExamYear" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) ExamYear() (r string, exists bool) {
	v := m._ExamYear
	if v == nil {
		return
	}
	return *v, true
}

// OldExamYear returns the old "ExamYear" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldExamYear(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamYear: %w", err)
	}
	return oldValue.ExamYear, nil
}

// ClearExamYear clears the value of the "ExamYear" field.
func (m *RecommendationsIPApplicationsMutation) ClearExamYear() {
	m._ExamYear = nil
	m.clearedFields[recommendationsipapplications.FieldExamYear] = struct{}{}
}

// ExamYearCleared returns if the "ExamYear" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) ExamYearCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldExamYear]
	return ok
}

// ResetExamYear resets all changes to the "ExamYear" field.
func (m *RecommendationsIPApplicationsMutation) ResetExamYear() {
	m._ExamYear = nil
	delete(m.clearedFields, recommendationsipapplications.FieldExamYear)
}

// SetVacancyYear sets the "VacancyYear" field.
func (m *RecommendationsIPApplicationsMutation) SetVacancyYear(i int32) {
	m._VacancyYear = &i
	m.add_VacancyYear = nil
}

// VacancyYear returns the value of the "VacancyYear" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) VacancyYear() (r int32, exists bool) {
	v := m._VacancyYear
	if v == nil {
		return
	}
	return *v, true
}

// OldVacancyYear returns the old "VacancyYear" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldVacancyYear(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVacancyYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVacancyYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVacancyYear: %w", err)
	}
	return oldValue.VacancyYear, nil
}

// AddVacancyYear adds i to the "VacancyYear" field.
func (m *RecommendationsIPApplicationsMutation) AddVacancyYear(i int32) {
	if m.add_VacancyYear != nil {
		*m.add_VacancyYear += i
	} else {
		m.add_VacancyYear = &i
	}
}

// AddedVacancyYear returns the value that was added to the "VacancyYear" field in this mutation.
func (m *RecommendationsIPApplicationsMutation) AddedVacancyYear() (r int32, exists bool) {
	v := m.add_VacancyYear
	if v == nil {
		return
	}
	return *v, true
}

// ClearVacancyYear clears the value of the "VacancyYear" field.
func (m *RecommendationsIPApplicationsMutation) ClearVacancyYear() {
	m._VacancyYear = nil
	m.add_VacancyYear = nil
	m.clearedFields[recommendationsipapplications.FieldVacancyYear] = struct{}{}
}

// VacancyYearCleared returns if the "VacancyYear" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) VacancyYearCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldVacancyYear]
	return ok
}

// ResetVacancyYear resets all changes to the "VacancyYear" field.
func (m *RecommendationsIPApplicationsMutation) ResetVacancyYear() {
	m._VacancyYear = nil
	m.add_VacancyYear = nil
	delete(m.clearedFields, recommendationsipapplications.FieldVacancyYear)
}

// SetCARecommendations sets the "CA_Recommendations" field.
func (m *RecommendationsIPApplicationsMutation) SetCARecommendations(s string) {
	m._CA_Recommendations = &s
}

// CARecommendations returns the value of the "CA_Recommendations" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) CARecommendations() (r string, exists bool) {
	v := m._CA_Recommendations
	if v == nil {
		return
	}
	return *v, true
}

// OldCARecommendations returns the old "CA_Recommendations" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldCARecommendations(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCARecommendations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCARecommendations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCARecommendations: %w", err)
	}
	return oldValue.CARecommendations, nil
}

// ClearCARecommendations clears the value of the "CA_Recommendations" field.
func (m *RecommendationsIPApplicationsMutation) ClearCARecommendations() {
	m._CA_Recommendations = nil
	m.clearedFields[recommendationsipapplications.FieldCARecommendations] = struct{}{}
}

// CARecommendationsCleared returns if the "CA_Recommendations" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) CARecommendationsCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldCARecommendations]
	return ok
}

// ResetCARecommendations resets all changes to the "CA_Recommendations" field.
func (m *RecommendationsIPApplicationsMutation) ResetCARecommendations() {
	m._CA_Recommendations = nil
	delete(m.clearedFields, recommendationsipapplications.FieldCARecommendations)
}

// SetCAUpdatedAt sets the "CA_UpdatedAt" field.
func (m *RecommendationsIPApplicationsMutation) SetCAUpdatedAt(s string) {
	m._CA_UpdatedAt = &s
}

// CAUpdatedAt returns the value of the "CA_UpdatedAt" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) CAUpdatedAt() (r string, exists bool) {
	v := m._CA_UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCAUpdatedAt returns the old "CA_UpdatedAt" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldCAUpdatedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCAUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCAUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCAUpdatedAt: %w", err)
	}
	return oldValue.CAUpdatedAt, nil
}

// ClearCAUpdatedAt clears the value of the "CA_UpdatedAt" field.
func (m *RecommendationsIPApplicationsMutation) ClearCAUpdatedAt() {
	m._CA_UpdatedAt = nil
	m.clearedFields[recommendationsipapplications.FieldCAUpdatedAt] = struct{}{}
}

// CAUpdatedAtCleared returns if the "CA_UpdatedAt" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) CAUpdatedAtCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldCAUpdatedAt]
	return ok
}

// ResetCAUpdatedAt resets all changes to the "CA_UpdatedAt" field.
func (m *RecommendationsIPApplicationsMutation) ResetCAUpdatedAt() {
	m._CA_UpdatedAt = nil
	delete(m.clearedFields, recommendationsipapplications.FieldCAUpdatedAt)
}

// SetCAUserName sets the "CA_UserName" field.
func (m *RecommendationsIPApplicationsMutation) SetCAUserName(s string) {
	m._CA_UserName = &s
}

// CAUserName returns the value of the "CA_UserName" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) CAUserName() (r string, exists bool) {
	v := m._CA_UserName
	if v == nil {
		return
	}
	return *v, true
}

// OldCAUserName returns the old "CA_UserName" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldCAUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCAUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCAUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCAUserName: %w", err)
	}
	return oldValue.CAUserName, nil
}

// ClearCAUserName clears the value of the "CA_UserName" field.
func (m *RecommendationsIPApplicationsMutation) ClearCAUserName() {
	m._CA_UserName = nil
	m.clearedFields[recommendationsipapplications.FieldCAUserName] = struct{}{}
}

// CAUserNameCleared returns if the "CA_UserName" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) CAUserNameCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldCAUserName]
	return ok
}

// ResetCAUserName resets all changes to the "CA_UserName" field.
func (m *RecommendationsIPApplicationsMutation) ResetCAUserName() {
	m._CA_UserName = nil
	delete(m.clearedFields, recommendationsipapplications.FieldCAUserName)
}

// SetCARemarks sets the "CA_Remarks" field.
func (m *RecommendationsIPApplicationsMutation) SetCARemarks(s string) {
	m._CA_Remarks = &s
}

// CARemarks returns the value of the "CA_Remarks" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) CARemarks() (r string, exists bool) {
	v := m._CA_Remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldCARemarks returns the old "CA_Remarks" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldCARemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCARemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCARemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCARemarks: %w", err)
	}
	return oldValue.CARemarks, nil
}

// ClearCARemarks clears the value of the "CA_Remarks" field.
func (m *RecommendationsIPApplicationsMutation) ClearCARemarks() {
	m._CA_Remarks = nil
	m.clearedFields[recommendationsipapplications.FieldCARemarks] = struct{}{}
}

// CARemarksCleared returns if the "CA_Remarks" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) CARemarksCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldCARemarks]
	return ok
}

// ResetCARemarks resets all changes to the "CA_Remarks" field.
func (m *RecommendationsIPApplicationsMutation) ResetCARemarks() {
	m._CA_Remarks = nil
	delete(m.clearedFields, recommendationsipapplications.FieldCARemarks)
}

// SetNORecommendations sets the "NO_Recommendations" field.
func (m *RecommendationsIPApplicationsMutation) SetNORecommendations(s string) {
	m._NO_Recommendations = &s
}

// NORecommendations returns the value of the "NO_Recommendations" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) NORecommendations() (r string, exists bool) {
	v := m._NO_Recommendations
	if v == nil {
		return
	}
	return *v, true
}

// OldNORecommendations returns the old "NO_Recommendations" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldNORecommendations(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNORecommendations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNORecommendations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNORecommendations: %w", err)
	}
	return oldValue.NORecommendations, nil
}

// ClearNORecommendations clears the value of the "NO_Recommendations" field.
func (m *RecommendationsIPApplicationsMutation) ClearNORecommendations() {
	m._NO_Recommendations = nil
	m.clearedFields[recommendationsipapplications.FieldNORecommendations] = struct{}{}
}

// NORecommendationsCleared returns if the "NO_Recommendations" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) NORecommendationsCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldNORecommendations]
	return ok
}

// ResetNORecommendations resets all changes to the "NO_Recommendations" field.
func (m *RecommendationsIPApplicationsMutation) ResetNORecommendations() {
	m._NO_Recommendations = nil
	delete(m.clearedFields, recommendationsipapplications.FieldNORecommendations)
}

// SetNOUpdatedAt sets the "NO_UpdatedAt" field.
func (m *RecommendationsIPApplicationsMutation) SetNOUpdatedAt(s string) {
	m._NO_UpdatedAt = &s
}

// NOUpdatedAt returns the value of the "NO_UpdatedAt" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) NOUpdatedAt() (r string, exists bool) {
	v := m._NO_UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldNOUpdatedAt returns the old "NO_UpdatedAt" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldNOUpdatedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNOUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNOUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNOUpdatedAt: %w", err)
	}
	return oldValue.NOUpdatedAt, nil
}

// ClearNOUpdatedAt clears the value of the "NO_UpdatedAt" field.
func (m *RecommendationsIPApplicationsMutation) ClearNOUpdatedAt() {
	m._NO_UpdatedAt = nil
	m.clearedFields[recommendationsipapplications.FieldNOUpdatedAt] = struct{}{}
}

// NOUpdatedAtCleared returns if the "NO_UpdatedAt" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) NOUpdatedAtCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldNOUpdatedAt]
	return ok
}

// ResetNOUpdatedAt resets all changes to the "NO_UpdatedAt" field.
func (m *RecommendationsIPApplicationsMutation) ResetNOUpdatedAt() {
	m._NO_UpdatedAt = nil
	delete(m.clearedFields, recommendationsipapplications.FieldNOUpdatedAt)
}

// SetNOUserName sets the "NO_UserName" field.
func (m *RecommendationsIPApplicationsMutation) SetNOUserName(s string) {
	m._NO_UserName = &s
}

// NOUserName returns the value of the "NO_UserName" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) NOUserName() (r string, exists bool) {
	v := m._NO_UserName
	if v == nil {
		return
	}
	return *v, true
}

// OldNOUserName returns the old "NO_UserName" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldNOUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNOUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNOUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNOUserName: %w", err)
	}
	return oldValue.NOUserName, nil
}

// ClearNOUserName clears the value of the "NO_UserName" field.
func (m *RecommendationsIPApplicationsMutation) ClearNOUserName() {
	m._NO_UserName = nil
	m.clearedFields[recommendationsipapplications.FieldNOUserName] = struct{}{}
}

// NOUserNameCleared returns if the "NO_UserName" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) NOUserNameCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldNOUserName]
	return ok
}

// ResetNOUserName resets all changes to the "NO_UserName" field.
func (m *RecommendationsIPApplicationsMutation) ResetNOUserName() {
	m._NO_UserName = nil
	delete(m.clearedFields, recommendationsipapplications.FieldNOUserName)
}

// SetNORemarks sets the "NO_Remarks" field.
func (m *RecommendationsIPApplicationsMutation) SetNORemarks(s string) {
	m._NO_Remarks = &s
}

// NORemarks returns the value of the "NO_Remarks" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) NORemarks() (r string, exists bool) {
	v := m._NO_Remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldNORemarks returns the old "NO_Remarks" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldNORemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNORemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNORemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNORemarks: %w", err)
	}
	return oldValue.NORemarks, nil
}

// ClearNORemarks clears the value of the "NO_Remarks" field.
func (m *RecommendationsIPApplicationsMutation) ClearNORemarks() {
	m._NO_Remarks = nil
	m.clearedFields[recommendationsipapplications.FieldNORemarks] = struct{}{}
}

// NORemarksCleared returns if the "NO_Remarks" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) NORemarksCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldNORemarks]
	return ok
}

// ResetNORemarks resets all changes to the "NO_Remarks" field.
func (m *RecommendationsIPApplicationsMutation) ResetNORemarks() {
	m._NO_Remarks = nil
	delete(m.clearedFields, recommendationsipapplications.FieldNORemarks)
}

// SetApplicationStatus sets the "ApplicationStatus" field.
func (m *RecommendationsIPApplicationsMutation) SetApplicationStatus(s string) {
	m._ApplicationStatus = &s
}

// ApplicationStatus returns the value of the "ApplicationStatus" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) ApplicationStatus() (r string, exists bool) {
	v := m._ApplicationStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationStatus returns the old "ApplicationStatus" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldApplicationStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationStatus: %w", err)
	}
	return oldValue.ApplicationStatus, nil
}

// ClearApplicationStatus clears the value of the "ApplicationStatus" field.
func (m *RecommendationsIPApplicationsMutation) ClearApplicationStatus() {
	m._ApplicationStatus = nil
	m.clearedFields[recommendationsipapplications.FieldApplicationStatus] = struct{}{}
}

// ApplicationStatusCleared returns if the "ApplicationStatus" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) ApplicationStatusCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldApplicationStatus]
	return ok
}

// ResetApplicationStatus resets all changes to the "ApplicationStatus" field.
func (m *RecommendationsIPApplicationsMutation) ResetApplicationStatus() {
	m._ApplicationStatus = nil
	delete(m.clearedFields, recommendationsipapplications.FieldApplicationStatus)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *RecommendationsIPApplicationsMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *RecommendationsIPApplicationsMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[recommendationsipapplications.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *RecommendationsIPApplicationsMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, recommendationsipapplications.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *RecommendationsIPApplicationsMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *RecommendationsIPApplicationsMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the RecommendationsIPApplications entity.
// If the RecommendationsIPApplications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendationsIPApplicationsMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *RecommendationsIPApplicationsMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[recommendationsipapplications.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[recommendationsipapplications.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *RecommendationsIPApplicationsMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, recommendationsipapplications.FieldUpdatedBy)
}

// SetApplnRefID sets the "ApplnRef" edge to the Exam_Applications_IP entity by id.
func (m *RecommendationsIPApplicationsMutation) SetApplnRefID(id int64) {
	m._ApplnRef = &id
}

// ClearApplnRef clears the "ApplnRef" edge to the Exam_Applications_IP entity.
func (m *RecommendationsIPApplicationsMutation) ClearApplnRef() {
	m.cleared_ApplnRef = true
}

// ApplnRefCleared reports if the "ApplnRef" edge to the Exam_Applications_IP entity was cleared.
func (m *RecommendationsIPApplicationsMutation) ApplnRefCleared() bool {
	return m.ApplicationIDCleared() || m.cleared_ApplnRef
}

// ApplnRefID returns the "ApplnRef" edge ID in the mutation.
func (m *RecommendationsIPApplicationsMutation) ApplnRefID() (id int64, exists bool) {
	if m._ApplnRef != nil {
		return *m._ApplnRef, true
	}
	return
}

// ApplnRefIDs returns the "ApplnRef" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplnRefID instead. It exists only for internal usage by the builders.
func (m *RecommendationsIPApplicationsMutation) ApplnRefIDs() (ids []int64) {
	if id := m._ApplnRef; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplnRef resets all changes to the "ApplnRef" edge.
func (m *RecommendationsIPApplicationsMutation) ResetApplnRef() {
	m._ApplnRef = nil
	m.cleared_ApplnRef = false
}

// Where appends a list predicates to the RecommendationsIPApplicationsMutation builder.
func (m *RecommendationsIPApplicationsMutation) Where(ps ...predicate.RecommendationsIPApplications) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecommendationsIPApplicationsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecommendationsIPApplicationsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RecommendationsIPApplications, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecommendationsIPApplicationsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecommendationsIPApplicationsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RecommendationsIPApplications).
func (m *RecommendationsIPApplicationsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecommendationsIPApplicationsMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m._ApplnRef != nil {
		fields = append(fields, recommendationsipapplications.FieldApplicationID)
	}
	if m._EmployeeID != nil {
		fields = append(fields, recommendationsipapplications.FieldEmployeeID)
	}
	if m._ExamNameCode != nil {
		fields = append(fields, recommendationsipapplications.FieldExamNameCode)
	}
	if m._ExamYear != nil {
		fields = append(fields, recommendationsipapplications.FieldExamYear)
	}
	if m._VacancyYear != nil {
		fields = append(fields, recommendationsipapplications.FieldVacancyYear)
	}
	if m._CA_Recommendations != nil {
		fields = append(fields, recommendationsipapplications.FieldCARecommendations)
	}
	if m._CA_UpdatedAt != nil {
		fields = append(fields, recommendationsipapplications.FieldCAUpdatedAt)
	}
	if m._CA_UserName != nil {
		fields = append(fields, recommendationsipapplications.FieldCAUserName)
	}
	if m._CA_Remarks != nil {
		fields = append(fields, recommendationsipapplications.FieldCARemarks)
	}
	if m._NO_Recommendations != nil {
		fields = append(fields, recommendationsipapplications.FieldNORecommendations)
	}
	if m._NO_UpdatedAt != nil {
		fields = append(fields, recommendationsipapplications.FieldNOUpdatedAt)
	}
	if m._NO_UserName != nil {
		fields = append(fields, recommendationsipapplications.FieldNOUserName)
	}
	if m._NO_Remarks != nil {
		fields = append(fields, recommendationsipapplications.FieldNORemarks)
	}
	if m._ApplicationStatus != nil {
		fields = append(fields, recommendationsipapplications.FieldApplicationStatus)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, recommendationsipapplications.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, recommendationsipapplications.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecommendationsIPApplicationsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recommendationsipapplications.FieldApplicationID:
		return m.ApplicationID()
	case recommendationsipapplications.FieldEmployeeID:
		return m.EmployeeID()
	case recommendationsipapplications.FieldExamNameCode:
		return m.ExamNameCode()
	case recommendationsipapplications.FieldExamYear:
		return m.ExamYear()
	case recommendationsipapplications.FieldVacancyYear:
		return m.VacancyYear()
	case recommendationsipapplications.FieldCARecommendations:
		return m.CARecommendations()
	case recommendationsipapplications.FieldCAUpdatedAt:
		return m.CAUpdatedAt()
	case recommendationsipapplications.FieldCAUserName:
		return m.CAUserName()
	case recommendationsipapplications.FieldCARemarks:
		return m.CARemarks()
	case recommendationsipapplications.FieldNORecommendations:
		return m.NORecommendations()
	case recommendationsipapplications.FieldNOUpdatedAt:
		return m.NOUpdatedAt()
	case recommendationsipapplications.FieldNOUserName:
		return m.NOUserName()
	case recommendationsipapplications.FieldNORemarks:
		return m.NORemarks()
	case recommendationsipapplications.FieldApplicationStatus:
		return m.ApplicationStatus()
	case recommendationsipapplications.FieldUpdatedAt:
		return m.UpdatedAt()
	case recommendationsipapplications.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecommendationsIPApplicationsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recommendationsipapplications.FieldApplicationID:
		return m.OldApplicationID(ctx)
	case recommendationsipapplications.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case recommendationsipapplications.FieldExamNameCode:
		return m.OldExamNameCode(ctx)
	case recommendationsipapplications.FieldExamYear:
		return m.OldExamYear(ctx)
	case recommendationsipapplications.FieldVacancyYear:
		return m.OldVacancyYear(ctx)
	case recommendationsipapplications.FieldCARecommendations:
		return m.OldCARecommendations(ctx)
	case recommendationsipapplications.FieldCAUpdatedAt:
		return m.OldCAUpdatedAt(ctx)
	case recommendationsipapplications.FieldCAUserName:
		return m.OldCAUserName(ctx)
	case recommendationsipapplications.FieldCARemarks:
		return m.OldCARemarks(ctx)
	case recommendationsipapplications.FieldNORecommendations:
		return m.OldNORecommendations(ctx)
	case recommendationsipapplications.FieldNOUpdatedAt:
		return m.OldNOUpdatedAt(ctx)
	case recommendationsipapplications.FieldNOUserName:
		return m.OldNOUserName(ctx)
	case recommendationsipapplications.FieldNORemarks:
		return m.OldNORemarks(ctx)
	case recommendationsipapplications.FieldApplicationStatus:
		return m.OldApplicationStatus(ctx)
	case recommendationsipapplications.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case recommendationsipapplications.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown RecommendationsIPApplications field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecommendationsIPApplicationsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recommendationsipapplications.FieldApplicationID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationID(v)
		return nil
	case recommendationsipapplications.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case recommendationsipapplications.FieldExamNameCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamNameCode(v)
		return nil
	case recommendationsipapplications.FieldExamYear:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamYear(v)
		return nil
	case recommendationsipapplications.FieldVacancyYear:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVacancyYear(v)
		return nil
	case recommendationsipapplications.FieldCARecommendations:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCARecommendations(v)
		return nil
	case recommendationsipapplications.FieldCAUpdatedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCAUpdatedAt(v)
		return nil
	case recommendationsipapplications.FieldCAUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCAUserName(v)
		return nil
	case recommendationsipapplications.FieldCARemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCARemarks(v)
		return nil
	case recommendationsipapplications.FieldNORecommendations:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNORecommendations(v)
		return nil
	case recommendationsipapplications.FieldNOUpdatedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNOUpdatedAt(v)
		return nil
	case recommendationsipapplications.FieldNOUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNOUserName(v)
		return nil
	case recommendationsipapplications.FieldNORemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNORemarks(v)
		return nil
	case recommendationsipapplications.FieldApplicationStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationStatus(v)
		return nil
	case recommendationsipapplications.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case recommendationsipapplications.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown RecommendationsIPApplications field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecommendationsIPApplicationsMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeeID != nil {
		fields = append(fields, recommendationsipapplications.FieldEmployeeID)
	}
	if m.add_VacancyYear != nil {
		fields = append(fields, recommendationsipapplications.FieldVacancyYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecommendationsIPApplicationsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recommendationsipapplications.FieldEmployeeID:
		return m.AddedEmployeeID()
	case recommendationsipapplications.FieldVacancyYear:
		return m.AddedVacancyYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecommendationsIPApplicationsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recommendationsipapplications.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	case recommendationsipapplications.FieldVacancyYear:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVacancyYear(v)
		return nil
	}
	return fmt.Errorf("unknown RecommendationsIPApplications numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecommendationsIPApplicationsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recommendationsipapplications.FieldApplicationID) {
		fields = append(fields, recommendationsipapplications.FieldApplicationID)
	}
	if m.FieldCleared(recommendationsipapplications.FieldEmployeeID) {
		fields = append(fields, recommendationsipapplications.FieldEmployeeID)
	}
	if m.FieldCleared(recommendationsipapplications.FieldExamNameCode) {
		fields = append(fields, recommendationsipapplications.FieldExamNameCode)
	}
	if m.FieldCleared(recommendationsipapplications.FieldExamYear) {
		fields = append(fields, recommendationsipapplications.FieldExamYear)
	}
	if m.FieldCleared(recommendationsipapplications.FieldVacancyYear) {
		fields = append(fields, recommendationsipapplications.FieldVacancyYear)
	}
	if m.FieldCleared(recommendationsipapplications.FieldCARecommendations) {
		fields = append(fields, recommendationsipapplications.FieldCARecommendations)
	}
	if m.FieldCleared(recommendationsipapplications.FieldCAUpdatedAt) {
		fields = append(fields, recommendationsipapplications.FieldCAUpdatedAt)
	}
	if m.FieldCleared(recommendationsipapplications.FieldCAUserName) {
		fields = append(fields, recommendationsipapplications.FieldCAUserName)
	}
	if m.FieldCleared(recommendationsipapplications.FieldCARemarks) {
		fields = append(fields, recommendationsipapplications.FieldCARemarks)
	}
	if m.FieldCleared(recommendationsipapplications.FieldNORecommendations) {
		fields = append(fields, recommendationsipapplications.FieldNORecommendations)
	}
	if m.FieldCleared(recommendationsipapplications.FieldNOUpdatedAt) {
		fields = append(fields, recommendationsipapplications.FieldNOUpdatedAt)
	}
	if m.FieldCleared(recommendationsipapplications.FieldNOUserName) {
		fields = append(fields, recommendationsipapplications.FieldNOUserName)
	}
	if m.FieldCleared(recommendationsipapplications.FieldNORemarks) {
		fields = append(fields, recommendationsipapplications.FieldNORemarks)
	}
	if m.FieldCleared(recommendationsipapplications.FieldApplicationStatus) {
		fields = append(fields, recommendationsipapplications.FieldApplicationStatus)
	}
	if m.FieldCleared(recommendationsipapplications.FieldUpdatedAt) {
		fields = append(fields, recommendationsipapplications.FieldUpdatedAt)
	}
	if m.FieldCleared(recommendationsipapplications.FieldUpdatedBy) {
		fields = append(fields, recommendationsipapplications.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecommendationsIPApplicationsMutation) ClearField(name string) error {
	switch name {
	case recommendationsipapplications.FieldApplicationID:
		m.ClearApplicationID()
		return nil
	case recommendationsipapplications.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case recommendationsipapplications.FieldExamNameCode:
		m.ClearExamNameCode()
		return nil
	case recommendationsipapplications.FieldExamYear:
		m.ClearExamYear()
		return nil
	case recommendationsipapplications.FieldVacancyYear:
		m.ClearVacancyYear()
		return nil
	case recommendationsipapplications.FieldCARecommendations:
		m.ClearCARecommendations()
		return nil
	case recommendationsipapplications.FieldCAUpdatedAt:
		m.ClearCAUpdatedAt()
		return nil
	case recommendationsipapplications.FieldCAUserName:
		m.ClearCAUserName()
		return nil
	case recommendationsipapplications.FieldCARemarks:
		m.ClearCARemarks()
		return nil
	case recommendationsipapplications.FieldNORecommendations:
		m.ClearNORecommendations()
		return nil
	case recommendationsipapplications.FieldNOUpdatedAt:
		m.ClearNOUpdatedAt()
		return nil
	case recommendationsipapplications.FieldNOUserName:
		m.ClearNOUserName()
		return nil
	case recommendationsipapplications.FieldNORemarks:
		m.ClearNORemarks()
		return nil
	case recommendationsipapplications.FieldApplicationStatus:
		m.ClearApplicationStatus()
		return nil
	case recommendationsipapplications.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case recommendationsipapplications.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown RecommendationsIPApplications nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecommendationsIPApplicationsMutation) ResetField(name string) error {
	switch name {
	case recommendationsipapplications.FieldApplicationID:
		m.ResetApplicationID()
		return nil
	case recommendationsipapplications.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case recommendationsipapplications.FieldExamNameCode:
		m.ResetExamNameCode()
		return nil
	case recommendationsipapplications.FieldExamYear:
		m.ResetExamYear()
		return nil
	case recommendationsipapplications.FieldVacancyYear:
		m.ResetVacancyYear()
		return nil
	case recommendationsipapplications.FieldCARecommendations:
		m.ResetCARecommendations()
		return nil
	case recommendationsipapplications.FieldCAUpdatedAt:
		m.ResetCAUpdatedAt()
		return nil
	case recommendationsipapplications.FieldCAUserName:
		m.ResetCAUserName()
		return nil
	case recommendationsipapplications.FieldCARemarks:
		m.ResetCARemarks()
		return nil
	case recommendationsipapplications.FieldNORecommendations:
		m.ResetNORecommendations()
		return nil
	case recommendationsipapplications.FieldNOUpdatedAt:
		m.ResetNOUpdatedAt()
		return nil
	case recommendationsipapplications.FieldNOUserName:
		m.ResetNOUserName()
		return nil
	case recommendationsipapplications.FieldNORemarks:
		m.ResetNORemarks()
		return nil
	case recommendationsipapplications.FieldApplicationStatus:
		m.ResetApplicationStatus()
		return nil
	case recommendationsipapplications.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case recommendationsipapplications.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown RecommendationsIPApplications field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecommendationsIPApplicationsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._ApplnRef != nil {
		edges = append(edges, recommendationsipapplications.EdgeApplnRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecommendationsIPApplicationsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recommendationsipapplications.EdgeApplnRef:
		if id := m._ApplnRef; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecommendationsIPApplicationsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecommendationsIPApplicationsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_ApplnRef {
		edges = append(edges, recommendationsipapplications.EdgeApplnRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecommendationsIPApplicationsMutation) EdgeCleared(name string) bool {
	switch name {
	case recommendationsipapplications.EdgeApplnRef:
		return m.cleared_ApplnRef
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecommendationsIPApplicationsMutation) ClearEdge(name string) error {
	switch name {
	case recommendationsipapplications.EdgeApplnRef:
		m.ClearApplnRef()
		return nil
	}
	return fmt.Errorf("unknown RecommendationsIPApplications unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecommendationsIPApplicationsMutation) ResetEdge(name string) error {
	switch name {
	case recommendationsipapplications.EdgeApplnRef:
		m.ResetApplnRef()
		return nil
	}
	return fmt.Errorf("unknown RecommendationsIPApplications edge %s", name)
}

// RegionMasterMutation represents an operation that mutates the RegionMaster nodes in the graph.
type RegionMasterMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int32
	_RegionCode           *int32
	add_RegionCode        *int32
	_RegionOfficeId       *string
	_OfficeType           *string
	_RegionOfficeName     *string
	_ReportingOfficeType  *string
	_ReportingOfficeCode  *string
	_EmailID              *string
	_MobileNumber         *int32
	add_MobileNumber      *int32
	_CircleCode           *int32
	add_CircleCode        *int32
	clearedFields         map[string]struct{}
	circle_ref            map[int32]struct{}
	removedcircle_ref     map[int32]struct{}
	clearedcircle_ref     bool
	regions               map[int32]struct{}
	removedregions        map[int32]struct{}
	clearedregions        bool
	region_ref_ref        map[int32]struct{}
	removedregion_ref_ref map[int32]struct{}
	clearedregion_ref_ref bool
	done                  bool
	oldValue              func(context.Context) (*RegionMaster, error)
	predicates            []predicate.RegionMaster
}

var _ ent.Mutation = (*RegionMasterMutation)(nil)

// regionmasterOption allows management of the mutation configuration using functional options.
type regionmasterOption func(*RegionMasterMutation)

// newRegionMasterMutation creates new mutation for the RegionMaster entity.
func newRegionMasterMutation(c config, op Op, opts ...regionmasterOption) *RegionMasterMutation {
	m := &RegionMasterMutation{
		config:        c,
		op:            op,
		typ:           TypeRegionMaster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegionMasterID sets the ID field of the mutation.
func withRegionMasterID(id int32) regionmasterOption {
	return func(m *RegionMasterMutation) {
		var (
			err   error
			once  sync.Once
			value *RegionMaster
		)
		m.oldValue = func(ctx context.Context) (*RegionMaster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RegionMaster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegionMaster sets the old RegionMaster of the mutation.
func withRegionMaster(node *RegionMaster) regionmasterOption {
	return func(m *RegionMasterMutation) {
		m.oldValue = func(context.Context) (*RegionMaster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegionMasterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegionMasterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RegionMaster entities.
func (m *RegionMasterMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RegionMasterMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RegionMasterMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RegionMaster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRegionCode sets the "RegionCode" field.
func (m *RegionMasterMutation) SetRegionCode(i int32) {
	m._RegionCode = &i
	m.add_RegionCode = nil
}

// RegionCode returns the value of the "RegionCode" field in the mutation.
func (m *RegionMasterMutation) RegionCode() (r int32, exists bool) {
	v := m._RegionCode
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionCode returns the old "RegionCode" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldRegionCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionCode: %w", err)
	}
	return oldValue.RegionCode, nil
}

// AddRegionCode adds i to the "RegionCode" field.
func (m *RegionMasterMutation) AddRegionCode(i int32) {
	if m.add_RegionCode != nil {
		*m.add_RegionCode += i
	} else {
		m.add_RegionCode = &i
	}
}

// AddedRegionCode returns the value that was added to the "RegionCode" field in this mutation.
func (m *RegionMasterMutation) AddedRegionCode() (r int32, exists bool) {
	v := m.add_RegionCode
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegionCode resets all changes to the "RegionCode" field.
func (m *RegionMasterMutation) ResetRegionCode() {
	m._RegionCode = nil
	m.add_RegionCode = nil
}

// SetRegionOfficeId sets the "RegionOfficeId" field.
func (m *RegionMasterMutation) SetRegionOfficeId(s string) {
	m._RegionOfficeId = &s
}

// RegionOfficeId returns the value of the "RegionOfficeId" field in the mutation.
func (m *RegionMasterMutation) RegionOfficeId() (r string, exists bool) {
	v := m._RegionOfficeId
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionOfficeId returns the old "RegionOfficeId" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldRegionOfficeId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionOfficeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionOfficeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionOfficeId: %w", err)
	}
	return oldValue.RegionOfficeId, nil
}

// ResetRegionOfficeId resets all changes to the "RegionOfficeId" field.
func (m *RegionMasterMutation) ResetRegionOfficeId() {
	m._RegionOfficeId = nil
}

// SetOfficeType sets the "OfficeType" field.
func (m *RegionMasterMutation) SetOfficeType(s string) {
	m._OfficeType = &s
}

// OfficeType returns the value of the "OfficeType" field in the mutation.
func (m *RegionMasterMutation) OfficeType() (r string, exists bool) {
	v := m._OfficeType
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeType returns the old "OfficeType" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldOfficeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeType: %w", err)
	}
	return oldValue.OfficeType, nil
}

// ResetOfficeType resets all changes to the "OfficeType" field.
func (m *RegionMasterMutation) ResetOfficeType() {
	m._OfficeType = nil
}

// SetRegionOfficeName sets the "RegionOfficeName" field.
func (m *RegionMasterMutation) SetRegionOfficeName(s string) {
	m._RegionOfficeName = &s
}

// RegionOfficeName returns the value of the "RegionOfficeName" field in the mutation.
func (m *RegionMasterMutation) RegionOfficeName() (r string, exists bool) {
	v := m._RegionOfficeName
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionOfficeName returns the old "RegionOfficeName" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldRegionOfficeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionOfficeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionOfficeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionOfficeName: %w", err)
	}
	return oldValue.RegionOfficeName, nil
}

// ResetRegionOfficeName resets all changes to the "RegionOfficeName" field.
func (m *RegionMasterMutation) ResetRegionOfficeName() {
	m._RegionOfficeName = nil
}

// SetReportingOfficeType sets the "ReportingOfficeType" field.
func (m *RegionMasterMutation) SetReportingOfficeType(s string) {
	m._ReportingOfficeType = &s
}

// ReportingOfficeType returns the value of the "ReportingOfficeType" field in the mutation.
func (m *RegionMasterMutation) ReportingOfficeType() (r string, exists bool) {
	v := m._ReportingOfficeType
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingOfficeType returns the old "ReportingOfficeType" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldReportingOfficeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingOfficeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingOfficeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingOfficeType: %w", err)
	}
	return oldValue.ReportingOfficeType, nil
}

// ClearReportingOfficeType clears the value of the "ReportingOfficeType" field.
func (m *RegionMasterMutation) ClearReportingOfficeType() {
	m._ReportingOfficeType = nil
	m.clearedFields[regionmaster.FieldReportingOfficeType] = struct{}{}
}

// ReportingOfficeTypeCleared returns if the "ReportingOfficeType" field was cleared in this mutation.
func (m *RegionMasterMutation) ReportingOfficeTypeCleared() bool {
	_, ok := m.clearedFields[regionmaster.FieldReportingOfficeType]
	return ok
}

// ResetReportingOfficeType resets all changes to the "ReportingOfficeType" field.
func (m *RegionMasterMutation) ResetReportingOfficeType() {
	m._ReportingOfficeType = nil
	delete(m.clearedFields, regionmaster.FieldReportingOfficeType)
}

// SetReportingOfficeCode sets the "ReportingOfficeCode" field.
func (m *RegionMasterMutation) SetReportingOfficeCode(s string) {
	m._ReportingOfficeCode = &s
}

// ReportingOfficeCode returns the value of the "ReportingOfficeCode" field in the mutation.
func (m *RegionMasterMutation) ReportingOfficeCode() (r string, exists bool) {
	v := m._ReportingOfficeCode
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingOfficeCode returns the old "ReportingOfficeCode" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldReportingOfficeCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingOfficeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingOfficeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingOfficeCode: %w", err)
	}
	return oldValue.ReportingOfficeCode, nil
}

// ClearReportingOfficeCode clears the value of the "ReportingOfficeCode" field.
func (m *RegionMasterMutation) ClearReportingOfficeCode() {
	m._ReportingOfficeCode = nil
	m.clearedFields[regionmaster.FieldReportingOfficeCode] = struct{}{}
}

// ReportingOfficeCodeCleared returns if the "ReportingOfficeCode" field was cleared in this mutation.
func (m *RegionMasterMutation) ReportingOfficeCodeCleared() bool {
	_, ok := m.clearedFields[regionmaster.FieldReportingOfficeCode]
	return ok
}

// ResetReportingOfficeCode resets all changes to the "ReportingOfficeCode" field.
func (m *RegionMasterMutation) ResetReportingOfficeCode() {
	m._ReportingOfficeCode = nil
	delete(m.clearedFields, regionmaster.FieldReportingOfficeCode)
}

// SetEmailID sets the "EmailID" field.
func (m *RegionMasterMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *RegionMasterMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ClearEmailID clears the value of the "EmailID" field.
func (m *RegionMasterMutation) ClearEmailID() {
	m._EmailID = nil
	m.clearedFields[regionmaster.FieldEmailID] = struct{}{}
}

// EmailIDCleared returns if the "EmailID" field was cleared in this mutation.
func (m *RegionMasterMutation) EmailIDCleared() bool {
	_, ok := m.clearedFields[regionmaster.FieldEmailID]
	return ok
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *RegionMasterMutation) ResetEmailID() {
	m._EmailID = nil
	delete(m.clearedFields, regionmaster.FieldEmailID)
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *RegionMasterMutation) SetMobileNumber(i int32) {
	m._MobileNumber = &i
	m.add_MobileNumber = nil
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *RegionMasterMutation) MobileNumber() (r int32, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldMobileNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// AddMobileNumber adds i to the "MobileNumber" field.
func (m *RegionMasterMutation) AddMobileNumber(i int32) {
	if m.add_MobileNumber != nil {
		*m.add_MobileNumber += i
	} else {
		m.add_MobileNumber = &i
	}
}

// AddedMobileNumber returns the value that was added to the "MobileNumber" field in this mutation.
func (m *RegionMasterMutation) AddedMobileNumber() (r int32, exists bool) {
	v := m.add_MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearMobileNumber clears the value of the "MobileNumber" field.
func (m *RegionMasterMutation) ClearMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	m.clearedFields[regionmaster.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "MobileNumber" field was cleared in this mutation.
func (m *RegionMasterMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[regionmaster.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *RegionMasterMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	m.add_MobileNumber = nil
	delete(m.clearedFields, regionmaster.FieldMobileNumber)
}

// SetCircleCode sets the "CircleCode" field.
func (m *RegionMasterMutation) SetCircleCode(i int32) {
	m._CircleCode = &i
	m.add_CircleCode = nil
}

// CircleCode returns the value of the "CircleCode" field in the mutation.
func (m *RegionMasterMutation) CircleCode() (r int32, exists bool) {
	v := m._CircleCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCircleCode returns the old "CircleCode" field's value of the RegionMaster entity.
// If the RegionMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMasterMutation) OldCircleCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCircleCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCircleCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCircleCode: %w", err)
	}
	return oldValue.CircleCode, nil
}

// AddCircleCode adds i to the "CircleCode" field.
func (m *RegionMasterMutation) AddCircleCode(i int32) {
	if m.add_CircleCode != nil {
		*m.add_CircleCode += i
	} else {
		m.add_CircleCode = &i
	}
}

// AddedCircleCode returns the value that was added to the "CircleCode" field in this mutation.
func (m *RegionMasterMutation) AddedCircleCode() (r int32, exists bool) {
	v := m.add_CircleCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearCircleCode clears the value of the "CircleCode" field.
func (m *RegionMasterMutation) ClearCircleCode() {
	m._CircleCode = nil
	m.add_CircleCode = nil
	m.clearedFields[regionmaster.FieldCircleCode] = struct{}{}
}

// CircleCodeCleared returns if the "CircleCode" field was cleared in this mutation.
func (m *RegionMasterMutation) CircleCodeCleared() bool {
	_, ok := m.clearedFields[regionmaster.FieldCircleCode]
	return ok
}

// ResetCircleCode resets all changes to the "CircleCode" field.
func (m *RegionMasterMutation) ResetCircleCode() {
	m._CircleCode = nil
	m.add_CircleCode = nil
	delete(m.clearedFields, regionmaster.FieldCircleCode)
}

// AddCircleRefIDs adds the "circle_ref" edge to the CircleMaster entity by ids.
func (m *RegionMasterMutation) AddCircleRefIDs(ids ...int32) {
	if m.circle_ref == nil {
		m.circle_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.circle_ref[ids[i]] = struct{}{}
	}
}

// ClearCircleRef clears the "circle_ref" edge to the CircleMaster entity.
func (m *RegionMasterMutation) ClearCircleRef() {
	m.clearedcircle_ref = true
}

// CircleRefCleared reports if the "circle_ref" edge to the CircleMaster entity was cleared.
func (m *RegionMasterMutation) CircleRefCleared() bool {
	return m.clearedcircle_ref
}

// RemoveCircleRefIDs removes the "circle_ref" edge to the CircleMaster entity by IDs.
func (m *RegionMasterMutation) RemoveCircleRefIDs(ids ...int32) {
	if m.removedcircle_ref == nil {
		m.removedcircle_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.circle_ref, ids[i])
		m.removedcircle_ref[ids[i]] = struct{}{}
	}
}

// RemovedCircleRef returns the removed IDs of the "circle_ref" edge to the CircleMaster entity.
func (m *RegionMasterMutation) RemovedCircleRefIDs() (ids []int32) {
	for id := range m.removedcircle_ref {
		ids = append(ids, id)
	}
	return
}

// CircleRefIDs returns the "circle_ref" edge IDs in the mutation.
func (m *RegionMasterMutation) CircleRefIDs() (ids []int32) {
	for id := range m.circle_ref {
		ids = append(ids, id)
	}
	return
}

// ResetCircleRef resets all changes to the "circle_ref" edge.
func (m *RegionMasterMutation) ResetCircleRef() {
	m.circle_ref = nil
	m.clearedcircle_ref = false
	m.removedcircle_ref = nil
}

// AddRegionIDs adds the "regions" edge to the DivisionMaster entity by ids.
func (m *RegionMasterMutation) AddRegionIDs(ids ...int32) {
	if m.regions == nil {
		m.regions = make(map[int32]struct{})
	}
	for i := range ids {
		m.regions[ids[i]] = struct{}{}
	}
}

// ClearRegions clears the "regions" edge to the DivisionMaster entity.
func (m *RegionMasterMutation) ClearRegions() {
	m.clearedregions = true
}

// RegionsCleared reports if the "regions" edge to the DivisionMaster entity was cleared.
func (m *RegionMasterMutation) RegionsCleared() bool {
	return m.clearedregions
}

// RemoveRegionIDs removes the "regions" edge to the DivisionMaster entity by IDs.
func (m *RegionMasterMutation) RemoveRegionIDs(ids ...int32) {
	if m.removedregions == nil {
		m.removedregions = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.regions, ids[i])
		m.removedregions[ids[i]] = struct{}{}
	}
}

// RemovedRegions returns the removed IDs of the "regions" edge to the DivisionMaster entity.
func (m *RegionMasterMutation) RemovedRegionsIDs() (ids []int32) {
	for id := range m.removedregions {
		ids = append(ids, id)
	}
	return
}

// RegionsIDs returns the "regions" edge IDs in the mutation.
func (m *RegionMasterMutation) RegionsIDs() (ids []int32) {
	for id := range m.regions {
		ids = append(ids, id)
	}
	return
}

// ResetRegions resets all changes to the "regions" edge.
func (m *RegionMasterMutation) ResetRegions() {
	m.regions = nil
	m.clearedregions = false
	m.removedregions = nil
}

// AddRegionRefRefIDs adds the "region_ref_ref" edge to the Facility entity by ids.
func (m *RegionMasterMutation) AddRegionRefRefIDs(ids ...int32) {
	if m.region_ref_ref == nil {
		m.region_ref_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.region_ref_ref[ids[i]] = struct{}{}
	}
}

// ClearRegionRefRef clears the "region_ref_ref" edge to the Facility entity.
func (m *RegionMasterMutation) ClearRegionRefRef() {
	m.clearedregion_ref_ref = true
}

// RegionRefRefCleared reports if the "region_ref_ref" edge to the Facility entity was cleared.
func (m *RegionMasterMutation) RegionRefRefCleared() bool {
	return m.clearedregion_ref_ref
}

// RemoveRegionRefRefIDs removes the "region_ref_ref" edge to the Facility entity by IDs.
func (m *RegionMasterMutation) RemoveRegionRefRefIDs(ids ...int32) {
	if m.removedregion_ref_ref == nil {
		m.removedregion_ref_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.region_ref_ref, ids[i])
		m.removedregion_ref_ref[ids[i]] = struct{}{}
	}
}

// RemovedRegionRefRef returns the removed IDs of the "region_ref_ref" edge to the Facility entity.
func (m *RegionMasterMutation) RemovedRegionRefRefIDs() (ids []int32) {
	for id := range m.removedregion_ref_ref {
		ids = append(ids, id)
	}
	return
}

// RegionRefRefIDs returns the "region_ref_ref" edge IDs in the mutation.
func (m *RegionMasterMutation) RegionRefRefIDs() (ids []int32) {
	for id := range m.region_ref_ref {
		ids = append(ids, id)
	}
	return
}

// ResetRegionRefRef resets all changes to the "region_ref_ref" edge.
func (m *RegionMasterMutation) ResetRegionRefRef() {
	m.region_ref_ref = nil
	m.clearedregion_ref_ref = false
	m.removedregion_ref_ref = nil
}

// Where appends a list predicates to the RegionMasterMutation builder.
func (m *RegionMasterMutation) Where(ps ...predicate.RegionMaster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RegionMasterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RegionMasterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RegionMaster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RegionMasterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RegionMasterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RegionMaster).
func (m *RegionMasterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RegionMasterMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._RegionCode != nil {
		fields = append(fields, regionmaster.FieldRegionCode)
	}
	if m._RegionOfficeId != nil {
		fields = append(fields, regionmaster.FieldRegionOfficeId)
	}
	if m._OfficeType != nil {
		fields = append(fields, regionmaster.FieldOfficeType)
	}
	if m._RegionOfficeName != nil {
		fields = append(fields, regionmaster.FieldRegionOfficeName)
	}
	if m._ReportingOfficeType != nil {
		fields = append(fields, regionmaster.FieldReportingOfficeType)
	}
	if m._ReportingOfficeCode != nil {
		fields = append(fields, regionmaster.FieldReportingOfficeCode)
	}
	if m._EmailID != nil {
		fields = append(fields, regionmaster.FieldEmailID)
	}
	if m._MobileNumber != nil {
		fields = append(fields, regionmaster.FieldMobileNumber)
	}
	if m._CircleCode != nil {
		fields = append(fields, regionmaster.FieldCircleCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RegionMasterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case regionmaster.FieldRegionCode:
		return m.RegionCode()
	case regionmaster.FieldRegionOfficeId:
		return m.RegionOfficeId()
	case regionmaster.FieldOfficeType:
		return m.OfficeType()
	case regionmaster.FieldRegionOfficeName:
		return m.RegionOfficeName()
	case regionmaster.FieldReportingOfficeType:
		return m.ReportingOfficeType()
	case regionmaster.FieldReportingOfficeCode:
		return m.ReportingOfficeCode()
	case regionmaster.FieldEmailID:
		return m.EmailID()
	case regionmaster.FieldMobileNumber:
		return m.MobileNumber()
	case regionmaster.FieldCircleCode:
		return m.CircleCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RegionMasterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case regionmaster.FieldRegionCode:
		return m.OldRegionCode(ctx)
	case regionmaster.FieldRegionOfficeId:
		return m.OldRegionOfficeId(ctx)
	case regionmaster.FieldOfficeType:
		return m.OldOfficeType(ctx)
	case regionmaster.FieldRegionOfficeName:
		return m.OldRegionOfficeName(ctx)
	case regionmaster.FieldReportingOfficeType:
		return m.OldReportingOfficeType(ctx)
	case regionmaster.FieldReportingOfficeCode:
		return m.OldReportingOfficeCode(ctx)
	case regionmaster.FieldEmailID:
		return m.OldEmailID(ctx)
	case regionmaster.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case regionmaster.FieldCircleCode:
		return m.OldCircleCode(ctx)
	}
	return nil, fmt.Errorf("unknown RegionMaster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMasterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case regionmaster.FieldRegionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionCode(v)
		return nil
	case regionmaster.FieldRegionOfficeId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionOfficeId(v)
		return nil
	case regionmaster.FieldOfficeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeType(v)
		return nil
	case regionmaster.FieldRegionOfficeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionOfficeName(v)
		return nil
	case regionmaster.FieldReportingOfficeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingOfficeType(v)
		return nil
	case regionmaster.FieldReportingOfficeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingOfficeCode(v)
		return nil
	case regionmaster.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case regionmaster.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case regionmaster.FieldCircleCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCircleCode(v)
		return nil
	}
	return fmt.Errorf("unknown RegionMaster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RegionMasterMutation) AddedFields() []string {
	var fields []string
	if m.add_RegionCode != nil {
		fields = append(fields, regionmaster.FieldRegionCode)
	}
	if m.add_MobileNumber != nil {
		fields = append(fields, regionmaster.FieldMobileNumber)
	}
	if m.add_CircleCode != nil {
		fields = append(fields, regionmaster.FieldCircleCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RegionMasterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case regionmaster.FieldRegionCode:
		return m.AddedRegionCode()
	case regionmaster.FieldMobileNumber:
		return m.AddedMobileNumber()
	case regionmaster.FieldCircleCode:
		return m.AddedCircleCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMasterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case regionmaster.FieldRegionCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegionCode(v)
		return nil
	case regionmaster.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMobileNumber(v)
		return nil
	case regionmaster.FieldCircleCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCircleCode(v)
		return nil
	}
	return fmt.Errorf("unknown RegionMaster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RegionMasterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(regionmaster.FieldReportingOfficeType) {
		fields = append(fields, regionmaster.FieldReportingOfficeType)
	}
	if m.FieldCleared(regionmaster.FieldReportingOfficeCode) {
		fields = append(fields, regionmaster.FieldReportingOfficeCode)
	}
	if m.FieldCleared(regionmaster.FieldEmailID) {
		fields = append(fields, regionmaster.FieldEmailID)
	}
	if m.FieldCleared(regionmaster.FieldMobileNumber) {
		fields = append(fields, regionmaster.FieldMobileNumber)
	}
	if m.FieldCleared(regionmaster.FieldCircleCode) {
		fields = append(fields, regionmaster.FieldCircleCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RegionMasterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegionMasterMutation) ClearField(name string) error {
	switch name {
	case regionmaster.FieldReportingOfficeType:
		m.ClearReportingOfficeType()
		return nil
	case regionmaster.FieldReportingOfficeCode:
		m.ClearReportingOfficeCode()
		return nil
	case regionmaster.FieldEmailID:
		m.ClearEmailID()
		return nil
	case regionmaster.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	case regionmaster.FieldCircleCode:
		m.ClearCircleCode()
		return nil
	}
	return fmt.Errorf("unknown RegionMaster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RegionMasterMutation) ResetField(name string) error {
	switch name {
	case regionmaster.FieldRegionCode:
		m.ResetRegionCode()
		return nil
	case regionmaster.FieldRegionOfficeId:
		m.ResetRegionOfficeId()
		return nil
	case regionmaster.FieldOfficeType:
		m.ResetOfficeType()
		return nil
	case regionmaster.FieldRegionOfficeName:
		m.ResetRegionOfficeName()
		return nil
	case regionmaster.FieldReportingOfficeType:
		m.ResetReportingOfficeType()
		return nil
	case regionmaster.FieldReportingOfficeCode:
		m.ResetReportingOfficeCode()
		return nil
	case regionmaster.FieldEmailID:
		m.ResetEmailID()
		return nil
	case regionmaster.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case regionmaster.FieldCircleCode:
		m.ResetCircleCode()
		return nil
	}
	return fmt.Errorf("unknown RegionMaster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RegionMasterMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.circle_ref != nil {
		edges = append(edges, regionmaster.EdgeCircleRef)
	}
	if m.regions != nil {
		edges = append(edges, regionmaster.EdgeRegions)
	}
	if m.region_ref_ref != nil {
		edges = append(edges, regionmaster.EdgeRegionRefRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RegionMasterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case regionmaster.EdgeCircleRef:
		ids := make([]ent.Value, 0, len(m.circle_ref))
		for id := range m.circle_ref {
			ids = append(ids, id)
		}
		return ids
	case regionmaster.EdgeRegions:
		ids := make([]ent.Value, 0, len(m.regions))
		for id := range m.regions {
			ids = append(ids, id)
		}
		return ids
	case regionmaster.EdgeRegionRefRef:
		ids := make([]ent.Value, 0, len(m.region_ref_ref))
		for id := range m.region_ref_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RegionMasterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcircle_ref != nil {
		edges = append(edges, regionmaster.EdgeCircleRef)
	}
	if m.removedregions != nil {
		edges = append(edges, regionmaster.EdgeRegions)
	}
	if m.removedregion_ref_ref != nil {
		edges = append(edges, regionmaster.EdgeRegionRefRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RegionMasterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case regionmaster.EdgeCircleRef:
		ids := make([]ent.Value, 0, len(m.removedcircle_ref))
		for id := range m.removedcircle_ref {
			ids = append(ids, id)
		}
		return ids
	case regionmaster.EdgeRegions:
		ids := make([]ent.Value, 0, len(m.removedregions))
		for id := range m.removedregions {
			ids = append(ids, id)
		}
		return ids
	case regionmaster.EdgeRegionRefRef:
		ids := make([]ent.Value, 0, len(m.removedregion_ref_ref))
		for id := range m.removedregion_ref_ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RegionMasterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcircle_ref {
		edges = append(edges, regionmaster.EdgeCircleRef)
	}
	if m.clearedregions {
		edges = append(edges, regionmaster.EdgeRegions)
	}
	if m.clearedregion_ref_ref {
		edges = append(edges, regionmaster.EdgeRegionRefRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RegionMasterMutation) EdgeCleared(name string) bool {
	switch name {
	case regionmaster.EdgeCircleRef:
		return m.clearedcircle_ref
	case regionmaster.EdgeRegions:
		return m.clearedregions
	case regionmaster.EdgeRegionRefRef:
		return m.clearedregion_ref_ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RegionMasterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown RegionMaster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RegionMasterMutation) ResetEdge(name string) error {
	switch name {
	case regionmaster.EdgeCircleRef:
		m.ResetCircleRef()
		return nil
	case regionmaster.EdgeRegions:
		m.ResetRegions()
		return nil
	case regionmaster.EdgeRegionRefRef:
		m.ResetRegionRefRef()
		return nil
	}
	return fmt.Errorf("unknown RegionMaster edge %s", name)
}

// ReversalApplicationIPMutation represents an operation that mutates the Reversal_Application_IP nodes in the graph.
type ReversalApplicationIPMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int64
	_EmployeeID                 *int64
	add_EmployeeID              *int64
	_EmployeeName               *string
	_DOB                        *string
	_Gender                     *reversal_application_ip.Gender
	_MobileNumber               *string
	_EmailID                    *string
	_EmployeeCategory           *string
	_Cadre                      *string
	_EmployeePost               *string
	_FacilityID                 *string
	_DCCS                       *string
	_DCInPresentCadre           *string
	_DeputationOfficeId         *string
	_DisabilityType             *string
	_DisabilityPercentage       *string
	_Education                  *string
	_ExamCodeIP                 *int32
	add_ExamCodeIP              *int32
	_ExamYear                   *string
	_CentrePreference           *string
	_Signature                  *string
	_Photo                      *string
	_ApplicationStatus          *string
	_ReversalApplnSubmittedDate *time.Time
	_VA_Remarks                 *string
	_VA_UserName                *string
	_VA_Date                    *time.Time
	_CA_Remarks                 *string
	_CA_UserName                *string
	_CA_Date                    *time.Time
	_AppliactionRemarks         *string
	_UpdatedAt                  *time.Time
	_UpdatedBy                  *string
	_RoleUserCode               *int32
	add_RoleUserCode            *int32
	clearedFields               map[string]struct{}
	done                        bool
	oldValue                    func(context.Context) (*Reversal_Application_IP, error)
	predicates                  []predicate.Reversal_Application_IP
}

var _ ent.Mutation = (*ReversalApplicationIPMutation)(nil)

// reversalApplicationIPOption allows management of the mutation configuration using functional options.
type reversalApplicationIPOption func(*ReversalApplicationIPMutation)

// newReversalApplicationIPMutation creates new mutation for the Reversal_Application_IP entity.
func newReversalApplicationIPMutation(c config, op Op, opts ...reversalApplicationIPOption) *ReversalApplicationIPMutation {
	m := &ReversalApplicationIPMutation{
		config:        c,
		op:            op,
		typ:           TypeReversalApplicationIP,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReversal_Application_IPID sets the ID field of the mutation.
func withReversal_Application_IPID(id int64) reversalApplicationIPOption {
	return func(m *ReversalApplicationIPMutation) {
		var (
			err   error
			once  sync.Once
			value *Reversal_Application_IP
		)
		m.oldValue = func(ctx context.Context) (*Reversal_Application_IP, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reversal_Application_IP.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReversal_Application_IP sets the old Reversal_Application_IP of the mutation.
func withReversal_Application_IP(node *Reversal_Application_IP) reversalApplicationIPOption {
	return func(m *ReversalApplicationIPMutation) {
		m.oldValue = func(context.Context) (*Reversal_Application_IP, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReversalApplicationIPMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReversalApplicationIPMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Reversal_Application_IP entities.
func (m *ReversalApplicationIPMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReversalApplicationIPMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReversalApplicationIPMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Reversal_Application_IP.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *ReversalApplicationIPMutation) SetEmployeeID(i int64) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *ReversalApplicationIPMutation) EmployeeID() (r int64, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldEmployeeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *ReversalApplicationIPMutation) AddEmployeeID(i int64) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *ReversalApplicationIPMutation) AddedEmployeeID() (r int64, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeeID clears the value of the "EmployeeID" field.
func (m *ReversalApplicationIPMutation) ClearEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	m.clearedFields[reversal_application_ip.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "EmployeeID" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *ReversalApplicationIPMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	delete(m.clearedFields, reversal_application_ip.FieldEmployeeID)
}

// SetEmployeeName sets the "EmployeeName" field.
func (m *ReversalApplicationIPMutation) SetEmployeeName(s string) {
	m._EmployeeName = &s
}

// EmployeeName returns the value of the "EmployeeName" field in the mutation.
func (m *ReversalApplicationIPMutation) EmployeeName() (r string, exists bool) {
	v := m._EmployeeName
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeName returns the old "EmployeeName" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldEmployeeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeName: %w", err)
	}
	return oldValue.EmployeeName, nil
}

// ClearEmployeeName clears the value of the "EmployeeName" field.
func (m *ReversalApplicationIPMutation) ClearEmployeeName() {
	m._EmployeeName = nil
	m.clearedFields[reversal_application_ip.FieldEmployeeName] = struct{}{}
}

// EmployeeNameCleared returns if the "EmployeeName" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) EmployeeNameCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldEmployeeName]
	return ok
}

// ResetEmployeeName resets all changes to the "EmployeeName" field.
func (m *ReversalApplicationIPMutation) ResetEmployeeName() {
	m._EmployeeName = nil
	delete(m.clearedFields, reversal_application_ip.FieldEmployeeName)
}

// SetDOB sets the "DOB" field.
func (m *ReversalApplicationIPMutation) SetDOB(s string) {
	m._DOB = &s
}

// DOB returns the value of the "DOB" field in the mutation.
func (m *ReversalApplicationIPMutation) DOB() (r string, exists bool) {
	v := m._DOB
	if v == nil {
		return
	}
	return *v, true
}

// OldDOB returns the old "DOB" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldDOB(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOB: %w", err)
	}
	return oldValue.DOB, nil
}

// ClearDOB clears the value of the "DOB" field.
func (m *ReversalApplicationIPMutation) ClearDOB() {
	m._DOB = nil
	m.clearedFields[reversal_application_ip.FieldDOB] = struct{}{}
}

// DOBCleared returns if the "DOB" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) DOBCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldDOB]
	return ok
}

// ResetDOB resets all changes to the "DOB" field.
func (m *ReversalApplicationIPMutation) ResetDOB() {
	m._DOB = nil
	delete(m.clearedFields, reversal_application_ip.FieldDOB)
}

// SetGender sets the "Gender" field.
func (m *ReversalApplicationIPMutation) SetGender(rai reversal_application_ip.Gender) {
	m._Gender = &rai
}

// Gender returns the value of the "Gender" field in the mutation.
func (m *ReversalApplicationIPMutation) Gender() (r reversal_application_ip.Gender, exists bool) {
	v := m._Gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "Gender" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldGender(ctx context.Context) (v reversal_application_ip.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "Gender" field.
func (m *ReversalApplicationIPMutation) ResetGender() {
	m._Gender = nil
}

// SetMobileNumber sets the "MobileNumber" field.
func (m *ReversalApplicationIPMutation) SetMobileNumber(s string) {
	m._MobileNumber = &s
}

// MobileNumber returns the value of the "MobileNumber" field in the mutation.
func (m *ReversalApplicationIPMutation) MobileNumber() (r string, exists bool) {
	v := m._MobileNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "MobileNumber" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldMobileNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// ClearMobileNumber clears the value of the "MobileNumber" field.
func (m *ReversalApplicationIPMutation) ClearMobileNumber() {
	m._MobileNumber = nil
	m.clearedFields[reversal_application_ip.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "MobileNumber" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "MobileNumber" field.
func (m *ReversalApplicationIPMutation) ResetMobileNumber() {
	m._MobileNumber = nil
	delete(m.clearedFields, reversal_application_ip.FieldMobileNumber)
}

// SetEmailID sets the "EmailID" field.
func (m *ReversalApplicationIPMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *ReversalApplicationIPMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ClearEmailID clears the value of the "EmailID" field.
func (m *ReversalApplicationIPMutation) ClearEmailID() {
	m._EmailID = nil
	m.clearedFields[reversal_application_ip.FieldEmailID] = struct{}{}
}

// EmailIDCleared returns if the "EmailID" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) EmailIDCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldEmailID]
	return ok
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *ReversalApplicationIPMutation) ResetEmailID() {
	m._EmailID = nil
	delete(m.clearedFields, reversal_application_ip.FieldEmailID)
}

// SetEmployeeCategory sets the "EmployeeCategory" field.
func (m *ReversalApplicationIPMutation) SetEmployeeCategory(s string) {
	m._EmployeeCategory = &s
}

// EmployeeCategory returns the value of the "EmployeeCategory" field in the mutation.
func (m *ReversalApplicationIPMutation) EmployeeCategory() (r string, exists bool) {
	v := m._EmployeeCategory
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCategory returns the old "EmployeeCategory" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldEmployeeCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCategory: %w", err)
	}
	return oldValue.EmployeeCategory, nil
}

// ClearEmployeeCategory clears the value of the "EmployeeCategory" field.
func (m *ReversalApplicationIPMutation) ClearEmployeeCategory() {
	m._EmployeeCategory = nil
	m.clearedFields[reversal_application_ip.FieldEmployeeCategory] = struct{}{}
}

// EmployeeCategoryCleared returns if the "EmployeeCategory" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) EmployeeCategoryCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldEmployeeCategory]
	return ok
}

// ResetEmployeeCategory resets all changes to the "EmployeeCategory" field.
func (m *ReversalApplicationIPMutation) ResetEmployeeCategory() {
	m._EmployeeCategory = nil
	delete(m.clearedFields, reversal_application_ip.FieldEmployeeCategory)
}

// SetCadre sets the "Cadre" field.
func (m *ReversalApplicationIPMutation) SetCadre(s string) {
	m._Cadre = &s
}

// Cadre returns the value of the "Cadre" field in the mutation.
func (m *ReversalApplicationIPMutation) Cadre() (r string, exists bool) {
	v := m._Cadre
	if v == nil {
		return
	}
	return *v, true
}

// OldCadre returns the old "Cadre" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadre: %w", err)
	}
	return oldValue.Cadre, nil
}

// ClearCadre clears the value of the "Cadre" field.
func (m *ReversalApplicationIPMutation) ClearCadre() {
	m._Cadre = nil
	m.clearedFields[reversal_application_ip.FieldCadre] = struct{}{}
}

// CadreCleared returns if the "Cadre" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) CadreCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldCadre]
	return ok
}

// ResetCadre resets all changes to the "Cadre" field.
func (m *ReversalApplicationIPMutation) ResetCadre() {
	m._Cadre = nil
	delete(m.clearedFields, reversal_application_ip.FieldCadre)
}

// SetEmployeePost sets the "EmployeePost" field.
func (m *ReversalApplicationIPMutation) SetEmployeePost(s string) {
	m._EmployeePost = &s
}

// EmployeePost returns the value of the "EmployeePost" field in the mutation.
func (m *ReversalApplicationIPMutation) EmployeePost() (r string, exists bool) {
	v := m._EmployeePost
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeePost returns the old "EmployeePost" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldEmployeePost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeePost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeePost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeePost: %w", err)
	}
	return oldValue.EmployeePost, nil
}

// ClearEmployeePost clears the value of the "EmployeePost" field.
func (m *ReversalApplicationIPMutation) ClearEmployeePost() {
	m._EmployeePost = nil
	m.clearedFields[reversal_application_ip.FieldEmployeePost] = struct{}{}
}

// EmployeePostCleared returns if the "EmployeePost" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) EmployeePostCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldEmployeePost]
	return ok
}

// ResetEmployeePost resets all changes to the "EmployeePost" field.
func (m *ReversalApplicationIPMutation) ResetEmployeePost() {
	m._EmployeePost = nil
	delete(m.clearedFields, reversal_application_ip.FieldEmployeePost)
}

// SetFacilityID sets the "FacilityID" field.
func (m *ReversalApplicationIPMutation) SetFacilityID(s string) {
	m._FacilityID = &s
}

// FacilityID returns the value of the "FacilityID" field in the mutation.
func (m *ReversalApplicationIPMutation) FacilityID() (r string, exists bool) {
	v := m._FacilityID
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityID returns the old "FacilityID" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldFacilityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityID: %w", err)
	}
	return oldValue.FacilityID, nil
}

// ClearFacilityID clears the value of the "FacilityID" field.
func (m *ReversalApplicationIPMutation) ClearFacilityID() {
	m._FacilityID = nil
	m.clearedFields[reversal_application_ip.FieldFacilityID] = struct{}{}
}

// FacilityIDCleared returns if the "FacilityID" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) FacilityIDCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldFacilityID]
	return ok
}

// ResetFacilityID resets all changes to the "FacilityID" field.
func (m *ReversalApplicationIPMutation) ResetFacilityID() {
	m._FacilityID = nil
	delete(m.clearedFields, reversal_application_ip.FieldFacilityID)
}

// SetDCCS sets the "DCCS" field.
func (m *ReversalApplicationIPMutation) SetDCCS(s string) {
	m._DCCS = &s
}

// DCCS returns the value of the "DCCS" field in the mutation.
func (m *ReversalApplicationIPMutation) DCCS() (r string, exists bool) {
	v := m._DCCS
	if v == nil {
		return
	}
	return *v, true
}

// OldDCCS returns the old "DCCS" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldDCCS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCCS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCCS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCCS: %w", err)
	}
	return oldValue.DCCS, nil
}

// ClearDCCS clears the value of the "DCCS" field.
func (m *ReversalApplicationIPMutation) ClearDCCS() {
	m._DCCS = nil
	m.clearedFields[reversal_application_ip.FieldDCCS] = struct{}{}
}

// DCCSCleared returns if the "DCCS" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) DCCSCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldDCCS]
	return ok
}

// ResetDCCS resets all changes to the "DCCS" field.
func (m *ReversalApplicationIPMutation) ResetDCCS() {
	m._DCCS = nil
	delete(m.clearedFields, reversal_application_ip.FieldDCCS)
}

// SetDCInPresentCadre sets the "DCInPresentCadre" field.
func (m *ReversalApplicationIPMutation) SetDCInPresentCadre(s string) {
	m._DCInPresentCadre = &s
}

// DCInPresentCadre returns the value of the "DCInPresentCadre" field in the mutation.
func (m *ReversalApplicationIPMutation) DCInPresentCadre() (r string, exists bool) {
	v := m._DCInPresentCadre
	if v == nil {
		return
	}
	return *v, true
}

// OldDCInPresentCadre returns the old "DCInPresentCadre" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldDCInPresentCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDCInPresentCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDCInPresentCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDCInPresentCadre: %w", err)
	}
	return oldValue.DCInPresentCadre, nil
}

// ClearDCInPresentCadre clears the value of the "DCInPresentCadre" field.
func (m *ReversalApplicationIPMutation) ClearDCInPresentCadre() {
	m._DCInPresentCadre = nil
	m.clearedFields[reversal_application_ip.FieldDCInPresentCadre] = struct{}{}
}

// DCInPresentCadreCleared returns if the "DCInPresentCadre" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) DCInPresentCadreCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldDCInPresentCadre]
	return ok
}

// ResetDCInPresentCadre resets all changes to the "DCInPresentCadre" field.
func (m *ReversalApplicationIPMutation) ResetDCInPresentCadre() {
	m._DCInPresentCadre = nil
	delete(m.clearedFields, reversal_application_ip.FieldDCInPresentCadre)
}

// SetDeputationOfficeId sets the "DeputationOfficeId" field.
func (m *ReversalApplicationIPMutation) SetDeputationOfficeId(s string) {
	m._DeputationOfficeId = &s
}

// DeputationOfficeId returns the value of the "DeputationOfficeId" field in the mutation.
func (m *ReversalApplicationIPMutation) DeputationOfficeId() (r string, exists bool) {
	v := m._DeputationOfficeId
	if v == nil {
		return
	}
	return *v, true
}

// OldDeputationOfficeId returns the old "DeputationOfficeId" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldDeputationOfficeId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeputationOfficeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeputationOfficeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeputationOfficeId: %w", err)
	}
	return oldValue.DeputationOfficeId, nil
}

// ClearDeputationOfficeId clears the value of the "DeputationOfficeId" field.
func (m *ReversalApplicationIPMutation) ClearDeputationOfficeId() {
	m._DeputationOfficeId = nil
	m.clearedFields[reversal_application_ip.FieldDeputationOfficeId] = struct{}{}
}

// DeputationOfficeIdCleared returns if the "DeputationOfficeId" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) DeputationOfficeIdCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldDeputationOfficeId]
	return ok
}

// ResetDeputationOfficeId resets all changes to the "DeputationOfficeId" field.
func (m *ReversalApplicationIPMutation) ResetDeputationOfficeId() {
	m._DeputationOfficeId = nil
	delete(m.clearedFields, reversal_application_ip.FieldDeputationOfficeId)
}

// SetDisabilityType sets the "DisabilityType" field.
func (m *ReversalApplicationIPMutation) SetDisabilityType(s string) {
	m._DisabilityType = &s
}

// DisabilityType returns the value of the "DisabilityType" field in the mutation.
func (m *ReversalApplicationIPMutation) DisabilityType() (r string, exists bool) {
	v := m._DisabilityType
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityType returns the old "DisabilityType" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldDisabilityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityType: %w", err)
	}
	return oldValue.DisabilityType, nil
}

// ClearDisabilityType clears the value of the "DisabilityType" field.
func (m *ReversalApplicationIPMutation) ClearDisabilityType() {
	m._DisabilityType = nil
	m.clearedFields[reversal_application_ip.FieldDisabilityType] = struct{}{}
}

// DisabilityTypeCleared returns if the "DisabilityType" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) DisabilityTypeCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldDisabilityType]
	return ok
}

// ResetDisabilityType resets all changes to the "DisabilityType" field.
func (m *ReversalApplicationIPMutation) ResetDisabilityType() {
	m._DisabilityType = nil
	delete(m.clearedFields, reversal_application_ip.FieldDisabilityType)
}

// SetDisabilityPercentage sets the "DisabilityPercentage" field.
func (m *ReversalApplicationIPMutation) SetDisabilityPercentage(s string) {
	m._DisabilityPercentage = &s
}

// DisabilityPercentage returns the value of the "DisabilityPercentage" field in the mutation.
func (m *ReversalApplicationIPMutation) DisabilityPercentage() (r string, exists bool) {
	v := m._DisabilityPercentage
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabilityPercentage returns the old "DisabilityPercentage" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldDisabilityPercentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabilityPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabilityPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabilityPercentage: %w", err)
	}
	return oldValue.DisabilityPercentage, nil
}

// ClearDisabilityPercentage clears the value of the "DisabilityPercentage" field.
func (m *ReversalApplicationIPMutation) ClearDisabilityPercentage() {
	m._DisabilityPercentage = nil
	m.clearedFields[reversal_application_ip.FieldDisabilityPercentage] = struct{}{}
}

// DisabilityPercentageCleared returns if the "DisabilityPercentage" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) DisabilityPercentageCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldDisabilityPercentage]
	return ok
}

// ResetDisabilityPercentage resets all changes to the "DisabilityPercentage" field.
func (m *ReversalApplicationIPMutation) ResetDisabilityPercentage() {
	m._DisabilityPercentage = nil
	delete(m.clearedFields, reversal_application_ip.FieldDisabilityPercentage)
}

// SetEducation sets the "Education" field.
func (m *ReversalApplicationIPMutation) SetEducation(s string) {
	m._Education = &s
}

// Education returns the value of the "Education" field in the mutation.
func (m *ReversalApplicationIPMutation) Education() (r string, exists bool) {
	v := m._Education
	if v == nil {
		return
	}
	return *v, true
}

// OldEducation returns the old "Education" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldEducation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducation: %w", err)
	}
	return oldValue.Education, nil
}

// ClearEducation clears the value of the "Education" field.
func (m *ReversalApplicationIPMutation) ClearEducation() {
	m._Education = nil
	m.clearedFields[reversal_application_ip.FieldEducation] = struct{}{}
}

// EducationCleared returns if the "Education" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) EducationCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldEducation]
	return ok
}

// ResetEducation resets all changes to the "Education" field.
func (m *ReversalApplicationIPMutation) ResetEducation() {
	m._Education = nil
	delete(m.clearedFields, reversal_application_ip.FieldEducation)
}

// SetExamCodeIP sets the "ExamCodeIP" field.
func (m *ReversalApplicationIPMutation) SetExamCodeIP(i int32) {
	m._ExamCodeIP = &i
	m.add_ExamCodeIP = nil
}

// ExamCodeIP returns the value of the "ExamCodeIP" field in the mutation.
func (m *ReversalApplicationIPMutation) ExamCodeIP() (r int32, exists bool) {
	v := m._ExamCodeIP
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCodeIP returns the old "ExamCodeIP" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldExamCodeIP(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCodeIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCodeIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCodeIP: %w", err)
	}
	return oldValue.ExamCodeIP, nil
}

// AddExamCodeIP adds i to the "ExamCodeIP" field.
func (m *ReversalApplicationIPMutation) AddExamCodeIP(i int32) {
	if m.add_ExamCodeIP != nil {
		*m.add_ExamCodeIP += i
	} else {
		m.add_ExamCodeIP = &i
	}
}

// AddedExamCodeIP returns the value that was added to the "ExamCodeIP" field in this mutation.
func (m *ReversalApplicationIPMutation) AddedExamCodeIP() (r int32, exists bool) {
	v := m.add_ExamCodeIP
	if v == nil {
		return
	}
	return *v, true
}

// ClearExamCodeIP clears the value of the "ExamCodeIP" field.
func (m *ReversalApplicationIPMutation) ClearExamCodeIP() {
	m._ExamCodeIP = nil
	m.add_ExamCodeIP = nil
	m.clearedFields[reversal_application_ip.FieldExamCodeIP] = struct{}{}
}

// ExamCodeIPCleared returns if the "ExamCodeIP" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) ExamCodeIPCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldExamCodeIP]
	return ok
}

// ResetExamCodeIP resets all changes to the "ExamCodeIP" field.
func (m *ReversalApplicationIPMutation) ResetExamCodeIP() {
	m._ExamCodeIP = nil
	m.add_ExamCodeIP = nil
	delete(m.clearedFields, reversal_application_ip.FieldExamCodeIP)
}

// SetExamYear sets the "ExamYear" field.
func (m *ReversalApplicationIPMutation) SetExamYear(s string) {
	m._ExamYear = &s
}

// ExamYear returns the value of the "ExamYear" field in the mutation.
func (m *ReversalApplicationIPMutation) ExamYear() (r string, exists bool) {
	v := m._ExamYear
	if v == nil {
		return
	}
	return *v, true
}

// OldExamYear returns the old "ExamYear" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldExamYear(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamYear: %w", err)
	}
	return oldValue.ExamYear, nil
}

// ClearExamYear clears the value of the "ExamYear" field.
func (m *ReversalApplicationIPMutation) ClearExamYear() {
	m._ExamYear = nil
	m.clearedFields[reversal_application_ip.FieldExamYear] = struct{}{}
}

// ExamYearCleared returns if the "ExamYear" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) ExamYearCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldExamYear]
	return ok
}

// ResetExamYear resets all changes to the "ExamYear" field.
func (m *ReversalApplicationIPMutation) ResetExamYear() {
	m._ExamYear = nil
	delete(m.clearedFields, reversal_application_ip.FieldExamYear)
}

// SetCentrePreference sets the "CentrePreference" field.
func (m *ReversalApplicationIPMutation) SetCentrePreference(s string) {
	m._CentrePreference = &s
}

// CentrePreference returns the value of the "CentrePreference" field in the mutation.
func (m *ReversalApplicationIPMutation) CentrePreference() (r string, exists bool) {
	v := m._CentrePreference
	if v == nil {
		return
	}
	return *v, true
}

// OldCentrePreference returns the old "CentrePreference" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldCentrePreference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCentrePreference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCentrePreference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCentrePreference: %w", err)
	}
	return oldValue.CentrePreference, nil
}

// ClearCentrePreference clears the value of the "CentrePreference" field.
func (m *ReversalApplicationIPMutation) ClearCentrePreference() {
	m._CentrePreference = nil
	m.clearedFields[reversal_application_ip.FieldCentrePreference] = struct{}{}
}

// CentrePreferenceCleared returns if the "CentrePreference" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) CentrePreferenceCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldCentrePreference]
	return ok
}

// ResetCentrePreference resets all changes to the "CentrePreference" field.
func (m *ReversalApplicationIPMutation) ResetCentrePreference() {
	m._CentrePreference = nil
	delete(m.clearedFields, reversal_application_ip.FieldCentrePreference)
}

// SetSignature sets the "Signature" field.
func (m *ReversalApplicationIPMutation) SetSignature(s string) {
	m._Signature = &s
}

// Signature returns the value of the "Signature" field in the mutation.
func (m *ReversalApplicationIPMutation) Signature() (r string, exists bool) {
	v := m._Signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "Signature" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "Signature" field.
func (m *ReversalApplicationIPMutation) ClearSignature() {
	m._Signature = nil
	m.clearedFields[reversal_application_ip.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "Signature" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "Signature" field.
func (m *ReversalApplicationIPMutation) ResetSignature() {
	m._Signature = nil
	delete(m.clearedFields, reversal_application_ip.FieldSignature)
}

// SetPhoto sets the "Photo" field.
func (m *ReversalApplicationIPMutation) SetPhoto(s string) {
	m._Photo = &s
}

// Photo returns the value of the "Photo" field in the mutation.
func (m *ReversalApplicationIPMutation) Photo() (r string, exists bool) {
	v := m._Photo
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoto returns the old "Photo" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoto: %w", err)
	}
	return oldValue.Photo, nil
}

// ClearPhoto clears the value of the "Photo" field.
func (m *ReversalApplicationIPMutation) ClearPhoto() {
	m._Photo = nil
	m.clearedFields[reversal_application_ip.FieldPhoto] = struct{}{}
}

// PhotoCleared returns if the "Photo" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) PhotoCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldPhoto]
	return ok
}

// ResetPhoto resets all changes to the "Photo" field.
func (m *ReversalApplicationIPMutation) ResetPhoto() {
	m._Photo = nil
	delete(m.clearedFields, reversal_application_ip.FieldPhoto)
}

// SetApplicationStatus sets the "ApplicationStatus" field.
func (m *ReversalApplicationIPMutation) SetApplicationStatus(s string) {
	m._ApplicationStatus = &s
}

// ApplicationStatus returns the value of the "ApplicationStatus" field in the mutation.
func (m *ReversalApplicationIPMutation) ApplicationStatus() (r string, exists bool) {
	v := m._ApplicationStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationStatus returns the old "ApplicationStatus" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldApplicationStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationStatus: %w", err)
	}
	return oldValue.ApplicationStatus, nil
}

// ClearApplicationStatus clears the value of the "ApplicationStatus" field.
func (m *ReversalApplicationIPMutation) ClearApplicationStatus() {
	m._ApplicationStatus = nil
	m.clearedFields[reversal_application_ip.FieldApplicationStatus] = struct{}{}
}

// ApplicationStatusCleared returns if the "ApplicationStatus" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) ApplicationStatusCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldApplicationStatus]
	return ok
}

// ResetApplicationStatus resets all changes to the "ApplicationStatus" field.
func (m *ReversalApplicationIPMutation) ResetApplicationStatus() {
	m._ApplicationStatus = nil
	delete(m.clearedFields, reversal_application_ip.FieldApplicationStatus)
}

// SetReversalApplnSubmittedDate sets the "ReversalApplnSubmittedDate" field.
func (m *ReversalApplicationIPMutation) SetReversalApplnSubmittedDate(t time.Time) {
	m._ReversalApplnSubmittedDate = &t
}

// ReversalApplnSubmittedDate returns the value of the "ReversalApplnSubmittedDate" field in the mutation.
func (m *ReversalApplicationIPMutation) ReversalApplnSubmittedDate() (r time.Time, exists bool) {
	v := m._ReversalApplnSubmittedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldReversalApplnSubmittedDate returns the old "ReversalApplnSubmittedDate" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldReversalApplnSubmittedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReversalApplnSubmittedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReversalApplnSubmittedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReversalApplnSubmittedDate: %w", err)
	}
	return oldValue.ReversalApplnSubmittedDate, nil
}

// ClearReversalApplnSubmittedDate clears the value of the "ReversalApplnSubmittedDate" field.
func (m *ReversalApplicationIPMutation) ClearReversalApplnSubmittedDate() {
	m._ReversalApplnSubmittedDate = nil
	m.clearedFields[reversal_application_ip.FieldReversalApplnSubmittedDate] = struct{}{}
}

// ReversalApplnSubmittedDateCleared returns if the "ReversalApplnSubmittedDate" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) ReversalApplnSubmittedDateCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldReversalApplnSubmittedDate]
	return ok
}

// ResetReversalApplnSubmittedDate resets all changes to the "ReversalApplnSubmittedDate" field.
func (m *ReversalApplicationIPMutation) ResetReversalApplnSubmittedDate() {
	m._ReversalApplnSubmittedDate = nil
	delete(m.clearedFields, reversal_application_ip.FieldReversalApplnSubmittedDate)
}

// SetVARemarks sets the "VA_Remarks" field.
func (m *ReversalApplicationIPMutation) SetVARemarks(s string) {
	m._VA_Remarks = &s
}

// VARemarks returns the value of the "VA_Remarks" field in the mutation.
func (m *ReversalApplicationIPMutation) VARemarks() (r string, exists bool) {
	v := m._VA_Remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldVARemarks returns the old "VA_Remarks" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldVARemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVARemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVARemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVARemarks: %w", err)
	}
	return oldValue.VARemarks, nil
}

// ClearVARemarks clears the value of the "VA_Remarks" field.
func (m *ReversalApplicationIPMutation) ClearVARemarks() {
	m._VA_Remarks = nil
	m.clearedFields[reversal_application_ip.FieldVARemarks] = struct{}{}
}

// VARemarksCleared returns if the "VA_Remarks" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) VARemarksCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldVARemarks]
	return ok
}

// ResetVARemarks resets all changes to the "VA_Remarks" field.
func (m *ReversalApplicationIPMutation) ResetVARemarks() {
	m._VA_Remarks = nil
	delete(m.clearedFields, reversal_application_ip.FieldVARemarks)
}

// SetVAUserName sets the "VA_UserName" field.
func (m *ReversalApplicationIPMutation) SetVAUserName(s string) {
	m._VA_UserName = &s
}

// VAUserName returns the value of the "VA_UserName" field in the mutation.
func (m *ReversalApplicationIPMutation) VAUserName() (r string, exists bool) {
	v := m._VA_UserName
	if v == nil {
		return
	}
	return *v, true
}

// OldVAUserName returns the old "VA_UserName" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldVAUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVAUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVAUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVAUserName: %w", err)
	}
	return oldValue.VAUserName, nil
}

// ClearVAUserName clears the value of the "VA_UserName" field.
func (m *ReversalApplicationIPMutation) ClearVAUserName() {
	m._VA_UserName = nil
	m.clearedFields[reversal_application_ip.FieldVAUserName] = struct{}{}
}

// VAUserNameCleared returns if the "VA_UserName" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) VAUserNameCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldVAUserName]
	return ok
}

// ResetVAUserName resets all changes to the "VA_UserName" field.
func (m *ReversalApplicationIPMutation) ResetVAUserName() {
	m._VA_UserName = nil
	delete(m.clearedFields, reversal_application_ip.FieldVAUserName)
}

// SetVADate sets the "VA_Date" field.
func (m *ReversalApplicationIPMutation) SetVADate(t time.Time) {
	m._VA_Date = &t
}

// VADate returns the value of the "VA_Date" field in the mutation.
func (m *ReversalApplicationIPMutation) VADate() (r time.Time, exists bool) {
	v := m._VA_Date
	if v == nil {
		return
	}
	return *v, true
}

// OldVADate returns the old "VA_Date" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldVADate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVADate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVADate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVADate: %w", err)
	}
	return oldValue.VADate, nil
}

// ClearVADate clears the value of the "VA_Date" field.
func (m *ReversalApplicationIPMutation) ClearVADate() {
	m._VA_Date = nil
	m.clearedFields[reversal_application_ip.FieldVADate] = struct{}{}
}

// VADateCleared returns if the "VA_Date" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) VADateCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldVADate]
	return ok
}

// ResetVADate resets all changes to the "VA_Date" field.
func (m *ReversalApplicationIPMutation) ResetVADate() {
	m._VA_Date = nil
	delete(m.clearedFields, reversal_application_ip.FieldVADate)
}

// SetCARemarks sets the "CA_Remarks" field.
func (m *ReversalApplicationIPMutation) SetCARemarks(s string) {
	m._CA_Remarks = &s
}

// CARemarks returns the value of the "CA_Remarks" field in the mutation.
func (m *ReversalApplicationIPMutation) CARemarks() (r string, exists bool) {
	v := m._CA_Remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldCARemarks returns the old "CA_Remarks" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldCARemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCARemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCARemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCARemarks: %w", err)
	}
	return oldValue.CARemarks, nil
}

// ClearCARemarks clears the value of the "CA_Remarks" field.
func (m *ReversalApplicationIPMutation) ClearCARemarks() {
	m._CA_Remarks = nil
	m.clearedFields[reversal_application_ip.FieldCARemarks] = struct{}{}
}

// CARemarksCleared returns if the "CA_Remarks" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) CARemarksCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldCARemarks]
	return ok
}

// ResetCARemarks resets all changes to the "CA_Remarks" field.
func (m *ReversalApplicationIPMutation) ResetCARemarks() {
	m._CA_Remarks = nil
	delete(m.clearedFields, reversal_application_ip.FieldCARemarks)
}

// SetCAUserName sets the "CA_UserName" field.
func (m *ReversalApplicationIPMutation) SetCAUserName(s string) {
	m._CA_UserName = &s
}

// CAUserName returns the value of the "CA_UserName" field in the mutation.
func (m *ReversalApplicationIPMutation) CAUserName() (r string, exists bool) {
	v := m._CA_UserName
	if v == nil {
		return
	}
	return *v, true
}

// OldCAUserName returns the old "CA_UserName" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldCAUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCAUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCAUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCAUserName: %w", err)
	}
	return oldValue.CAUserName, nil
}

// ClearCAUserName clears the value of the "CA_UserName" field.
func (m *ReversalApplicationIPMutation) ClearCAUserName() {
	m._CA_UserName = nil
	m.clearedFields[reversal_application_ip.FieldCAUserName] = struct{}{}
}

// CAUserNameCleared returns if the "CA_UserName" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) CAUserNameCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldCAUserName]
	return ok
}

// ResetCAUserName resets all changes to the "CA_UserName" field.
func (m *ReversalApplicationIPMutation) ResetCAUserName() {
	m._CA_UserName = nil
	delete(m.clearedFields, reversal_application_ip.FieldCAUserName)
}

// SetCADate sets the "CA_Date" field.
func (m *ReversalApplicationIPMutation) SetCADate(t time.Time) {
	m._CA_Date = &t
}

// CADate returns the value of the "CA_Date" field in the mutation.
func (m *ReversalApplicationIPMutation) CADate() (r time.Time, exists bool) {
	v := m._CA_Date
	if v == nil {
		return
	}
	return *v, true
}

// OldCADate returns the old "CA_Date" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldCADate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCADate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCADate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCADate: %w", err)
	}
	return oldValue.CADate, nil
}

// ClearCADate clears the value of the "CA_Date" field.
func (m *ReversalApplicationIPMutation) ClearCADate() {
	m._CA_Date = nil
	m.clearedFields[reversal_application_ip.FieldCADate] = struct{}{}
}

// CADateCleared returns if the "CA_Date" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) CADateCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldCADate]
	return ok
}

// ResetCADate resets all changes to the "CA_Date" field.
func (m *ReversalApplicationIPMutation) ResetCADate() {
	m._CA_Date = nil
	delete(m.clearedFields, reversal_application_ip.FieldCADate)
}

// SetAppliactionRemarks sets the "AppliactionRemarks" field.
func (m *ReversalApplicationIPMutation) SetAppliactionRemarks(s string) {
	m._AppliactionRemarks = &s
}

// AppliactionRemarks returns the value of the "AppliactionRemarks" field in the mutation.
func (m *ReversalApplicationIPMutation) AppliactionRemarks() (r string, exists bool) {
	v := m._AppliactionRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliactionRemarks returns the old "AppliactionRemarks" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldAppliactionRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliactionRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliactionRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliactionRemarks: %w", err)
	}
	return oldValue.AppliactionRemarks, nil
}

// ClearAppliactionRemarks clears the value of the "AppliactionRemarks" field.
func (m *ReversalApplicationIPMutation) ClearAppliactionRemarks() {
	m._AppliactionRemarks = nil
	m.clearedFields[reversal_application_ip.FieldAppliactionRemarks] = struct{}{}
}

// AppliactionRemarksCleared returns if the "AppliactionRemarks" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) AppliactionRemarksCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldAppliactionRemarks]
	return ok
}

// ResetAppliactionRemarks resets all changes to the "AppliactionRemarks" field.
func (m *ReversalApplicationIPMutation) ResetAppliactionRemarks() {
	m._AppliactionRemarks = nil
	delete(m.clearedFields, reversal_application_ip.FieldAppliactionRemarks)
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *ReversalApplicationIPMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *ReversalApplicationIPMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "UpdatedAt" field.
func (m *ReversalApplicationIPMutation) ClearUpdatedAt() {
	m._UpdatedAt = nil
	m.clearedFields[reversal_application_ip.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "UpdatedAt" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *ReversalApplicationIPMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
	delete(m.clearedFields, reversal_application_ip.FieldUpdatedAt)
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *ReversalApplicationIPMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *ReversalApplicationIPMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "UpdatedBy" field.
func (m *ReversalApplicationIPMutation) ClearUpdatedBy() {
	m._UpdatedBy = nil
	m.clearedFields[reversal_application_ip.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "UpdatedBy" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *ReversalApplicationIPMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
	delete(m.clearedFields, reversal_application_ip.FieldUpdatedBy)
}

// SetRoleUserCode sets the "RoleUserCode" field.
func (m *ReversalApplicationIPMutation) SetRoleUserCode(i int32) {
	m._RoleUserCode = &i
	m.add_RoleUserCode = nil
}

// RoleUserCode returns the value of the "RoleUserCode" field in the mutation.
func (m *ReversalApplicationIPMutation) RoleUserCode() (r int32, exists bool) {
	v := m._RoleUserCode
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleUserCode returns the old "RoleUserCode" field's value of the Reversal_Application_IP entity.
// If the Reversal_Application_IP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReversalApplicationIPMutation) OldRoleUserCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleUserCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleUserCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleUserCode: %w", err)
	}
	return oldValue.RoleUserCode, nil
}

// AddRoleUserCode adds i to the "RoleUserCode" field.
func (m *ReversalApplicationIPMutation) AddRoleUserCode(i int32) {
	if m.add_RoleUserCode != nil {
		*m.add_RoleUserCode += i
	} else {
		m.add_RoleUserCode = &i
	}
}

// AddedRoleUserCode returns the value that was added to the "RoleUserCode" field in this mutation.
func (m *ReversalApplicationIPMutation) AddedRoleUserCode() (r int32, exists bool) {
	v := m.add_RoleUserCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoleUserCode clears the value of the "RoleUserCode" field.
func (m *ReversalApplicationIPMutation) ClearRoleUserCode() {
	m._RoleUserCode = nil
	m.add_RoleUserCode = nil
	m.clearedFields[reversal_application_ip.FieldRoleUserCode] = struct{}{}
}

// RoleUserCodeCleared returns if the "RoleUserCode" field was cleared in this mutation.
func (m *ReversalApplicationIPMutation) RoleUserCodeCleared() bool {
	_, ok := m.clearedFields[reversal_application_ip.FieldRoleUserCode]
	return ok
}

// ResetRoleUserCode resets all changes to the "RoleUserCode" field.
func (m *ReversalApplicationIPMutation) ResetRoleUserCode() {
	m._RoleUserCode = nil
	m.add_RoleUserCode = nil
	delete(m.clearedFields, reversal_application_ip.FieldRoleUserCode)
}

// Where appends a list predicates to the ReversalApplicationIPMutation builder.
func (m *ReversalApplicationIPMutation) Where(ps ...predicate.Reversal_Application_IP) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReversalApplicationIPMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReversalApplicationIPMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Reversal_Application_IP, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReversalApplicationIPMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReversalApplicationIPMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Reversal_Application_IP).
func (m *ReversalApplicationIPMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReversalApplicationIPMutation) Fields() []string {
	fields := make([]string, 0, 33)
	if m._EmployeeID != nil {
		fields = append(fields, reversal_application_ip.FieldEmployeeID)
	}
	if m._EmployeeName != nil {
		fields = append(fields, reversal_application_ip.FieldEmployeeName)
	}
	if m._DOB != nil {
		fields = append(fields, reversal_application_ip.FieldDOB)
	}
	if m._Gender != nil {
		fields = append(fields, reversal_application_ip.FieldGender)
	}
	if m._MobileNumber != nil {
		fields = append(fields, reversal_application_ip.FieldMobileNumber)
	}
	if m._EmailID != nil {
		fields = append(fields, reversal_application_ip.FieldEmailID)
	}
	if m._EmployeeCategory != nil {
		fields = append(fields, reversal_application_ip.FieldEmployeeCategory)
	}
	if m._Cadre != nil {
		fields = append(fields, reversal_application_ip.FieldCadre)
	}
	if m._EmployeePost != nil {
		fields = append(fields, reversal_application_ip.FieldEmployeePost)
	}
	if m._FacilityID != nil {
		fields = append(fields, reversal_application_ip.FieldFacilityID)
	}
	if m._DCCS != nil {
		fields = append(fields, reversal_application_ip.FieldDCCS)
	}
	if m._DCInPresentCadre != nil {
		fields = append(fields, reversal_application_ip.FieldDCInPresentCadre)
	}
	if m._DeputationOfficeId != nil {
		fields = append(fields, reversal_application_ip.FieldDeputationOfficeId)
	}
	if m._DisabilityType != nil {
		fields = append(fields, reversal_application_ip.FieldDisabilityType)
	}
	if m._DisabilityPercentage != nil {
		fields = append(fields, reversal_application_ip.FieldDisabilityPercentage)
	}
	if m._Education != nil {
		fields = append(fields, reversal_application_ip.FieldEducation)
	}
	if m._ExamCodeIP != nil {
		fields = append(fields, reversal_application_ip.FieldExamCodeIP)
	}
	if m._ExamYear != nil {
		fields = append(fields, reversal_application_ip.FieldExamYear)
	}
	if m._CentrePreference != nil {
		fields = append(fields, reversal_application_ip.FieldCentrePreference)
	}
	if m._Signature != nil {
		fields = append(fields, reversal_application_ip.FieldSignature)
	}
	if m._Photo != nil {
		fields = append(fields, reversal_application_ip.FieldPhoto)
	}
	if m._ApplicationStatus != nil {
		fields = append(fields, reversal_application_ip.FieldApplicationStatus)
	}
	if m._ReversalApplnSubmittedDate != nil {
		fields = append(fields, reversal_application_ip.FieldReversalApplnSubmittedDate)
	}
	if m._VA_Remarks != nil {
		fields = append(fields, reversal_application_ip.FieldVARemarks)
	}
	if m._VA_UserName != nil {
		fields = append(fields, reversal_application_ip.FieldVAUserName)
	}
	if m._VA_Date != nil {
		fields = append(fields, reversal_application_ip.FieldVADate)
	}
	if m._CA_Remarks != nil {
		fields = append(fields, reversal_application_ip.FieldCARemarks)
	}
	if m._CA_UserName != nil {
		fields = append(fields, reversal_application_ip.FieldCAUserName)
	}
	if m._CA_Date != nil {
		fields = append(fields, reversal_application_ip.FieldCADate)
	}
	if m._AppliactionRemarks != nil {
		fields = append(fields, reversal_application_ip.FieldAppliactionRemarks)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, reversal_application_ip.FieldUpdatedAt)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, reversal_application_ip.FieldUpdatedBy)
	}
	if m._RoleUserCode != nil {
		fields = append(fields, reversal_application_ip.FieldRoleUserCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReversalApplicationIPMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reversal_application_ip.FieldEmployeeID:
		return m.EmployeeID()
	case reversal_application_ip.FieldEmployeeName:
		return m.EmployeeName()
	case reversal_application_ip.FieldDOB:
		return m.DOB()
	case reversal_application_ip.FieldGender:
		return m.Gender()
	case reversal_application_ip.FieldMobileNumber:
		return m.MobileNumber()
	case reversal_application_ip.FieldEmailID:
		return m.EmailID()
	case reversal_application_ip.FieldEmployeeCategory:
		return m.EmployeeCategory()
	case reversal_application_ip.FieldCadre:
		return m.Cadre()
	case reversal_application_ip.FieldEmployeePost:
		return m.EmployeePost()
	case reversal_application_ip.FieldFacilityID:
		return m.FacilityID()
	case reversal_application_ip.FieldDCCS:
		return m.DCCS()
	case reversal_application_ip.FieldDCInPresentCadre:
		return m.DCInPresentCadre()
	case reversal_application_ip.FieldDeputationOfficeId:
		return m.DeputationOfficeId()
	case reversal_application_ip.FieldDisabilityType:
		return m.DisabilityType()
	case reversal_application_ip.FieldDisabilityPercentage:
		return m.DisabilityPercentage()
	case reversal_application_ip.FieldEducation:
		return m.Education()
	case reversal_application_ip.FieldExamCodeIP:
		return m.ExamCodeIP()
	case reversal_application_ip.FieldExamYear:
		return m.ExamYear()
	case reversal_application_ip.FieldCentrePreference:
		return m.CentrePreference()
	case reversal_application_ip.FieldSignature:
		return m.Signature()
	case reversal_application_ip.FieldPhoto:
		return m.Photo()
	case reversal_application_ip.FieldApplicationStatus:
		return m.ApplicationStatus()
	case reversal_application_ip.FieldReversalApplnSubmittedDate:
		return m.ReversalApplnSubmittedDate()
	case reversal_application_ip.FieldVARemarks:
		return m.VARemarks()
	case reversal_application_ip.FieldVAUserName:
		return m.VAUserName()
	case reversal_application_ip.FieldVADate:
		return m.VADate()
	case reversal_application_ip.FieldCARemarks:
		return m.CARemarks()
	case reversal_application_ip.FieldCAUserName:
		return m.CAUserName()
	case reversal_application_ip.FieldCADate:
		return m.CADate()
	case reversal_application_ip.FieldAppliactionRemarks:
		return m.AppliactionRemarks()
	case reversal_application_ip.FieldUpdatedAt:
		return m.UpdatedAt()
	case reversal_application_ip.FieldUpdatedBy:
		return m.UpdatedBy()
	case reversal_application_ip.FieldRoleUserCode:
		return m.RoleUserCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReversalApplicationIPMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reversal_application_ip.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case reversal_application_ip.FieldEmployeeName:
		return m.OldEmployeeName(ctx)
	case reversal_application_ip.FieldDOB:
		return m.OldDOB(ctx)
	case reversal_application_ip.FieldGender:
		return m.OldGender(ctx)
	case reversal_application_ip.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case reversal_application_ip.FieldEmailID:
		return m.OldEmailID(ctx)
	case reversal_application_ip.FieldEmployeeCategory:
		return m.OldEmployeeCategory(ctx)
	case reversal_application_ip.FieldCadre:
		return m.OldCadre(ctx)
	case reversal_application_ip.FieldEmployeePost:
		return m.OldEmployeePost(ctx)
	case reversal_application_ip.FieldFacilityID:
		return m.OldFacilityID(ctx)
	case reversal_application_ip.FieldDCCS:
		return m.OldDCCS(ctx)
	case reversal_application_ip.FieldDCInPresentCadre:
		return m.OldDCInPresentCadre(ctx)
	case reversal_application_ip.FieldDeputationOfficeId:
		return m.OldDeputationOfficeId(ctx)
	case reversal_application_ip.FieldDisabilityType:
		return m.OldDisabilityType(ctx)
	case reversal_application_ip.FieldDisabilityPercentage:
		return m.OldDisabilityPercentage(ctx)
	case reversal_application_ip.FieldEducation:
		return m.OldEducation(ctx)
	case reversal_application_ip.FieldExamCodeIP:
		return m.OldExamCodeIP(ctx)
	case reversal_application_ip.FieldExamYear:
		return m.OldExamYear(ctx)
	case reversal_application_ip.FieldCentrePreference:
		return m.OldCentrePreference(ctx)
	case reversal_application_ip.FieldSignature:
		return m.OldSignature(ctx)
	case reversal_application_ip.FieldPhoto:
		return m.OldPhoto(ctx)
	case reversal_application_ip.FieldApplicationStatus:
		return m.OldApplicationStatus(ctx)
	case reversal_application_ip.FieldReversalApplnSubmittedDate:
		return m.OldReversalApplnSubmittedDate(ctx)
	case reversal_application_ip.FieldVARemarks:
		return m.OldVARemarks(ctx)
	case reversal_application_ip.FieldVAUserName:
		return m.OldVAUserName(ctx)
	case reversal_application_ip.FieldVADate:
		return m.OldVADate(ctx)
	case reversal_application_ip.FieldCARemarks:
		return m.OldCARemarks(ctx)
	case reversal_application_ip.FieldCAUserName:
		return m.OldCAUserName(ctx)
	case reversal_application_ip.FieldCADate:
		return m.OldCADate(ctx)
	case reversal_application_ip.FieldAppliactionRemarks:
		return m.OldAppliactionRemarks(ctx)
	case reversal_application_ip.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case reversal_application_ip.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case reversal_application_ip.FieldRoleUserCode:
		return m.OldRoleUserCode(ctx)
	}
	return nil, fmt.Errorf("unknown Reversal_Application_IP field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReversalApplicationIPMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reversal_application_ip.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case reversal_application_ip.FieldEmployeeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeName(v)
		return nil
	case reversal_application_ip.FieldDOB:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOB(v)
		return nil
	case reversal_application_ip.FieldGender:
		v, ok := value.(reversal_application_ip.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case reversal_application_ip.FieldMobileNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case reversal_application_ip.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case reversal_application_ip.FieldEmployeeCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCategory(v)
		return nil
	case reversal_application_ip.FieldCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadre(v)
		return nil
	case reversal_application_ip.FieldEmployeePost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeePost(v)
		return nil
	case reversal_application_ip.FieldFacilityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityID(v)
		return nil
	case reversal_application_ip.FieldDCCS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCCS(v)
		return nil
	case reversal_application_ip.FieldDCInPresentCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDCInPresentCadre(v)
		return nil
	case reversal_application_ip.FieldDeputationOfficeId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeputationOfficeId(v)
		return nil
	case reversal_application_ip.FieldDisabilityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityType(v)
		return nil
	case reversal_application_ip.FieldDisabilityPercentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabilityPercentage(v)
		return nil
	case reversal_application_ip.FieldEducation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducation(v)
		return nil
	case reversal_application_ip.FieldExamCodeIP:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCodeIP(v)
		return nil
	case reversal_application_ip.FieldExamYear:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamYear(v)
		return nil
	case reversal_application_ip.FieldCentrePreference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCentrePreference(v)
		return nil
	case reversal_application_ip.FieldSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case reversal_application_ip.FieldPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoto(v)
		return nil
	case reversal_application_ip.FieldApplicationStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationStatus(v)
		return nil
	case reversal_application_ip.FieldReversalApplnSubmittedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReversalApplnSubmittedDate(v)
		return nil
	case reversal_application_ip.FieldVARemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVARemarks(v)
		return nil
	case reversal_application_ip.FieldVAUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVAUserName(v)
		return nil
	case reversal_application_ip.FieldVADate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVADate(v)
		return nil
	case reversal_application_ip.FieldCARemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCARemarks(v)
		return nil
	case reversal_application_ip.FieldCAUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCAUserName(v)
		return nil
	case reversal_application_ip.FieldCADate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCADate(v)
		return nil
	case reversal_application_ip.FieldAppliactionRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliactionRemarks(v)
		return nil
	case reversal_application_ip.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case reversal_application_ip.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case reversal_application_ip.FieldRoleUserCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleUserCode(v)
		return nil
	}
	return fmt.Errorf("unknown Reversal_Application_IP field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReversalApplicationIPMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeeID != nil {
		fields = append(fields, reversal_application_ip.FieldEmployeeID)
	}
	if m.add_ExamCodeIP != nil {
		fields = append(fields, reversal_application_ip.FieldExamCodeIP)
	}
	if m.add_RoleUserCode != nil {
		fields = append(fields, reversal_application_ip.FieldRoleUserCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReversalApplicationIPMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reversal_application_ip.FieldEmployeeID:
		return m.AddedEmployeeID()
	case reversal_application_ip.FieldExamCodeIP:
		return m.AddedExamCodeIP()
	case reversal_application_ip.FieldRoleUserCode:
		return m.AddedRoleUserCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReversalApplicationIPMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reversal_application_ip.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	case reversal_application_ip.FieldExamCodeIP:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamCodeIP(v)
		return nil
	case reversal_application_ip.FieldRoleUserCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleUserCode(v)
		return nil
	}
	return fmt.Errorf("unknown Reversal_Application_IP numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReversalApplicationIPMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reversal_application_ip.FieldEmployeeID) {
		fields = append(fields, reversal_application_ip.FieldEmployeeID)
	}
	if m.FieldCleared(reversal_application_ip.FieldEmployeeName) {
		fields = append(fields, reversal_application_ip.FieldEmployeeName)
	}
	if m.FieldCleared(reversal_application_ip.FieldDOB) {
		fields = append(fields, reversal_application_ip.FieldDOB)
	}
	if m.FieldCleared(reversal_application_ip.FieldMobileNumber) {
		fields = append(fields, reversal_application_ip.FieldMobileNumber)
	}
	if m.FieldCleared(reversal_application_ip.FieldEmailID) {
		fields = append(fields, reversal_application_ip.FieldEmailID)
	}
	if m.FieldCleared(reversal_application_ip.FieldEmployeeCategory) {
		fields = append(fields, reversal_application_ip.FieldEmployeeCategory)
	}
	if m.FieldCleared(reversal_application_ip.FieldCadre) {
		fields = append(fields, reversal_application_ip.FieldCadre)
	}
	if m.FieldCleared(reversal_application_ip.FieldEmployeePost) {
		fields = append(fields, reversal_application_ip.FieldEmployeePost)
	}
	if m.FieldCleared(reversal_application_ip.FieldFacilityID) {
		fields = append(fields, reversal_application_ip.FieldFacilityID)
	}
	if m.FieldCleared(reversal_application_ip.FieldDCCS) {
		fields = append(fields, reversal_application_ip.FieldDCCS)
	}
	if m.FieldCleared(reversal_application_ip.FieldDCInPresentCadre) {
		fields = append(fields, reversal_application_ip.FieldDCInPresentCadre)
	}
	if m.FieldCleared(reversal_application_ip.FieldDeputationOfficeId) {
		fields = append(fields, reversal_application_ip.FieldDeputationOfficeId)
	}
	if m.FieldCleared(reversal_application_ip.FieldDisabilityType) {
		fields = append(fields, reversal_application_ip.FieldDisabilityType)
	}
	if m.FieldCleared(reversal_application_ip.FieldDisabilityPercentage) {
		fields = append(fields, reversal_application_ip.FieldDisabilityPercentage)
	}
	if m.FieldCleared(reversal_application_ip.FieldEducation) {
		fields = append(fields, reversal_application_ip.FieldEducation)
	}
	if m.FieldCleared(reversal_application_ip.FieldExamCodeIP) {
		fields = append(fields, reversal_application_ip.FieldExamCodeIP)
	}
	if m.FieldCleared(reversal_application_ip.FieldExamYear) {
		fields = append(fields, reversal_application_ip.FieldExamYear)
	}
	if m.FieldCleared(reversal_application_ip.FieldCentrePreference) {
		fields = append(fields, reversal_application_ip.FieldCentrePreference)
	}
	if m.FieldCleared(reversal_application_ip.FieldSignature) {
		fields = append(fields, reversal_application_ip.FieldSignature)
	}
	if m.FieldCleared(reversal_application_ip.FieldPhoto) {
		fields = append(fields, reversal_application_ip.FieldPhoto)
	}
	if m.FieldCleared(reversal_application_ip.FieldApplicationStatus) {
		fields = append(fields, reversal_application_ip.FieldApplicationStatus)
	}
	if m.FieldCleared(reversal_application_ip.FieldReversalApplnSubmittedDate) {
		fields = append(fields, reversal_application_ip.FieldReversalApplnSubmittedDate)
	}
	if m.FieldCleared(reversal_application_ip.FieldVARemarks) {
		fields = append(fields, reversal_application_ip.FieldVARemarks)
	}
	if m.FieldCleared(reversal_application_ip.FieldVAUserName) {
		fields = append(fields, reversal_application_ip.FieldVAUserName)
	}
	if m.FieldCleared(reversal_application_ip.FieldVADate) {
		fields = append(fields, reversal_application_ip.FieldVADate)
	}
	if m.FieldCleared(reversal_application_ip.FieldCARemarks) {
		fields = append(fields, reversal_application_ip.FieldCARemarks)
	}
	if m.FieldCleared(reversal_application_ip.FieldCAUserName) {
		fields = append(fields, reversal_application_ip.FieldCAUserName)
	}
	if m.FieldCleared(reversal_application_ip.FieldCADate) {
		fields = append(fields, reversal_application_ip.FieldCADate)
	}
	if m.FieldCleared(reversal_application_ip.FieldAppliactionRemarks) {
		fields = append(fields, reversal_application_ip.FieldAppliactionRemarks)
	}
	if m.FieldCleared(reversal_application_ip.FieldUpdatedAt) {
		fields = append(fields, reversal_application_ip.FieldUpdatedAt)
	}
	if m.FieldCleared(reversal_application_ip.FieldUpdatedBy) {
		fields = append(fields, reversal_application_ip.FieldUpdatedBy)
	}
	if m.FieldCleared(reversal_application_ip.FieldRoleUserCode) {
		fields = append(fields, reversal_application_ip.FieldRoleUserCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReversalApplicationIPMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReversalApplicationIPMutation) ClearField(name string) error {
	switch name {
	case reversal_application_ip.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case reversal_application_ip.FieldEmployeeName:
		m.ClearEmployeeName()
		return nil
	case reversal_application_ip.FieldDOB:
		m.ClearDOB()
		return nil
	case reversal_application_ip.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	case reversal_application_ip.FieldEmailID:
		m.ClearEmailID()
		return nil
	case reversal_application_ip.FieldEmployeeCategory:
		m.ClearEmployeeCategory()
		return nil
	case reversal_application_ip.FieldCadre:
		m.ClearCadre()
		return nil
	case reversal_application_ip.FieldEmployeePost:
		m.ClearEmployeePost()
		return nil
	case reversal_application_ip.FieldFacilityID:
		m.ClearFacilityID()
		return nil
	case reversal_application_ip.FieldDCCS:
		m.ClearDCCS()
		return nil
	case reversal_application_ip.FieldDCInPresentCadre:
		m.ClearDCInPresentCadre()
		return nil
	case reversal_application_ip.FieldDeputationOfficeId:
		m.ClearDeputationOfficeId()
		return nil
	case reversal_application_ip.FieldDisabilityType:
		m.ClearDisabilityType()
		return nil
	case reversal_application_ip.FieldDisabilityPercentage:
		m.ClearDisabilityPercentage()
		return nil
	case reversal_application_ip.FieldEducation:
		m.ClearEducation()
		return nil
	case reversal_application_ip.FieldExamCodeIP:
		m.ClearExamCodeIP()
		return nil
	case reversal_application_ip.FieldExamYear:
		m.ClearExamYear()
		return nil
	case reversal_application_ip.FieldCentrePreference:
		m.ClearCentrePreference()
		return nil
	case reversal_application_ip.FieldSignature:
		m.ClearSignature()
		return nil
	case reversal_application_ip.FieldPhoto:
		m.ClearPhoto()
		return nil
	case reversal_application_ip.FieldApplicationStatus:
		m.ClearApplicationStatus()
		return nil
	case reversal_application_ip.FieldReversalApplnSubmittedDate:
		m.ClearReversalApplnSubmittedDate()
		return nil
	case reversal_application_ip.FieldVARemarks:
		m.ClearVARemarks()
		return nil
	case reversal_application_ip.FieldVAUserName:
		m.ClearVAUserName()
		return nil
	case reversal_application_ip.FieldVADate:
		m.ClearVADate()
		return nil
	case reversal_application_ip.FieldCARemarks:
		m.ClearCARemarks()
		return nil
	case reversal_application_ip.FieldCAUserName:
		m.ClearCAUserName()
		return nil
	case reversal_application_ip.FieldCADate:
		m.ClearCADate()
		return nil
	case reversal_application_ip.FieldAppliactionRemarks:
		m.ClearAppliactionRemarks()
		return nil
	case reversal_application_ip.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case reversal_application_ip.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case reversal_application_ip.FieldRoleUserCode:
		m.ClearRoleUserCode()
		return nil
	}
	return fmt.Errorf("unknown Reversal_Application_IP nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReversalApplicationIPMutation) ResetField(name string) error {
	switch name {
	case reversal_application_ip.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case reversal_application_ip.FieldEmployeeName:
		m.ResetEmployeeName()
		return nil
	case reversal_application_ip.FieldDOB:
		m.ResetDOB()
		return nil
	case reversal_application_ip.FieldGender:
		m.ResetGender()
		return nil
	case reversal_application_ip.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case reversal_application_ip.FieldEmailID:
		m.ResetEmailID()
		return nil
	case reversal_application_ip.FieldEmployeeCategory:
		m.ResetEmployeeCategory()
		return nil
	case reversal_application_ip.FieldCadre:
		m.ResetCadre()
		return nil
	case reversal_application_ip.FieldEmployeePost:
		m.ResetEmployeePost()
		return nil
	case reversal_application_ip.FieldFacilityID:
		m.ResetFacilityID()
		return nil
	case reversal_application_ip.FieldDCCS:
		m.ResetDCCS()
		return nil
	case reversal_application_ip.FieldDCInPresentCadre:
		m.ResetDCInPresentCadre()
		return nil
	case reversal_application_ip.FieldDeputationOfficeId:
		m.ResetDeputationOfficeId()
		return nil
	case reversal_application_ip.FieldDisabilityType:
		m.ResetDisabilityType()
		return nil
	case reversal_application_ip.FieldDisabilityPercentage:
		m.ResetDisabilityPercentage()
		return nil
	case reversal_application_ip.FieldEducation:
		m.ResetEducation()
		return nil
	case reversal_application_ip.FieldExamCodeIP:
		m.ResetExamCodeIP()
		return nil
	case reversal_application_ip.FieldExamYear:
		m.ResetExamYear()
		return nil
	case reversal_application_ip.FieldCentrePreference:
		m.ResetCentrePreference()
		return nil
	case reversal_application_ip.FieldSignature:
		m.ResetSignature()
		return nil
	case reversal_application_ip.FieldPhoto:
		m.ResetPhoto()
		return nil
	case reversal_application_ip.FieldApplicationStatus:
		m.ResetApplicationStatus()
		return nil
	case reversal_application_ip.FieldReversalApplnSubmittedDate:
		m.ResetReversalApplnSubmittedDate()
		return nil
	case reversal_application_ip.FieldVARemarks:
		m.ResetVARemarks()
		return nil
	case reversal_application_ip.FieldVAUserName:
		m.ResetVAUserName()
		return nil
	case reversal_application_ip.FieldVADate:
		m.ResetVADate()
		return nil
	case reversal_application_ip.FieldCARemarks:
		m.ResetCARemarks()
		return nil
	case reversal_application_ip.FieldCAUserName:
		m.ResetCAUserName()
		return nil
	case reversal_application_ip.FieldCADate:
		m.ResetCADate()
		return nil
	case reversal_application_ip.FieldAppliactionRemarks:
		m.ResetAppliactionRemarks()
		return nil
	case reversal_application_ip.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case reversal_application_ip.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case reversal_application_ip.FieldRoleUserCode:
		m.ResetRoleUserCode()
		return nil
	}
	return fmt.Errorf("unknown Reversal_Application_IP field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReversalApplicationIPMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReversalApplicationIPMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReversalApplicationIPMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReversalApplicationIPMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReversalApplicationIPMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReversalApplicationIPMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReversalApplicationIPMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Reversal_Application_IP unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReversalApplicationIPMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Reversal_Application_IP edge %s", name)
}

// RoleMasterMutation represents an operation that mutates the RoleMaster nodes in the graph.
type RoleMasterMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int32
	_RoleName            *string
	_CreatedDate         *time.Time
	_Status              *bool
	clearedFields        map[string]struct{}
	roles                map[int32]struct{}
	removedroles         map[int32]struct{}
	clearedroles         bool
	_Roles_Ref           map[int64]struct{}
	removed_Roles_Ref    map[int64]struct{}
	cleared_Roles_Ref    bool
	_Roles_PS_Ref        map[int64]struct{}
	removed_Roles_PS_Ref map[int64]struct{}
	cleared_Roles_PS_Ref bool
	_Roles_IP_Ref        map[int64]struct{}
	removed_Roles_IP_Ref map[int64]struct{}
	cleared_Roles_IP_Ref bool
	done                 bool
	oldValue             func(context.Context) (*RoleMaster, error)
	predicates           []predicate.RoleMaster
}

var _ ent.Mutation = (*RoleMasterMutation)(nil)

// rolemasterOption allows management of the mutation configuration using functional options.
type rolemasterOption func(*RoleMasterMutation)

// newRoleMasterMutation creates new mutation for the RoleMaster entity.
func newRoleMasterMutation(c config, op Op, opts ...rolemasterOption) *RoleMasterMutation {
	m := &RoleMasterMutation{
		config:        c,
		op:            op,
		typ:           TypeRoleMaster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleMasterID sets the ID field of the mutation.
func withRoleMasterID(id int32) rolemasterOption {
	return func(m *RoleMasterMutation) {
		var (
			err   error
			once  sync.Once
			value *RoleMaster
		)
		m.oldValue = func(ctx context.Context) (*RoleMaster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoleMaster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoleMaster sets the old RoleMaster of the mutation.
func withRoleMaster(node *RoleMaster) rolemasterOption {
	return func(m *RoleMasterMutation) {
		m.oldValue = func(context.Context) (*RoleMaster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMasterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMasterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RoleMaster entities.
func (m *RoleMasterMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMasterMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMasterMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoleMaster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoleName sets the "RoleName" field.
func (m *RoleMasterMutation) SetRoleName(s string) {
	m._RoleName = &s
}

// RoleName returns the value of the "RoleName" field in the mutation.
func (m *RoleMasterMutation) RoleName() (r string, exists bool) {
	v := m._RoleName
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleName returns the old "RoleName" field's value of the RoleMaster entity.
// If the RoleMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMasterMutation) OldRoleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleName: %w", err)
	}
	return oldValue.RoleName, nil
}

// ResetRoleName resets all changes to the "RoleName" field.
func (m *RoleMasterMutation) ResetRoleName() {
	m._RoleName = nil
}

// SetCreatedDate sets the "CreatedDate" field.
func (m *RoleMasterMutation) SetCreatedDate(t time.Time) {
	m._CreatedDate = &t
}

// CreatedDate returns the value of the "CreatedDate" field in the mutation.
func (m *RoleMasterMutation) CreatedDate() (r time.Time, exists bool) {
	v := m._CreatedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "CreatedDate" field's value of the RoleMaster entity.
// If the RoleMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMasterMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ClearCreatedDate clears the value of the "CreatedDate" field.
func (m *RoleMasterMutation) ClearCreatedDate() {
	m._CreatedDate = nil
	m.clearedFields[rolemaster.FieldCreatedDate] = struct{}{}
}

// CreatedDateCleared returns if the "CreatedDate" field was cleared in this mutation.
func (m *RoleMasterMutation) CreatedDateCleared() bool {
	_, ok := m.clearedFields[rolemaster.FieldCreatedDate]
	return ok
}

// ResetCreatedDate resets all changes to the "CreatedDate" field.
func (m *RoleMasterMutation) ResetCreatedDate() {
	m._CreatedDate = nil
	delete(m.clearedFields, rolemaster.FieldCreatedDate)
}

// SetStatus sets the "Status" field.
func (m *RoleMasterMutation) SetStatus(b bool) {
	m._Status = &b
}

// Status returns the value of the "Status" field in the mutation.
func (m *RoleMasterMutation) Status() (r bool, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the RoleMaster entity.
// If the RoleMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMasterMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "Status" field.
func (m *RoleMasterMutation) ResetStatus() {
	m._Status = nil
}

// AddRoleIDs adds the "roles" edge to the AdminLogin entity by ids.
func (m *RoleMasterMutation) AddRoleIDs(ids ...int32) {
	if m.roles == nil {
		m.roles = make(map[int32]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the AdminLogin entity.
func (m *RoleMasterMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the AdminLogin entity was cleared.
func (m *RoleMasterMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the AdminLogin entity by IDs.
func (m *RoleMasterMutation) RemoveRoleIDs(ids ...int32) {
	if m.removedroles == nil {
		m.removedroles = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the AdminLogin entity.
func (m *RoleMasterMutation) RemovedRolesIDs() (ids []int32) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *RoleMasterMutation) RolesIDs() (ids []int32) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *RoleMasterMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddRolesRefIDs adds the "Roles_Ref" edge to the UserMaster entity by ids.
func (m *RoleMasterMutation) AddRolesRefIDs(ids ...int64) {
	if m._Roles_Ref == nil {
		m._Roles_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		m._Roles_Ref[ids[i]] = struct{}{}
	}
}

// ClearRolesRef clears the "Roles_Ref" edge to the UserMaster entity.
func (m *RoleMasterMutation) ClearRolesRef() {
	m.cleared_Roles_Ref = true
}

// RolesRefCleared reports if the "Roles_Ref" edge to the UserMaster entity was cleared.
func (m *RoleMasterMutation) RolesRefCleared() bool {
	return m.cleared_Roles_Ref
}

// RemoveRolesRefIDs removes the "Roles_Ref" edge to the UserMaster entity by IDs.
func (m *RoleMasterMutation) RemoveRolesRefIDs(ids ...int64) {
	if m.removed_Roles_Ref == nil {
		m.removed_Roles_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._Roles_Ref, ids[i])
		m.removed_Roles_Ref[ids[i]] = struct{}{}
	}
}

// RemovedRolesRef returns the removed IDs of the "Roles_Ref" edge to the UserMaster entity.
func (m *RoleMasterMutation) RemovedRolesRefIDs() (ids []int64) {
	for id := range m.removed_Roles_Ref {
		ids = append(ids, id)
	}
	return
}

// RolesRefIDs returns the "Roles_Ref" edge IDs in the mutation.
func (m *RoleMasterMutation) RolesRefIDs() (ids []int64) {
	for id := range m._Roles_Ref {
		ids = append(ids, id)
	}
	return
}

// ResetRolesRef resets all changes to the "Roles_Ref" edge.
func (m *RoleMasterMutation) ResetRolesRef() {
	m._Roles_Ref = nil
	m.cleared_Roles_Ref = false
	m.removed_Roles_Ref = nil
}

// AddRolesPSRefIDs adds the "Roles_PS_Ref" edge to the Exam_Applications_PS entity by ids.
func (m *RoleMasterMutation) AddRolesPSRefIDs(ids ...int64) {
	if m._Roles_PS_Ref == nil {
		m._Roles_PS_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		m._Roles_PS_Ref[ids[i]] = struct{}{}
	}
}

// ClearRolesPSRef clears the "Roles_PS_Ref" edge to the Exam_Applications_PS entity.
func (m *RoleMasterMutation) ClearRolesPSRef() {
	m.cleared_Roles_PS_Ref = true
}

// RolesPSRefCleared reports if the "Roles_PS_Ref" edge to the Exam_Applications_PS entity was cleared.
func (m *RoleMasterMutation) RolesPSRefCleared() bool {
	return m.cleared_Roles_PS_Ref
}

// RemoveRolesPSRefIDs removes the "Roles_PS_Ref" edge to the Exam_Applications_PS entity by IDs.
func (m *RoleMasterMutation) RemoveRolesPSRefIDs(ids ...int64) {
	if m.removed_Roles_PS_Ref == nil {
		m.removed_Roles_PS_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._Roles_PS_Ref, ids[i])
		m.removed_Roles_PS_Ref[ids[i]] = struct{}{}
	}
}

// RemovedRolesPSRef returns the removed IDs of the "Roles_PS_Ref" edge to the Exam_Applications_PS entity.
func (m *RoleMasterMutation) RemovedRolesPSRefIDs() (ids []int64) {
	for id := range m.removed_Roles_PS_Ref {
		ids = append(ids, id)
	}
	return
}

// RolesPSRefIDs returns the "Roles_PS_Ref" edge IDs in the mutation.
func (m *RoleMasterMutation) RolesPSRefIDs() (ids []int64) {
	for id := range m._Roles_PS_Ref {
		ids = append(ids, id)
	}
	return
}

// ResetRolesPSRef resets all changes to the "Roles_PS_Ref" edge.
func (m *RoleMasterMutation) ResetRolesPSRef() {
	m._Roles_PS_Ref = nil
	m.cleared_Roles_PS_Ref = false
	m.removed_Roles_PS_Ref = nil
}

// AddRolesIPRefIDs adds the "Roles_IP_Ref" edge to the Exam_Applications_IP entity by ids.
func (m *RoleMasterMutation) AddRolesIPRefIDs(ids ...int64) {
	if m._Roles_IP_Ref == nil {
		m._Roles_IP_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		m._Roles_IP_Ref[ids[i]] = struct{}{}
	}
}

// ClearRolesIPRef clears the "Roles_IP_Ref" edge to the Exam_Applications_IP entity.
func (m *RoleMasterMutation) ClearRolesIPRef() {
	m.cleared_Roles_IP_Ref = true
}

// RolesIPRefCleared reports if the "Roles_IP_Ref" edge to the Exam_Applications_IP entity was cleared.
func (m *RoleMasterMutation) RolesIPRefCleared() bool {
	return m.cleared_Roles_IP_Ref
}

// RemoveRolesIPRefIDs removes the "Roles_IP_Ref" edge to the Exam_Applications_IP entity by IDs.
func (m *RoleMasterMutation) RemoveRolesIPRefIDs(ids ...int64) {
	if m.removed_Roles_IP_Ref == nil {
		m.removed_Roles_IP_Ref = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._Roles_IP_Ref, ids[i])
		m.removed_Roles_IP_Ref[ids[i]] = struct{}{}
	}
}

// RemovedRolesIPRef returns the removed IDs of the "Roles_IP_Ref" edge to the Exam_Applications_IP entity.
func (m *RoleMasterMutation) RemovedRolesIPRefIDs() (ids []int64) {
	for id := range m.removed_Roles_IP_Ref {
		ids = append(ids, id)
	}
	return
}

// RolesIPRefIDs returns the "Roles_IP_Ref" edge IDs in the mutation.
func (m *RoleMasterMutation) RolesIPRefIDs() (ids []int64) {
	for id := range m._Roles_IP_Ref {
		ids = append(ids, id)
	}
	return
}

// ResetRolesIPRef resets all changes to the "Roles_IP_Ref" edge.
func (m *RoleMasterMutation) ResetRolesIPRef() {
	m._Roles_IP_Ref = nil
	m.cleared_Roles_IP_Ref = false
	m.removed_Roles_IP_Ref = nil
}

// Where appends a list predicates to the RoleMasterMutation builder.
func (m *RoleMasterMutation) Where(ps ...predicate.RoleMaster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMasterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMasterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoleMaster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMasterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMasterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoleMaster).
func (m *RoleMasterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMasterMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._RoleName != nil {
		fields = append(fields, rolemaster.FieldRoleName)
	}
	if m._CreatedDate != nil {
		fields = append(fields, rolemaster.FieldCreatedDate)
	}
	if m._Status != nil {
		fields = append(fields, rolemaster.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMasterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rolemaster.FieldRoleName:
		return m.RoleName()
	case rolemaster.FieldCreatedDate:
		return m.CreatedDate()
	case rolemaster.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMasterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rolemaster.FieldRoleName:
		return m.OldRoleName(ctx)
	case rolemaster.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	case rolemaster.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown RoleMaster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMasterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rolemaster.FieldRoleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleName(v)
		return nil
	case rolemaster.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	case rolemaster.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown RoleMaster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMasterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMasterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMasterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RoleMaster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMasterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rolemaster.FieldCreatedDate) {
		fields = append(fields, rolemaster.FieldCreatedDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMasterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMasterMutation) ClearField(name string) error {
	switch name {
	case rolemaster.FieldCreatedDate:
		m.ClearCreatedDate()
		return nil
	}
	return fmt.Errorf("unknown RoleMaster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMasterMutation) ResetField(name string) error {
	switch name {
	case rolemaster.FieldRoleName:
		m.ResetRoleName()
		return nil
	case rolemaster.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	case rolemaster.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown RoleMaster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMasterMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.roles != nil {
		edges = append(edges, rolemaster.EdgeRoles)
	}
	if m._Roles_Ref != nil {
		edges = append(edges, rolemaster.EdgeRolesRef)
	}
	if m._Roles_PS_Ref != nil {
		edges = append(edges, rolemaster.EdgeRolesPSRef)
	}
	if m._Roles_IP_Ref != nil {
		edges = append(edges, rolemaster.EdgeRolesIPRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMasterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rolemaster.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case rolemaster.EdgeRolesRef:
		ids := make([]ent.Value, 0, len(m._Roles_Ref))
		for id := range m._Roles_Ref {
			ids = append(ids, id)
		}
		return ids
	case rolemaster.EdgeRolesPSRef:
		ids := make([]ent.Value, 0, len(m._Roles_PS_Ref))
		for id := range m._Roles_PS_Ref {
			ids = append(ids, id)
		}
		return ids
	case rolemaster.EdgeRolesIPRef:
		ids := make([]ent.Value, 0, len(m._Roles_IP_Ref))
		for id := range m._Roles_IP_Ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMasterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedroles != nil {
		edges = append(edges, rolemaster.EdgeRoles)
	}
	if m.removed_Roles_Ref != nil {
		edges = append(edges, rolemaster.EdgeRolesRef)
	}
	if m.removed_Roles_PS_Ref != nil {
		edges = append(edges, rolemaster.EdgeRolesPSRef)
	}
	if m.removed_Roles_IP_Ref != nil {
		edges = append(edges, rolemaster.EdgeRolesIPRef)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMasterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rolemaster.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case rolemaster.EdgeRolesRef:
		ids := make([]ent.Value, 0, len(m.removed_Roles_Ref))
		for id := range m.removed_Roles_Ref {
			ids = append(ids, id)
		}
		return ids
	case rolemaster.EdgeRolesPSRef:
		ids := make([]ent.Value, 0, len(m.removed_Roles_PS_Ref))
		for id := range m.removed_Roles_PS_Ref {
			ids = append(ids, id)
		}
		return ids
	case rolemaster.EdgeRolesIPRef:
		ids := make([]ent.Value, 0, len(m.removed_Roles_IP_Ref))
		for id := range m.removed_Roles_IP_Ref {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMasterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedroles {
		edges = append(edges, rolemaster.EdgeRoles)
	}
	if m.cleared_Roles_Ref {
		edges = append(edges, rolemaster.EdgeRolesRef)
	}
	if m.cleared_Roles_PS_Ref {
		edges = append(edges, rolemaster.EdgeRolesPSRef)
	}
	if m.cleared_Roles_IP_Ref {
		edges = append(edges, rolemaster.EdgeRolesIPRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMasterMutation) EdgeCleared(name string) bool {
	switch name {
	case rolemaster.EdgeRoles:
		return m.clearedroles
	case rolemaster.EdgeRolesRef:
		return m.cleared_Roles_Ref
	case rolemaster.EdgeRolesPSRef:
		return m.cleared_Roles_PS_Ref
	case rolemaster.EdgeRolesIPRef:
		return m.cleared_Roles_IP_Ref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMasterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown RoleMaster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMasterMutation) ResetEdge(name string) error {
	switch name {
	case rolemaster.EdgeRoles:
		m.ResetRoles()
		return nil
	case rolemaster.EdgeRolesRef:
		m.ResetRolesRef()
		return nil
	case rolemaster.EdgeRolesPSRef:
		m.ResetRolesPSRef()
		return nil
	case rolemaster.EdgeRolesIPRef:
		m.ResetRolesIPRef()
		return nil
	}
	return fmt.Errorf("unknown RoleMaster edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_EmployeedID         *string
	_IDVerified          *bool
	_IDRemStatus         *bool
	_IDRemarks           *string
	_EmployeedName       *string
	nameVerified         *bool
	nameRemStatus        *bool
	nameRemarks          *string
	_DOB                 *time.Time
	_DOBVerified         *bool
	_DOBRemStatus        *bool
	_DOBRemarks          *string
	_Gender              *user.Gender
	genderVerified       *bool
	genderRemStatus      *bool
	genderRemarks        *string
	_Cadreid             *int32
	add_Cadreid          *int32
	cadreidVerified      *bool
	cadreidRemStatus     *bool
	cadreidRemarks       *string
	_OfficeID            *int32
	add_OfficeID         *int32
	officeIDVerified     *bool
	officeIDRemStatus    *bool
	officeIDRemarks      *string
	_PH                  *bool
	_PHVerified          *bool
	_PHRemStatus         *bool
	_PHRemarks           *string
	_PHDetails           *string
	_PHDetailsVerified   *bool
	_PHDetailsRemStatus  *bool
	_PHDetailsRemarks    *string
	_APSWorking          *bool
	_APSWorkingVerified  *bool
	_APSWorkingRemStatus *bool
	_APSWorkingRemarks   *string
	profilestatus        *bool
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeedID sets the "EmployeedID" field.
func (m *UserMutation) SetEmployeedID(s string) {
	m._EmployeedID = &s
}

// EmployeedID returns the value of the "EmployeedID" field in the mutation.
func (m *UserMutation) EmployeedID() (r string, exists bool) {
	v := m._EmployeedID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeedID returns the old "EmployeedID" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmployeedID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeedID: %w", err)
	}
	return oldValue.EmployeedID, nil
}

// ResetEmployeedID resets all changes to the "EmployeedID" field.
func (m *UserMutation) ResetEmployeedID() {
	m._EmployeedID = nil
}

// SetIDVerified sets the "IDVerified" field.
func (m *UserMutation) SetIDVerified(b bool) {
	m._IDVerified = &b
}

// IDVerified returns the value of the "IDVerified" field in the mutation.
func (m *UserMutation) IDVerified() (r bool, exists bool) {
	v := m._IDVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldIDVerified returns the old "IDVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIDVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDVerified: %w", err)
	}
	return oldValue.IDVerified, nil
}

// ResetIDVerified resets all changes to the "IDVerified" field.
func (m *UserMutation) ResetIDVerified() {
	m._IDVerified = nil
}

// SetIDRemStatus sets the "IDRemStatus" field.
func (m *UserMutation) SetIDRemStatus(b bool) {
	m._IDRemStatus = &b
}

// IDRemStatus returns the value of the "IDRemStatus" field in the mutation.
func (m *UserMutation) IDRemStatus() (r bool, exists bool) {
	v := m._IDRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldIDRemStatus returns the old "IDRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIDRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDRemStatus: %w", err)
	}
	return oldValue.IDRemStatus, nil
}

// ResetIDRemStatus resets all changes to the "IDRemStatus" field.
func (m *UserMutation) ResetIDRemStatus() {
	m._IDRemStatus = nil
}

// SetIDRemarks sets the "IDRemarks" field.
func (m *UserMutation) SetIDRemarks(s string) {
	m._IDRemarks = &s
}

// IDRemarks returns the value of the "IDRemarks" field in the mutation.
func (m *UserMutation) IDRemarks() (r string, exists bool) {
	v := m._IDRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldIDRemarks returns the old "IDRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIDRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDRemarks: %w", err)
	}
	return oldValue.IDRemarks, nil
}

// ResetIDRemarks resets all changes to the "IDRemarks" field.
func (m *UserMutation) ResetIDRemarks() {
	m._IDRemarks = nil
}

// SetEmployeedName sets the "EmployeedName" field.
func (m *UserMutation) SetEmployeedName(s string) {
	m._EmployeedName = &s
}

// EmployeedName returns the value of the "EmployeedName" field in the mutation.
func (m *UserMutation) EmployeedName() (r string, exists bool) {
	v := m._EmployeedName
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeedName returns the old "EmployeedName" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmployeedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeedName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeedName: %w", err)
	}
	return oldValue.EmployeedName, nil
}

// ResetEmployeedName resets all changes to the "EmployeedName" field.
func (m *UserMutation) ResetEmployeedName() {
	m._EmployeedName = nil
}

// SetNameVerified sets the "nameVerified" field.
func (m *UserMutation) SetNameVerified(b bool) {
	m.nameVerified = &b
}

// NameVerified returns the value of the "nameVerified" field in the mutation.
func (m *UserMutation) NameVerified() (r bool, exists bool) {
	v := m.nameVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldNameVerified returns the old "nameVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNameVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameVerified: %w", err)
	}
	return oldValue.NameVerified, nil
}

// ResetNameVerified resets all changes to the "nameVerified" field.
func (m *UserMutation) ResetNameVerified() {
	m.nameVerified = nil
}

// SetNameRemStatus sets the "nameRemStatus" field.
func (m *UserMutation) SetNameRemStatus(b bool) {
	m.nameRemStatus = &b
}

// NameRemStatus returns the value of the "nameRemStatus" field in the mutation.
func (m *UserMutation) NameRemStatus() (r bool, exists bool) {
	v := m.nameRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldNameRemStatus returns the old "nameRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNameRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameRemStatus: %w", err)
	}
	return oldValue.NameRemStatus, nil
}

// ResetNameRemStatus resets all changes to the "nameRemStatus" field.
func (m *UserMutation) ResetNameRemStatus() {
	m.nameRemStatus = nil
}

// SetNameRemarks sets the "nameRemarks" field.
func (m *UserMutation) SetNameRemarks(s string) {
	m.nameRemarks = &s
}

// NameRemarks returns the value of the "nameRemarks" field in the mutation.
func (m *UserMutation) NameRemarks() (r string, exists bool) {
	v := m.nameRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldNameRemarks returns the old "nameRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNameRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameRemarks: %w", err)
	}
	return oldValue.NameRemarks, nil
}

// ResetNameRemarks resets all changes to the "nameRemarks" field.
func (m *UserMutation) ResetNameRemarks() {
	m.nameRemarks = nil
}

// SetDOB sets the "DOB" field.
func (m *UserMutation) SetDOB(t time.Time) {
	m._DOB = &t
}

// DOB returns the value of the "DOB" field in the mutation.
func (m *UserMutation) DOB() (r time.Time, exists bool) {
	v := m._DOB
	if v == nil {
		return
	}
	return *v, true
}

// OldDOB returns the old "DOB" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDOB(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOB: %w", err)
	}
	return oldValue.DOB, nil
}

// ResetDOB resets all changes to the "DOB" field.
func (m *UserMutation) ResetDOB() {
	m._DOB = nil
}

// SetDOBVerified sets the "DOBVerified" field.
func (m *UserMutation) SetDOBVerified(b bool) {
	m._DOBVerified = &b
}

// DOBVerified returns the value of the "DOBVerified" field in the mutation.
func (m *UserMutation) DOBVerified() (r bool, exists bool) {
	v := m._DOBVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldDOBVerified returns the old "DOBVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDOBVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOBVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOBVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOBVerified: %w", err)
	}
	return oldValue.DOBVerified, nil
}

// ResetDOBVerified resets all changes to the "DOBVerified" field.
func (m *UserMutation) ResetDOBVerified() {
	m._DOBVerified = nil
}

// SetDOBRemStatus sets the "DOBRemStatus" field.
func (m *UserMutation) SetDOBRemStatus(b bool) {
	m._DOBRemStatus = &b
}

// DOBRemStatus returns the value of the "DOBRemStatus" field in the mutation.
func (m *UserMutation) DOBRemStatus() (r bool, exists bool) {
	v := m._DOBRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldDOBRemStatus returns the old "DOBRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDOBRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOBRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOBRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOBRemStatus: %w", err)
	}
	return oldValue.DOBRemStatus, nil
}

// ResetDOBRemStatus resets all changes to the "DOBRemStatus" field.
func (m *UserMutation) ResetDOBRemStatus() {
	m._DOBRemStatus = nil
}

// SetDOBRemarks sets the "DOBRemarks" field.
func (m *UserMutation) SetDOBRemarks(s string) {
	m._DOBRemarks = &s
}

// DOBRemarks returns the value of the "DOBRemarks" field in the mutation.
func (m *UserMutation) DOBRemarks() (r string, exists bool) {
	v := m._DOBRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldDOBRemarks returns the old "DOBRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDOBRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDOBRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDOBRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOBRemarks: %w", err)
	}
	return oldValue.DOBRemarks, nil
}

// ResetDOBRemarks resets all changes to the "DOBRemarks" field.
func (m *UserMutation) ResetDOBRemarks() {
	m._DOBRemarks = nil
}

// SetGender sets the "Gender" field.
func (m *UserMutation) SetGender(u user.Gender) {
	m._Gender = &u
}

// Gender returns the value of the "Gender" field in the mutation.
func (m *UserMutation) Gender() (r user.Gender, exists bool) {
	v := m._Gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "Gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v user.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "Gender" field.
func (m *UserMutation) ResetGender() {
	m._Gender = nil
}

// SetGenderVerified sets the "genderVerified" field.
func (m *UserMutation) SetGenderVerified(b bool) {
	m.genderVerified = &b
}

// GenderVerified returns the value of the "genderVerified" field in the mutation.
func (m *UserMutation) GenderVerified() (r bool, exists bool) {
	v := m.genderVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderVerified returns the old "genderVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGenderVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenderVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenderVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderVerified: %w", err)
	}
	return oldValue.GenderVerified, nil
}

// ResetGenderVerified resets all changes to the "genderVerified" field.
func (m *UserMutation) ResetGenderVerified() {
	m.genderVerified = nil
}

// SetGenderRemStatus sets the "genderRemStatus" field.
func (m *UserMutation) SetGenderRemStatus(b bool) {
	m.genderRemStatus = &b
}

// GenderRemStatus returns the value of the "genderRemStatus" field in the mutation.
func (m *UserMutation) GenderRemStatus() (r bool, exists bool) {
	v := m.genderRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderRemStatus returns the old "genderRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGenderRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenderRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenderRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderRemStatus: %w", err)
	}
	return oldValue.GenderRemStatus, nil
}

// ResetGenderRemStatus resets all changes to the "genderRemStatus" field.
func (m *UserMutation) ResetGenderRemStatus() {
	m.genderRemStatus = nil
}

// SetGenderRemarks sets the "genderRemarks" field.
func (m *UserMutation) SetGenderRemarks(s string) {
	m.genderRemarks = &s
}

// GenderRemarks returns the value of the "genderRemarks" field in the mutation.
func (m *UserMutation) GenderRemarks() (r string, exists bool) {
	v := m.genderRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderRemarks returns the old "genderRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGenderRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenderRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenderRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderRemarks: %w", err)
	}
	return oldValue.GenderRemarks, nil
}

// ResetGenderRemarks resets all changes to the "genderRemarks" field.
func (m *UserMutation) ResetGenderRemarks() {
	m.genderRemarks = nil
}

// SetCadreid sets the "Cadreid" field.
func (m *UserMutation) SetCadreid(i int32) {
	m._Cadreid = &i
	m.add_Cadreid = nil
}

// Cadreid returns the value of the "Cadreid" field in the mutation.
func (m *UserMutation) Cadreid() (r int32, exists bool) {
	v := m._Cadreid
	if v == nil {
		return
	}
	return *v, true
}

// OldCadreid returns the old "Cadreid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCadreid(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadreid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadreid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadreid: %w", err)
	}
	return oldValue.Cadreid, nil
}

// AddCadreid adds i to the "Cadreid" field.
func (m *UserMutation) AddCadreid(i int32) {
	if m.add_Cadreid != nil {
		*m.add_Cadreid += i
	} else {
		m.add_Cadreid = &i
	}
}

// AddedCadreid returns the value that was added to the "Cadreid" field in this mutation.
func (m *UserMutation) AddedCadreid() (r int32, exists bool) {
	v := m.add_Cadreid
	if v == nil {
		return
	}
	return *v, true
}

// ResetCadreid resets all changes to the "Cadreid" field.
func (m *UserMutation) ResetCadreid() {
	m._Cadreid = nil
	m.add_Cadreid = nil
}

// SetCadreidVerified sets the "cadreidVerified" field.
func (m *UserMutation) SetCadreidVerified(b bool) {
	m.cadreidVerified = &b
}

// CadreidVerified returns the value of the "cadreidVerified" field in the mutation.
func (m *UserMutation) CadreidVerified() (r bool, exists bool) {
	v := m.cadreidVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldCadreidVerified returns the old "cadreidVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCadreidVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadreidVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadreidVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadreidVerified: %w", err)
	}
	return oldValue.CadreidVerified, nil
}

// ResetCadreidVerified resets all changes to the "cadreidVerified" field.
func (m *UserMutation) ResetCadreidVerified() {
	m.cadreidVerified = nil
}

// SetCadreidRemStatus sets the "cadreidRemStatus" field.
func (m *UserMutation) SetCadreidRemStatus(b bool) {
	m.cadreidRemStatus = &b
}

// CadreidRemStatus returns the value of the "cadreidRemStatus" field in the mutation.
func (m *UserMutation) CadreidRemStatus() (r bool, exists bool) {
	v := m.cadreidRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldCadreidRemStatus returns the old "cadreidRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCadreidRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadreidRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadreidRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadreidRemStatus: %w", err)
	}
	return oldValue.CadreidRemStatus, nil
}

// ResetCadreidRemStatus resets all changes to the "cadreidRemStatus" field.
func (m *UserMutation) ResetCadreidRemStatus() {
	m.cadreidRemStatus = nil
}

// SetCadreidRemarks sets the "cadreidRemarks" field.
func (m *UserMutation) SetCadreidRemarks(s string) {
	m.cadreidRemarks = &s
}

// CadreidRemarks returns the value of the "cadreidRemarks" field in the mutation.
func (m *UserMutation) CadreidRemarks() (r string, exists bool) {
	v := m.cadreidRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldCadreidRemarks returns the old "cadreidRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCadreidRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadreidRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadreidRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadreidRemarks: %w", err)
	}
	return oldValue.CadreidRemarks, nil
}

// ResetCadreidRemarks resets all changes to the "cadreidRemarks" field.
func (m *UserMutation) ResetCadreidRemarks() {
	m.cadreidRemarks = nil
}

// SetOfficeID sets the "OfficeID" field.
func (m *UserMutation) SetOfficeID(i int32) {
	m._OfficeID = &i
	m.add_OfficeID = nil
}

// OfficeID returns the value of the "OfficeID" field in the mutation.
func (m *UserMutation) OfficeID() (r int32, exists bool) {
	v := m._OfficeID
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeID returns the old "OfficeID" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOfficeID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeID: %w", err)
	}
	return oldValue.OfficeID, nil
}

// AddOfficeID adds i to the "OfficeID" field.
func (m *UserMutation) AddOfficeID(i int32) {
	if m.add_OfficeID != nil {
		*m.add_OfficeID += i
	} else {
		m.add_OfficeID = &i
	}
}

// AddedOfficeID returns the value that was added to the "OfficeID" field in this mutation.
func (m *UserMutation) AddedOfficeID() (r int32, exists bool) {
	v := m.add_OfficeID
	if v == nil {
		return
	}
	return *v, true
}

// ResetOfficeID resets all changes to the "OfficeID" field.
func (m *UserMutation) ResetOfficeID() {
	m._OfficeID = nil
	m.add_OfficeID = nil
}

// SetOfficeIDVerified sets the "officeIDVerified" field.
func (m *UserMutation) SetOfficeIDVerified(b bool) {
	m.officeIDVerified = &b
}

// OfficeIDVerified returns the value of the "officeIDVerified" field in the mutation.
func (m *UserMutation) OfficeIDVerified() (r bool, exists bool) {
	v := m.officeIDVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeIDVerified returns the old "officeIDVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOfficeIDVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeIDVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeIDVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeIDVerified: %w", err)
	}
	return oldValue.OfficeIDVerified, nil
}

// ResetOfficeIDVerified resets all changes to the "officeIDVerified" field.
func (m *UserMutation) ResetOfficeIDVerified() {
	m.officeIDVerified = nil
}

// SetOfficeIDRemStatus sets the "officeIDRemStatus" field.
func (m *UserMutation) SetOfficeIDRemStatus(b bool) {
	m.officeIDRemStatus = &b
}

// OfficeIDRemStatus returns the value of the "officeIDRemStatus" field in the mutation.
func (m *UserMutation) OfficeIDRemStatus() (r bool, exists bool) {
	v := m.officeIDRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeIDRemStatus returns the old "officeIDRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOfficeIDRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeIDRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeIDRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeIDRemStatus: %w", err)
	}
	return oldValue.OfficeIDRemStatus, nil
}

// ResetOfficeIDRemStatus resets all changes to the "officeIDRemStatus" field.
func (m *UserMutation) ResetOfficeIDRemStatus() {
	m.officeIDRemStatus = nil
}

// SetOfficeIDRemarks sets the "officeIDRemarks" field.
func (m *UserMutation) SetOfficeIDRemarks(s string) {
	m.officeIDRemarks = &s
}

// OfficeIDRemarks returns the value of the "officeIDRemarks" field in the mutation.
func (m *UserMutation) OfficeIDRemarks() (r string, exists bool) {
	v := m.officeIDRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeIDRemarks returns the old "officeIDRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOfficeIDRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeIDRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeIDRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeIDRemarks: %w", err)
	}
	return oldValue.OfficeIDRemarks, nil
}

// ResetOfficeIDRemarks resets all changes to the "officeIDRemarks" field.
func (m *UserMutation) ResetOfficeIDRemarks() {
	m.officeIDRemarks = nil
}

// SetPH sets the "PH" field.
func (m *UserMutation) SetPH(b bool) {
	m._PH = &b
}

// PH returns the value of the "PH" field in the mutation.
func (m *UserMutation) PH() (r bool, exists bool) {
	v := m._PH
	if v == nil {
		return
	}
	return *v, true
}

// OldPH returns the old "PH" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPH(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPH: %w", err)
	}
	return oldValue.PH, nil
}

// ResetPH resets all changes to the "PH" field.
func (m *UserMutation) ResetPH() {
	m._PH = nil
}

// SetPHVerified sets the "PHVerified" field.
func (m *UserMutation) SetPHVerified(b bool) {
	m._PHVerified = &b
}

// PHVerified returns the value of the "PHVerified" field in the mutation.
func (m *UserMutation) PHVerified() (r bool, exists bool) {
	v := m._PHVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldPHVerified returns the old "PHVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPHVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPHVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPHVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHVerified: %w", err)
	}
	return oldValue.PHVerified, nil
}

// ResetPHVerified resets all changes to the "PHVerified" field.
func (m *UserMutation) ResetPHVerified() {
	m._PHVerified = nil
}

// SetPHRemStatus sets the "PHRemStatus" field.
func (m *UserMutation) SetPHRemStatus(b bool) {
	m._PHRemStatus = &b
}

// PHRemStatus returns the value of the "PHRemStatus" field in the mutation.
func (m *UserMutation) PHRemStatus() (r bool, exists bool) {
	v := m._PHRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldPHRemStatus returns the old "PHRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPHRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPHRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPHRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHRemStatus: %w", err)
	}
	return oldValue.PHRemStatus, nil
}

// ResetPHRemStatus resets all changes to the "PHRemStatus" field.
func (m *UserMutation) ResetPHRemStatus() {
	m._PHRemStatus = nil
}

// SetPHRemarks sets the "PHRemarks" field.
func (m *UserMutation) SetPHRemarks(s string) {
	m._PHRemarks = &s
}

// PHRemarks returns the value of the "PHRemarks" field in the mutation.
func (m *UserMutation) PHRemarks() (r string, exists bool) {
	v := m._PHRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldPHRemarks returns the old "PHRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPHRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPHRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPHRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHRemarks: %w", err)
	}
	return oldValue.PHRemarks, nil
}

// ResetPHRemarks resets all changes to the "PHRemarks" field.
func (m *UserMutation) ResetPHRemarks() {
	m._PHRemarks = nil
}

// SetPHDetails sets the "PHDetails" field.
func (m *UserMutation) SetPHDetails(s string) {
	m._PHDetails = &s
}

// PHDetails returns the value of the "PHDetails" field in the mutation.
func (m *UserMutation) PHDetails() (r string, exists bool) {
	v := m._PHDetails
	if v == nil {
		return
	}
	return *v, true
}

// OldPHDetails returns the old "PHDetails" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPHDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPHDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPHDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHDetails: %w", err)
	}
	return oldValue.PHDetails, nil
}

// ClearPHDetails clears the value of the "PHDetails" field.
func (m *UserMutation) ClearPHDetails() {
	m._PHDetails = nil
	m.clearedFields[user.FieldPHDetails] = struct{}{}
}

// PHDetailsCleared returns if the "PHDetails" field was cleared in this mutation.
func (m *UserMutation) PHDetailsCleared() bool {
	_, ok := m.clearedFields[user.FieldPHDetails]
	return ok
}

// ResetPHDetails resets all changes to the "PHDetails" field.
func (m *UserMutation) ResetPHDetails() {
	m._PHDetails = nil
	delete(m.clearedFields, user.FieldPHDetails)
}

// SetPHDetailsVerified sets the "PHDetailsVerified" field.
func (m *UserMutation) SetPHDetailsVerified(b bool) {
	m._PHDetailsVerified = &b
}

// PHDetailsVerified returns the value of the "PHDetailsVerified" field in the mutation.
func (m *UserMutation) PHDetailsVerified() (r bool, exists bool) {
	v := m._PHDetailsVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldPHDetailsVerified returns the old "PHDetailsVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPHDetailsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPHDetailsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPHDetailsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHDetailsVerified: %w", err)
	}
	return oldValue.PHDetailsVerified, nil
}

// ResetPHDetailsVerified resets all changes to the "PHDetailsVerified" field.
func (m *UserMutation) ResetPHDetailsVerified() {
	m._PHDetailsVerified = nil
}

// SetPHDetailsRemStatus sets the "PHDetailsRemStatus" field.
func (m *UserMutation) SetPHDetailsRemStatus(b bool) {
	m._PHDetailsRemStatus = &b
}

// PHDetailsRemStatus returns the value of the "PHDetailsRemStatus" field in the mutation.
func (m *UserMutation) PHDetailsRemStatus() (r bool, exists bool) {
	v := m._PHDetailsRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldPHDetailsRemStatus returns the old "PHDetailsRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPHDetailsRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPHDetailsRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPHDetailsRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHDetailsRemStatus: %w", err)
	}
	return oldValue.PHDetailsRemStatus, nil
}

// ResetPHDetailsRemStatus resets all changes to the "PHDetailsRemStatus" field.
func (m *UserMutation) ResetPHDetailsRemStatus() {
	m._PHDetailsRemStatus = nil
}

// SetPHDetailsRemarks sets the "PHDetailsRemarks" field.
func (m *UserMutation) SetPHDetailsRemarks(s string) {
	m._PHDetailsRemarks = &s
}

// PHDetailsRemarks returns the value of the "PHDetailsRemarks" field in the mutation.
func (m *UserMutation) PHDetailsRemarks() (r string, exists bool) {
	v := m._PHDetailsRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldPHDetailsRemarks returns the old "PHDetailsRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPHDetailsRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPHDetailsRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPHDetailsRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHDetailsRemarks: %w", err)
	}
	return oldValue.PHDetailsRemarks, nil
}

// ResetPHDetailsRemarks resets all changes to the "PHDetailsRemarks" field.
func (m *UserMutation) ResetPHDetailsRemarks() {
	m._PHDetailsRemarks = nil
}

// SetAPSWorking sets the "APSWorking" field.
func (m *UserMutation) SetAPSWorking(b bool) {
	m._APSWorking = &b
}

// APSWorking returns the value of the "APSWorking" field in the mutation.
func (m *UserMutation) APSWorking() (r bool, exists bool) {
	v := m._APSWorking
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorking returns the old "APSWorking" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAPSWorking(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorking is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorking requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorking: %w", err)
	}
	return oldValue.APSWorking, nil
}

// ResetAPSWorking resets all changes to the "APSWorking" field.
func (m *UserMutation) ResetAPSWorking() {
	m._APSWorking = nil
}

// SetAPSWorkingVerified sets the "APSWorkingVerified" field.
func (m *UserMutation) SetAPSWorkingVerified(b bool) {
	m._APSWorkingVerified = &b
}

// APSWorkingVerified returns the value of the "APSWorkingVerified" field in the mutation.
func (m *UserMutation) APSWorkingVerified() (r bool, exists bool) {
	v := m._APSWorkingVerified
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorkingVerified returns the old "APSWorkingVerified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAPSWorkingVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorkingVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorkingVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorkingVerified: %w", err)
	}
	return oldValue.APSWorkingVerified, nil
}

// ResetAPSWorkingVerified resets all changes to the "APSWorkingVerified" field.
func (m *UserMutation) ResetAPSWorkingVerified() {
	m._APSWorkingVerified = nil
}

// SetAPSWorkingRemStatus sets the "APSWorkingRemStatus" field.
func (m *UserMutation) SetAPSWorkingRemStatus(b bool) {
	m._APSWorkingRemStatus = &b
}

// APSWorkingRemStatus returns the value of the "APSWorkingRemStatus" field in the mutation.
func (m *UserMutation) APSWorkingRemStatus() (r bool, exists bool) {
	v := m._APSWorkingRemStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorkingRemStatus returns the old "APSWorkingRemStatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAPSWorkingRemStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorkingRemStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorkingRemStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorkingRemStatus: %w", err)
	}
	return oldValue.APSWorkingRemStatus, nil
}

// ResetAPSWorkingRemStatus resets all changes to the "APSWorkingRemStatus" field.
func (m *UserMutation) ResetAPSWorkingRemStatus() {
	m._APSWorkingRemStatus = nil
}

// SetAPSWorkingRemarks sets the "APSWorkingRemarks" field.
func (m *UserMutation) SetAPSWorkingRemarks(s string) {
	m._APSWorkingRemarks = &s
}

// APSWorkingRemarks returns the value of the "APSWorkingRemarks" field in the mutation.
func (m *UserMutation) APSWorkingRemarks() (r string, exists bool) {
	v := m._APSWorkingRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldAPSWorkingRemarks returns the old "APSWorkingRemarks" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAPSWorkingRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPSWorkingRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPSWorkingRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPSWorkingRemarks: %w", err)
	}
	return oldValue.APSWorkingRemarks, nil
}

// ResetAPSWorkingRemarks resets all changes to the "APSWorkingRemarks" field.
func (m *UserMutation) ResetAPSWorkingRemarks() {
	m._APSWorkingRemarks = nil
}

// SetProfilestatus sets the "profilestatus" field.
func (m *UserMutation) SetProfilestatus(b bool) {
	m.profilestatus = &b
}

// Profilestatus returns the value of the "profilestatus" field in the mutation.
func (m *UserMutation) Profilestatus() (r bool, exists bool) {
	v := m.profilestatus
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilestatus returns the old "profilestatus" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfilestatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilestatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilestatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilestatus: %w", err)
	}
	return oldValue.Profilestatus, nil
}

// ResetProfilestatus resets all changes to the "profilestatus" field.
func (m *UserMutation) ResetProfilestatus() {
	m.profilestatus = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 37)
	if m._EmployeedID != nil {
		fields = append(fields, user.FieldEmployeedID)
	}
	if m._IDVerified != nil {
		fields = append(fields, user.FieldIDVerified)
	}
	if m._IDRemStatus != nil {
		fields = append(fields, user.FieldIDRemStatus)
	}
	if m._IDRemarks != nil {
		fields = append(fields, user.FieldIDRemarks)
	}
	if m._EmployeedName != nil {
		fields = append(fields, user.FieldEmployeedName)
	}
	if m.nameVerified != nil {
		fields = append(fields, user.FieldNameVerified)
	}
	if m.nameRemStatus != nil {
		fields = append(fields, user.FieldNameRemStatus)
	}
	if m.nameRemarks != nil {
		fields = append(fields, user.FieldNameRemarks)
	}
	if m._DOB != nil {
		fields = append(fields, user.FieldDOB)
	}
	if m._DOBVerified != nil {
		fields = append(fields, user.FieldDOBVerified)
	}
	if m._DOBRemStatus != nil {
		fields = append(fields, user.FieldDOBRemStatus)
	}
	if m._DOBRemarks != nil {
		fields = append(fields, user.FieldDOBRemarks)
	}
	if m._Gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.genderVerified != nil {
		fields = append(fields, user.FieldGenderVerified)
	}
	if m.genderRemStatus != nil {
		fields = append(fields, user.FieldGenderRemStatus)
	}
	if m.genderRemarks != nil {
		fields = append(fields, user.FieldGenderRemarks)
	}
	if m._Cadreid != nil {
		fields = append(fields, user.FieldCadreid)
	}
	if m.cadreidVerified != nil {
		fields = append(fields, user.FieldCadreidVerified)
	}
	if m.cadreidRemStatus != nil {
		fields = append(fields, user.FieldCadreidRemStatus)
	}
	if m.cadreidRemarks != nil {
		fields = append(fields, user.FieldCadreidRemarks)
	}
	if m._OfficeID != nil {
		fields = append(fields, user.FieldOfficeID)
	}
	if m.officeIDVerified != nil {
		fields = append(fields, user.FieldOfficeIDVerified)
	}
	if m.officeIDRemStatus != nil {
		fields = append(fields, user.FieldOfficeIDRemStatus)
	}
	if m.officeIDRemarks != nil {
		fields = append(fields, user.FieldOfficeIDRemarks)
	}
	if m._PH != nil {
		fields = append(fields, user.FieldPH)
	}
	if m._PHVerified != nil {
		fields = append(fields, user.FieldPHVerified)
	}
	if m._PHRemStatus != nil {
		fields = append(fields, user.FieldPHRemStatus)
	}
	if m._PHRemarks != nil {
		fields = append(fields, user.FieldPHRemarks)
	}
	if m._PHDetails != nil {
		fields = append(fields, user.FieldPHDetails)
	}
	if m._PHDetailsVerified != nil {
		fields = append(fields, user.FieldPHDetailsVerified)
	}
	if m._PHDetailsRemStatus != nil {
		fields = append(fields, user.FieldPHDetailsRemStatus)
	}
	if m._PHDetailsRemarks != nil {
		fields = append(fields, user.FieldPHDetailsRemarks)
	}
	if m._APSWorking != nil {
		fields = append(fields, user.FieldAPSWorking)
	}
	if m._APSWorkingVerified != nil {
		fields = append(fields, user.FieldAPSWorkingVerified)
	}
	if m._APSWorkingRemStatus != nil {
		fields = append(fields, user.FieldAPSWorkingRemStatus)
	}
	if m._APSWorkingRemarks != nil {
		fields = append(fields, user.FieldAPSWorkingRemarks)
	}
	if m.profilestatus != nil {
		fields = append(fields, user.FieldProfilestatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmployeedID:
		return m.EmployeedID()
	case user.FieldIDVerified:
		return m.IDVerified()
	case user.FieldIDRemStatus:
		return m.IDRemStatus()
	case user.FieldIDRemarks:
		return m.IDRemarks()
	case user.FieldEmployeedName:
		return m.EmployeedName()
	case user.FieldNameVerified:
		return m.NameVerified()
	case user.FieldNameRemStatus:
		return m.NameRemStatus()
	case user.FieldNameRemarks:
		return m.NameRemarks()
	case user.FieldDOB:
		return m.DOB()
	case user.FieldDOBVerified:
		return m.DOBVerified()
	case user.FieldDOBRemStatus:
		return m.DOBRemStatus()
	case user.FieldDOBRemarks:
		return m.DOBRemarks()
	case user.FieldGender:
		return m.Gender()
	case user.FieldGenderVerified:
		return m.GenderVerified()
	case user.FieldGenderRemStatus:
		return m.GenderRemStatus()
	case user.FieldGenderRemarks:
		return m.GenderRemarks()
	case user.FieldCadreid:
		return m.Cadreid()
	case user.FieldCadreidVerified:
		return m.CadreidVerified()
	case user.FieldCadreidRemStatus:
		return m.CadreidRemStatus()
	case user.FieldCadreidRemarks:
		return m.CadreidRemarks()
	case user.FieldOfficeID:
		return m.OfficeID()
	case user.FieldOfficeIDVerified:
		return m.OfficeIDVerified()
	case user.FieldOfficeIDRemStatus:
		return m.OfficeIDRemStatus()
	case user.FieldOfficeIDRemarks:
		return m.OfficeIDRemarks()
	case user.FieldPH:
		return m.PH()
	case user.FieldPHVerified:
		return m.PHVerified()
	case user.FieldPHRemStatus:
		return m.PHRemStatus()
	case user.FieldPHRemarks:
		return m.PHRemarks()
	case user.FieldPHDetails:
		return m.PHDetails()
	case user.FieldPHDetailsVerified:
		return m.PHDetailsVerified()
	case user.FieldPHDetailsRemStatus:
		return m.PHDetailsRemStatus()
	case user.FieldPHDetailsRemarks:
		return m.PHDetailsRemarks()
	case user.FieldAPSWorking:
		return m.APSWorking()
	case user.FieldAPSWorkingVerified:
		return m.APSWorkingVerified()
	case user.FieldAPSWorkingRemStatus:
		return m.APSWorkingRemStatus()
	case user.FieldAPSWorkingRemarks:
		return m.APSWorkingRemarks()
	case user.FieldProfilestatus:
		return m.Profilestatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmployeedID:
		return m.OldEmployeedID(ctx)
	case user.FieldIDVerified:
		return m.OldIDVerified(ctx)
	case user.FieldIDRemStatus:
		return m.OldIDRemStatus(ctx)
	case user.FieldIDRemarks:
		return m.OldIDRemarks(ctx)
	case user.FieldEmployeedName:
		return m.OldEmployeedName(ctx)
	case user.FieldNameVerified:
		return m.OldNameVerified(ctx)
	case user.FieldNameRemStatus:
		return m.OldNameRemStatus(ctx)
	case user.FieldNameRemarks:
		return m.OldNameRemarks(ctx)
	case user.FieldDOB:
		return m.OldDOB(ctx)
	case user.FieldDOBVerified:
		return m.OldDOBVerified(ctx)
	case user.FieldDOBRemStatus:
		return m.OldDOBRemStatus(ctx)
	case user.FieldDOBRemarks:
		return m.OldDOBRemarks(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldGenderVerified:
		return m.OldGenderVerified(ctx)
	case user.FieldGenderRemStatus:
		return m.OldGenderRemStatus(ctx)
	case user.FieldGenderRemarks:
		return m.OldGenderRemarks(ctx)
	case user.FieldCadreid:
		return m.OldCadreid(ctx)
	case user.FieldCadreidVerified:
		return m.OldCadreidVerified(ctx)
	case user.FieldCadreidRemStatus:
		return m.OldCadreidRemStatus(ctx)
	case user.FieldCadreidRemarks:
		return m.OldCadreidRemarks(ctx)
	case user.FieldOfficeID:
		return m.OldOfficeID(ctx)
	case user.FieldOfficeIDVerified:
		return m.OldOfficeIDVerified(ctx)
	case user.FieldOfficeIDRemStatus:
		return m.OldOfficeIDRemStatus(ctx)
	case user.FieldOfficeIDRemarks:
		return m.OldOfficeIDRemarks(ctx)
	case user.FieldPH:
		return m.OldPH(ctx)
	case user.FieldPHVerified:
		return m.OldPHVerified(ctx)
	case user.FieldPHRemStatus:
		return m.OldPHRemStatus(ctx)
	case user.FieldPHRemarks:
		return m.OldPHRemarks(ctx)
	case user.FieldPHDetails:
		return m.OldPHDetails(ctx)
	case user.FieldPHDetailsVerified:
		return m.OldPHDetailsVerified(ctx)
	case user.FieldPHDetailsRemStatus:
		return m.OldPHDetailsRemStatus(ctx)
	case user.FieldPHDetailsRemarks:
		return m.OldPHDetailsRemarks(ctx)
	case user.FieldAPSWorking:
		return m.OldAPSWorking(ctx)
	case user.FieldAPSWorkingVerified:
		return m.OldAPSWorkingVerified(ctx)
	case user.FieldAPSWorkingRemStatus:
		return m.OldAPSWorkingRemStatus(ctx)
	case user.FieldAPSWorkingRemarks:
		return m.OldAPSWorkingRemarks(ctx)
	case user.FieldProfilestatus:
		return m.OldProfilestatus(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmployeedID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeedID(v)
		return nil
	case user.FieldIDVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDVerified(v)
		return nil
	case user.FieldIDRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDRemStatus(v)
		return nil
	case user.FieldIDRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDRemarks(v)
		return nil
	case user.FieldEmployeedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeedName(v)
		return nil
	case user.FieldNameVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameVerified(v)
		return nil
	case user.FieldNameRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameRemStatus(v)
		return nil
	case user.FieldNameRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameRemarks(v)
		return nil
	case user.FieldDOB:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOB(v)
		return nil
	case user.FieldDOBVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOBVerified(v)
		return nil
	case user.FieldDOBRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOBRemStatus(v)
		return nil
	case user.FieldDOBRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOBRemarks(v)
		return nil
	case user.FieldGender:
		v, ok := value.(user.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldGenderVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderVerified(v)
		return nil
	case user.FieldGenderRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderRemStatus(v)
		return nil
	case user.FieldGenderRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderRemarks(v)
		return nil
	case user.FieldCadreid:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadreid(v)
		return nil
	case user.FieldCadreidVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadreidVerified(v)
		return nil
	case user.FieldCadreidRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadreidRemStatus(v)
		return nil
	case user.FieldCadreidRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadreidRemarks(v)
		return nil
	case user.FieldOfficeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeID(v)
		return nil
	case user.FieldOfficeIDVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeIDVerified(v)
		return nil
	case user.FieldOfficeIDRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeIDRemStatus(v)
		return nil
	case user.FieldOfficeIDRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeIDRemarks(v)
		return nil
	case user.FieldPH:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPH(v)
		return nil
	case user.FieldPHVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHVerified(v)
		return nil
	case user.FieldPHRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHRemStatus(v)
		return nil
	case user.FieldPHRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHRemarks(v)
		return nil
	case user.FieldPHDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHDetails(v)
		return nil
	case user.FieldPHDetailsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHDetailsVerified(v)
		return nil
	case user.FieldPHDetailsRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHDetailsRemStatus(v)
		return nil
	case user.FieldPHDetailsRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHDetailsRemarks(v)
		return nil
	case user.FieldAPSWorking:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorking(v)
		return nil
	case user.FieldAPSWorkingVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorkingVerified(v)
		return nil
	case user.FieldAPSWorkingRemStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorkingRemStatus(v)
		return nil
	case user.FieldAPSWorkingRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPSWorkingRemarks(v)
		return nil
	case user.FieldProfilestatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilestatus(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.add_Cadreid != nil {
		fields = append(fields, user.FieldCadreid)
	}
	if m.add_OfficeID != nil {
		fields = append(fields, user.FieldOfficeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCadreid:
		return m.AddedCadreid()
	case user.FieldOfficeID:
		return m.AddedOfficeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCadreid:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCadreid(v)
		return nil
	case user.FieldOfficeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOfficeID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPHDetails) {
		fields = append(fields, user.FieldPHDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPHDetails:
		m.ClearPHDetails()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmployeedID:
		m.ResetEmployeedID()
		return nil
	case user.FieldIDVerified:
		m.ResetIDVerified()
		return nil
	case user.FieldIDRemStatus:
		m.ResetIDRemStatus()
		return nil
	case user.FieldIDRemarks:
		m.ResetIDRemarks()
		return nil
	case user.FieldEmployeedName:
		m.ResetEmployeedName()
		return nil
	case user.FieldNameVerified:
		m.ResetNameVerified()
		return nil
	case user.FieldNameRemStatus:
		m.ResetNameRemStatus()
		return nil
	case user.FieldNameRemarks:
		m.ResetNameRemarks()
		return nil
	case user.FieldDOB:
		m.ResetDOB()
		return nil
	case user.FieldDOBVerified:
		m.ResetDOBVerified()
		return nil
	case user.FieldDOBRemStatus:
		m.ResetDOBRemStatus()
		return nil
	case user.FieldDOBRemarks:
		m.ResetDOBRemarks()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldGenderVerified:
		m.ResetGenderVerified()
		return nil
	case user.FieldGenderRemStatus:
		m.ResetGenderRemStatus()
		return nil
	case user.FieldGenderRemarks:
		m.ResetGenderRemarks()
		return nil
	case user.FieldCadreid:
		m.ResetCadreid()
		return nil
	case user.FieldCadreidVerified:
		m.ResetCadreidVerified()
		return nil
	case user.FieldCadreidRemStatus:
		m.ResetCadreidRemStatus()
		return nil
	case user.FieldCadreidRemarks:
		m.ResetCadreidRemarks()
		return nil
	case user.FieldOfficeID:
		m.ResetOfficeID()
		return nil
	case user.FieldOfficeIDVerified:
		m.ResetOfficeIDVerified()
		return nil
	case user.FieldOfficeIDRemStatus:
		m.ResetOfficeIDRemStatus()
		return nil
	case user.FieldOfficeIDRemarks:
		m.ResetOfficeIDRemarks()
		return nil
	case user.FieldPH:
		m.ResetPH()
		return nil
	case user.FieldPHVerified:
		m.ResetPHVerified()
		return nil
	case user.FieldPHRemStatus:
		m.ResetPHRemStatus()
		return nil
	case user.FieldPHRemarks:
		m.ResetPHRemarks()
		return nil
	case user.FieldPHDetails:
		m.ResetPHDetails()
		return nil
	case user.FieldPHDetailsVerified:
		m.ResetPHDetailsVerified()
		return nil
	case user.FieldPHDetailsRemStatus:
		m.ResetPHDetailsRemStatus()
		return nil
	case user.FieldPHDetailsRemarks:
		m.ResetPHDetailsRemarks()
		return nil
	case user.FieldAPSWorking:
		m.ResetAPSWorking()
		return nil
	case user.FieldAPSWorkingVerified:
		m.ResetAPSWorkingVerified()
		return nil
	case user.FieldAPSWorkingRemStatus:
		m.ResetAPSWorkingRemStatus()
		return nil
	case user.FieldAPSWorkingRemarks:
		m.ResetAPSWorkingRemarks()
		return nil
	case user.FieldProfilestatus:
		m.ResetProfilestatus()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// UserMasterMutation represents an operation that mutates the UserMaster nodes in the graph.
type UserMasterMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	_EmployeeID           *int64
	add_EmployeeID        *int64
	_EmployeeName         *string
	_FacilityID           *string
	_Cadre                *string
	_Mobile               *string
	_EmailID              *string
	_UserName             *string
	_Password             *string
	_OTP                  *int32
	add_OTP               *int32
	_ExamCode             *int32
	add_ExamCode          *int32
	_ExamCodePS           *int32
	add_ExamCodePS        *int32
	_OTPRemarks           *string
	_Status               *bool
	_NewPasswordRequest   *bool
	_CreatedAt            *time.Time
	_OTPTriggeredTime     *time.Time
	_CreatedBy            *string
	clearedFields         map[string]struct{}
	roles                 *int32
	clearedroles          bool
	_UsermasterRef        map[int64]struct{}
	removed_UsermasterRef map[int64]struct{}
	cleared_UsermasterRef bool
	_UsersPSRef           map[int64]struct{}
	removed_UsersPSRef    map[int64]struct{}
	cleared_UsersPSRef    bool
	_UsersIPRef           map[int64]struct{}
	removed_UsersIPRef    map[int64]struct{}
	cleared_UsersIPRef    bool
	users_ps_type         map[int32]struct{}
	removedusers_ps_type  map[int32]struct{}
	clearedusers_ps_type  bool
	users_ip_type         map[int32]struct{}
	removedusers_ip_type  map[int32]struct{}
	clearedusers_ip_type  bool
	done                  bool
	oldValue              func(context.Context) (*UserMaster, error)
	predicates            []predicate.UserMaster
}

var _ ent.Mutation = (*UserMasterMutation)(nil)

// usermasterOption allows management of the mutation configuration using functional options.
type usermasterOption func(*UserMasterMutation)

// newUserMasterMutation creates new mutation for the UserMaster entity.
func newUserMasterMutation(c config, op Op, opts ...usermasterOption) *UserMasterMutation {
	m := &UserMasterMutation{
		config:        c,
		op:            op,
		typ:           TypeUserMaster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserMasterID sets the ID field of the mutation.
func withUserMasterID(id int64) usermasterOption {
	return func(m *UserMasterMutation) {
		var (
			err   error
			once  sync.Once
			value *UserMaster
		)
		m.oldValue = func(ctx context.Context) (*UserMaster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserMaster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserMaster sets the old UserMaster of the mutation.
func withUserMaster(node *UserMaster) usermasterOption {
	return func(m *UserMasterMutation) {
		m.oldValue = func(context.Context) (*UserMaster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMasterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMasterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserMaster entities.
func (m *UserMasterMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMasterMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMasterMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserMaster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *UserMasterMutation) SetEmployeeID(i int64) {
	m._EmployeeID = &i
	m.add_EmployeeID = nil
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *UserMasterMutation) EmployeeID() (r int64, exists bool) {
	v := m._EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldEmployeeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// AddEmployeeID adds i to the "EmployeeID" field.
func (m *UserMasterMutation) AddEmployeeID(i int64) {
	if m.add_EmployeeID != nil {
		*m.add_EmployeeID += i
	} else {
		m.add_EmployeeID = &i
	}
}

// AddedEmployeeID returns the value that was added to the "EmployeeID" field in this mutation.
func (m *UserMasterMutation) AddedEmployeeID() (r int64, exists bool) {
	v := m.add_EmployeeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmployeeID clears the value of the "EmployeeID" field.
func (m *UserMasterMutation) ClearEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	m.clearedFields[usermaster.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "EmployeeID" field was cleared in this mutation.
func (m *UserMasterMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *UserMasterMutation) ResetEmployeeID() {
	m._EmployeeID = nil
	m.add_EmployeeID = nil
	delete(m.clearedFields, usermaster.FieldEmployeeID)
}

// SetEmployeeName sets the "EmployeeName" field.
func (m *UserMasterMutation) SetEmployeeName(s string) {
	m._EmployeeName = &s
}

// EmployeeName returns the value of the "EmployeeName" field in the mutation.
func (m *UserMasterMutation) EmployeeName() (r string, exists bool) {
	v := m._EmployeeName
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeName returns the old "EmployeeName" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldEmployeeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeName: %w", err)
	}
	return oldValue.EmployeeName, nil
}

// ClearEmployeeName clears the value of the "EmployeeName" field.
func (m *UserMasterMutation) ClearEmployeeName() {
	m._EmployeeName = nil
	m.clearedFields[usermaster.FieldEmployeeName] = struct{}{}
}

// EmployeeNameCleared returns if the "EmployeeName" field was cleared in this mutation.
func (m *UserMasterMutation) EmployeeNameCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldEmployeeName]
	return ok
}

// ResetEmployeeName resets all changes to the "EmployeeName" field.
func (m *UserMasterMutation) ResetEmployeeName() {
	m._EmployeeName = nil
	delete(m.clearedFields, usermaster.FieldEmployeeName)
}

// SetFacilityID sets the "FacilityID" field.
func (m *UserMasterMutation) SetFacilityID(s string) {
	m._FacilityID = &s
}

// FacilityID returns the value of the "FacilityID" field in the mutation.
func (m *UserMasterMutation) FacilityID() (r string, exists bool) {
	v := m._FacilityID
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityID returns the old "FacilityID" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldFacilityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityID: %w", err)
	}
	return oldValue.FacilityID, nil
}

// ClearFacilityID clears the value of the "FacilityID" field.
func (m *UserMasterMutation) ClearFacilityID() {
	m._FacilityID = nil
	m.clearedFields[usermaster.FieldFacilityID] = struct{}{}
}

// FacilityIDCleared returns if the "FacilityID" field was cleared in this mutation.
func (m *UserMasterMutation) FacilityIDCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldFacilityID]
	return ok
}

// ResetFacilityID resets all changes to the "FacilityID" field.
func (m *UserMasterMutation) ResetFacilityID() {
	m._FacilityID = nil
	delete(m.clearedFields, usermaster.FieldFacilityID)
}

// SetCadre sets the "Cadre" field.
func (m *UserMasterMutation) SetCadre(s string) {
	m._Cadre = &s
}

// Cadre returns the value of the "Cadre" field in the mutation.
func (m *UserMasterMutation) Cadre() (r string, exists bool) {
	v := m._Cadre
	if v == nil {
		return
	}
	return *v, true
}

// OldCadre returns the old "Cadre" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldCadre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCadre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCadre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCadre: %w", err)
	}
	return oldValue.Cadre, nil
}

// ClearCadre clears the value of the "Cadre" field.
func (m *UserMasterMutation) ClearCadre() {
	m._Cadre = nil
	m.clearedFields[usermaster.FieldCadre] = struct{}{}
}

// CadreCleared returns if the "Cadre" field was cleared in this mutation.
func (m *UserMasterMutation) CadreCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldCadre]
	return ok
}

// ResetCadre resets all changes to the "Cadre" field.
func (m *UserMasterMutation) ResetCadre() {
	m._Cadre = nil
	delete(m.clearedFields, usermaster.FieldCadre)
}

// SetRoleUserCode sets the "RoleUserCode" field.
func (m *UserMasterMutation) SetRoleUserCode(i int32) {
	m.roles = &i
}

// RoleUserCode returns the value of the "RoleUserCode" field in the mutation.
func (m *UserMasterMutation) RoleUserCode() (r int32, exists bool) {
	v := m.roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleUserCode returns the old "RoleUserCode" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldRoleUserCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleUserCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleUserCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleUserCode: %w", err)
	}
	return oldValue.RoleUserCode, nil
}

// ClearRoleUserCode clears the value of the "RoleUserCode" field.
func (m *UserMasterMutation) ClearRoleUserCode() {
	m.roles = nil
	m.clearedFields[usermaster.FieldRoleUserCode] = struct{}{}
}

// RoleUserCodeCleared returns if the "RoleUserCode" field was cleared in this mutation.
func (m *UserMasterMutation) RoleUserCodeCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldRoleUserCode]
	return ok
}

// ResetRoleUserCode resets all changes to the "RoleUserCode" field.
func (m *UserMasterMutation) ResetRoleUserCode() {
	m.roles = nil
	delete(m.clearedFields, usermaster.FieldRoleUserCode)
}

// SetMobile sets the "Mobile" field.
func (m *UserMasterMutation) SetMobile(s string) {
	m._Mobile = &s
}

// Mobile returns the value of the "Mobile" field in the mutation.
func (m *UserMasterMutation) Mobile() (r string, exists bool) {
	v := m._Mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "Mobile" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "Mobile" field.
func (m *UserMasterMutation) ClearMobile() {
	m._Mobile = nil
	m.clearedFields[usermaster.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "Mobile" field was cleared in this mutation.
func (m *UserMasterMutation) MobileCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "Mobile" field.
func (m *UserMasterMutation) ResetMobile() {
	m._Mobile = nil
	delete(m.clearedFields, usermaster.FieldMobile)
}

// SetEmailID sets the "EmailID" field.
func (m *UserMasterMutation) SetEmailID(s string) {
	m._EmailID = &s
}

// EmailID returns the value of the "EmailID" field in the mutation.
func (m *UserMasterMutation) EmailID() (r string, exists bool) {
	v := m._EmailID
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailID returns the old "EmailID" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldEmailID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailID: %w", err)
	}
	return oldValue.EmailID, nil
}

// ClearEmailID clears the value of the "EmailID" field.
func (m *UserMasterMutation) ClearEmailID() {
	m._EmailID = nil
	m.clearedFields[usermaster.FieldEmailID] = struct{}{}
}

// EmailIDCleared returns if the "EmailID" field was cleared in this mutation.
func (m *UserMasterMutation) EmailIDCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldEmailID]
	return ok
}

// ResetEmailID resets all changes to the "EmailID" field.
func (m *UserMasterMutation) ResetEmailID() {
	m._EmailID = nil
	delete(m.clearedFields, usermaster.FieldEmailID)
}

// SetUserName sets the "UserName" field.
func (m *UserMasterMutation) SetUserName(s string) {
	m._UserName = &s
}

// UserName returns the value of the "UserName" field in the mutation.
func (m *UserMasterMutation) UserName() (r string, exists bool) {
	v := m._UserName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "UserName" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "UserName" field.
func (m *UserMasterMutation) ClearUserName() {
	m._UserName = nil
	m.clearedFields[usermaster.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "UserName" field was cleared in this mutation.
func (m *UserMasterMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "UserName" field.
func (m *UserMasterMutation) ResetUserName() {
	m._UserName = nil
	delete(m.clearedFields, usermaster.FieldUserName)
}

// SetPassword sets the "Password" field.
func (m *UserMasterMutation) SetPassword(s string) {
	m._Password = &s
}

// Password returns the value of the "Password" field in the mutation.
func (m *UserMasterMutation) Password() (r string, exists bool) {
	v := m._Password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "Password" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "Password" field.
func (m *UserMasterMutation) ClearPassword() {
	m._Password = nil
	m.clearedFields[usermaster.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "Password" field was cleared in this mutation.
func (m *UserMasterMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "Password" field.
func (m *UserMasterMutation) ResetPassword() {
	m._Password = nil
	delete(m.clearedFields, usermaster.FieldPassword)
}

// SetOTP sets the "OTP" field.
func (m *UserMasterMutation) SetOTP(i int32) {
	m._OTP = &i
	m.add_OTP = nil
}

// OTP returns the value of the "OTP" field in the mutation.
func (m *UserMasterMutation) OTP() (r int32, exists bool) {
	v := m._OTP
	if v == nil {
		return
	}
	return *v, true
}

// OldOTP returns the old "OTP" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldOTP(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOTP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOTP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOTP: %w", err)
	}
	return oldValue.OTP, nil
}

// AddOTP adds i to the "OTP" field.
func (m *UserMasterMutation) AddOTP(i int32) {
	if m.add_OTP != nil {
		*m.add_OTP += i
	} else {
		m.add_OTP = &i
	}
}

// AddedOTP returns the value that was added to the "OTP" field in this mutation.
func (m *UserMasterMutation) AddedOTP() (r int32, exists bool) {
	v := m.add_OTP
	if v == nil {
		return
	}
	return *v, true
}

// ClearOTP clears the value of the "OTP" field.
func (m *UserMasterMutation) ClearOTP() {
	m._OTP = nil
	m.add_OTP = nil
	m.clearedFields[usermaster.FieldOTP] = struct{}{}
}

// OTPCleared returns if the "OTP" field was cleared in this mutation.
func (m *UserMasterMutation) OTPCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldOTP]
	return ok
}

// ResetOTP resets all changes to the "OTP" field.
func (m *UserMasterMutation) ResetOTP() {
	m._OTP = nil
	m.add_OTP = nil
	delete(m.clearedFields, usermaster.FieldOTP)
}

// SetExamCode sets the "ExamCode" field.
func (m *UserMasterMutation) SetExamCode(i int32) {
	m._ExamCode = &i
	m.add_ExamCode = nil
}

// ExamCode returns the value of the "ExamCode" field in the mutation.
func (m *UserMasterMutation) ExamCode() (r int32, exists bool) {
	v := m._ExamCode
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCode returns the old "ExamCode" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldExamCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCode: %w", err)
	}
	return oldValue.ExamCode, nil
}

// AddExamCode adds i to the "ExamCode" field.
func (m *UserMasterMutation) AddExamCode(i int32) {
	if m.add_ExamCode != nil {
		*m.add_ExamCode += i
	} else {
		m.add_ExamCode = &i
	}
}

// AddedExamCode returns the value that was added to the "ExamCode" field in this mutation.
func (m *UserMasterMutation) AddedExamCode() (r int32, exists bool) {
	v := m.add_ExamCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearExamCode clears the value of the "ExamCode" field.
func (m *UserMasterMutation) ClearExamCode() {
	m._ExamCode = nil
	m.add_ExamCode = nil
	m.clearedFields[usermaster.FieldExamCode] = struct{}{}
}

// ExamCodeCleared returns if the "ExamCode" field was cleared in this mutation.
func (m *UserMasterMutation) ExamCodeCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldExamCode]
	return ok
}

// ResetExamCode resets all changes to the "ExamCode" field.
func (m *UserMasterMutation) ResetExamCode() {
	m._ExamCode = nil
	m.add_ExamCode = nil
	delete(m.clearedFields, usermaster.FieldExamCode)
}

// SetExamCodePS sets the "ExamCodePS" field.
func (m *UserMasterMutation) SetExamCodePS(i int32) {
	m._ExamCodePS = &i
	m.add_ExamCodePS = nil
}

// ExamCodePS returns the value of the "ExamCodePS" field in the mutation.
func (m *UserMasterMutation) ExamCodePS() (r int32, exists bool) {
	v := m._ExamCodePS
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCodePS returns the old "ExamCodePS" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldExamCodePS(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamCodePS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamCodePS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCodePS: %w", err)
	}
	return oldValue.ExamCodePS, nil
}

// AddExamCodePS adds i to the "ExamCodePS" field.
func (m *UserMasterMutation) AddExamCodePS(i int32) {
	if m.add_ExamCodePS != nil {
		*m.add_ExamCodePS += i
	} else {
		m.add_ExamCodePS = &i
	}
}

// AddedExamCodePS returns the value that was added to the "ExamCodePS" field in this mutation.
func (m *UserMasterMutation) AddedExamCodePS() (r int32, exists bool) {
	v := m.add_ExamCodePS
	if v == nil {
		return
	}
	return *v, true
}

// ClearExamCodePS clears the value of the "ExamCodePS" field.
func (m *UserMasterMutation) ClearExamCodePS() {
	m._ExamCodePS = nil
	m.add_ExamCodePS = nil
	m.clearedFields[usermaster.FieldExamCodePS] = struct{}{}
}

// ExamCodePSCleared returns if the "ExamCodePS" field was cleared in this mutation.
func (m *UserMasterMutation) ExamCodePSCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldExamCodePS]
	return ok
}

// ResetExamCodePS resets all changes to the "ExamCodePS" field.
func (m *UserMasterMutation) ResetExamCodePS() {
	m._ExamCodePS = nil
	m.add_ExamCodePS = nil
	delete(m.clearedFields, usermaster.FieldExamCodePS)
}

// SetOTPRemarks sets the "OTPRemarks" field.
func (m *UserMasterMutation) SetOTPRemarks(s string) {
	m._OTPRemarks = &s
}

// OTPRemarks returns the value of the "OTPRemarks" field in the mutation.
func (m *UserMasterMutation) OTPRemarks() (r string, exists bool) {
	v := m._OTPRemarks
	if v == nil {
		return
	}
	return *v, true
}

// OldOTPRemarks returns the old "OTPRemarks" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldOTPRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOTPRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOTPRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOTPRemarks: %w", err)
	}
	return oldValue.OTPRemarks, nil
}

// ClearOTPRemarks clears the value of the "OTPRemarks" field.
func (m *UserMasterMutation) ClearOTPRemarks() {
	m._OTPRemarks = nil
	m.clearedFields[usermaster.FieldOTPRemarks] = struct{}{}
}

// OTPRemarksCleared returns if the "OTPRemarks" field was cleared in this mutation.
func (m *UserMasterMutation) OTPRemarksCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldOTPRemarks]
	return ok
}

// ResetOTPRemarks resets all changes to the "OTPRemarks" field.
func (m *UserMasterMutation) ResetOTPRemarks() {
	m._OTPRemarks = nil
	delete(m.clearedFields, usermaster.FieldOTPRemarks)
}

// SetStatus sets the "Status" field.
func (m *UserMasterMutation) SetStatus(b bool) {
	m._Status = &b
}

// Status returns the value of the "Status" field in the mutation.
func (m *UserMasterMutation) Status() (r bool, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "Status" field.
func (m *UserMasterMutation) ClearStatus() {
	m._Status = nil
	m.clearedFields[usermaster.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "Status" field was cleared in this mutation.
func (m *UserMasterMutation) StatusCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "Status" field.
func (m *UserMasterMutation) ResetStatus() {
	m._Status = nil
	delete(m.clearedFields, usermaster.FieldStatus)
}

// SetNewPasswordRequest sets the "NewPasswordRequest" field.
func (m *UserMasterMutation) SetNewPasswordRequest(b bool) {
	m._NewPasswordRequest = &b
}

// NewPasswordRequest returns the value of the "NewPasswordRequest" field in the mutation.
func (m *UserMasterMutation) NewPasswordRequest() (r bool, exists bool) {
	v := m._NewPasswordRequest
	if v == nil {
		return
	}
	return *v, true
}

// OldNewPasswordRequest returns the old "NewPasswordRequest" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldNewPasswordRequest(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewPasswordRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewPasswordRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewPasswordRequest: %w", err)
	}
	return oldValue.NewPasswordRequest, nil
}

// ClearNewPasswordRequest clears the value of the "NewPasswordRequest" field.
func (m *UserMasterMutation) ClearNewPasswordRequest() {
	m._NewPasswordRequest = nil
	m.clearedFields[usermaster.FieldNewPasswordRequest] = struct{}{}
}

// NewPasswordRequestCleared returns if the "NewPasswordRequest" field was cleared in this mutation.
func (m *UserMasterMutation) NewPasswordRequestCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldNewPasswordRequest]
	return ok
}

// ResetNewPasswordRequest resets all changes to the "NewPasswordRequest" field.
func (m *UserMasterMutation) ResetNewPasswordRequest() {
	m._NewPasswordRequest = nil
	delete(m.clearedFields, usermaster.FieldNewPasswordRequest)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *UserMasterMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *UserMasterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "CreatedAt" field.
func (m *UserMasterMutation) ClearCreatedAt() {
	m._CreatedAt = nil
	m.clearedFields[usermaster.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "CreatedAt" field was cleared in this mutation.
func (m *UserMasterMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *UserMasterMutation) ResetCreatedAt() {
	m._CreatedAt = nil
	delete(m.clearedFields, usermaster.FieldCreatedAt)
}

// SetOTPTriggeredTime sets the "OTPTriggeredTime" field.
func (m *UserMasterMutation) SetOTPTriggeredTime(t time.Time) {
	m._OTPTriggeredTime = &t
}

// OTPTriggeredTime returns the value of the "OTPTriggeredTime" field in the mutation.
func (m *UserMasterMutation) OTPTriggeredTime() (r time.Time, exists bool) {
	v := m._OTPTriggeredTime
	if v == nil {
		return
	}
	return *v, true
}

// OldOTPTriggeredTime returns the old "OTPTriggeredTime" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldOTPTriggeredTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOTPTriggeredTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOTPTriggeredTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOTPTriggeredTime: %w", err)
	}
	return oldValue.OTPTriggeredTime, nil
}

// ClearOTPTriggeredTime clears the value of the "OTPTriggeredTime" field.
func (m *UserMasterMutation) ClearOTPTriggeredTime() {
	m._OTPTriggeredTime = nil
	m.clearedFields[usermaster.FieldOTPTriggeredTime] = struct{}{}
}

// OTPTriggeredTimeCleared returns if the "OTPTriggeredTime" field was cleared in this mutation.
func (m *UserMasterMutation) OTPTriggeredTimeCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldOTPTriggeredTime]
	return ok
}

// ResetOTPTriggeredTime resets all changes to the "OTPTriggeredTime" field.
func (m *UserMasterMutation) ResetOTPTriggeredTime() {
	m._OTPTriggeredTime = nil
	delete(m.clearedFields, usermaster.FieldOTPTriggeredTime)
}

// SetCreatedBy sets the "CreatedBy" field.
func (m *UserMasterMutation) SetCreatedBy(s string) {
	m._CreatedBy = &s
}

// CreatedBy returns the value of the "CreatedBy" field in the mutation.
func (m *UserMasterMutation) CreatedBy() (r string, exists bool) {
	v := m._CreatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "CreatedBy" field's value of the UserMaster entity.
// If the UserMaster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMasterMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "CreatedBy" field.
func (m *UserMasterMutation) ClearCreatedBy() {
	m._CreatedBy = nil
	m.clearedFields[usermaster.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "CreatedBy" field was cleared in this mutation.
func (m *UserMasterMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[usermaster.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "CreatedBy" field.
func (m *UserMasterMutation) ResetCreatedBy() {
	m._CreatedBy = nil
	delete(m.clearedFields, usermaster.FieldCreatedBy)
}

// SetRolesID sets the "roles" edge to the RoleMaster entity by id.
func (m *UserMasterMutation) SetRolesID(id int32) {
	m.roles = &id
}

// ClearRoles clears the "roles" edge to the RoleMaster entity.
func (m *UserMasterMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the RoleMaster entity was cleared.
func (m *UserMasterMutation) RolesCleared() bool {
	return m.RoleUserCodeCleared() || m.clearedroles
}

// RolesID returns the "roles" edge ID in the mutation.
func (m *UserMasterMutation) RolesID() (id int32, exists bool) {
	if m.roles != nil {
		return *m.roles, true
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RolesID instead. It exists only for internal usage by the builders.
func (m *UserMasterMutation) RolesIDs() (ids []int32) {
	if id := m.roles; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMasterMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
}

// AddUsermasterRefIDs adds the "UsermasterRef" edge to the EmployeeMaster entity by ids.
func (m *UserMasterMutation) AddUsermasterRefIDs(ids ...int64) {
	if m._UsermasterRef == nil {
		m._UsermasterRef = make(map[int64]struct{})
	}
	for i := range ids {
		m._UsermasterRef[ids[i]] = struct{}{}
	}
}

// ClearUsermasterRef clears the "UsermasterRef" edge to the EmployeeMaster entity.
func (m *UserMasterMutation) ClearUsermasterRef() {
	m.cleared_UsermasterRef = true
}

// UsermasterRefCleared reports if the "UsermasterRef" edge to the EmployeeMaster entity was cleared.
func (m *UserMasterMutation) UsermasterRefCleared() bool {
	return m.cleared_UsermasterRef
}

// RemoveUsermasterRefIDs removes the "UsermasterRef" edge to the EmployeeMaster entity by IDs.
func (m *UserMasterMutation) RemoveUsermasterRefIDs(ids ...int64) {
	if m.removed_UsermasterRef == nil {
		m.removed_UsermasterRef = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._UsermasterRef, ids[i])
		m.removed_UsermasterRef[ids[i]] = struct{}{}
	}
}

// RemovedUsermasterRef returns the removed IDs of the "UsermasterRef" edge to the EmployeeMaster entity.
func (m *UserMasterMutation) RemovedUsermasterRefIDs() (ids []int64) {
	for id := range m.removed_UsermasterRef {
		ids = append(ids, id)
	}
	return
}

// UsermasterRefIDs returns the "UsermasterRef" edge IDs in the mutation.
func (m *UserMasterMutation) UsermasterRefIDs() (ids []int64) {
	for id := range m._UsermasterRef {
		ids = append(ids, id)
	}
	return
}

// ResetUsermasterRef resets all changes to the "UsermasterRef" edge.
func (m *UserMasterMutation) ResetUsermasterRef() {
	m._UsermasterRef = nil
	m.cleared_UsermasterRef = false
	m.removed_UsermasterRef = nil
}

// AddUsersPSRefIDs adds the "UsersPSRef" edge to the Exam_Applications_PS entity by ids.
func (m *UserMasterMutation) AddUsersPSRefIDs(ids ...int64) {
	if m._UsersPSRef == nil {
		m._UsersPSRef = make(map[int64]struct{})
	}
	for i := range ids {
		m._UsersPSRef[ids[i]] = struct{}{}
	}
}

// ClearUsersPSRef clears the "UsersPSRef" edge to the Exam_Applications_PS entity.
func (m *UserMasterMutation) ClearUsersPSRef() {
	m.cleared_UsersPSRef = true
}

// UsersPSRefCleared reports if the "UsersPSRef" edge to the Exam_Applications_PS entity was cleared.
func (m *UserMasterMutation) UsersPSRefCleared() bool {
	return m.cleared_UsersPSRef
}

// RemoveUsersPSRefIDs removes the "UsersPSRef" edge to the Exam_Applications_PS entity by IDs.
func (m *UserMasterMutation) RemoveUsersPSRefIDs(ids ...int64) {
	if m.removed_UsersPSRef == nil {
		m.removed_UsersPSRef = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._UsersPSRef, ids[i])
		m.removed_UsersPSRef[ids[i]] = struct{}{}
	}
}

// RemovedUsersPSRef returns the removed IDs of the "UsersPSRef" edge to the Exam_Applications_PS entity.
func (m *UserMasterMutation) RemovedUsersPSRefIDs() (ids []int64) {
	for id := range m.removed_UsersPSRef {
		ids = append(ids, id)
	}
	return
}

// UsersPSRefIDs returns the "UsersPSRef" edge IDs in the mutation.
func (m *UserMasterMutation) UsersPSRefIDs() (ids []int64) {
	for id := range m._UsersPSRef {
		ids = append(ids, id)
	}
	return
}

// ResetUsersPSRef resets all changes to the "UsersPSRef" edge.
func (m *UserMasterMutation) ResetUsersPSRef() {
	m._UsersPSRef = nil
	m.cleared_UsersPSRef = false
	m.removed_UsersPSRef = nil
}

// AddUsersIPRefIDs adds the "UsersIPRef" edge to the Exam_Applications_IP entity by ids.
func (m *UserMasterMutation) AddUsersIPRefIDs(ids ...int64) {
	if m._UsersIPRef == nil {
		m._UsersIPRef = make(map[int64]struct{})
	}
	for i := range ids {
		m._UsersIPRef[ids[i]] = struct{}{}
	}
}

// ClearUsersIPRef clears the "UsersIPRef" edge to the Exam_Applications_IP entity.
func (m *UserMasterMutation) ClearUsersIPRef() {
	m.cleared_UsersIPRef = true
}

// UsersIPRefCleared reports if the "UsersIPRef" edge to the Exam_Applications_IP entity was cleared.
func (m *UserMasterMutation) UsersIPRefCleared() bool {
	return m.cleared_UsersIPRef
}

// RemoveUsersIPRefIDs removes the "UsersIPRef" edge to the Exam_Applications_IP entity by IDs.
func (m *UserMasterMutation) RemoveUsersIPRefIDs(ids ...int64) {
	if m.removed_UsersIPRef == nil {
		m.removed_UsersIPRef = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._UsersIPRef, ids[i])
		m.removed_UsersIPRef[ids[i]] = struct{}{}
	}
}

// RemovedUsersIPRef returns the removed IDs of the "UsersIPRef" edge to the Exam_Applications_IP entity.
func (m *UserMasterMutation) RemovedUsersIPRefIDs() (ids []int64) {
	for id := range m.removed_UsersIPRef {
		ids = append(ids, id)
	}
	return
}

// UsersIPRefIDs returns the "UsersIPRef" edge IDs in the mutation.
func (m *UserMasterMutation) UsersIPRefIDs() (ids []int64) {
	for id := range m._UsersIPRef {
		ids = append(ids, id)
	}
	return
}

// ResetUsersIPRef resets all changes to the "UsersIPRef" edge.
func (m *UserMasterMutation) ResetUsersIPRef() {
	m._UsersIPRef = nil
	m.cleared_UsersIPRef = false
	m.removed_UsersIPRef = nil
}

// AddUsersPsTypeIDs adds the "users_ps_type" edge to the Exam_PS entity by ids.
func (m *UserMasterMutation) AddUsersPsTypeIDs(ids ...int32) {
	if m.users_ps_type == nil {
		m.users_ps_type = make(map[int32]struct{})
	}
	for i := range ids {
		m.users_ps_type[ids[i]] = struct{}{}
	}
}

// ClearUsersPsType clears the "users_ps_type" edge to the Exam_PS entity.
func (m *UserMasterMutation) ClearUsersPsType() {
	m.clearedusers_ps_type = true
}

// UsersPsTypeCleared reports if the "users_ps_type" edge to the Exam_PS entity was cleared.
func (m *UserMasterMutation) UsersPsTypeCleared() bool {
	return m.clearedusers_ps_type
}

// RemoveUsersPsTypeIDs removes the "users_ps_type" edge to the Exam_PS entity by IDs.
func (m *UserMasterMutation) RemoveUsersPsTypeIDs(ids ...int32) {
	if m.removedusers_ps_type == nil {
		m.removedusers_ps_type = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.users_ps_type, ids[i])
		m.removedusers_ps_type[ids[i]] = struct{}{}
	}
}

// RemovedUsersPsType returns the removed IDs of the "users_ps_type" edge to the Exam_PS entity.
func (m *UserMasterMutation) RemovedUsersPsTypeIDs() (ids []int32) {
	for id := range m.removedusers_ps_type {
		ids = append(ids, id)
	}
	return
}

// UsersPsTypeIDs returns the "users_ps_type" edge IDs in the mutation.
func (m *UserMasterMutation) UsersPsTypeIDs() (ids []int32) {
	for id := range m.users_ps_type {
		ids = append(ids, id)
	}
	return
}

// ResetUsersPsType resets all changes to the "users_ps_type" edge.
func (m *UserMasterMutation) ResetUsersPsType() {
	m.users_ps_type = nil
	m.clearedusers_ps_type = false
	m.removedusers_ps_type = nil
}

// AddUsersIPTypeIDs adds the "users_ip_type" edge to the Exam_IP entity by ids.
func (m *UserMasterMutation) AddUsersIPTypeIDs(ids ...int32) {
	if m.users_ip_type == nil {
		m.users_ip_type = make(map[int32]struct{})
	}
	for i := range ids {
		m.users_ip_type[ids[i]] = struct{}{}
	}
}

// ClearUsersIPType clears the "users_ip_type" edge to the Exam_IP entity.
func (m *UserMasterMutation) ClearUsersIPType() {
	m.clearedusers_ip_type = true
}

// UsersIPTypeCleared reports if the "users_ip_type" edge to the Exam_IP entity was cleared.
func (m *UserMasterMutation) UsersIPTypeCleared() bool {
	return m.clearedusers_ip_type
}

// RemoveUsersIPTypeIDs removes the "users_ip_type" edge to the Exam_IP entity by IDs.
func (m *UserMasterMutation) RemoveUsersIPTypeIDs(ids ...int32) {
	if m.removedusers_ip_type == nil {
		m.removedusers_ip_type = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.users_ip_type, ids[i])
		m.removedusers_ip_type[ids[i]] = struct{}{}
	}
}

// RemovedUsersIPType returns the removed IDs of the "users_ip_type" edge to the Exam_IP entity.
func (m *UserMasterMutation) RemovedUsersIPTypeIDs() (ids []int32) {
	for id := range m.removedusers_ip_type {
		ids = append(ids, id)
	}
	return
}

// UsersIPTypeIDs returns the "users_ip_type" edge IDs in the mutation.
func (m *UserMasterMutation) UsersIPTypeIDs() (ids []int32) {
	for id := range m.users_ip_type {
		ids = append(ids, id)
	}
	return
}

// ResetUsersIPType resets all changes to the "users_ip_type" edge.
func (m *UserMasterMutation) ResetUsersIPType() {
	m.users_ip_type = nil
	m.clearedusers_ip_type = false
	m.removedusers_ip_type = nil
}

// Where appends a list predicates to the UserMasterMutation builder.
func (m *UserMasterMutation) Where(ps ...predicate.UserMaster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMasterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMasterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserMaster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMasterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMasterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserMaster).
func (m *UserMasterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMasterMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m._EmployeeID != nil {
		fields = append(fields, usermaster.FieldEmployeeID)
	}
	if m._EmployeeName != nil {
		fields = append(fields, usermaster.FieldEmployeeName)
	}
	if m._FacilityID != nil {
		fields = append(fields, usermaster.FieldFacilityID)
	}
	if m._Cadre != nil {
		fields = append(fields, usermaster.FieldCadre)
	}
	if m.roles != nil {
		fields = append(fields, usermaster.FieldRoleUserCode)
	}
	if m._Mobile != nil {
		fields = append(fields, usermaster.FieldMobile)
	}
	if m._EmailID != nil {
		fields = append(fields, usermaster.FieldEmailID)
	}
	if m._UserName != nil {
		fields = append(fields, usermaster.FieldUserName)
	}
	if m._Password != nil {
		fields = append(fields, usermaster.FieldPassword)
	}
	if m._OTP != nil {
		fields = append(fields, usermaster.FieldOTP)
	}
	if m._ExamCode != nil {
		fields = append(fields, usermaster.FieldExamCode)
	}
	if m._ExamCodePS != nil {
		fields = append(fields, usermaster.FieldExamCodePS)
	}
	if m._OTPRemarks != nil {
		fields = append(fields, usermaster.FieldOTPRemarks)
	}
	if m._Status != nil {
		fields = append(fields, usermaster.FieldStatus)
	}
	if m._NewPasswordRequest != nil {
		fields = append(fields, usermaster.FieldNewPasswordRequest)
	}
	if m._CreatedAt != nil {
		fields = append(fields, usermaster.FieldCreatedAt)
	}
	if m._OTPTriggeredTime != nil {
		fields = append(fields, usermaster.FieldOTPTriggeredTime)
	}
	if m._CreatedBy != nil {
		fields = append(fields, usermaster.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMasterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usermaster.FieldEmployeeID:
		return m.EmployeeID()
	case usermaster.FieldEmployeeName:
		return m.EmployeeName()
	case usermaster.FieldFacilityID:
		return m.FacilityID()
	case usermaster.FieldCadre:
		return m.Cadre()
	case usermaster.FieldRoleUserCode:
		return m.RoleUserCode()
	case usermaster.FieldMobile:
		return m.Mobile()
	case usermaster.FieldEmailID:
		return m.EmailID()
	case usermaster.FieldUserName:
		return m.UserName()
	case usermaster.FieldPassword:
		return m.Password()
	case usermaster.FieldOTP:
		return m.OTP()
	case usermaster.FieldExamCode:
		return m.ExamCode()
	case usermaster.FieldExamCodePS:
		return m.ExamCodePS()
	case usermaster.FieldOTPRemarks:
		return m.OTPRemarks()
	case usermaster.FieldStatus:
		return m.Status()
	case usermaster.FieldNewPasswordRequest:
		return m.NewPasswordRequest()
	case usermaster.FieldCreatedAt:
		return m.CreatedAt()
	case usermaster.FieldOTPTriggeredTime:
		return m.OTPTriggeredTime()
	case usermaster.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMasterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usermaster.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case usermaster.FieldEmployeeName:
		return m.OldEmployeeName(ctx)
	case usermaster.FieldFacilityID:
		return m.OldFacilityID(ctx)
	case usermaster.FieldCadre:
		return m.OldCadre(ctx)
	case usermaster.FieldRoleUserCode:
		return m.OldRoleUserCode(ctx)
	case usermaster.FieldMobile:
		return m.OldMobile(ctx)
	case usermaster.FieldEmailID:
		return m.OldEmailID(ctx)
	case usermaster.FieldUserName:
		return m.OldUserName(ctx)
	case usermaster.FieldPassword:
		return m.OldPassword(ctx)
	case usermaster.FieldOTP:
		return m.OldOTP(ctx)
	case usermaster.FieldExamCode:
		return m.OldExamCode(ctx)
	case usermaster.FieldExamCodePS:
		return m.OldExamCodePS(ctx)
	case usermaster.FieldOTPRemarks:
		return m.OldOTPRemarks(ctx)
	case usermaster.FieldStatus:
		return m.OldStatus(ctx)
	case usermaster.FieldNewPasswordRequest:
		return m.OldNewPasswordRequest(ctx)
	case usermaster.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usermaster.FieldOTPTriggeredTime:
		return m.OldOTPTriggeredTime(ctx)
	case usermaster.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown UserMaster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMasterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usermaster.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case usermaster.FieldEmployeeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeName(v)
		return nil
	case usermaster.FieldFacilityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityID(v)
		return nil
	case usermaster.FieldCadre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCadre(v)
		return nil
	case usermaster.FieldRoleUserCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleUserCode(v)
		return nil
	case usermaster.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case usermaster.FieldEmailID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailID(v)
		return nil
	case usermaster.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case usermaster.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case usermaster.FieldOTP:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOTP(v)
		return nil
	case usermaster.FieldExamCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCode(v)
		return nil
	case usermaster.FieldExamCodePS:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCodePS(v)
		return nil
	case usermaster.FieldOTPRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOTPRemarks(v)
		return nil
	case usermaster.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case usermaster.FieldNewPasswordRequest:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewPasswordRequest(v)
		return nil
	case usermaster.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usermaster.FieldOTPTriggeredTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOTPTriggeredTime(v)
		return nil
	case usermaster.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserMaster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMasterMutation) AddedFields() []string {
	var fields []string
	if m.add_EmployeeID != nil {
		fields = append(fields, usermaster.FieldEmployeeID)
	}
	if m.add_OTP != nil {
		fields = append(fields, usermaster.FieldOTP)
	}
	if m.add_ExamCode != nil {
		fields = append(fields, usermaster.FieldExamCode)
	}
	if m.add_ExamCodePS != nil {
		fields = append(fields, usermaster.FieldExamCodePS)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMasterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usermaster.FieldEmployeeID:
		return m.AddedEmployeeID()
	case usermaster.FieldOTP:
		return m.AddedOTP()
	case usermaster.FieldExamCode:
		return m.AddedExamCode()
	case usermaster.FieldExamCodePS:
		return m.AddedExamCodePS()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMasterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usermaster.FieldEmployeeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeID(v)
		return nil
	case usermaster.FieldOTP:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOTP(v)
		return nil
	case usermaster.FieldExamCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamCode(v)
		return nil
	case usermaster.FieldExamCodePS:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamCodePS(v)
		return nil
	}
	return fmt.Errorf("unknown UserMaster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMasterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usermaster.FieldEmployeeID) {
		fields = append(fields, usermaster.FieldEmployeeID)
	}
	if m.FieldCleared(usermaster.FieldEmployeeName) {
		fields = append(fields, usermaster.FieldEmployeeName)
	}
	if m.FieldCleared(usermaster.FieldFacilityID) {
		fields = append(fields, usermaster.FieldFacilityID)
	}
	if m.FieldCleared(usermaster.FieldCadre) {
		fields = append(fields, usermaster.FieldCadre)
	}
	if m.FieldCleared(usermaster.FieldRoleUserCode) {
		fields = append(fields, usermaster.FieldRoleUserCode)
	}
	if m.FieldCleared(usermaster.FieldMobile) {
		fields = append(fields, usermaster.FieldMobile)
	}
	if m.FieldCleared(usermaster.FieldEmailID) {
		fields = append(fields, usermaster.FieldEmailID)
	}
	if m.FieldCleared(usermaster.FieldUserName) {
		fields = append(fields, usermaster.FieldUserName)
	}
	if m.FieldCleared(usermaster.FieldPassword) {
		fields = append(fields, usermaster.FieldPassword)
	}
	if m.FieldCleared(usermaster.FieldOTP) {
		fields = append(fields, usermaster.FieldOTP)
	}
	if m.FieldCleared(usermaster.FieldExamCode) {
		fields = append(fields, usermaster.FieldExamCode)
	}
	if m.FieldCleared(usermaster.FieldExamCodePS) {
		fields = append(fields, usermaster.FieldExamCodePS)
	}
	if m.FieldCleared(usermaster.FieldOTPRemarks) {
		fields = append(fields, usermaster.FieldOTPRemarks)
	}
	if m.FieldCleared(usermaster.FieldStatus) {
		fields = append(fields, usermaster.FieldStatus)
	}
	if m.FieldCleared(usermaster.FieldNewPasswordRequest) {
		fields = append(fields, usermaster.FieldNewPasswordRequest)
	}
	if m.FieldCleared(usermaster.FieldCreatedAt) {
		fields = append(fields, usermaster.FieldCreatedAt)
	}
	if m.FieldCleared(usermaster.FieldOTPTriggeredTime) {
		fields = append(fields, usermaster.FieldOTPTriggeredTime)
	}
	if m.FieldCleared(usermaster.FieldCreatedBy) {
		fields = append(fields, usermaster.FieldCreatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMasterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMasterMutation) ClearField(name string) error {
	switch name {
	case usermaster.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case usermaster.FieldEmployeeName:
		m.ClearEmployeeName()
		return nil
	case usermaster.FieldFacilityID:
		m.ClearFacilityID()
		return nil
	case usermaster.FieldCadre:
		m.ClearCadre()
		return nil
	case usermaster.FieldRoleUserCode:
		m.ClearRoleUserCode()
		return nil
	case usermaster.FieldMobile:
		m.ClearMobile()
		return nil
	case usermaster.FieldEmailID:
		m.ClearEmailID()
		return nil
	case usermaster.FieldUserName:
		m.ClearUserName()
		return nil
	case usermaster.FieldPassword:
		m.ClearPassword()
		return nil
	case usermaster.FieldOTP:
		m.ClearOTP()
		return nil
	case usermaster.FieldExamCode:
		m.ClearExamCode()
		return nil
	case usermaster.FieldExamCodePS:
		m.ClearExamCodePS()
		return nil
	case usermaster.FieldOTPRemarks:
		m.ClearOTPRemarks()
		return nil
	case usermaster.FieldStatus:
		m.ClearStatus()
		return nil
	case usermaster.FieldNewPasswordRequest:
		m.ClearNewPasswordRequest()
		return nil
	case usermaster.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case usermaster.FieldOTPTriggeredTime:
		m.ClearOTPTriggeredTime()
		return nil
	case usermaster.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown UserMaster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMasterMutation) ResetField(name string) error {
	switch name {
	case usermaster.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case usermaster.FieldEmployeeName:
		m.ResetEmployeeName()
		return nil
	case usermaster.FieldFacilityID:
		m.ResetFacilityID()
		return nil
	case usermaster.FieldCadre:
		m.ResetCadre()
		return nil
	case usermaster.FieldRoleUserCode:
		m.ResetRoleUserCode()
		return nil
	case usermaster.FieldMobile:
		m.ResetMobile()
		return nil
	case usermaster.FieldEmailID:
		m.ResetEmailID()
		return nil
	case usermaster.FieldUserName:
		m.ResetUserName()
		return nil
	case usermaster.FieldPassword:
		m.ResetPassword()
		return nil
	case usermaster.FieldOTP:
		m.ResetOTP()
		return nil
	case usermaster.FieldExamCode:
		m.ResetExamCode()
		return nil
	case usermaster.FieldExamCodePS:
		m.ResetExamCodePS()
		return nil
	case usermaster.FieldOTPRemarks:
		m.ResetOTPRemarks()
		return nil
	case usermaster.FieldStatus:
		m.ResetStatus()
		return nil
	case usermaster.FieldNewPasswordRequest:
		m.ResetNewPasswordRequest()
		return nil
	case usermaster.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usermaster.FieldOTPTriggeredTime:
		m.ResetOTPTriggeredTime()
		return nil
	case usermaster.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown UserMaster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMasterMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.roles != nil {
		edges = append(edges, usermaster.EdgeRoles)
	}
	if m._UsermasterRef != nil {
		edges = append(edges, usermaster.EdgeUsermasterRef)
	}
	if m._UsersPSRef != nil {
		edges = append(edges, usermaster.EdgeUsersPSRef)
	}
	if m._UsersIPRef != nil {
		edges = append(edges, usermaster.EdgeUsersIPRef)
	}
	if m.users_ps_type != nil {
		edges = append(edges, usermaster.EdgeUsersPsType)
	}
	if m.users_ip_type != nil {
		edges = append(edges, usermaster.EdgeUsersIPType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMasterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usermaster.EdgeRoles:
		if id := m.roles; id != nil {
			return []ent.Value{*id}
		}
	case usermaster.EdgeUsermasterRef:
		ids := make([]ent.Value, 0, len(m._UsermasterRef))
		for id := range m._UsermasterRef {
			ids = append(ids, id)
		}
		return ids
	case usermaster.EdgeUsersPSRef:
		ids := make([]ent.Value, 0, len(m._UsersPSRef))
		for id := range m._UsersPSRef {
			ids = append(ids, id)
		}
		return ids
	case usermaster.EdgeUsersIPRef:
		ids := make([]ent.Value, 0, len(m._UsersIPRef))
		for id := range m._UsersIPRef {
			ids = append(ids, id)
		}
		return ids
	case usermaster.EdgeUsersPsType:
		ids := make([]ent.Value, 0, len(m.users_ps_type))
		for id := range m.users_ps_type {
			ids = append(ids, id)
		}
		return ids
	case usermaster.EdgeUsersIPType:
		ids := make([]ent.Value, 0, len(m.users_ip_type))
		for id := range m.users_ip_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMasterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removed_UsermasterRef != nil {
		edges = append(edges, usermaster.EdgeUsermasterRef)
	}
	if m.removed_UsersPSRef != nil {
		edges = append(edges, usermaster.EdgeUsersPSRef)
	}
	if m.removed_UsersIPRef != nil {
		edges = append(edges, usermaster.EdgeUsersIPRef)
	}
	if m.removedusers_ps_type != nil {
		edges = append(edges, usermaster.EdgeUsersPsType)
	}
	if m.removedusers_ip_type != nil {
		edges = append(edges, usermaster.EdgeUsersIPType)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMasterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usermaster.EdgeUsermasterRef:
		ids := make([]ent.Value, 0, len(m.removed_UsermasterRef))
		for id := range m.removed_UsermasterRef {
			ids = append(ids, id)
		}
		return ids
	case usermaster.EdgeUsersPSRef:
		ids := make([]ent.Value, 0, len(m.removed_UsersPSRef))
		for id := range m.removed_UsersPSRef {
			ids = append(ids, id)
		}
		return ids
	case usermaster.EdgeUsersIPRef:
		ids := make([]ent.Value, 0, len(m.removed_UsersIPRef))
		for id := range m.removed_UsersIPRef {
			ids = append(ids, id)
		}
		return ids
	case usermaster.EdgeUsersPsType:
		ids := make([]ent.Value, 0, len(m.removedusers_ps_type))
		for id := range m.removedusers_ps_type {
			ids = append(ids, id)
		}
		return ids
	case usermaster.EdgeUsersIPType:
		ids := make([]ent.Value, 0, len(m.removedusers_ip_type))
		for id := range m.removedusers_ip_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMasterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedroles {
		edges = append(edges, usermaster.EdgeRoles)
	}
	if m.cleared_UsermasterRef {
		edges = append(edges, usermaster.EdgeUsermasterRef)
	}
	if m.cleared_UsersPSRef {
		edges = append(edges, usermaster.EdgeUsersPSRef)
	}
	if m.cleared_UsersIPRef {
		edges = append(edges, usermaster.EdgeUsersIPRef)
	}
	if m.clearedusers_ps_type {
		edges = append(edges, usermaster.EdgeUsersPsType)
	}
	if m.clearedusers_ip_type {
		edges = append(edges, usermaster.EdgeUsersIPType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMasterMutation) EdgeCleared(name string) bool {
	switch name {
	case usermaster.EdgeRoles:
		return m.clearedroles
	case usermaster.EdgeUsermasterRef:
		return m.cleared_UsermasterRef
	case usermaster.EdgeUsersPSRef:
		return m.cleared_UsersPSRef
	case usermaster.EdgeUsersIPRef:
		return m.cleared_UsersIPRef
	case usermaster.EdgeUsersPsType:
		return m.clearedusers_ps_type
	case usermaster.EdgeUsersIPType:
		return m.clearedusers_ip_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMasterMutation) ClearEdge(name string) error {
	switch name {
	case usermaster.EdgeRoles:
		m.ClearRoles()
		return nil
	}
	return fmt.Errorf("unknown UserMaster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMasterMutation) ResetEdge(name string) error {
	switch name {
	case usermaster.EdgeRoles:
		m.ResetRoles()
		return nil
	case usermaster.EdgeUsermasterRef:
		m.ResetUsermasterRef()
		return nil
	case usermaster.EdgeUsersPSRef:
		m.ResetUsersPSRef()
		return nil
	case usermaster.EdgeUsersIPRef:
		m.ResetUsersIPRef()
		return nil
	case usermaster.EdgeUsersPsType:
		m.ResetUsersPsType()
		return nil
	case usermaster.EdgeUsersIPType:
		m.ResetUsersIPType()
		return nil
	}
	return fmt.Errorf("unknown UserMaster edge %s", name)
}

// VacancyYearMutation represents an operation that mutates the VacancyYear nodes in the graph.
type VacancyYearMutation struct {
	config
	op                 Op
	typ                string
	id                 *int32
	_FromDate          *time.Time
	_ToDate            *time.Time
	_NotifyCode        *int32
	add_NotifyCode     *int32
	_VacancyYear       *string
	_CalendarCode      *int32
	add_CalendarCode   *int32
	clearedFields      map[string]struct{}
	vacancy_ref        map[int32]struct{}
	removedvacancy_ref map[int32]struct{}
	clearedvacancy_ref bool
	exams              map[int32]struct{}
	removedexams       map[int32]struct{}
	clearedexams       bool
	done               bool
	oldValue           func(context.Context) (*VacancyYear, error)
	predicates         []predicate.VacancyYear
}

var _ ent.Mutation = (*VacancyYearMutation)(nil)

// vacancyyearOption allows management of the mutation configuration using functional options.
type vacancyyearOption func(*VacancyYearMutation)

// newVacancyYearMutation creates new mutation for the VacancyYear entity.
func newVacancyYearMutation(c config, op Op, opts ...vacancyyearOption) *VacancyYearMutation {
	m := &VacancyYearMutation{
		config:        c,
		op:            op,
		typ:           TypeVacancyYear,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVacancyYearID sets the ID field of the mutation.
func withVacancyYearID(id int32) vacancyyearOption {
	return func(m *VacancyYearMutation) {
		var (
			err   error
			once  sync.Once
			value *VacancyYear
		)
		m.oldValue = func(ctx context.Context) (*VacancyYear, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VacancyYear.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVacancyYear sets the old VacancyYear of the mutation.
func withVacancyYear(node *VacancyYear) vacancyyearOption {
	return func(m *VacancyYearMutation) {
		m.oldValue = func(context.Context) (*VacancyYear, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VacancyYearMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VacancyYearMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VacancyYear entities.
func (m *VacancyYearMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VacancyYearMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VacancyYearMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VacancyYear.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFromDate sets the "FromDate" field.
func (m *VacancyYearMutation) SetFromDate(t time.Time) {
	m._FromDate = &t
}

// FromDate returns the value of the "FromDate" field in the mutation.
func (m *VacancyYearMutation) FromDate() (r time.Time, exists bool) {
	v := m._FromDate
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDate returns the old "FromDate" field's value of the VacancyYear entity.
// If the VacancyYear object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VacancyYearMutation) OldFromDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDate: %w", err)
	}
	return oldValue.FromDate, nil
}

// ResetFromDate resets all changes to the "FromDate" field.
func (m *VacancyYearMutation) ResetFromDate() {
	m._FromDate = nil
}

// SetToDate sets the "ToDate" field.
func (m *VacancyYearMutation) SetToDate(t time.Time) {
	m._ToDate = &t
}

// ToDate returns the value of the "ToDate" field in the mutation.
func (m *VacancyYearMutation) ToDate() (r time.Time, exists bool) {
	v := m._ToDate
	if v == nil {
		return
	}
	return *v, true
}

// OldToDate returns the old "ToDate" field's value of the VacancyYear entity.
// If the VacancyYear object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VacancyYearMutation) OldToDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToDate: %w", err)
	}
	return oldValue.ToDate, nil
}

// ResetToDate resets all changes to the "ToDate" field.
func (m *VacancyYearMutation) ResetToDate() {
	m._ToDate = nil
}

// SetNotifyCode sets the "NotifyCode" field.
func (m *VacancyYearMutation) SetNotifyCode(i int32) {
	m._NotifyCode = &i
	m.add_NotifyCode = nil
}

// NotifyCode returns the value of the "NotifyCode" field in the mutation.
func (m *VacancyYearMutation) NotifyCode() (r int32, exists bool) {
	v := m._NotifyCode
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyCode returns the old "NotifyCode" field's value of the VacancyYear entity.
// If the VacancyYear object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VacancyYearMutation) OldNotifyCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyCode: %w", err)
	}
	return oldValue.NotifyCode, nil
}

// AddNotifyCode adds i to the "NotifyCode" field.
func (m *VacancyYearMutation) AddNotifyCode(i int32) {
	if m.add_NotifyCode != nil {
		*m.add_NotifyCode += i
	} else {
		m.add_NotifyCode = &i
	}
}

// AddedNotifyCode returns the value that was added to the "NotifyCode" field in this mutation.
func (m *VacancyYearMutation) AddedNotifyCode() (r int32, exists bool) {
	v := m.add_NotifyCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearNotifyCode clears the value of the "NotifyCode" field.
func (m *VacancyYearMutation) ClearNotifyCode() {
	m._NotifyCode = nil
	m.add_NotifyCode = nil
	m.clearedFields[vacancyyear.FieldNotifyCode] = struct{}{}
}

// NotifyCodeCleared returns if the "NotifyCode" field was cleared in this mutation.
func (m *VacancyYearMutation) NotifyCodeCleared() bool {
	_, ok := m.clearedFields[vacancyyear.FieldNotifyCode]
	return ok
}

// ResetNotifyCode resets all changes to the "NotifyCode" field.
func (m *VacancyYearMutation) ResetNotifyCode() {
	m._NotifyCode = nil
	m.add_NotifyCode = nil
	delete(m.clearedFields, vacancyyear.FieldNotifyCode)
}

// SetVacancyYear sets the "VacancyYear" field.
func (m *VacancyYearMutation) SetVacancyYear(s string) {
	m._VacancyYear = &s
}

// VacancyYear returns the value of the "VacancyYear" field in the mutation.
func (m *VacancyYearMutation) VacancyYear() (r string, exists bool) {
	v := m._VacancyYear
	if v == nil {
		return
	}
	return *v, true
}

// OldVacancyYear returns the old "VacancyYear" field's value of the VacancyYear entity.
// If the VacancyYear object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VacancyYearMutation) OldVacancyYear(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVacancyYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVacancyYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVacancyYear: %w", err)
	}
	return oldValue.VacancyYear, nil
}

// ResetVacancyYear resets all changes to the "VacancyYear" field.
func (m *VacancyYearMutation) ResetVacancyYear() {
	m._VacancyYear = nil
}

// SetCalendarCode sets the "CalendarCode" field.
func (m *VacancyYearMutation) SetCalendarCode(i int32) {
	m._CalendarCode = &i
	m.add_CalendarCode = nil
}

// CalendarCode returns the value of the "CalendarCode" field in the mutation.
func (m *VacancyYearMutation) CalendarCode() (r int32, exists bool) {
	v := m._CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCalendarCode returns the old "CalendarCode" field's value of the VacancyYear entity.
// If the VacancyYear object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VacancyYearMutation) OldCalendarCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalendarCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalendarCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalendarCode: %w", err)
	}
	return oldValue.CalendarCode, nil
}

// AddCalendarCode adds i to the "CalendarCode" field.
func (m *VacancyYearMutation) AddCalendarCode(i int32) {
	if m.add_CalendarCode != nil {
		*m.add_CalendarCode += i
	} else {
		m.add_CalendarCode = &i
	}
}

// AddedCalendarCode returns the value that was added to the "CalendarCode" field in this mutation.
func (m *VacancyYearMutation) AddedCalendarCode() (r int32, exists bool) {
	v := m.add_CalendarCode
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalendarCode clears the value of the "CalendarCode" field.
func (m *VacancyYearMutation) ClearCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	m.clearedFields[vacancyyear.FieldCalendarCode] = struct{}{}
}

// CalendarCodeCleared returns if the "CalendarCode" field was cleared in this mutation.
func (m *VacancyYearMutation) CalendarCodeCleared() bool {
	_, ok := m.clearedFields[vacancyyear.FieldCalendarCode]
	return ok
}

// ResetCalendarCode resets all changes to the "CalendarCode" field.
func (m *VacancyYearMutation) ResetCalendarCode() {
	m._CalendarCode = nil
	m.add_CalendarCode = nil
	delete(m.clearedFields, vacancyyear.FieldCalendarCode)
}

// AddVacancyRefIDs adds the "vacancy_ref" edge to the ExamCalendar entity by ids.
func (m *VacancyYearMutation) AddVacancyRefIDs(ids ...int32) {
	if m.vacancy_ref == nil {
		m.vacancy_ref = make(map[int32]struct{})
	}
	for i := range ids {
		m.vacancy_ref[ids[i]] = struct{}{}
	}
}

// ClearVacancyRef clears the "vacancy_ref" edge to the ExamCalendar entity.
func (m *VacancyYearMutation) ClearVacancyRef() {
	m.clearedvacancy_ref = true
}

// VacancyRefCleared reports if the "vacancy_ref" edge to the ExamCalendar entity was cleared.
func (m *VacancyYearMutation) VacancyRefCleared() bool {
	return m.clearedvacancy_ref
}

// RemoveVacancyRefIDs removes the "vacancy_ref" edge to the ExamCalendar entity by IDs.
func (m *VacancyYearMutation) RemoveVacancyRefIDs(ids ...int32) {
	if m.removedvacancy_ref == nil {
		m.removedvacancy_ref = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.vacancy_ref, ids[i])
		m.removedvacancy_ref[ids[i]] = struct{}{}
	}
}

// RemovedVacancyRef returns the removed IDs of the "vacancy_ref" edge to the ExamCalendar entity.
func (m *VacancyYearMutation) RemovedVacancyRefIDs() (ids []int32) {
	for id := range m.removedvacancy_ref {
		ids = append(ids, id)
	}
	return
}

// VacancyRefIDs returns the "vacancy_ref" edge IDs in the mutation.
func (m *VacancyYearMutation) VacancyRefIDs() (ids []int32) {
	for id := range m.vacancy_ref {
		ids = append(ids, id)
	}
	return
}

// ResetVacancyRef resets all changes to the "vacancy_ref" edge.
func (m *VacancyYearMutation) ResetVacancyRef() {
	m.vacancy_ref = nil
	m.clearedvacancy_ref = false
	m.removedvacancy_ref = nil
}

// AddExamIDs adds the "exams" edge to the Exam entity by ids.
func (m *VacancyYearMutation) AddExamIDs(ids ...int32) {
	if m.exams == nil {
		m.exams = make(map[int32]struct{})
	}
	for i := range ids {
		m.exams[ids[i]] = struct{}{}
	}
}

// ClearExams clears the "exams" edge to the Exam entity.
func (m *VacancyYearMutation) ClearExams() {
	m.clearedexams = true
}

// ExamsCleared reports if the "exams" edge to the Exam entity was cleared.
func (m *VacancyYearMutation) ExamsCleared() bool {
	return m.clearedexams
}

// RemoveExamIDs removes the "exams" edge to the Exam entity by IDs.
func (m *VacancyYearMutation) RemoveExamIDs(ids ...int32) {
	if m.removedexams == nil {
		m.removedexams = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.exams, ids[i])
		m.removedexams[ids[i]] = struct{}{}
	}
}

// RemovedExams returns the removed IDs of the "exams" edge to the Exam entity.
func (m *VacancyYearMutation) RemovedExamsIDs() (ids []int32) {
	for id := range m.removedexams {
		ids = append(ids, id)
	}
	return
}

// ExamsIDs returns the "exams" edge IDs in the mutation.
func (m *VacancyYearMutation) ExamsIDs() (ids []int32) {
	for id := range m.exams {
		ids = append(ids, id)
	}
	return
}

// ResetExams resets all changes to the "exams" edge.
func (m *VacancyYearMutation) ResetExams() {
	m.exams = nil
	m.clearedexams = false
	m.removedexams = nil
}

// Where appends a list predicates to the VacancyYearMutation builder.
func (m *VacancyYearMutation) Where(ps ...predicate.VacancyYear) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VacancyYearMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VacancyYearMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VacancyYear, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VacancyYearMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VacancyYearMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VacancyYear).
func (m *VacancyYearMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VacancyYearMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._FromDate != nil {
		fields = append(fields, vacancyyear.FieldFromDate)
	}
	if m._ToDate != nil {
		fields = append(fields, vacancyyear.FieldToDate)
	}
	if m._NotifyCode != nil {
		fields = append(fields, vacancyyear.FieldNotifyCode)
	}
	if m._VacancyYear != nil {
		fields = append(fields, vacancyyear.FieldVacancyYear)
	}
	if m._CalendarCode != nil {
		fields = append(fields, vacancyyear.FieldCalendarCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VacancyYearMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vacancyyear.FieldFromDate:
		return m.FromDate()
	case vacancyyear.FieldToDate:
		return m.ToDate()
	case vacancyyear.FieldNotifyCode:
		return m.NotifyCode()
	case vacancyyear.FieldVacancyYear:
		return m.VacancyYear()
	case vacancyyear.FieldCalendarCode:
		return m.CalendarCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VacancyYearMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vacancyyear.FieldFromDate:
		return m.OldFromDate(ctx)
	case vacancyyear.FieldToDate:
		return m.OldToDate(ctx)
	case vacancyyear.FieldNotifyCode:
		return m.OldNotifyCode(ctx)
	case vacancyyear.FieldVacancyYear:
		return m.OldVacancyYear(ctx)
	case vacancyyear.FieldCalendarCode:
		return m.OldCalendarCode(ctx)
	}
	return nil, fmt.Errorf("unknown VacancyYear field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VacancyYearMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vacancyyear.FieldFromDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDate(v)
		return nil
	case vacancyyear.FieldToDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToDate(v)
		return nil
	case vacancyyear.FieldNotifyCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyCode(v)
		return nil
	case vacancyyear.FieldVacancyYear:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVacancyYear(v)
		return nil
	case vacancyyear.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalendarCode(v)
		return nil
	}
	return fmt.Errorf("unknown VacancyYear field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VacancyYearMutation) AddedFields() []string {
	var fields []string
	if m.add_NotifyCode != nil {
		fields = append(fields, vacancyyear.FieldNotifyCode)
	}
	if m.add_CalendarCode != nil {
		fields = append(fields, vacancyyear.FieldCalendarCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VacancyYearMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vacancyyear.FieldNotifyCode:
		return m.AddedNotifyCode()
	case vacancyyear.FieldCalendarCode:
		return m.AddedCalendarCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VacancyYearMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vacancyyear.FieldNotifyCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotifyCode(v)
		return nil
	case vacancyyear.FieldCalendarCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalendarCode(v)
		return nil
	}
	return fmt.Errorf("unknown VacancyYear numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VacancyYearMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vacancyyear.FieldNotifyCode) {
		fields = append(fields, vacancyyear.FieldNotifyCode)
	}
	if m.FieldCleared(vacancyyear.FieldCalendarCode) {
		fields = append(fields, vacancyyear.FieldCalendarCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VacancyYearMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VacancyYearMutation) ClearField(name string) error {
	switch name {
	case vacancyyear.FieldNotifyCode:
		m.ClearNotifyCode()
		return nil
	case vacancyyear.FieldCalendarCode:
		m.ClearCalendarCode()
		return nil
	}
	return fmt.Errorf("unknown VacancyYear nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VacancyYearMutation) ResetField(name string) error {
	switch name {
	case vacancyyear.FieldFromDate:
		m.ResetFromDate()
		return nil
	case vacancyyear.FieldToDate:
		m.ResetToDate()
		return nil
	case vacancyyear.FieldNotifyCode:
		m.ResetNotifyCode()
		return nil
	case vacancyyear.FieldVacancyYear:
		m.ResetVacancyYear()
		return nil
	case vacancyyear.FieldCalendarCode:
		m.ResetCalendarCode()
		return nil
	}
	return fmt.Errorf("unknown VacancyYear field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VacancyYearMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.vacancy_ref != nil {
		edges = append(edges, vacancyyear.EdgeVacancyRef)
	}
	if m.exams != nil {
		edges = append(edges, vacancyyear.EdgeExams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VacancyYearMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vacancyyear.EdgeVacancyRef:
		ids := make([]ent.Value, 0, len(m.vacancy_ref))
		for id := range m.vacancy_ref {
			ids = append(ids, id)
		}
		return ids
	case vacancyyear.EdgeExams:
		ids := make([]ent.Value, 0, len(m.exams))
		for id := range m.exams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VacancyYearMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvacancy_ref != nil {
		edges = append(edges, vacancyyear.EdgeVacancyRef)
	}
	if m.removedexams != nil {
		edges = append(edges, vacancyyear.EdgeExams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VacancyYearMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vacancyyear.EdgeVacancyRef:
		ids := make([]ent.Value, 0, len(m.removedvacancy_ref))
		for id := range m.removedvacancy_ref {
			ids = append(ids, id)
		}
		return ids
	case vacancyyear.EdgeExams:
		ids := make([]ent.Value, 0, len(m.removedexams))
		for id := range m.removedexams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VacancyYearMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvacancy_ref {
		edges = append(edges, vacancyyear.EdgeVacancyRef)
	}
	if m.clearedexams {
		edges = append(edges, vacancyyear.EdgeExams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VacancyYearMutation) EdgeCleared(name string) bool {
	switch name {
	case vacancyyear.EdgeVacancyRef:
		return m.clearedvacancy_ref
	case vacancyyear.EdgeExams:
		return m.clearedexams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VacancyYearMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown VacancyYear unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VacancyYearMutation) ResetEdge(name string) error {
	switch name {
	case vacancyyear.EdgeVacancyRef:
		m.ResetVacancyRef()
		return nil
	case vacancyyear.EdgeExams:
		m.ResetExams()
		return nil
	}
	return fmt.Errorf("unknown VacancyYear edge %s", name)
}
